# (progn (org-beamer-export-to-pdf) (switch-to-buffer "progress-report-may-2020.pdf"))
# M-x org-beamer-export-to-pdf
#+TITLE: Supervisory Committee Meeting
#+AUTHOR: Musa Al-hassy

# +ATTR_LATEX: :width 0.9\paperwidth :height 0.85\paperheight

* Beamer Setup :ignore:
#+OPTIONS: H:2 toc:nil d:nil title:nil
# BEAMER_THEME: Rochester
# BEAMER_THEME: Copenhagen
# +BEAMER_THEME: default
# +BEAMER_THEME: metropolis [numbering=fraction, progressbar=frametitle, titleformat=smallcaps]
#+BEAMER_THEME: metropolis

#+BEAMER_COLOR_THEME: structure[RGB={87,83,170}]
#+LATEX_HEADER: \hypersetup{pdfauthor="Musa Al-hassy", pdftitle="Supervisory Committee Meeting", colorlinks, linkcolor=black, urlcolor=blue}
#+LATEX: \AtBeginSection{\frame{\sectionpage}}
# use the \insertsection command to get the current section name

# +LATEX_COMPILER: pdflatex -shell-escape

#+LATEX_HEADER: \setbeamersize{text margin left=3mm,text margin right=3mm}

#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}

#+latex_header: \usepackage{picture,xcolor,multicol}

# Needs to be before \begin{document}, hence in a latex-header.
# Add numbers to slides.
#
#+LATEX_HEADER: \setbeamertemplate {footline}{\color{gray}\hspace{49.7em}\insertframenumber\strut\quad}
# LATEX_HEADER: \setbeamertemplate{footline}[frame number]

# minted, like other verbatim, environments is ``fragile'' wrt to beamer.
# Hence all frames with code may behave erracticly if not marked fragile.
#
# \begin{frame}[fragile]{titleHere}

#+LATEX_HEADER: \usepackage{minted}
# https://armkeh.github.io/unicode-sty/
#+LATEX_HEADER: \usepackage{\string~"/unicode-sty/unicode"}

# Removing the red box that appears in "minted" when using unicode.
# Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+LATEX_HEADER: \makeatother

# Did you ``print to file'' or did you ``save a copy''?
# Previously, after ``save a copy'' I have been able to continue editing
# fillable PDFs.

\title[Supervisory Committee Meeting]{The Final Supervisory Committee Meeting}
\date{May 20, 2020}

\begin{frame}
  \titlepage
   % \begin{block}{}
     \centerline{<< Prototype, Unbundling at Will, and Thesis Writing >>}
   % \end{block}
\end{frame}

# to use super tiny fonts, or large ones; e.g., \scalebox{.2}{supertiny}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{lipsum}
#+BEGIN_EXPORT latex
\newcommand\Wider[2][3em]{%
\makebox[\linewidth][c]{%
  \begin{minipage}{\dimexpr\textwidth+#1\relax}
  \raggedright#2
  \end{minipage}%
  }%
}
#+END_EXPORT

* Past and Present Efforts
** Research Question
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

#+begin_center
*Use a dependently-typed language (DTL) to implement the â€˜missingâ€™ module system
features directly inside the language*
#+end_center

\pause
-----
#+LaTeX: \setminted[haskell]{fontsize=\scriptsize, breaklines}
#+begin_src haskell +n 0
-- Terms: Expressions and Types
e, Ï„ ::= Î±          -- base types and constants
    | Typeáµ¢       -- â€œtype of typesâ€; Universe of types at level i : â„•
    | â„•             -- â€œLevelsâ€ for the type hierarchy
    | Î  x : Ï„ â€¢ Ï„   -- â€œPiâ€, dependent-function type
    | Î£ x : Ï„ â€¢ Ï„   -- â€œSigmaâ€, dependent-sum type
    | x             -- Variable
    | e e           -- Application; Î -elimination
    | Î» x : Ï„ â€¢ e   -- Abstraction; Î -introduction
    | (e , e)       -- Pairing; Î£-introduction
    | fst e | snd e -- Projections; Î£-elimination
    | Fix ğ‘­         -- Fixpoints for ğ‘­ : Typeáµ¢ â†’ Typeáµ¢

-- Abbreviation: Provided Î² does not refer to variable â€˜_â€™,
(Î± â†’ Î²) :=  (Î  _ : Î± â€¢ Î²)
 #+end_src
#+latex: \vspace{-1em}
| DTL Syntax   |
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}

** Ubiquitous *mechanical* module constructions are *out of reach* of DTL module systems...

   # [[file:~/thesis-proposal/patterns.png]]

#+latex_header: \usepackage{smartdiagram}
#+latex: \vspace{-2em}
#+begin_export latex
\begin{center}
\smartdiagram[constellation diagram]{
 {\footnotesize Monoids}
,{\footnotesize Monoids \emph{with} carrier \texttt{C}}
,{\footnotesize Homomorphisms, products, duals}
,{\footnotesize Signature (Tree skeletons)}
,{\footnotesize Pointed Magma} % (â€œExclusionâ€)
,{\footnotesize Terms} %  (Trees with variables)
,{\footnotesize Monoids \emph{over} a setoid}
%,Universal Algebra constructions
,{\scriptsize Monoids \emph{with} carrier \texttt{C} and operation $\oplus$}
% %
% Build a program,Set up,Run,Analyze,Modify~/\\ Add,Check
}

\end{center}
#+end_export

:Hide:

\begin{figure}
\centering
 \makebox[\textwidth]{\includegraphics[width=.9\paperwidth, height=.75\paperheight]{~/thesis-proposal/patterns.png}}
\end{figure}

\pause
#+begin_export latex
  % X-axis to the right and Y-axis upwards
  \setlength{\unitlength}{1cm}
  \begin{picture}(0,0)(0,0)
   \put(8.5,8.5){\underline{\textbf{\emph{PL Research is about}}}}
   \put(8.5,8.0){\underline{\textbf{\emph{getting free stuff:}}}}
   \put(8.5,7.5){\underline{\textbf{\emph{We can get a lot!}}}}
\end{picture}
#+end_export

:End:

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "committee.pdf"))

** Evidence that the theory â€˜actually worksâ€™

#+begin_center
*Prototype* with an editor extension
/then/ incorporate *lessons learned* into a DTL library!
#+end_center

#+begin_export latex
\begin{figure}
\centering
 \makebox[\textwidth]{\includegraphics[width=.5\paperwidth, height=.4\paperheight]{~/thesis-proposal/Paper0_MousingOverLarge.png}}
\end{figure}
#+end_export

\pause
1. =PackageFormer= Emacs Editor Extension
2. =Context= Agda Library

** Prototype â‡’ Publication

 /A Language Feature to Unbundle Data at Will/ (GPCE '19)

 #+ATTR_LATEX: :width 0.75\paperwidth :height 0.75\paperheight
 [[file:~/thesis-proposal/gpce19.png]]

** Prototype â‡’ *Lisp Metaprogramming*, ASTs, Untyped, String Manipulation, Agda Generation, Macro DSL
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

# +ATTR_LATEX: :height 0.75\paperheight
# [[file:~/thesis-proposal/lisp.png]]
#+latex: \centering
#+LaTeX: \setminted[common-lisp]{fontsize=\tiny, breaklines}
#+latex: \begin{minipage}[t]{0.95\linewidth}
#+BEGIN_SRC emacs-lisp
{-lisp
(ğ’± recordâ‚ (discard-equations nil)
 = "Reify a variational as an Agda â€œrecordâ€.
    Elements with equations are construed as
    derivatives of fields  ---the elements
    without any equations--- by default, unless
    DISCARD-EQUATIONS is provided with a non-nil value."
  :kind record
  :alter-elements
    (Î» es â†’
      (thread-last es
      ;; Keep or drop eqns depending on â€œdiscard-equationsâ€
      (--map
        (if discard-equations
            (map-equations (Î» _ â†’ nil) it)
            it))
      ;; Unless there's equations, mark elements as fields.
      (--map (map-qualifier
        (Î» _ â†’ (unless (element-equations it)
               "field")) it)))))
-}

{-700
Monoid-record-with-definitional-extensions  =  MonoidP recordâ‚
Monoid-record-with-extensions-as-fields     =  MonoidP recordâ‚ :discard-equations t
-}
#+END_SRC
#+LaTeX: \setminted[common-lisp]{fontsize=\footnotesize, breaklines}
#+latex:   \end{minipage}

** Generated 200+ theories using the Lisp metaprogramming framework ---the MathScheme library

# +ATTR_LATEX: :width 0.75\paperwidth :height 0.75\paperheight
# [[file:~/thesis-proposal/200+specs.png]]

#+LaTeX: \setminted[haskell]{fontsize=\tiny, breaklines}
#+BEGIN_SRC haskell
AdditiveMagma            = Magma renamingâ€² "_*_ to _+_"
LeftDivisionMagma        = Magma renamingâ€² "_*_ to _â•²_"
RightDivisionMagma       = Magma renamingâ€² "_*_ to _â•±_"
LeftOperation            = MultiCarrier extended-byâ€² "_âŸ«_ : U â†’ S â†’ S"
RightOperation           = MultiCarrier extended-byâ€² "_âŸª_ : S â†’ U â†’ S"
IdempotentMagma          = Magma extended-byâ€² "*-idempotent : âˆ€ (x : U) â†’ (x * x) â‰¡ x"
IdempotentAdditiveMagma  = IdempotentMagma renamingâ€² "_*_ to _+_"
SelectiveMagma           = Magma extended-byâ€² "*-selective : âˆ€ (x y : U) â†’ (x * y â‰¡ x) âŠ (x * y â‰¡ y)"
SelectiveAdditiveMagma   = SelectiveMagma renamingâ€² "_*_ to _+_"
PointedMagma             = Magma unionâ€² PointedCarrier
PointedğŸ˜Magma            = PointedMagma renamingâ€² "e to ğŸ˜"
AdditivePointed1Magma    = PointedMagma renamingâ€² "_*_ to _+_; e to ğŸ™"
LeftPointAction          = PointedMagma extended-by "pointactLeft  :  U â†’ U; pointactLeft x = e * x"
RightPointAction         = PointedMagma extended-by "pointactRight  :  U â†’ U; pointactRight x = x * e"
CommutativeMagma         = Magma extended-byâ€² "*-commutative  :  âˆ€ (x y : U) â†’  (x * y) â‰¡ (y * x)"
CommutativeAdditiveMagma = CommutativeMagma renamingâ€² "_*_ to _+_"
PointedCommutativeMagma  = PointedMagma unionâ€² CommutativeMagma âŸ´ :remark "over Magma"
AntiAbsorbent            = Magma extended-byâ€² "*-anti-self-absorbent  : âˆ€ (x y : U) â†’ (x * (x * y)) â‰¡ y"
SteinerMagma             = CommutativeMagma unionâ€² AntiAbsorbent âŸ´ :remark "over Magma"
Squag                    = SteinerMagma unionâ€² IdempotentMagma âŸ´ :remark "over Magma"
PointedSteinerMagma      = PointedMagma unionâ€² SteinerMagma âŸ´ :remark "over Magma"
UnipotentPointedMagma    = PointedMagma extended-byâ€² "unipotent  : âˆ€ (x : U) â†’  (x * x) â‰¡ e"
Sloop                    = PointedSteinerMagma unionâ€² UnipotentPointedMagma
#+END_SRC
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(2,6){\colorbox{yellow}{\Large Terse, readable, specifications}}
\put(2,5.4){\colorbox{yellow}{\Large â†¦ Useful, typecheckable, dauntingly large code }}

\pause
\put(2,4){\colorbox{yellow}{\Large 200+ \textbf{one-line} specs}}
\put(2,3.4){\colorbox{yellow}{\Large \hspace{1em} â†¦ 1500+ lines of typechecked Agda}}
\pause
\put(2,2.8){\colorbox{yellow}{\Large â‡’ 750\% efficiency savings}}

\put(2,1.8){\colorbox{yellow}{\Large Useful engineering result}}
\end{picture}
#+end_export

** *Pushout* unions, intersections, extensions, views, â€¦

# +ATTR_LATEX: :height 0.75\paperheight
# [[file:~/thesis-proposal/pushouts.png]]

#+LaTeX: \setminted[common-lisp]{fontsize=\tiny, breaklines}
#+BEGIN_SRC emacs-lisp
(ğ’± union pf (renamingâ‚ "") (renamingâ‚‚ "") (adjoin-retractâ‚ t) (adjoin-retractâ‚‚ t)
 = "Union the elements of the parent PackageFormer with those of
    the provided PF symbolic name, then adorn the result with two views:
    One to the parent and one to the provided PF.

    If an identifer is shared but has different types, then crash."
   :alter-elements (Î» es â†’
     (let* ((p (symbol-name 'pf))
            (esâ‚ (alter-elements es renaming renamingâ‚ :adjoin-retract nil))
            (esâ‚‚ (alter-elements ($ğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘ -ğ‘œğ‘“ p) renaming renamingâ‚‚ :adjoin-retract nil))
            (esâ€² (-concat esâ‚ esâ‚‚)))

      ;; Ensure no name clashes!
      (loop for n in (find-duplicates (mapcar #'element-name esâ€²))
            for e = (--filter (equal n (element-name it)) esâ€²)
            unless (--all-p (equal (car e) it) e)
            do (-let [debug-on-error nil]
              (error "%s = %s union %s \n\n\t\t â© Error: Elements â€œ%sâ€ conflict!\n\n\t\t\t%s"
                     $ğ‘›ğ‘ğ‘šğ‘’ $ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ p (element-name (car e)) (s-join "\n\t\t\t" (mapcar #'show-element e)))))

   ;; return value
   (-concat
       esâ€²
       (when adjoin-retractâ‚ (list (element-retract $ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ es :new esâ‚ :name adjoin-retractâ‚)))
       (when adjoin-retractâ‚‚ (list (element-retract p     ($ğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘ -ğ‘œğ‘“ p) :new esâ‚‚ :name adjoin-retractâ‚‚)))))))
#+END_SRC
#+LaTeX: \setminted[common-lisp]{fontsize=\footnotesize, breaklines}


#+latex: \centerline{\alert{Primitives are motivated from existing, real-world, DTL libraries!}}

** Primary Lesson Learned: *=:waist=*

The difference between *field* and *parameter* is an illusion ---as is that of *input*
and *output* when one considers relations rather than deterministic functions.

\pause
-----

User-defined variational: /Drop definitions when lifting fields into parameters./
# [[file:~/thesis-proposal/waist.png]]
#+LaTeX: \setminted[common-lisp]{fontsize=\tiny, breaklines}
#+BEGIN_SRC emacs-lisp
(ğ’± unbundling n
 = "Turn the first N elements into parameters to the PackageFormer.

    Any elements above the waist line have their equations dropped."
   :waist n
   :alter-elements (Î» es â†’
     (-let [i 0]
       (--graph-map (progn (incf i) (<= i n))
                    (map-equations (-const nil) it)
                    es))))
#+END_SRC
#+LaTeX: \setminted[common-lisp]{fontsize=\footnotesize, breaklines}

** Characterising =:waist= as Î â†’Î»

#+ATTR_LATEX: :width 0.4\paperwidth
# [[file:~/thesis-proposal/waist-pi-to-lambda-char.png]]

# +begin_center


# src_haskell[:exports code]{Î â†’Î» (Î  a : A â€¢ Ï„)  =  (Î» a : A â€¢ Ï„)}

#+BEGIN_SRC haskell
Î â†’Î» (Î  a : A â€¢ Ï„)  =  (Î» a : A â€¢ Ï„)
#+END_SRC

\pause
-----
\vspace{0.5em}

#+begin_parallelNB org
#+begin_src haskell
idâ‚€ : Setâ‚
idâ‚€ = Î  X âˆ¶ Set â€¢ Î  e âˆ¶ X â€¢ X

idâ‚ : Î  X âˆ¶ Set â€¢ Set
idâ‚ = Î» (X : Set) â†’ Î  e âˆ¶ X â€¢ X

idâ‚‚ : Î  X âˆ¶ Set â€¢ Î  e âˆ¶ X â€¢ Set
idâ‚‚ = Î» (X : Set) (e : X) â†’ X
#+end_src

#+latex: \columnbreak

\pause
+ ~idáµ¢â‚Šâ‚ â‰ˆ Î â†’Î» idáµ¢~
+ ~idâ‚€~ is a /type of functions/
+ ~idâ‚~ is a /function on types/

#+end_parallelNB

:Details:
We shall refer to the latter change
as @@latex: \emph{re\"{\i}fication}@@ since the result is more concrete: It can
be applied. This transformation will be
denoted by ~Î â†’Î»~. To clarify this subtlety, consider the following forms of the
polymorphic identity function. Notice that $\mathsf{id}áµ¢$ /exposes/ =i=-many details at the
type level to indicate the sort of data it consists of. However, notice that ~idâ‚€~ is
a type of functions whereas $\mathsf{id}â‚$ is a function on types. Indeed, the latter
:End:

** =Context= Agda Library â‡’ *Pragmatic Interface*

   # [[file:~/thesis-proposal/pragmattic.png]]

#+latex: \centering
#+latex: \begin{minipage}[t]{0.95\linewidth}
#+begin_src haskell
Monoid : âˆ€ â„“ â†’ Context (â„“suc â„“)
Monoid â„“ = do Carrier â† Set â„“
              _âŠ•_    â† (Carrier â†’ Carrier â†’ Carrier)
              Id      â† Carrier
              leftId  â† âˆ€ {x : Carrier} â†’ x âŠ• Id â‰¡ x
              rightId â† âˆ€ {x : Carrier} â†’ Id âŠ• x â‰¡ x
              assoc   â† âˆ€ {x y z} â†’ (x âŠ• y) âŠ• z  â‰¡  x âŠ• (y âŠ• z)
              End {â„“}
#+end_src
#+latex:   \end{minipage}

\pause \vspace{1em}
- Ideas: /Weak/ *Agda Reflection*, No fresh names, Monads, Termination,
  â€˜Reificationâ€™ Î â†’Î»

  \pause  \vspace{1em}
- Draft paper: /Do-it-yourself Module Systems/

** â€˜Allâ€™ module constructions are born from =Context=
# [[file:~/thesis-proposal/everything-is-a-context.png]]

# +begin_scriptsize org
    \pause \vspace{0.5em}
+ Context: â€œname-type pairsâ€
  #+BEGIN_SRC haskell
do S â† Set; s â† S; n â† (S â†’ S); End
#+END_SRC
    \pause \vspace{0.5em}

+ Record Type: â€œbundled-up dataâ€
   #+BEGIN_SRC haskell
Î£ S âˆ¶ Set â€¢ Î£ s âˆ¶ S â€¢ Î£ n âˆ¶ S â†’ S â€¢ ğŸ™
#+END_SRC
    \pause \vspace{0.5em}

+ Function Type: â€œa type of functionsâ€
   #+BEGIN_SRC haskell
Î  S â€¢ Î£ s âˆ¶ S â€¢ Î£ n âˆ¶ S â†’ S â€¢ ğŸ™
#+END_SRC
    \pause \vspace{0.5em}

+ Type constructor: â€œa function on typesâ€
   #+BEGIN_SRC haskell
Î» S â€¢ Î£ s âˆ¶ S â€¢ Î£ n âˆ¶ S â†’ S â€¢ ğŸ™
#+END_SRC
    \pause \vspace{0.5em}

+ Algebraic datatype: â€œa descriptive syntaxâ€
   #+BEGIN_SRC haskell
data ğ”» : Set where s : ğ”»; n : ğ”» â†’ ğ”»
#+END_SRC

# +end_scriptsize

** Comparing =PackageFormer= and =Context=
   # [[file:~/thesis-proposal/PF-Context-comparision.png]]

  |                          | PackageFormer      | Contexts             |
  |--------------------------+--------------------+----------------------|
  | Type of Entity           | Preprocessing Tool | Language Library     |
  | Specification Language   | Lisp + Agda        | Agda                 |
  | Well-formedness Checking | âŒ               | âœ“                    |
  | Termination Checking     | âœ“                  | âœ“                    |
  | Elaboration Tooltips     | âœ“                  | âŒ                 |
  | Rapid Prototyping        | âœ“                  | âœ“ (Slower)           |
  | Usability Barrier        | None               | None                 |
  | Extensibility Barrier    | Lisp               | Weak Metaprogramming |

** Current Activities

1. Complete a \alert{interpreter}, via a rewrite-system, for =PackageFormer=

   #+latex: \vspace{2em}

2. Finish \alert{writing thesis}
   - Demonstrate that \alert{common module idioms} are expressible in our framework
   - Demonstrate that several @@latex:\alert{uncommon notions of packaging from universal
     algebra} are also possible!@@

* Contributions

** Module Systems for DTLs

1. The ability to /implement/ module systems \alert{for DTLs within DTLs}

   #+latex: \vspace{1em} \pause
2. The ability to arbitrarily \alert{extend} such systems by users at a high-level

      #+latex: \vspace{1em} \pause
3. Demonstrate that there is an expressive yet minimal set of
   \alert{module meta-primitives} which allow common module constructions to be defined

   # **Unifying Seemingly Disparate Notions of Modules
      #+latex: \vspace{1em} \pause
4. [@4] Demonstrate that relationships between modules can also be \alert{mechanically}
   generated.
   # - In particular, if module â„¬ is obtained by applying a user-defined
   #   â€˜variationalâ€™ to module ğ’œ, then the user could also enrich the child module
   #   â„¬ with morphisms that describe its relationships to the parent module ğ’œ.
   # - E.g., if â„¬ is an extension of ğ’œ, then we may have a â€œforgetful mappingâ€
   #   that drops the new components; or if â„¬ is a â€˜minimalâ€™ rendition of the
   #   theory ğ’œ, then we have a â€œsmart constructorâ€ that forms the rich ğ’œ by only
   #   asking the few â„¬ components of the user.

** Termtypes as Modules

#+latex: \centering

5. [@5] Bring \alert{algebraic data types} under the umbrella of grouping mechanisms:
   An ADT is just a context whose symbols target the ADT â€˜carrierâ€™ and
   are not otherwise interpreted.
   - In particular, both an ADT and a record can be obtained *practically* from
     a *single* context declaration.

\pause

\vspace{-0.5em}
#+begin_parallel org

# +ATTR_LATEX: :width 0.45\paperwidth :height 0.35\paperheight
#+begin_src haskell
DynamicSystem : Context â„“â‚
DynamicSystem
    = do State â† Set
         start â† State
         next  â† (State â†’ State)
         End
#+end_src
# [[file:~/thesis-proposal/unbundling-DS-0.png]]

#+latex: \columnbreak

\pause
# +ATTR_LATEX: :width 0.2\paperwidth :height 0.2\paperheight
# [[file:~/thesis-proposal/DS-data.png]]

#+begin_src haskell
data ğ”» : Set where
    startD : ğ”»
    nextD  : ğ”» â†’ ğ”»
#+end_src

#+end_parallel

\pause
\vspace{-1.3em}
-----
\vspace{-2em}
#+latex: \begin{minipage}[t]{0.85\linewidth}
#+begin_src haskell
ğ”» = termtype (DynamicSystem :waist 1)

-- Pattern synonyms for more compact presentation
pattern startD  = Î¼ (injâ‚ tt)       -- : ğ”»
pattern nextD e = Î¼ (injâ‚‚ (injâ‚ e)) -- : ğ”» â†’ ğ”»
trivial : ğ”» â‰… â„•
#+end_src
#+latex: \end{minipage}

# +latex: \setlength{\unitlength}{1cm} \begin{picture}(0,0)(0,0)
# +latex: \put(6,-1.55){
# +ATTR_LATEX: :width 0.45\paperwidth :height 0.4\paperheight
# [[file:~/thesis-proposal/DS-termtype.png]]
# +latex: }
# +latex: \end{picture}

** Common data-structures as *free* termtypes
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

6. [@6] Show that common data-structures are \alert{mechanically the (free) termtypes} of
   common modules.

\centering
\vspace{-1em}
\pause

   | Module System         | Termtype |
   |-----------------------+----------|
   | Dynamical Structures  | Naturals |
   | Collection Structures | Lists    |
   | Pointed Structures    | Maybe    |

\vspace{-1em}
\pause

# +ATTR_LATEX: :width 0.45\paperwidth :height 0.5\paperheight
# [[file:~/thesis-proposal/lists-as-free-collections.png]]

#+LaTeX: \setminted[haskell]{fontsize=\scriptsize, breaklines}
#+begin_src haskell
Collection : âˆ€ â„“ â†’ Context (â„“suc â„“)
Collection â„“ = do Elem    â† Set â„“
                  Carrier â† Set â„“
                  insert  â† (Elem â†’ Carrier â†’ Carrier)
                  âˆ…       â† Carrier
                  End {â„“}

List : Set â†’ Set
List ElemType = termtype ((Collection â„“â‚€ :waist 2) ElemType)

pattern _::_ x xs = Î¼ (injâ‚ (x , xs , tt))
pattern  âˆ…        = Î¼ (injâ‚‚ (injâ‚ tt))
#+end_src
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "committee.pdf"))

** Solve the unbundling problem ---all in Agda!

7. [@7] The ability to â€˜unbundleâ€™ module fields as if they were parameters â€˜on
   the flyâ€™

\pause
\vspace{-1.2em}
-----
#+begin_parallelNB org
# +ATTR_LATEX: :width 0.45\paperwidth :height 0.5\paperheight
#+begin_src haskell
DynamicSystem : Context â„“â‚
DynamicSystem
    = do State â† Set
         start â† State
         next  â† (State â†’ State)
         End
#+end_src
# [[file:~/thesis-proposal/unbundling-DS-0.png]]

\pause \columnbreak
# +ATTR_LATEX: :width 0.45\paperwidth :height 0.5\paperheight
# [[file:~/thesis-proposal/unbundling-DS-1.png]]

#+BEGIN_SRC haskell
ğ’©â° : DynamicSystem :waist 0
ğ’©â° = âŸ¨ â„• , 0 , suc âŸ©

ğ’©Â¹ : (DynamicSystem :waist 1) â„•
ğ’©Â¹ = âŸ¨ 0 , suc âŸ©

ğ’©Â² : (DynamicSystem :waist 2) â„• 0
ğ’©Â² = âŸ¨ suc âŸ©

ğ’©Â³ : (DynamicSystem :waist 3) â„• 0 suc
ğ’©Â³ = âŸ¨âŸ©
#+END_SRC
#+end_parallelNB

\pause
#+begin_export latex
  % X-axis to the right and Y-axis upwards
  \setlength{\unitlength}{1cm}
  \begin{picture}(0,0)(0,0)
   \put(0,2.5){\textbf{Without redefining \texttt{DynamicSystem}},}
   \put(0,2.0){we are able to \textbf{fix} some of its fields}
   \put(0,1.5){by making them into parameters!}
\end{picture}
#+end_export

\pause
\vspace{-3em}
-----
\vspace{-0.5em}
#+begin_footnotesize org
# Using ~:waist ğ’¾~ we may fix the first ~ğ’¾~-parameters ahead of time.
# \vspace{-1em}
# + =(DynamicSystem :waist 1) â„•= is /the type of dynamic systems over carrier â„•/
# \vspace{-1em}

The type of dynamic systems *over* carrier â„• and start state 0
\newline is =(DynamicSystem :waist 2) â„• 0=.
#+end_footnotesize

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "committee.pdf"))

:Examples_in_the_wild:

Examples of the need for such on-the-fly unbundling can be found in numerous
places in the Haskell standard library. For instance, the standard libraries cite:data_monoid
have two isomorphic copies of the integers, called ~Sum~ and ~Product~, whose reason
for being is to distinguish two common monoids: The former is for /integers with
addition/ whereas the latter is for /integers with multiplication/.

:End:

** Theory & Implementation

8. [@8] Demonstrate that there is a \alert{practical implementation} of such a framework

   - [X] The =Context= framework is implemented in Agda and we've seen practical examples of
     its use.

      #+latex: \vspace{2em} \pause
9. Finally, the resulting framework is /mostly/ \alert{type-theory agnostic}: The target
   setting is DTLs but we only assume the barebones; if users drop parts of that
   theory, then /only/ some parts of the framework will no longer apply.

   - [ ] Started ...

# - For instance, in DTLs without a fixed-point functor the framework still
#   â€˜appliesâ€™, but can no longer be used to provide arbitrary algebraic data
#   types from contexts.
#
* Next Steps

** SMART Goals
# Slide I: Specific goals and milestones for the next six months

+ June 2020 :: Finish \alert{interpreter} for =PackageFormer=

   #+latex: \vspace{1em} \pause
+ July 2020 :: Finish writing \alert{thesis}
  - Possibly submit draft paper /Do-it-yourself Module Systems/

   #+latex: \vspace{1em} \pause
+ August 2020 :: \alert{Defend} thesis

** Summary
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

\pause

1. *Published* one paper regarding research and have a draft ready to be
   cleaned-up
      #+latex: \vspace{2em}
2. *Currently* working on the thesis with the \alert{intention} of defending in the next few months

\pause
\vspace{1em}
/Thank-you for your time!/

\vspace{1em}
\centerline{Questions?}
* COMMENT Half-page summary 2020

  This year I have completed the majority of my research and
  have begun the thesis writing phase.

  Since the last meeting of May 24 2019, the following tasks have been
  accomplished:
  + A prototype has been written to show the theory â€˜worksâ€™
  + An associated Agda library has also been written
  + A publication and paper draft have been written, attached
    - There were no prior publications

  Besides research, I was a teaching assistant in each academic term.

  Common, mechanical, patterns for module construction are just out
  of reach of the module systems of dependently-typed languages.
  Such languages permit a rich number of possible formulations for
  a module, such as by having some of its constituents exposed
  at the type level as paramters, others as fields, and others
  as definitional extensions.

  Library designers are generally conservative; they provide a predicate
  formulation consisting of a set of proof obligations that constrain the
  functional symbols provided as paramters in the type level. This formulation
  is then usually accompanied by a fully â€œbundled upâ€ variation that has no
  parameters and all relevant data is rendered as fields.

  However, trouble arises when library users wish to fix only one field ahead of
  time ---this is the â€œunbundling problemâ€ and it is akin to function uncurrying
  but for modules.

  Moreover, library designers for dependently-typed languages generally only
  provide a handful of formulations for a single module. Other formulations
  must be written out by hand by users, which must then form coercions
  between the new forms and those used in the library, so as to make use
  of the library's utilities.

  I have produced an editor extension for Agda's de-facto IDE, Emacs,
  which reduces the boilerplate for new formulations of modules to
  simple, usually one-line, specifications. The tool is run in the background
  and works on ordinary Agda files by looking at special comments.
  The specifications are expanded into typechecked Agda code.

  Moreover, using the lessons learned from the editor extension, an Agda library
  has been implemented to achieve similar goals within Agda itself.  Due to
  Agda's current metaprogramming limitations, such as the inability to produce
  fresh names, development with the library is slower than with the editor
  extension.

  A paper has been published regarding the editor extension
  and a paper draft is in preparation regarding the associated Agda library.

  Going forward, the aim is to finish thesis writing and to defend in the
  upcoming months, namely August 2020.
