# (progn (org-beamer-export-to-pdf) (switch-to-buffer "progress-report-may-2020.pdf"))
# M-x org-beamer-export-to-pdf
#+TITLE: Supervisory Committee Meeting
#+AUTHOR: Musa Al-hassy

# +ATTR_LATEX: :width 0.9\paperwidth :height 0.85\paperheight

* Beamer Setup :ignore:
#+OPTIONS: H:2 toc:nil d:nil title:nil
# BEAMER_THEME: Rochester
# BEAMER_THEME: Copenhagen
# +BEAMER_THEME: default
# +BEAMER_THEME: metropolis [numbering=fraction, progressbar=frametitle, titleformat=smallcaps]
#+BEAMER_THEME: metropolis

#+BEAMER_COLOR_THEME: structure[RGB={87,83,170}]
#+LATEX_HEADER: \hypersetup{pdfauthor="Musa Al-hassy", pdftitle="Supervisory Committee Meeting", colorlinks, linkcolor=black, urlcolor=blue}
#+LATEX: \AtBeginSection{\frame{\sectionpage}}
# use the \insertsection command to get the current section name

# +LATEX_COMPILER: pdflatex -shell-escape

#+LATEX_HEADER: \setbeamersize{text margin left=3mm,text margin right=3mm}

#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}

#+latex_header: \usepackage{picture,xcolor,multicol}

# Needs to be before \begin{document}, hence in a latex-header.
# Add numbers to slides.
#
#+LATEX_HEADER: \setbeamertemplate {footline}{\color{gray}\hspace{49.7em}\insertframenumber\strut\quad}
# LATEX_HEADER: \setbeamertemplate{footline}[frame number]

# minted, like other verbatim, environments is ``fragile'' wrt to beamer.
# Hence all frames with code may behave erracticly if not marked fragile.
#
# \begin{frame}[fragile]{titleHere}

#+LATEX_HEADER: \usepackage{minted}
# https://armkeh.github.io/unicode-sty/
#+LATEX_HEADER: \usepackage{\string~"/unicode-sty/unicode"}

# Removing the red box that appears in "minted" when using unicode.
# Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+LATEX_HEADER: \makeatother

# Did you ``print to file'' or did you ``save a copy''?
# Previously, after ``save a copy'' I have been able to continue editing
# fillable PDFs.

\title[Supervisory Committee Meeting]{The Final Supervisory Committee Meeting}
\date{May 20, 2020}

\begin{frame}
  \titlepage
   % \begin{block}{}
     \centerline{<< Prototype, Unbundling at Will, and Thesis Writing >>}
   % \end{block}
\end{frame}

# to use super tiny fonts, or large ones; e.g., \scalebox{.2}{supertiny}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{lipsum}
#+BEGIN_EXPORT latex
\newcommand\Wider[2][3em]{%
\makebox[\linewidth][c]{%
  \begin{minipage}{\dimexpr\textwidth+#1\relax}
  \raggedright#2
  \end{minipage}%
  }%
}
#+END_EXPORT

* Past and Present Efforts
** Research Question
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

#+begin_center
*Use a dependently-typed language (DTL) to implement the ‚Äòmissing‚Äô module system
features directly inside the language*
#+end_center

\pause
-----
#+LaTeX: \setminted[haskell]{fontsize=\scriptsize, breaklines}
#+begin_src haskell +n 0
-- Terms: Expressions and Types
e, œÑ ::= Œ±          -- base types and constants
    | Type·µ¢       -- ‚Äútype of types‚Äù; Universe of types at level i : ‚Ñï
    | ‚Ñï             -- ‚ÄúLevels‚Äù for the type hierarchy
    | Œ† x : œÑ ‚Ä¢ œÑ   -- ‚ÄúPi‚Äù, dependent-function type
    | Œ£ x : œÑ ‚Ä¢ œÑ   -- ‚ÄúSigma‚Äù, dependent-sum type
    | x             -- Variable
    | e e           -- Application; Œ†-elimination
    | Œª x : œÑ ‚Ä¢ e   -- Abstraction; Œ†-introduction
    | (e , e)       -- Pairing; Œ£-introduction
    | fst e | snd e -- Projections; Œ£-elimination
    | Fix ùë≠         -- Fixpoints for ùë≠ : Type·µ¢ ‚Üí Type·µ¢

-- Abbreviation: Provided Œ≤ does not refer to variable ‚Äò_‚Äô,
(Œ± ‚Üí Œ≤) :=  (Œ† _ : Œ± ‚Ä¢ Œ≤)
 #+end_src
#+latex: \vspace{-1em}
| DTL Syntax   |
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}

** Ubiquitous *mechanical* module constructions are *out of reach* of DTL module systems...

   # [[file:~/thesis-proposal/patterns.png]]

#+latex_header: \usepackage{smartdiagram}
#+latex: \vspace{-2em}
#+begin_export latex
\begin{center}
\smartdiagram[constellation diagram]{
 {\footnotesize Monoids}
,{\footnotesize Monoids \emph{with} carrier \texttt{C}}
,{\footnotesize Homomorphisms, products, duals}
,{\footnotesize Signature (Tree skeletons)}
,{\footnotesize Pointed Magma} % (‚ÄúExclusion‚Äù)
,{\footnotesize Terms} %  (Trees with variables)
,{\footnotesize Monoids \emph{over} a setoid}
%,Universal Algebra constructions
,{\scriptsize Monoids \emph{with} carrier \texttt{C} and operation $\oplus$}
% %
% Build a program,Set up,Run,Analyze,Modify~/\\ Add,Check
}

\end{center}
#+end_export

:Hide:

\begin{figure}
\centering
 \makebox[\textwidth]{\includegraphics[width=.9\paperwidth, height=.75\paperheight]{~/thesis-proposal/patterns.png}}
\end{figure}

\pause
#+begin_export latex
  % X-axis to the right and Y-axis upwards
  \setlength{\unitlength}{1cm}
  \begin{picture}(0,0)(0,0)
   \put(8.5,8.5){\underline{\textbf{\emph{PL Research is about}}}}
   \put(8.5,8.0){\underline{\textbf{\emph{getting free stuff:}}}}
   \put(8.5,7.5){\underline{\textbf{\emph{We can get a lot!}}}}
\end{picture}
#+end_export

:End:

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "committee.pdf"))

** Evidence that the theory ‚Äòactually works‚Äô

#+begin_center
*Prototype* with an editor extension
/then/ incorporate *lessons learned* into a DTL library!
#+end_center

#+begin_export latex
\begin{figure}
\centering
 \makebox[\textwidth]{\includegraphics[width=.5\paperwidth, height=.4\paperheight]{~/thesis-proposal/Paper0_MousingOverLarge.png}}
\end{figure}
#+end_export

\pause
1. =PackageFormer= Emacs Editor Extension
2. =Context= Agda Library

** Prototype ‚áí Publication

 /A Language Feature to Unbundle Data at Will/ (GPCE '19)

 #+ATTR_LATEX: :width 0.75\paperwidth :height 0.75\paperheight
 [[file:~/thesis-proposal/gpce19.png]]

** Prototype ‚áí *Lisp Metaprogramming*, ASTs, Untyped, String Manipulation, Agda Generation, Macro DSL
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

# +ATTR_LATEX: :height 0.75\paperheight
# [[file:~/thesis-proposal/lisp.png]]
#+latex: \centering
#+LaTeX: \setminted[common-lisp]{fontsize=\tiny, breaklines}
#+latex: \begin{minipage}[t]{0.95\linewidth}
#+BEGIN_SRC emacs-lisp
{-lisp
(ùí± record‚ÇÅ (discard-equations nil)
 = "Reify a variational as an Agda ‚Äúrecord‚Äù.
    Elements with equations are construed as
    derivatives of fields  ---the elements
    without any equations--- by default, unless
    DISCARD-EQUATIONS is provided with a non-nil value."
  :kind record
  :alter-elements
    (Œª es ‚Üí
      (thread-last es
      ;; Keep or drop eqns depending on ‚Äúdiscard-equations‚Äù
      (--map
        (if discard-equations
            (map-equations (Œª _ ‚Üí nil) it)
            it))
      ;; Unless there's equations, mark elements as fields.
      (--map (map-qualifier
        (Œª _ ‚Üí (unless (element-equations it)
               "field")) it)))))
-}

{-700
Monoid-record-with-definitional-extensions  =  MonoidP record‚ÇÅ
Monoid-record-with-extensions-as-fields     =  MonoidP record‚ÇÅ :discard-equations t
-}
#+END_SRC
#+LaTeX: \setminted[common-lisp]{fontsize=\footnotesize, breaklines}
#+latex:   \end{minipage}

** Generated 200+ theories using the Lisp metaprogramming framework ---the MathScheme library

# +ATTR_LATEX: :width 0.75\paperwidth :height 0.75\paperheight
# [[file:~/thesis-proposal/200+specs.png]]

#+LaTeX: \setminted[haskell]{fontsize=\tiny, breaklines}
#+BEGIN_SRC haskell
AdditiveMagma            = Magma renaming‚Ä≤ "_*_ to _+_"
LeftDivisionMagma        = Magma renaming‚Ä≤ "_*_ to _‚ï≤_"
RightDivisionMagma       = Magma renaming‚Ä≤ "_*_ to _‚ï±_"
LeftOperation            = MultiCarrier extended-by‚Ä≤ "_‚ü´_ : U ‚Üí S ‚Üí S"
RightOperation           = MultiCarrier extended-by‚Ä≤ "_‚ü™_ : S ‚Üí U ‚Üí S"
IdempotentMagma          = Magma extended-by‚Ä≤ "*-idempotent : ‚àÄ (x : U) ‚Üí (x * x) ‚â° x"
IdempotentAdditiveMagma  = IdempotentMagma renaming‚Ä≤ "_*_ to _+_"
SelectiveMagma           = Magma extended-by‚Ä≤ "*-selective : ‚àÄ (x y : U) ‚Üí (x * y ‚â° x) ‚äé (x * y ‚â° y)"
SelectiveAdditiveMagma   = SelectiveMagma renaming‚Ä≤ "_*_ to _+_"
PointedMagma             = Magma union‚Ä≤ PointedCarrier
PointedùüòMagma            = PointedMagma renaming‚Ä≤ "e to ùüò"
AdditivePointed1Magma    = PointedMagma renaming‚Ä≤ "_*_ to _+_; e to ùüô"
LeftPointAction          = PointedMagma extended-by "pointactLeft  :  U ‚Üí U; pointactLeft x = e * x"
RightPointAction         = PointedMagma extended-by "pointactRight  :  U ‚Üí U; pointactRight x = x * e"
CommutativeMagma         = Magma extended-by‚Ä≤ "*-commutative  :  ‚àÄ (x y : U) ‚Üí  (x * y) ‚â° (y * x)"
CommutativeAdditiveMagma = CommutativeMagma renaming‚Ä≤ "_*_ to _+_"
PointedCommutativeMagma  = PointedMagma union‚Ä≤ CommutativeMagma ‚ü¥ :remark "over Magma"
AntiAbsorbent            = Magma extended-by‚Ä≤ "*-anti-self-absorbent  : ‚àÄ (x y : U) ‚Üí (x * (x * y)) ‚â° y"
SteinerMagma             = CommutativeMagma union‚Ä≤ AntiAbsorbent ‚ü¥ :remark "over Magma"
Squag                    = SteinerMagma union‚Ä≤ IdempotentMagma ‚ü¥ :remark "over Magma"
PointedSteinerMagma      = PointedMagma union‚Ä≤ SteinerMagma ‚ü¥ :remark "over Magma"
UnipotentPointedMagma    = PointedMagma extended-by‚Ä≤ "unipotent  : ‚àÄ (x : U) ‚Üí  (x * x) ‚â° e"
Sloop                    = PointedSteinerMagma union‚Ä≤ UnipotentPointedMagma
#+END_SRC
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(2,6){\colorbox{yellow}{\Large Terse, readable, specifications}}
\put(2,5.4){\colorbox{yellow}{\Large ‚Ü¶ Useful, typecheckable, dauntingly large code }}

\pause
\put(2,4){\colorbox{yellow}{\Large 200+ \textbf{one-line} specs}}
\put(2,3.4){\colorbox{yellow}{\Large \hspace{1em} ‚Ü¶ 1500+ lines of typechecked Agda}}
\pause
\put(2,2.8){\colorbox{yellow}{\Large ‚áí 750\% efficiency savings}}

\put(2,1.8){\colorbox{yellow}{\Large Useful engineering result}}
\end{picture}
#+end_export

** *Pushout* unions, intersections, extensions, views, ‚Ä¶

# +ATTR_LATEX: :height 0.75\paperheight
# [[file:~/thesis-proposal/pushouts.png]]

#+LaTeX: \setminted[common-lisp]{fontsize=\tiny, breaklines}
#+BEGIN_SRC emacs-lisp
(ùí± union pf (renaming‚ÇÅ "") (renaming‚ÇÇ "") (adjoin-retract‚ÇÅ t) (adjoin-retract‚ÇÇ t)
 = "Union the elements of the parent PackageFormer with those of
    the provided PF symbolic name, then adorn the result with two views:
    One to the parent and one to the provided PF.

    If an identifer is shared but has different types, then crash."
   :alter-elements (Œª es ‚Üí
     (let* ((p (symbol-name 'pf))
            (es‚ÇÅ (alter-elements es renaming renaming‚ÇÅ :adjoin-retract nil))
            (es‚ÇÇ (alter-elements ($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì p) renaming renaming‚ÇÇ :adjoin-retract nil))
            (es‚Ä≤ (-concat es‚ÇÅ es‚ÇÇ)))

      ;; Ensure no name clashes!
      (loop for n in (find-duplicates (mapcar #'element-name es‚Ä≤))
            for e = (--filter (equal n (element-name it)) es‚Ä≤)
            unless (--all-p (equal (car e) it) e)
            do (-let [debug-on-error nil]
              (error "%s = %s union %s \n\n\t\t ‚û© Error: Elements ‚Äú%s‚Äù conflict!\n\n\t\t\t%s"
                     $ùëõùëéùëöùëí $ùëùùëéùëüùëíùëõùë° p (element-name (car e)) (s-join "\n\t\t\t" (mapcar #'show-element e)))))

   ;; return value
   (-concat
       es‚Ä≤
       (when adjoin-retract‚ÇÅ (list (element-retract $ùëùùëéùëüùëíùëõùë° es :new es‚ÇÅ :name adjoin-retract‚ÇÅ)))
       (when adjoin-retract‚ÇÇ (list (element-retract p     ($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì p) :new es‚ÇÇ :name adjoin-retract‚ÇÇ)))))))
#+END_SRC
#+LaTeX: \setminted[common-lisp]{fontsize=\footnotesize, breaklines}


#+latex: \centerline{\alert{Primitives are motivated from existing, real-world, DTL libraries!}}

** Primary Lesson Learned: *=:waist=*

The difference between *field* and *parameter* is an illusion ---as is that of *input*
and *output* when one considers relations rather than deterministic functions.

\pause
-----

User-defined variational: /Drop definitions when lifting fields into parameters./
# [[file:~/thesis-proposal/waist.png]]
#+LaTeX: \setminted[common-lisp]{fontsize=\tiny, breaklines}
#+BEGIN_SRC emacs-lisp
(ùí± unbundling n
 = "Turn the first N elements into parameters to the PackageFormer.

    Any elements above the waist line have their equations dropped."
   :waist n
   :alter-elements (Œª es ‚Üí
     (-let [i 0]
       (--graph-map (progn (incf i) (<= i n))
                    (map-equations (-const nil) it)
                    es))))
#+END_SRC
#+LaTeX: \setminted[common-lisp]{fontsize=\footnotesize, breaklines}

** Characterising =:waist= as Œ†‚ÜíŒª

#+ATTR_LATEX: :width 0.4\paperwidth
# [[file:~/thesis-proposal/waist-pi-to-lambda-char.png]]

# +begin_center


# src_haskell[:exports code]{Œ†‚ÜíŒª (Œ† a : A ‚Ä¢ œÑ)  =  (Œª a : A ‚Ä¢ œÑ)}

#+BEGIN_SRC haskell
Œ†‚ÜíŒª (Œ† a : A ‚Ä¢ œÑ)  =  (Œª a : A ‚Ä¢ œÑ)
#+END_SRC

\pause
-----
\vspace{0.5em}

#+begin_parallelNB org
#+begin_src haskell
id‚ÇÄ : Set‚ÇÅ
id‚ÇÄ = Œ† X ‚à∂ Set ‚Ä¢ Œ† e ‚à∂ X ‚Ä¢ X

id‚ÇÅ : Œ† X ‚à∂ Set ‚Ä¢ Set
id‚ÇÅ = Œª (X : Set) ‚Üí Œ† e ‚à∂ X ‚Ä¢ X

id‚ÇÇ : Œ† X ‚à∂ Set ‚Ä¢ Œ† e ‚à∂ X ‚Ä¢ Set
id‚ÇÇ = Œª (X : Set) (e : X) ‚Üí X
#+end_src

#+latex: \columnbreak

\pause
+ ~id·µ¢‚Çä‚ÇÅ ‚âà Œ†‚ÜíŒª id·µ¢~
+ ~id‚ÇÄ~ is a /type of functions/
+ ~id‚ÇÅ~ is a /function on types/

#+end_parallelNB

:Details:
We shall refer to the latter change
as @@latex: \emph{re\"{\i}fication}@@ since the result is more concrete: It can
be applied. This transformation will be
denoted by ~Œ†‚ÜíŒª~. To clarify this subtlety, consider the following forms of the
polymorphic identity function. Notice that $\mathsf{id}·µ¢$ /exposes/ =i=-many details at the
type level to indicate the sort of data it consists of. However, notice that ~id‚ÇÄ~ is
a type of functions whereas $\mathsf{id}‚ÇÅ$ is a function on types. Indeed, the latter
:End:

** =Context= Agda Library ‚áí *Pragmatic Interface*

   # [[file:~/thesis-proposal/pragmattic.png]]

#+latex: \centering
#+latex: \begin{minipage}[t]{0.95\linewidth}
#+begin_src haskell
Monoid : ‚àÄ ‚Ñì ‚Üí Context (‚Ñìsuc ‚Ñì)
Monoid ‚Ñì = do Carrier ‚Üê Set ‚Ñì
              _‚äï_    ‚Üê (Carrier ‚Üí Carrier ‚Üí Carrier)
              Id      ‚Üê Carrier
              leftId  ‚Üê ‚àÄ {x : Carrier} ‚Üí x ‚äï Id ‚â° x
              rightId ‚Üê ‚àÄ {x : Carrier} ‚Üí Id ‚äï x ‚â° x
              assoc   ‚Üê ‚àÄ {x y z} ‚Üí (x ‚äï y) ‚äï z  ‚â°  x ‚äï (y ‚äï z)
              End {‚Ñì}
#+end_src
#+latex:   \end{minipage}

\pause \vspace{1em}
- Ideas: /Weak/ *Agda Reflection*, No fresh names, Monads, Termination,
  ‚ÄòReification‚Äô Œ†‚ÜíŒª

  \pause  \vspace{1em}
- Draft paper: /Do-it-yourself Module Systems/

** ‚ÄòAll‚Äô module constructions are born from =Context=
# [[file:~/thesis-proposal/everything-is-a-context.png]]

# +begin_scriptsize org
    \pause \vspace{0.5em}
+ Context: ‚Äúname-type pairs‚Äù
  #+BEGIN_SRC haskell
do S ‚Üê Set; s ‚Üê S; n ‚Üê (S ‚Üí S); End
#+END_SRC
    \pause \vspace{0.5em}

+ Record Type: ‚Äúbundled-up data‚Äù
   #+BEGIN_SRC haskell
Œ£ S ‚à∂ Set ‚Ä¢ Œ£ s ‚à∂ S ‚Ä¢ Œ£ n ‚à∂ S ‚Üí S ‚Ä¢ ùüô
#+END_SRC
    \pause \vspace{0.5em}

+ Function Type: ‚Äúa type of functions‚Äù
   #+BEGIN_SRC haskell
Œ† S ‚Ä¢ Œ£ s ‚à∂ S ‚Ä¢ Œ£ n ‚à∂ S ‚Üí S ‚Ä¢ ùüô
#+END_SRC
    \pause \vspace{0.5em}

+ Type constructor: ‚Äúa function on types‚Äù
   #+BEGIN_SRC haskell
Œª S ‚Ä¢ Œ£ s ‚à∂ S ‚Ä¢ Œ£ n ‚à∂ S ‚Üí S ‚Ä¢ ùüô
#+END_SRC
    \pause \vspace{0.5em}

+ Algebraic datatype: ‚Äúa descriptive syntax‚Äù
   #+BEGIN_SRC haskell
data ùîª : Set where s : ùîª; n : ùîª ‚Üí ùîª
#+END_SRC

# +end_scriptsize

** Comparing =PackageFormer= and =Context=
   # [[file:~/thesis-proposal/PF-Context-comparision.png]]

  |                          | PackageFormer      | Contexts             |
  |--------------------------+--------------------+----------------------|
  | Type of Entity           | Preprocessing Tool | Language Library     |
  | Specification Language   | Lisp + Agda        | Agda                 |
  | Well-formedness Checking | ‚ùå               | ‚úì                    |
  | Termination Checking     | ‚úì                  | ‚úì                    |
  | Elaboration Tooltips     | ‚úì                  | ‚ùå                 |
  | Rapid Prototyping        | ‚úì                  | ‚úì (Slower)           |
  | Usability Barrier        | None               | None                 |
  | Extensibility Barrier    | Lisp               | Weak Metaprogramming |

** Current Activities

1. Complete a \alert{interpreter}, via a rewrite-system, for =PackageFormer=

   #+latex: \vspace{2em}

2. Finish \alert{writing thesis}
   - Demonstrate that \alert{common module idioms} are expressible in our framework
   - Demonstrate that several @@latex:\alert{uncommon notions of packaging from universal
     algebra} are also possible!@@

* Contributions

** Module Systems for DTLs

1. The ability to /implement/ module systems \alert{for DTLs within DTLs}

   #+latex: \vspace{1em} \pause
2. The ability to arbitrarily \alert{extend} such systems by users at a high-level

      #+latex: \vspace{1em} \pause
3. Demonstrate that there is an expressive yet minimal set of
   \alert{module meta-primitives} which allow common module constructions to be defined

   # **Unifying Seemingly Disparate Notions of Modules
      #+latex: \vspace{1em} \pause
4. [@4] Demonstrate that relationships between modules can also be \alert{mechanically}
   generated.
   # - In particular, if module ‚Ñ¨ is obtained by applying a user-defined
   #   ‚Äòvariational‚Äô to module ùíú, then the user could also enrich the child module
   #   ‚Ñ¨ with morphisms that describe its relationships to the parent module ùíú.
   # - E.g., if ‚Ñ¨ is an extension of ùíú, then we may have a ‚Äúforgetful mapping‚Äù
   #   that drops the new components; or if ‚Ñ¨ is a ‚Äòminimal‚Äô rendition of the
   #   theory ùíú, then we have a ‚Äúsmart constructor‚Äù that forms the rich ùíú by only
   #   asking the few ‚Ñ¨ components of the user.

** Termtypes as Modules

#+latex: \centering

5. [@5] Bring \alert{algebraic data types} under the umbrella of grouping mechanisms:
   An ADT is just a context whose symbols target the ADT ‚Äòcarrier‚Äô and
   are not otherwise interpreted.
   - In particular, both an ADT and a record can be obtained *practically* from
     a *single* context declaration.

\pause

\vspace{-0.5em}
#+begin_parallel org

# +ATTR_LATEX: :width 0.45\paperwidth :height 0.35\paperheight
#+begin_src haskell
DynamicSystem : Context ‚Ñì‚ÇÅ
DynamicSystem
    = do State ‚Üê Set
         start ‚Üê State
         next  ‚Üê (State ‚Üí State)
         End
#+end_src
# [[file:~/thesis-proposal/unbundling-DS-0.png]]

#+latex: \columnbreak

\pause
# +ATTR_LATEX: :width 0.2\paperwidth :height 0.2\paperheight
# [[file:~/thesis-proposal/DS-data.png]]

#+begin_src haskell
data ùîª : Set where
    startD : ùîª
    nextD  : ùîª ‚Üí ùîª
#+end_src

#+end_parallel

\pause
\vspace{-1.3em}
-----
\vspace{-2em}
#+latex: \begin{minipage}[t]{0.85\linewidth}
#+begin_src haskell
ùîª = termtype (DynamicSystem :waist 1)

-- Pattern synonyms for more compact presentation
pattern startD  = Œº (inj‚ÇÅ tt)       -- : ùîª
pattern nextD e = Œº (inj‚ÇÇ (inj‚ÇÅ e)) -- : ùîª ‚Üí ùîª
trivial : ùîª ‚âÖ ‚Ñï
#+end_src
#+latex: \end{minipage}

# +latex: \setlength{\unitlength}{1cm} \begin{picture}(0,0)(0,0)
# +latex: \put(6,-1.55){
# +ATTR_LATEX: :width 0.45\paperwidth :height 0.4\paperheight
# [[file:~/thesis-proposal/DS-termtype.png]]
# +latex: }
# +latex: \end{picture}

** Common data-structures as *free* termtypes
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

6. [@6] Show that common data-structures are \alert{mechanically the (free) termtypes} of
   common modules.

\centering
\vspace{-1em}
\pause

   | Module System         | Termtype |
   |-----------------------+----------|
   | Dynamical Structures  | Naturals |
   | Collection Structures | Lists    |
   | Pointed Structures    | Maybe    |

\vspace{-1em}
\pause

# +ATTR_LATEX: :width 0.45\paperwidth :height 0.5\paperheight
# [[file:~/thesis-proposal/lists-as-free-collections.png]]

#+LaTeX: \setminted[haskell]{fontsize=\scriptsize, breaklines}
#+begin_src haskell
Collection : ‚àÄ ‚Ñì ‚Üí Context (‚Ñìsuc ‚Ñì)
Collection ‚Ñì = do Elem    ‚Üê Set ‚Ñì
                  Carrier ‚Üê Set ‚Ñì
                  insert  ‚Üê (Elem ‚Üí Carrier ‚Üí Carrier)
                  ‚àÖ       ‚Üê Carrier
                  End {‚Ñì}

List : Set ‚Üí Set
List ElemType = termtype ((Collection ‚Ñì‚ÇÄ :waist 2) ElemType)

pattern _::_ x xs = Œº (inj‚ÇÅ (x , xs , tt))
pattern  ‚àÖ        = Œº (inj‚ÇÇ (inj‚ÇÅ tt))
#+end_src
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "committee.pdf"))

** Solve the unbundling problem ---all in Agda!

7. [@7] The ability to ‚Äòunbundle‚Äô module fields as if they were parameters ‚Äòon
   the fly‚Äô

\pause
\vspace{-1.2em}
-----
#+begin_parallelNB org
# +ATTR_LATEX: :width 0.45\paperwidth :height 0.5\paperheight
#+begin_src haskell
DynamicSystem : Context ‚Ñì‚ÇÅ
DynamicSystem
    = do State ‚Üê Set
         start ‚Üê State
         next  ‚Üê (State ‚Üí State)
         End
#+end_src
# [[file:~/thesis-proposal/unbundling-DS-0.png]]

\pause \columnbreak
# +ATTR_LATEX: :width 0.45\paperwidth :height 0.5\paperheight
# [[file:~/thesis-proposal/unbundling-DS-1.png]]

#+BEGIN_SRC haskell
ùí©‚Å∞ : DynamicSystem :waist 0
ùí©‚Å∞ = ‚ü® ‚Ñï , 0 , suc ‚ü©

ùí©¬π : (DynamicSystem :waist 1) ‚Ñï
ùí©¬π = ‚ü® 0 , suc ‚ü©

ùí©¬≤ : (DynamicSystem :waist 2) ‚Ñï 0
ùí©¬≤ = ‚ü® suc ‚ü©

ùí©¬≥ : (DynamicSystem :waist 3) ‚Ñï 0 suc
ùí©¬≥ = ‚ü®‚ü©
#+END_SRC
#+end_parallelNB

\pause
#+begin_export latex
  % X-axis to the right and Y-axis upwards
  \setlength{\unitlength}{1cm}
  \begin{picture}(0,0)(0,0)
   \put(0,2.5){\textbf{Without redefining \texttt{DynamicSystem}},}
   \put(0,2.0){we are able to \textbf{fix} some of its fields}
   \put(0,1.5){by making them into parameters!}
\end{picture}
#+end_export

\pause
\vspace{-3em}
-----
\vspace{-0.5em}
#+begin_footnotesize org
# Using ~:waist ùíæ~ we may fix the first ~ùíæ~-parameters ahead of time.
# \vspace{-1em}
# + =(DynamicSystem :waist 1) ‚Ñï= is /the type of dynamic systems over carrier ‚Ñï/
# \vspace{-1em}

The type of dynamic systems *over* carrier ‚Ñï and start state 0
\newline is =(DynamicSystem :waist 2) ‚Ñï 0=.
#+end_footnotesize

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "committee.pdf"))

:Examples_in_the_wild:

Examples of the need for such on-the-fly unbundling can be found in numerous
places in the Haskell standard library. For instance, the standard libraries cite:data_monoid
have two isomorphic copies of the integers, called ~Sum~ and ~Product~, whose reason
for being is to distinguish two common monoids: The former is for /integers with
addition/ whereas the latter is for /integers with multiplication/.

:End:

** Theory & Implementation

8. [@8] Demonstrate that there is a \alert{practical implementation} of such a framework

   - [X] The =Context= framework is implemented in Agda and we've seen practical examples of
     its use.

      #+latex: \vspace{2em} \pause
9. Finally, the resulting framework is /mostly/ \alert{type-theory agnostic}: The target
   setting is DTLs but we only assume the barebones; if users drop parts of that
   theory, then /only/ some parts of the framework will no longer apply.

   - [ ] Started ...

# - For instance, in DTLs without a fixed-point functor the framework still
#   ‚Äòapplies‚Äô, but can no longer be used to provide arbitrary algebraic data
#   types from contexts.
#
* Next Steps

** SMART Goals
# Slide I: Specific goals and milestones for the next six months

+ June 2020 :: Finish \alert{interpreter} for =PackageFormer=

   #+latex: \vspace{1em} \pause
+ July 2020 :: Finish writing \alert{thesis}
  - Possibly submit draft paper /Do-it-yourself Module Systems/

   #+latex: \vspace{1em} \pause
+ August 2020 :: \alert{Defend} thesis

** Summary
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

\pause

1. *Published* one paper regarding research and have a draft ready to be
   cleaned-up
      #+latex: \vspace{2em}
2. *Currently* working on the thesis with the \alert{intention} of defending in the next few months

\pause
\vspace{1em}
/Thank-you for your time!/

\vspace{1em}
\centerline{Questions?}
* COMMENT Half-page summary 2020

  This year I have completed the majority of my research and
  have begun the thesis writing phase.

  Since the last meeting of May 24 2019, the following tasks have been
  accomplished:
  + A prototype has been written to show the theory ‚Äòworks‚Äô
  + An associated Agda library has also been written
  + A publication and paper draft have been written, attached
    - There were no prior publications

  Besides research, I was a teaching assistant in each academic term.

  Common, mechanical, patterns for module construction are just out
  of reach of the module systems of dependently-typed languages.
  Such languages permit a rich number of possible formulations for
  a module, such as by having some of its constituents exposed
  at the type level as paramters, others as fields, and others
  as definitional extensions.

  Library designers are generally conservative; they provide a predicate
  formulation consisting of a set of proof obligations that constrain the
  functional symbols provided as paramters in the type level. This formulation
  is then usually accompanied by a fully ‚Äúbundled up‚Äù variation that has no
  parameters and all relevant data is rendered as fields.

  However, trouble arises when library users wish to fix only one field ahead of
  time ---this is the ‚Äúunbundling problem‚Äù and it is akin to function uncurrying
  but for modules.

  Moreover, library designers for dependently-typed languages generally only
  provide a handful of formulations for a single module. Other formulations
  must be written out by hand by users, which must then form coercions
  between the new forms and those used in the library, so as to make use
  of the library's utilities.

  I have produced an editor extension for Agda's de-facto IDE, Emacs,
  which reduces the boilerplate for new formulations of modules to
  simple, usually one-line, specifications. The tool is run in the background
  and works on ordinary Agda files by looking at special comments.
  The specifications are expanded into typechecked Agda code.

  Moreover, using the lessons learned from the editor extension, an Agda library
  has been implemented to achieve similar goals within Agda itself.  Due to
  Agda's current metaprogramming limitations, such as the inability to produce
  fresh names, development with the library is slower than with the editor
  extension.

  A paper has been published regarding the editor extension
  and a paper draft is in preparation regarding the associated Agda library.

  Going forward, the aim is to finish thesis writing and to defend in the
  upcoming months, namely August 2020.
