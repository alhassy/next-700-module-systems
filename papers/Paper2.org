#+TITLE: Monadically Making Modules
#+SUBTITLE: 3-for-1 Monadic Notation: Do-it-yourself module types
# +Subtitle: ---ICFP Deadline: March 3, 2020---
#+DESCRIPTION: Paper for ICFP 2020.
#+AUTHOR: Musa Al-hassy, Jacques Carette, Wolfram Kahl
#+EMAIL: alhassy@gmail.com
#+OPTIONS: toc:nil d:nil author:t title:nil
#+PROPERTY: header-args :tangle no :comments link
#+TODO: TODO | OLD LaTeX README Remarks space
#+MACRO: PF \textsf{PackageFormer}
#+property: header-args :tangle paper2.agda :comments link

# src_agda[:exports code]{
:PDF:
For some reason “src agda2” crashes minted, but “src agda” works fine.

     #+BEGIN_SRC emacs-lisp  :tangle no
(setq org-latex-pdf-process
      '("pdflatex -shell-escape -output-directory %o %f"
        ;; "biber %b"
        "bibtex %b"
        "pdflatex -shell-escape -output-directory %o %f"
        "pdflatex -shell-escape -output-directory %o %f"))

(add-to-list 'org-src-lang-modes '("agda" . haskell))

(setq color t)
(when color     (setq org-latex-listings 'minted
                      org-latex-packages-alist '(("" "minted"))))
(unless color      (setq org-latex-listings nil
                         org-latex-packages-alist nil))
     #+END_SRC

     #+RESULTS:

#+BEGIN_SRC emacs-lisp :tangle no
(setq org-latex-compiler "pdflatex")
(setq-default TeX-engine 'default)

(setq org-latex-listings nil)
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("" "listings"))
(add-to-list 'org-latex-packages-alist '("" "color"))

(org-latex-export-to-pdf)
#+END_SRC

#+RESULTS:
: /Users/musa/thesis-proposal/papers/Paper2.pdf

:End:

:WK:
+ [ ] The ``Graph'' in ``data Graph'' seems to be a misnomer (should be ``Edge''?) --- poor example?

+ [ ] First occurrence of ``termtypes'' --> ``term datatypes'' or ``datatypes of expressions/terms''?

+ [ ] ``is thus a macro that acts on the syntactic term representations''
    Explanation of and reference for Agda's ``reflection'' mechanism necessary:
    This needs to be reasonably readable for Haskell programmers who have never looked into Agda.
    (Also explain pattern synonyms, and probably also some other Agda features.)

+ [ ] The ``definition'' of \Pi\to\lambda is presumably pseudo-Agda:
    Please be clear about that! Preferably put the full definition into an appendix.

+ [ ] After code blocks, \noindent.
    Consider indenting the code blocks instead, for more traditional
    literate programming appearance.

+ [ ] Avoid linebreak in thh middle of math --- \hbox{}.
  - src_agda[:exports code]{

+ [ ] |Maybe| is not a terribly high climax...

+ [ ] PointedSet/PointedPF: Currently does not look very attractive to me ---
    do you have any ``bigger'' examples?
:End:

* README COMMENT Dependencies of this org file

In the source blocks below, go into each one and press C-c C-c
to have it executed. Some ‘results’ will be echoed into the buffer
if everything went well.

Rather than executing the following blocks each time you edit this file,
consider adding them to your Emacs [[https://alhassy.github.io/init/][configuration file]].

 + org-mode :: This particular markup is called org-mode.

     Let's obtain Org-mode along with the extras that allow us to ignore
     heading names, but still utilise their contents --e.g., such as a heading
     named ‘preamble’ that contains org-mode setup for a file.
     #+begin_src emacs-lisp
;; first we get a handy-dandy package manager

(require 'package)
(setq package-archives '(("org"       . "https://orgmode.org/elpa/")
                         ("gnu"       . "https://elpa.gnu.org/packages/")
                         ("melpa"     . "https://melpa.org/packages/")
                         ("melpa-stable" . "https://stable.melpa.org/packages/")
                         ))
(package-initialize)

(package-refresh-contents)

(package-install 'use-package)
(require 'use-package)
(setq use-package-always-ensure t)

;; then we get the org-mode goodness

(use-package org
  :ensure org-plus-contrib
  :config
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines)))
#+end_src

     This lets us use the ~:ignore:~ tag on headlines you'd like to have ignored,
     while not ignoring their content --see [[https://emacs.stackexchange.com/a/17677/10352][here]].

     - Use the ~:noexport:~ tag to omit a headline /and/ its contents.

 + minted & bib :: Source blocks obtain colour.

     Execute the following for bib ref as well as minted
     Org-mode uses the Minted package for source code highlighting in PDF/LaTeX
     --which in turn requires the pygmentize system tool.
     #+BEGIN_SRC emacs-lisp
     (setq org-latex-listings 'minted
           org-latex-packages-alist '(("" "minted"))
           org-latex-pdf-process
           '("pdflatex -shell-escape -output-directory %o %f"
             ;; "biber %b"
             "bibtex %b"
             "pdflatex -shell-escape -output-directory %o %f"
             "pdflatex -shell-escape -output-directory %o %f")
     )
     #+END_SRC

     #+RESULTS:
     | pdflatex -shell-escape -output-directory %o %f | bibtex %b | pdflatex -shell-escape -output-directory %o %f | pdflatex -shell-escape -output-directory %o %f |

You can then refer to Table (tab-boring). The ref links are also clickable, and
they take you to the spot where the label is defined. You can enter ref links
with completion. Press C-c C-l, type ref, press enter, and then press tab. You
will get a list of the labels defined in the buffer you can choose from. There
are many things you can make a ref to including a tblname, a label link, an
explicit \label{}, and an org-mode #+label: line. (tab-boring)

Instead of C-c C-l, use org-ref-insert-ref-link; e.g., ref:make-acmart-class
refers to the table below. Use “ref” to refer to Org entities.

See here for more: http://kitchingroup.cheme.cmu.edu/blog/2014/05/13/Using-org-ref-for-citations-and-references/

  # Enable the following to have small-font code blocks.
  # LATEX_HEADER: \RequirePackage{fancyvrb}
  # LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}

 + acmart :: Enable acmart latex class.

   #+NAME: make-acmart-class
   #+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("acmart" "\\documentclass{acmart}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

 (message "acmart has been loaded")
 #+END_SRC

 #+RESULTS: make-acmart-class
 : acmart has been loaded

  The GPCE 19 proceedings team needs us to submit the acmart.cls file along
  with our sources. So, let's bring that to our current directory.
#+BEGIN_SRC shell
(shell-command (s-collapse-whitespace (format "cp %s ."
                       (shell-command-to-string "kpsewhich acmart.cls"))))
#+END_SRC

#+RESULTS:
: 126

   The ‘footer’ at the end of this file currently executes only this code block for you
   ---if you enable the local vars. You can easily tweak it to execute the other blocks,
   if you like.

 + org-ref :: [[https://github.com/jkitchin/org-ref][An exquisite system]] for handling references.

    If everything works, the following entity will display useful data
    when the mouse hovers over it (•̀ᴗ•́)و If you click on it, then you're
    in for a lot of super neat stuff, such as searching for the pdf online!

    cite:agda_overview

    #+BEGIN_SRC emacs-lisp
(use-package org-ref :demand t)

;; Files to look at when no “╲bibliography{⋯}” is not present in a file.
;; Most useful for non-LaTeX files.
(setq reftex-default-bibliography '("References.bib"))

(use-package helm-bibtex :demand t)
;; If you use helm-bibtex as the citation key completion method you should set these variables too.

(setq bibtex-completion-bibliography "References.bib")
#+END_SRC

#+RESULTS:
: References.bib

#+RESULTS:
: References.bib

  Execute ~M-x helm-bibtex~ and, say, enter ~agda~ and you will be presented with
  all the entries in the bib database that mention ‘agda’. Super cool stuff.

* LaTeX setup                                                        :ignore:

#+latex_class_options: [10pt]

  # Visible editorial comments.
  # LATEX_HEADER: \usepackage{edcomms}
  # LATEX_HEADER: \edcommsfalse

  #+latex_header: \usepackage[font=itshape]{quoting}
  # Use quoting environment

** Document class options                                            :ignore:
  #+LATEX_CLASS: acmart
  # latex_class_options: [sigplan,screen]
  # latex_class_options: [sigplan,review,anonymous]
  # #+latex_class_options: [sigplan,review]
  # latex_class_options: [acmsmall,review,anonymous]

** Letter size and no page numbers or footers :ignore:
  # Letter-Size Paper Format, defaults
  #+latex_header: \pdfpagewidth=8.5in
  #+latex_header: \pdfpageheight=11in

  # switch off page numbering, “folios”
  # latex_header: \pagenumbering{gobble}

  # LATEX: \settopmatter{printccs=true, printfolios=false}

** Unicode & hyperlinks :ignore:
  # Dark green colour for links.
  #+LATEX_HEADER: \usepackage{color}
  #+LATEX_HEADER: \definecolor{darkgreen}{rgb}{0.0, 0.3, 0.1}
  #+LATEX_HEADER: \hypersetup{colorlinks,linkcolor=darkgreen,citecolor=darkgreen,urlcolor=darkgreen}

  #+LATEX_HEADER: \usepackage{../CheatSheet/UnicodeSymbols}

  #+LATEX_HEADER: \newcommand\boldblue[1]{\textcolor{blue}{\textbf{#1}}}
  #+LATEX_HEADER: \newcommand\boldred[1]{\textcolor{red}{\textbf{#1}}}
  #+LATEX_HEADER: \newcommand\boldgreen[1]{\textcolor{darkgreen}{\textbf{#1}}}

  #+LATEX_HEADER: \newunicodechar{ʳ}{\boldblue{\text{\ensuremath{^r}}}}

  #+LATEX_HEADER: \newunicodechar{Σ}{\boldblue{\text{\ensuremath{\Sigma}}}}
  #+LATEX_HEADER: \newunicodechar{⊎}{\boldblue{\text{\ensuremath{\uplus}}}}
  #+LATEX_HEADER: \newunicodechar{×}{\boldblue{\text{\ensuremath{\times}}}}
  #+LATEX_HEADER: \newunicodechar{Π}{\boldred{\text{\ensuremath{\Pi}}}}
  #+LATEX_HEADER: \newunicodechar{λ}{\boldgreen{\text{\ensuremath{\lambda}}}}
  #+LATEX_HEADER: \newunicodechar{≅}{\boldblue{\text{\ensuremath{\cong}}}}
  #+LATEX_HEADER: \newunicodechar{ℕ}{\boldblue{\text{\ensuremath{\mathbb{N}}}}}

  #+LATEX_HEADER: \DeclareMathOperator{\VCCompose}{\longrightarrow\hspace{-3ex}\oplus\;}
  #+LATEX_HEADER: \newunicodechar{⟴}{\ensuremath{\!\!\VCCompose}}
  #+LATEX_HEADER: \newunicodechar{𝓋}{\ensuremath{\!\!v}}
  #+LATEX_HEADER: \newunicodechar{𝒱}{\ensuremath{\mathcal{V}}}
  #+LATEX_HEADER: \newunicodechar{α}{\ensuremath{\alpha}}

  #+LATEX_HEADER: \newunicodechar{≇}{\ensuremath{\ncong}}

  #+LATEX_HEADER: \newunicodechar{ℓ}{\ensuremath{\ell}}
  #+LATEX_HEADER: \newunicodechar{‵}{\ensuremath{`}}
  #+LATEX_HEADER: \newunicodechar{↝}{\ensuremath{\longrightarrow}}
  #+LATEX_HEADER: \newunicodechar{⇊}{\ensuremath{\downarrow\!\downarrow}}

  # 𝑛𝑎𝑚𝑒
  #+LATEX_HEADER: \newunicodechar{𝑛}{\ensuremath{n}}
  #+LATEX_HEADER: \newunicodechar{𝑎}{\ensuremath{a}}
  #+LATEX_HEADER: \newunicodechar{𝑚}{\ensuremath{m}}
  #+LATEX_HEADER: \newunicodechar{𝑒}{\ensuremath{e}}

  #+LATEX_HEADER: \newunicodechar{⁰}{\ensuremath{^0}}
  #+LATEX_HEADER: \newunicodechar{ⁿ}{\ensuremath{^n}}
  #+LATEX_HEADER: \newunicodechar{³}{\ensuremath{^3}}

  #+LATEX_HEADER: \newunicodechar{Ξ}{\ensuremath{\Xi}}
  #+LATEX_HEADER: \newunicodechar{ξ}{\ensuremath{\xi}}

  #+LATEX_HEADER: \newunicodechar{𝕆}{\ensuremath{\textbb{O}}}
  #+LATEX_HEADER: \newunicodechar{𝕟}{\ensuremath{\textbb{n}}}
  #+LATEX_HEADER: \newunicodechar{𝕖}{\ensuremath{\textbb{e}}}

  #+LATEX_HEADER: \newunicodechar{⇌}{\ensuremath{\rightleftharpoons}}

  #+LATEX_HEADER: \newunicodechar{𝔾}{\ensuremath{\textbb{G}}}
  #+LATEX_HEADER: \newunicodechar{𝕣}{\ensuremath{\textbb{r}}}
  #+LATEX_HEADER: \newunicodechar{𝕒}{\ensuremath{\textbb{a}}}
  #+LATEX_HEADER: \newunicodechar{𝕡}{\ensuremath{\textbb{p}}}
  #+LATEX_HEADER: \newunicodechar{𝕙}{\ensuremath{\textbb{h}}}

  #+LATEX_HEADER: \newunicodechar{❌}{\ding{55}}
  #+LATEX_HEADER: \newunicodechar{✓}{\ding{51}}

  #+LATEX_HEADER: \newunicodechar{𝔻}{\ensuremath{\textbb{D}}}
  #+LATEX_HEADER: \newunicodechar{ℂ}{\ensuremath{\textbb{C}}}
  #+LATEX_HEADER: \newunicodechar{𝕄}{\ensuremath{\textbb{M}}}
  #+LATEX_HEADER: \newunicodechar{ℙ}{\ensuremath{\textbb{P}}}
  #+LATEX_HEADER: \newunicodechar{𝟘}{\ensuremath{\textbb{0}}}
  #+LATEX_HEADER: \newunicodechar{𝟙}{\ensuremath{\textbb{1}}}

  #+LATEX_HEADER: \newunicodechar{𝑷}{\ensuremath{\textbf{P}}}
  #+LATEX_HEADER: \newunicodechar{𝑭}{\ensuremath{\textbf{F}}}
  #+LATEX_HEADER: \newunicodechar{𝑯}{\ensuremath{\textbf{H}}}

** COMMENT CCSXML and Keywords                                               :ignore:
   # This must be /before/ maketitle!
   #+begin_export latex
 %%
 %% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.

 \begin{CCSXML}
 <ccs2012>
 <concept>
 <concept_id>10011007.10011006.10011008.10011009.10011019</concept_id>
 <concept_desc>Software and its engineering~Extensible languages</concept_desc>
 <concept_significance>500</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011024.10011031</concept_id>
 <concept_desc>Software and its engineering~Modules / packages</concept_desc>
 <concept_significance>500</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
 <concept_desc>Software and its engineering~Functional languages</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011024.10011025</concept_id>
 <concept_desc>Software and its engineering~Polymorphism</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011041.10011047</concept_id>
 <concept_desc>Software and its engineering~Source code generation</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011066.10011069</concept_id>
 <concept_desc>Software and its engineering~Integrated and visual development environments</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 </ccs2012>
 \end{CCSXML}

 \ccsdesc[500]{Software and its engineering~Extensible languages}
 \ccsdesc[500]{Software and its engineering~Modules / packages}
 \ccsdesc[300]{Software and its engineering~Functional languages}
 \ccsdesc[300]{Software and its engineering~Polymorphism}
 \ccsdesc[300]{Software and its engineering~Source code generation}
 \ccsdesc[300]{Software and its engineering~Integrated and visual development environments}

 %%
 %% Keywords. The author(s) should pick words that accurately describe
 %% the work being presented. Separate the keywords with commas.
 \keywords{Agda, meta-program, extensible, Emacs, packages, modules, dependent-types}
   #+end_export

** COMMENT Authors & title                                                   :ignore:

 #+begin_export latex
 \author{Musa Al-hassy}
 \affiliation{McMaster University, Canada}
 \email{alhassy@gmail.com}

 \author{Jacques Carette}
 \orcid{0000-0001-8993-9804}
 \affiliation{McMaster University, Canada}
 \email{carette@mcmaster.ca}

 \author{Wolfram Kahl}
 \orcid{0000-0002-6355-214X}
 \affiliation{McMaster University, Canada}
 \email{kahl@cas.mcmaster.ca}

 % \author{Musa Al-hassy \\ {\small \url{alhassy@gmail.com} \\ McMaster University \\ Computing and Software \\ Hamilton, Ontario, Canada}}
 % \author{Jacques Carette \\ {\small \url{carette@mcmaster.ca} \\ McMaster University \\ Computing and Software \\ Hamilton, Ontario, Canada}}
 % \author{Wolfram Kahl \\ {\small \url{kahl@cas.mcmaster.ca} \\ McMaster University \\ Computing and Software \\ Hamilton, Ontario, Canada}}

 #+end_export

** Widows and Orphans                                                :ignore:
 # An "orphan" is an isolated line of text at the bottom of a page;
 # an "orphan heading" is a heading without following body text at the bottom of the page;
 # a "widow" is an isolated line of text at the top of a page.
 #
 # LaTeX: In order to eliminate widows and orphans, you can copy the following commands into the LaTeX source before \begin{document} :
 #
   #+latex_header:        \clubpenalty = 10000
   #+latex_header:        \widowpenalty = 10000
   #+latex_header:        \displaywidowpenalty = 10000

 # Sometimes, orphans and widows will survive these commands, in which case a \vspace command might help.

** Balanced Columns on Last Page                                     :ignore:
   #+latex_header: \usepackage{flushend}

 # The two columns of the last page need to have the same length.
 #
 # + LaTeX (Option 1) :: Insert the command \usepackage{flushend} into the LaTeX source before \begin{document}.
 #
 # + LaTeX (Option 2) :: Insert \usepackage{balance} into the LaTeX source before \begin{document}
 #      and the following in the text that would appear as left column on the last page without balancing: \balance.
 #
 # + LaTeX (Option 3) :: If the above options do not work, it seems that one of the used packages prevents
 #      the balancing from working properly. In case you do not want to spend time on finding out which
 #       package it is, you can manually balance the last page by inserting a \newpage between your
 #       references in the .bbl file at an appropriate position. (Attention: Running bibtex again
 #       will overwrite this; alternatively, the contents of the .bbl file can be copy-and-paste'ed
 #       into the main LaTeX file in place of the \bibliography command.)
 #
** COMMENT GPCE’19 Copyright                                                 :ignore:

 # The following is specific to GPCE '19 and the paper
 # 'A Language Feature to Unbundle Data at Will (Short Paper)'
 # by Musa Al-hassy, Wolfram Kahl, and Jacques Carette.
 #
 #+latex_header: \setcopyright{acmcopyright}
 #+latex_header: \acmPrice{15.00}
 #+latex_header: \acmDOI{10.1145/3357765.3359523}
 #+latex_header: \acmYear{2019}
 #+latex_header: \copyrightyear{2019}
 #+latex_header: \acmISBN{978-1-4503-6980-0/19/10}
 #+latex_header: \acmConference[GPCE '19]{Proceedings of the 18th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences}{October 21--22, 2019}{Athens, Greece}
 #+latex_header: \acmBooktitle{Proceedings of the 18th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences (GPCE '19), October 21--22, 2019, Athens, Greece}
 #+latex_header:

* Abstract :ignore:

  #+begin_abstract org
  Can parameterised records and algebraic datatypes be derived from one
  pragmatic declaration?

  Record types give a universe of discourse, parameterised record types fix
  parts of that universe ahead of time, and algebraic datatypes give us
  first-class syntax, whence evaluators and optimisers.

  The answer is in the affirmative. Besides a practical
  shared declaration interface, which is extensible in the language,
  we also find that common data structures correspond to simple theories.
#+end_abstract

 \maketitle

* Header :noexport:

#+begin_src agda :tangle paper2.agda
module paper2 where

--------------------------------------------------------------------------------
-- (shell-command "ln -s /Users/musa/thesis-proposal/prototype/semantics-with-waist.agda semantics-with-waist.agda")

open import semantics-with-waist
open import Data.Product
open import Level renaming (zero to ℓ₀) hiding (suc)
open import Relation.Binary.PropositionalEquality hiding ([_])
open import Data.Nat
open import Function using (id)
open import Data.Bool renaming (Bool to 𝔹)
open import Data.Sum

open import Data.List
import Data.Unit as Unit
open import Reflection hiding (name; Type) renaming (_>>=_ to _>>=ₘ_)

ℓ₁ = Level.suc ℓ₀

-- Helpers for readability
pattern ⟨_⟩₁ x    = x , tt
pattern ⟨_,_⟩ x y = x , y , tt
#+end_src

* Introduction

  We routinely write algebraic datatypes to provide a first-class syntax for
  record values. We work with semantic values, but need syntax to provide
  serialisation and introspection capabilities.  A concept is thus rendered
  twice, once at the semantic level using records and again at the syntactic
  level using algebraic datatypes. Even worse, there is usually a need to expose
  fields of a record at the type level and so yet another variation of the same
  concept needs to be written.  Our idea is to unify the various type declarations
  into one ---using monadic do-notation and in-language meta-programming
  combinators to then extract possibly parameterised records and algebraic data
  types.

  For example, there are two ways to implement the type of graphs in the
  dependently-typed language Agda
 cite:Norell-2007,agda_overview: Having the vertices be a parameter or having
  them be a field of the record. Then there is also the syntax for graph vertex
  relationships.

#+begin_src agda
record Graph₀ : Set₁ where
  constructor ⟨_,_⟩₀
  field
    Vertex : Set
    Edges : Vertex → Vertex → Set

record Graph₁ (Vertex : Set) : Set₁ where
  constructor ⟨_⟩₁
  field
    Edges : Vertex → Vertex → Set

data 𝔾𝕣𝕒𝕡𝕙 (Vertex : Set) : Set where
  ⟨_,_⟩ₛ : Vertex → Vertex → 𝔾𝕣𝕒𝕡𝕙 Vertex
#+end_src

  #+latex: \noindent
  To illustrate the difference of the first two, consider the function ~comap~, which
  relabels the vertices of a graph, using a function ~f~ to transform vertices:
  :Hide:
  #+begin_src agda
open Graph₀
#+end_src
  :End:
#+begin_src agda
comap₀ : {A B : Set}
       → (f : A → B)
       → (Σ G ∶ Graph₀ • Vertex G ≡ B)
       → (Σ H ∶ Graph₀ • Vertex H ≡ A)
comap₀ {A} f (G , refl) = ⟨ A , (λ x y → Edges G (f x) (f y)) ⟩₀ , refl

comap₁ : {A B : Set}
       → (f : A → B)
       → Graph₁ B
       → Graph₁ A
comap₁ f ⟨ edges ⟩₁ = ⟨ (λ x y → edges (f x) (f y)) ⟩₁
  #+end_src

  #+latex: \noindent
  In ~comap₀~, the input graph ~G~ and the output graph ~H~ have their vertex sets
  constrained to match the type of the relabelling function ~f~.  Without the
  constraints, we could not even write the function for ~Graph₀~.
  With such an importance, it is surprising to see that the occurrences
  of the constraint proofs are uninsightful ~refl~-exivity proofs.
  In contrast, ~comap₁~ does not carry any excesses baggage at the type level
  nor at the implementation level.

  We will show an automatic technique for obtaining the above three definitions
  of graphs from a single declaration using similar notation.  Our contributions
  are to show:
  1. Languages with sufficiently powerful type systems and meta-programming can
     conflate record and term datatype declarations into one practical interface.  We
     identify the problem and the subtleties in shifting between representations
     in Section [[sec:problems]].

  2. Parameterised records can be obtained on-demand from non-parameterised
     records (Section [[sec:monadic-notation]]).
     - As with ~Graph₀~, the traditional cite:coq_cat_experiences approach to
       unbundling a record requires the use of transport along propositional
       equalities, with trivial ~refl~-exivity proofs. In Section
       [[sec:monadic-notation]], we develop a combinator, ~_:waist_~, which removes
       the boilerplate necessary at the type specialisation location as well as
       at the instance declaration location.

  3. Programming with fixed-points of unary type constructors can be made
     as simple as programming with term datatypes (Section
     [[sec:termtypes-as-fixedpoints]]).

  4. Astonishingly, we mechanically regain ubiquitous data structures such as ~ℕ,
     Maybe, List~ as the termtypes of simple pointed and monoidal theories
     (Section [[sec:free-datatypes]]).

  As an application, in Section [[sec:related-works]] we show that the resulting
  setup applies as a semantics for a declarative pre-processing tool that accomplishes the
  above tasks.

* The Problems
  <<sec:problems>>

There are a number of problems, with the number of parameters being exposed
being the pivotal concern. To exemplify the distinctions at the type level as
more parameters are exposed, consider the following approaches to formalising a
dynamical system ---a collection of states, a designated start state, and a
transition function.

#+begin_src agda :tangle paper2.agda
record DynamicSystem₀ : Set₁ where
  field
    State : Set
    start  : State
    next   : State → State

record DynamicSystem₁ (State : Set) : Set where
  field
    start : State
    next  : State → State

record DynamicSystem₂ (State : Set) (start : State) : Set where
  field
    next : State → State
#+end_src

#+latex: \noindent
Each =DynamicSystemᵢ= is a type constructor of =i=-many arguments;
but it is the types of these constructors that provide insight
into the sort of data they contain:
| Type           | Kind                      |
|----------------+---------------------------|
| =DynamicSystem₀= | =Set₁=                      |
| =DynamicSystem₁= | =Π X ∶ Set • Set=           |
| =DynamicSystem₂= | =Π X ∶ Set • Π x ∶ X • Set= |
:AgdaCheckedEvidence:
    #+begin_src agda :tangle paper2.agda
_ : Set₁
_ = DynamicSystem₀

_ : Π X ∶ Set • Set
_ = DynamicSystem₁

_ : Π X ∶ Set • Π x ∶ X • Set
_ = DynamicSystem₂
#+end_src
:End:

We shall refer to the concern of moving from a record to a parameterised record
as *the unbundling problem* cite:packaging_mathematical_structures. For example,
moving from the /type/ ~Set₁~ to the /function type/ ~Π X ∶ Set • Set~ gets us from
~DynamicSystem₀~ to something resembling ~DynamicSystem₁~, which we arrive at if we
can obtain a /type constructor/ ~λ X ∶ Set • ⋯~. We shall refer to the latter change
as /reification/ since the result is more concrete, it can be applied; it will be
denoted by ~Π→λ~. To clarify this subtlety, consider the following forms of the
polymorphic identity function. Notice that ~idᵢ~ /exposes/ 𝒾-many details at the
type level to indicate the sort it consists of. However, notice that ~id₀~ is
a type of functions whereas ~id₁~ is a function on types. Indeed, the latter
two are derived from the first one: ~idᵢ₊₁ = Π→λ idᵢ~ ---this is proven by
reflexivity in the appendices.
#+begin_src agda :tangle no
id₀ : Set₁
id₀ = Π X ∶ Set • Π e ∶ X • X

id₁ : Π X ∶ Set • Set
id₁ = λ (X : Set) → Π e ∶ X • X

id₂ : Π X ∶ Set • Π e ∶ X • Set
id₂ = λ (X : Set) (e : X) → X
#+end_src

#+latex: \noindent
Of-course, there is also the need for descriptions of values, which leads to the
following termtypes. We shall refer to the shift from record types to algebraic
data types as *the termtype problem*.
#+begin_src agda :tangle paper2.agda
data DSTerms₀ : Set where
  start : DSTerms₀
  next  : DSTerms₀ → DSTerms₀

data DSTerms₁ (State : Set) : Set where
  start : State → DSTerms₁ State
  next  : DSTerms₁ State → DSTerms₁ State

data DSTerms₂ (State : Set) (start : State) : Set where
  next : DSTerms₂ State start → DSTerms₂ State start
#+end_src
:Ignore:
Yet another way to encode dynamical systems would be by their syntax, as it
would be desirable when serialising them ---i.e., to obtain first-class
descriptions of dynamical system values.


Notice that the first algebraic data type is isomorphic to ~ℕ~, whereas the
remaining two are isomorphic to ~State × ℕ~ which keeps track of how many =next=
steps are necessary until a =State= value is reached ---this may be called
=Eventually State=.
The ~DSTermsᵢ~ share the same pattern of kind exposure as the ~DynamicSystemᵢ~ types.

AgdaCheckedEvidence
#+begin_src agda :tangle paper2.agda
_ : Set
_ = DSTerms₀

_ : Π X ∶ Set • Set
_ = DSTerms₁

_ : Π X ∶ Set • Π x ∶ X • Set
_ = DSTerms₂
#+end_src
:End:

#+latex: \noindent
Our aim is to obtain all of these notions ---of ways to group data together---
from a single user-friendly context declaration, using monadic notation.

* Monadic Notation
  <<sec:monadic-notation>>

  There is little use in an idea that is difficult to use in practice.  As such,
  we conflate records and termtypes by starting with an ideal syntax they would
  share, then derive the necessary artefacts that permit it. Our choice of
  syntax is monadic do-notation cite:DBLP:journals/iandc/Moggi91,cite:DBLP:conf/haskell/MarlowJKM16:

#+begin_src agda :tangle no
  DynamicSystem : Context ℓ₁
  DynamicSystem = do X ← Set
                     z ← X
                     s ← (X → X)
                     End
#+end_src
 #+latex: \noindent
 Here ~Context, End~, and the underlying monadic bind operator are unknown.  Since
 we want to be able to /expose/ a number of fields at will, we may take ~Context~ to
 be types indexed by a number denoting exposure.  Moreover, since records are a
 product type, we expect there to be a recursive definition whose base case will
 be the essential identity of products, the unit type ~𝟙~.

| Exposure |   | Elaboration                                |
|----------+---+--------------------------------------------|
|        0 |   | =Σ X ∶ Set  • Σ z ∶ X  • Σ s ∶ (X → X)  • 𝟙= |
|        1 |   | =Π X ∶ Set  • Σ z ∶ X  • Σ s ∶ (X → X)  • 𝟙= |
|        2 |   | =Π X ∶ Set  • Π z ∶ X  • Σ s ∶ (X → X)  • 𝟙= |
|        3 |   | =Π X ∶ Set  • Π z ∶ X  • Π s ∶ (X → X)  • 𝟙= |

With these elaborations of ~DynamicSystem~ to guide the way, we resolve
two of our unknowns.
#+begin_src agda :tangle no
{- “Contexts” are exposure-indexed types -}
Context = λ ℓ → ℕ → Set ℓ

{- Every type is a context -}
‵_ : ∀ {ℓ} → Set ℓ → Context ℓ
‵ S = λ _ → S

{- The “empty context” is the unit type -}
End : ∀ {ℓ} → Context ℓ
End = ‵ 𝟙
#+end_src

#+latex: \noindent
It remains to identify the definition of the underlying bind operation ~>>=~.
Classically, for a type constructor ~m~, bind is typed ~∀ {X Y : Set} → m X → (X →
m Y) → m Y~. It allows one to “extract an ~X~-value for later use” in the ~m Y~
context. Since our ~m = Context~ is from levels to types, we need to slightly
alter bind's typing.
#+begin_src agda :tangle no
_>>=_ : ∀ {a b}
      → (Γ : Context a)
      → (∀ {n} → Γ n → Context b)
      → Context (a ⊍ b)
(Γ >>= f) ℕ.zero  = Σ γ ∶ Γ 0 • f γ 0
(Γ >>= f) (suc n) = (γ : Γ n) → f γ n
#+end_src
#+latex: \noindent
The definition here accounts for the current exposure index: If zero, we have
/record types/, otherwise /function types/. Using this definition, the above
dynamical system context would need to be expressed using the lifting quote operation.
#+begin_src agda :tangle no
‵ Set >>= λ X → ‵ X >>= λ z → ‵ (X → X) >>= End
{- or -}
do X ← ‵ Set
   z ← ‵ X
   s ← ‵ (X → X)
   End
#+end_src
# See page 275.
#+latex: \noindent
Interestingly cite:Bird_2009,DBLP:conf/hopl/HudakHJW07, use of ~do~-notation in
preference to bind, ~>>=~, was suggested by John Launchbury in 1993 and was first
implemented by Mark Jones in Gofer.  Anyhow, with our goal of practicality in
mind, we shall “build the lifting quote into the definition” of bind:
#+begin_src agda :tangle no
_>>=_ : ∀ {a b}
      → (Γ : Set a)  -- Main difference
      → (Γ → Context b)
      → Context (a ⊍ b)
(Γ >>= f) ℕ.zero  = Σ γ ∶ Γ • f γ 0
(Γ >>= f) (suc n) = (γ : Γ) → f γ n
#+end_src
#+latex: \noindent
With this definition, the above declaration ~DynamicSystem~ typechecks.  However,
~DynamicSystem 𝒾 ≇ DynamicSystemᵢ~, instead ~DynamicSystem 𝒾~ are “factories”: Given
~𝒾~-many arguments, a product value is formed. What if we want to /instantiate/ some
of the factory arguments ahead of time?
#+begin_src agda :tangle no
𝒩₀ : DynamicSystem 0  {- ≈ Σ X ∶ Set  • Σ z ∶ X  • Σ s ∶ (X → X)  • 𝟙 -}
𝒩₀ = ℕ , 0 , suc , tt

𝒩₁ : DynamicSystem 1 {- ≈ Π X ∶ Set  • Σ z ∶ X  • Σ s ∶ (X → X)  • 𝟙 -}
𝒩₁ = λ X → ??? {- Impossible to complete if X is empty! -}

{- “Instantiaing” X to be ℕ in “DynamicSystem 1” -}
𝒩₁′ : let X = ℕ in Σ z ∶ X  • Σ s ∶ (X → X)  • 𝟙
𝒩₁′ = 0 , suc , tt
#+end_src
#+latex: \noindent
It seems what we need is method, say ~Π→λ~, that takes a ~Π~-type and transforms it
into a ~λ~-expression.  One could use a universe, an algebraic type of codes
denoting types, to define ~Π→λ~. However, one can no longer then easily use
existing types since they are not formed from the universe's constructors,
thereby resulting in duplication of existing types via the universe
encoding. This is not practical nor pragmatic.

As such, we are left with pattern matching on the language's type formation
primitives as the only reasonable approach. The method ~Π→λ~ is thus a macro that
acts on the syntactic term representations of types.
Below is main transformation ---the details can be found in Appendix
[[sec:pi-to-lambda]].
#+begin_src agda :tangle no
Π→λ (Π a ∶ A • τ) = (λ a ∶ A • τ)
{- One then extends this homomorphically over all possible term formers. -}
#+end_src
#+latex: \noindent
That is, we walk along the term tree replacing occurrences of ~Π~ with ~λ~. For example,
#+begin_src agda :tangle no
  Π→λ (Π→λ (DynamicSystem 2))
≡{- Definition of DynamicSystem at exposure level 2 -}
  Π→λ (Π→λ (Π X ∶ Set • Π s ∶ X  • Σ n ∶ X → X  • 𝟙))
≡{- Definition of Π→λ -}
  Π→λ (λ X ∶ Set • Π s ∶ X  • Σ n ∶ X → X  • 𝟙)
≡{- Homomorphy of Π→λ -}
  λ X ∶ Set • Π→λ (Π s ∶ X  • Σ n ∶ X → X  • 𝟙)
≡{- Definition of Π→λ -}
≡ λ X ∶ Set • λ s ∶ X  • Σ n ∶ X → X  • 𝟙
#+end_src

For practicality, ~_:waist_~ is a macro acting on contexts that repeats ~Π→λ~ a number of
times in order to lift a number of field components to the parameter level.
#+begin_src agda :tangle no
τ :waist n     = Π→λⁿ n (τ n)

Π→λⁿ 0       τ = τ
Π→λⁿ (n + 1) τ = Π→λⁿ n (Π→λ τ)
#+end_src
#+latex: \noindent
We can now “fix arguments ahead of time”. Before such demonstration, we need to
be mindful of our practicality goals: One declares a grouping mechanism with
~do … End~, which in turn has its instance values constructed with ~⟨ … ⟩~.
#+begin_src agda :tangle no
-- Expressions of the form “⋯ , tt” may now be written “⟨ ⋯ ⟩”
infixr 5 ⟨ _⟩
⟨⟩ : ∀ {ℓ} → 𝟙 {ℓ}
⟨⟩ = tt

⟨ : ∀ {ℓ} {S : Set ℓ} → S → S
⟨ s = s

_⟩ : ∀ {ℓ} {S : Set ℓ} → S → S × (𝟙 {ℓ})
s ⟩ = s , tt
#+end_src
#+latex: \noindent
The following instances of grouping types demonstrate how information moves from
the body level to the parameter level.
#+BEGIN_SRC agda
𝒩⁰ : DynamicSystem :waist 0
𝒩⁰ = ⟨ ℕ , 0 , suc ⟩

𝒩¹ : (DynamicSystem :waist 1) ℕ
𝒩¹ = ⟨ 0 , suc ⟩

𝒩² : (DynamicSystem :waist 2) ℕ 0
𝒩² = ⟨ suc ⟩

𝒩³ : (DynamicSystem :waist 3) ℕ 0 suc
𝒩³ = ⟨⟩
#+END_SRC
#+latex: \noindent
Using ~:waist 𝒾~ we may fix the first ~𝒾~-parameters ahead of time.  Indeed, the
type ~(DynamicSystem :waist 1) ℕ~ is /the type of dynamic systems over carrier ℕ/,
whereas ~(DynamicSystem :waist 2) ℕ 0~ is /the type of dynamic systems over
carrier ℕ and start state 0/.

Examples of the need for such on-the-fly unbundling can be found in numerous
places in the Haskell standard library. For instance, the standard libraries cite:data_monoid
have two isomorphic copies of the integers, called ~Sum~ and ~Product~, whose reason
for being is to distinguish two common monoids: The former is for /integers with
addition/ whereas the latter is for /integers with multiplication/.
An orthogonal solution would be to use contexts:
#+begin_src agda :tangle no
Monoid : ∀ ℓ → Context (ℓsuc ℓ)
Monoid ℓ = do Carrier ← Set ℓ
              _⊕_     ← (Carrier → Carrier → Carrier)
              Id      ← Carrier
              leftId  ← ∀ {x : Carrier} → x ⊕ Id ≡ x
              rightId ← ∀ {x : Carrier} → Id ⊕ x ≡ x
              assoc   ← ∀ {x y z} → (x ⊕ y) ⊕ z  ≡  x ⊕ (y ⊕ z)
              End {ℓ}
#+end_src
#+latex: \noindent
With this context, (~Monoid ℓ₀ :waist 2) M ⊕~ is the type of monoids over
/particular/ types ~M~ and /particular/ operations ~⊕~.  Of-course, this is orthogonal,
since traditionally unification on the carrier type ~M~ is what makes typeclasses
and canonical structures cite:coq_canonical_tutorial useful for ad-hoc
polymorphism.

# since Haskell's use-case is for canonical typeclasses, which utilise unification
# on the carrier type ~M~ to find instance implementations.

* Termtypes as Fixed-points
  <<sec:termtypes-as-fixedpoints>>

  We have a practical monadic syntax for possibly parameterised record types
  that we would like to extend to termtypes. Algebraic data types are a means to
  declare concrete representations of the least fixed-point of a functor.

  In particular, the description language ~𝔻~ for dynamical systems,
  ref:contexts-table, declares concrete constructors for the fixpoint of ~F~:

       | ~F : Set → Set~                 |
       | ~F = λ (D ∶ Set) → D ⊎ D~       |

  That is, ~𝔻 ≅ Fix F~ where:
  #+begin_src agda :tangle no
data Fix (F : Set → Set) : Set where
  μ : F (Fix F) → Fix F
#+end_src
#+latex: \noindent
 The problem is whether we can derive ~F~ from ~DynamicSystem~.
 Let us attempt a quick calculation.
#+name: termtypes-guide
#+caption: Guide to termtypes
#+BEGIN_SRC agda :tangle no
  do X ← Set; z ← X; s ← (X → X); End
⇒{- Use existing interpretation to obtain a record. -}
  Σ X : Set • Σ z : X • Σ s : (X → X) • 𝟙
⇒{- Pull out the carrier, “:waist 1”, to obtain a type constructor using “Π→λ”. -}
  λ X : Set • Σ z : X • Σ s : (X → X) • 𝟙
⇒{- Termtype constructors target the declared type, so only their sources matter.
   E.g., ‘z : X’ is a nullary constructor targeting the carrier ‘X’.
   This introduces 𝟙 types, so any existing occurances are dropped via 𝟘.
 -}
  λ X : Set • Σ z : 𝟙 • Σ s : X • 𝟘
⇒{- Termtypes are sums of products. -}
  λ X : Set •       𝟙   ⊎     X  ⊎ 𝟘
⇒{- Termtypes are fixpoints of type constructors. -}
  Fix (λ X • 𝟙 ⊎ X)  -- i.e., 𝔻
 #+END_SRC
#+latex: \noindent
 Since we may view an algebraic data-type as a fixed-point of the functor
  obtained from the union of the sources of its constructors, it suffices to
  treat the fields of a record as constructors, then obtain their sources, then
  union them.  That is, since algebraic-datatype constructors necessarily target
  the declared type, they are determined by their sources.  For example,
  considered as a unary constructor ~op : A → B~ targets the type termtype ~B~ and
  so its source is ~A~.  The details on the operations ~⇊, Σ→⊎, sources~ shown below
  can be found in appendices [[sec:decreasing-de-brujin]], [[sec:sigma-to-sum]], and
  [[sec:sources]], respectively.
  # ---since we're introducing
  # unit types, any existing unit types are dropped via ~𝟘~.
  #+begin_src agda :tangle no
⇊ τ = “reduce all de brujin indices of τ by 1”

Σ→⊎ (Σ a ∶ A • Ba) = A ⊎ Σ→⊎ (⇊ Ba)

sources (λ x ∶ (Π a ∶ A • Ba) • τ) = (λ x ∶ A • sources τ)
sources (λ x ∶ A              • τ) = (λ x ∶ 𝟙 • sources τ)

{- Extend “sources, Σ→⊎” homomorphicly to other syntactic constructs -}

termtype τ = Fix (Σ→⊎ (sources τ))
             #+end_src

# The hint ~“Replace products with sums”~ in the above calculation is realised
# formally as ~Σ→⊎ (sources τ)~.
#+latex: \noindent
It is instructive to visually see how ~𝔻~ is obtained from ~termtype~
in order to demonstrate that this approach to algebraic data types
is practical.
#+begin_src agda :tangle no
𝔻 = termtype (DynamicSystem :waist 1)

-- Pattern synonyms for more compact presentation
pattern startD  = μ (inj₁ tt)       -- : 𝔻
pattern nextD e = μ (inj₂ (inj₁ e)) -- : 𝔻 → 𝔻
#+end_src
#+latex: \noindent
With the ~pattern~ declarations, we can actually use these more meaningful names,
when pattern matching, instead of the seemingly daunting μ-~inj~-ections.
For instance, we can immediately see that the natural numbers act as
the description language for dynamical systems:
#+begin_src agda :tangle no
to : 𝔻 → ℕ
to startD    = 0
to (nextD x) = suc (to x)

from : ℕ → 𝔻
from zero    = startD
from (suc n) = nextD (from n)
#+end_src

* TODO Free Datatypes from Theories
  <<sec:free-datatypes>>

Astonishingly, useful programming datatypes arise from termtypes of theories
(contexts). That is, if src_agda[:exports code]{𝒞 : Set → Context ℓ₀} then
src_agda[:exports code]{ℂ′ = λ X → termtype (𝒞 X :waist 1)} can be used to form
‘free, lawless, 𝒞-instances’. For instance, earlier we witnessed that
the termtype of dynamical systems is essentially the natural numbers.
#+label: theories-data-structures
#+caption: Data structures as free theories
| Theory             | Termtype     |
|--------------------+--------------|
| Dynamical Systems  | ℕ            |
| Pointed Structures | Maybe        |
| Monoids            | Binary Trees |

To obtain trees over some ‘value type’ Ξ, one must start at the theory of
“monoids containing a given set Ξ”. Similarly, by starting at “theories of
pointed sets over a given set Ξ”, the resulting termtype is the ~Maybe~
type constructor ---another instructive exercise to the reader: Show that ~ℙ ≅ Maybe~.
#+begin_src agda :tangle no
PointedOver  : Set → Context (ℓsuc ℓ₀)
PointedOver Ξ    = do Carrier ← Set ℓ₀
                      point   ← Carrier
                      embed   ← (Ξ → Carrier)
                      End

ℙ : Set → Set
ℙ X = termtype (PointedOver X :waist 1)

-- Pattern synonyms for more compact presentation
pattern nothingP = μ (inj₁ tt)       -- : ℙ
pattern justP e  = μ (inj₂ (inj₁ e)) -- : ℙ → ℙ
#+end_src

#+latex: \noindent
The final entry in the table is a well known correspondence, that we
can, not only formally express, but also prove to be true. We present the setup
and leave it as an instructive exercise to the reader to present a
bijective pair of functions between =𝕄= and =TreeSkeleton=. Hint: Interactively
case-split on values of =𝕄= until the declared patterns appear, then associate them
with the constructors of ~TreeSkeleton~.
#+begin_src agda :tangle no
𝕄 : Set
𝕄 = termtype (Monoid ℓ₀ :waist 1)

-- Pattern synonyms for more compact presentation
pattern emptyM      = μ (inj₁ tt)                      -- : 𝕄
pattern branchM l r = μ (inj₂ (inj₁ (l , r , tt)))     -- : 𝕄 → 𝕄 → 𝕄
pattern absurdM a   = μ (inj₂ (inj₂ (inj₂ (inj₂ a))))  -- absurd values of 𝟘

data TreeSkeleton : Set where
  empty  : TreeSkeleton
  branch : TreeSkeleton → TreeSkeleton → TreeSkeleton
#+end_src

* Related Works
  <<sec:related-works>>

  Surprisingly, conflating parameterised and non-parameterised record types
  with termtypes /within a language in a practical fashion/ has not been done before.

  The PackageFormer cite:DBLP:conf/gpce/Al-hassyCK19,alhassy_thesis_proposal
  editor extension reads contexts ---in nearly the same notation as ours---
  enclosed in dedicated comments, then generates and imports Agda code from them
  seamlessly in the background whenever typechecking transpires. The framework
  provides a fixed number of meta-primitives for producing arbitrary notions of
  grouping mechanisms, and allows arbitrary Emacs Lisp cite:10.5555/229872 to be
  invoked in the construction of complex grouping mechanisms.

  #+caption: Comparing the in-language Context mechanism with the PackageFormer editor extension
  |                          | PackageFormer      | Contexts             |
  |--------------------------+--------------------+----------------------|
  | Type of Entity           | Preprocessing Tool | Language Library     |
  | Specification Language   | Lisp + Agda        | Agda                 |
  | Well-formedness Checking | ❌               | ✓                    |
  | Termination Checking     | ✓                  | ✓                    |
  | Elaboration Tooltips     | ✓                  | ❌                 |
  | Rapid Prototyping        | ✓                  | ✓ (Slower)           |
  | Usability Barrier        | None               | None                 |
  | Extensibility Barrier    | Lisp               | Weak Metaprogramming |

  The original PackageFormer paper provided the syntax necessary to form useful
  grouping mechanisms but was shy on the semantics of such constructs.  We have
  chosen the names of our combinators to closely match those of PackageFormer's
  with an aim of furnishing the mechanism with semantics by construing the
  syntax as semantics-functions; i.e., we have a shallow embedding of
  PackageFormer's constructs as Agda entities:

#+caption: Contexts as a semantics for PackageFormer constructs
| Syntax          | Semantics                    |
|-----------------+------------------------------|
| ~PackageFormer~   | ~Context~                      |
| ~:waist~          | ~:waist~                       |
| ~⟴~               | Forward function application |
| ~:kind~           | ~:kind~, see below             |
| ~:level~          | Agda built-in                |
| ~:alter-elements~ | Agda macros                  |

# Moreover, it is nearly as readable
#  and is a library method, rather than an editor extension.

PackageFormer's ~_:kind_~ meta-primitive dictates how an abstract grouping
mechanism should be viewed in terms of existing Agda syntax.  However, unlike
PackageFormer, all of our syntax consists of legitimate Agda terms.
Since language syntax is being manipulated, we are forced to define it as a macro:

#+begin_src agda :tangle no
data Kind : Set where
  ‵record    : Kind
  ‵typeclass : Kind
  ‵data      : Kind

𝒞 :kind ‵record    = 𝒞 0
𝒞 :kind ‵typeclass = 𝒞 :waist 1
𝒞 :kind ‵data      = termtype (𝒞 :waist 1)
#+end_src
# +latex: \noindent
We did not expect to be able to assign a full semantics to PackageFormer's
syntactic constructs due to Agda's substantially weak metaprogramming mechanism.
However, it is important to note that PackageFormer's Lisp extensibility
expedites the process of trying out arbitrary grouping mechanisms ---such as
partial-choices of pushouts and pullbacks along user-provided assignment
functions--- since it is all either string or symbolic list manipulation. On the
Agda side, using contexts, it would require exponentially more effort due to the
limited reflection mechanism and the intrusion of the stringent type system.

:Ignore:
For PackageFormer, we have implemented its primitives ~:waist~ and ~:kind~, the
other core meta-primitives are ~_⟴_~ and ~:alter-elements~. The former is a
syntactic form of function application, ~x ⟴ f ≈ f x~, which we already have by
juxtaposition in Agda. The latter, however, is a “hammer” that alters the
constituents of a grouping mechanism in an arbitrary fashion using the entire
power of Emacs Lisp ---which includes a large portion of Common Lisp.  We have
currently presented a partial semantics of PackageFormer's syntactic entities by
presenting them here as semantic functions on contexts.
:End:

* Conclusion

Starting from the insight that related grouping mechanisms could be unified, we
showed how related structures can be obtained from a single declaration using a
practical interface. The resulting framework, based on contexts, still captures
the familiar record declaration syntax as well as the expressivity of usual
algebraic datatype declarations ---at the minimal cost of using ~pattern~
declarations to aide as user-chosen constructor names.  We believe that our
approach to using contexts as general grouping mechanisms /with/ a practical
interface are interesting contributions.

We used the focus on practicality to guide the design of our context interface,
and provided interpretations both for the rather intuitive “contexts are
name-type records” view, and for the novel “contexts are fixed-points” view for
termtypes.  In addition, to obtain parameterised variants, we needed to
explicitly form “contexts whose contents are over a given ambient context”
---e.g., contexts of vector spaces are usually discussed with the understanding
that there is a context of fields that can be referenced--- which we did using
monads. These relationships are summarised in the following table.

#+caption: Contexts embody all kinds of grouping mechanisms
| Concept            | Concrete Syntax                       | Description            |
|--------------------+---------------------------------------+------------------------|
| Context            | =do S ← Set; s ← S; n ← (S → S); End=   | “name-type pairs”      |
|--------------------+---------------------------------------+------------------------|
| Record Type        | =Σ S ∶ Set • Σ s ∶ S • Σ n ∶ S → S • 𝟙= | “bundled-up data”      |
| Function Type      | =Π S • Σ s ∶ S • Σ n ∶ S → S • 𝟙=       | “a type of functions”  |
| Type constructor   | =λ S • Σ s ∶ S • Σ n ∶ S → S • 𝟙=       | “a function on types”  |
| Algebraic datatype | ~data 𝔻 : Set where s : 𝔻; n : 𝔻 → 𝔻~   | “a descriptive syntax” |

To those interested in exotic ways to group data together ---such as,
mechanically deriving product types and homomorphism types of theories---
we offer an interface that is extensible using Agda's reflection mechanism.
In comparison with, for example, special-purpose preprocessing tools, this
has obvious advantages in accessibility and semantics.

To Agda programmers, this offers a standard interface for grouping mechanisms
that had been sorely missing, with an interface that is so familiar that there
would be little barrier to its use. In particular, as we have shown, it acts as
an in-language library for exploring relationships between free theories and
data structures.  As we have only presented the high-level definitions of the
core combinators, leaving the Agda-specific details to the appendices, it is
also straightforward to translate the library into other dependently-typed
languages.

* appendix marker :ignore:
\appendix

:Musa:
The appendix marker must occur before the section on appendices.
:End:

* Appendices
#+latex_header: \usepackage[toc,page]{appendix}

Below is the entirety of the Context library discussed in the paper proper.

#+begin_src agda :tangle Context.agda
module Context where
#+end_src

** Imports
#+begin_src agda :tangle Context.agda
open import Level renaming (_⊔_ to _⊍_; suc to ℓsuc; zero to ℓ₀)
open import Relation.Binary.PropositionalEquality
open import Relation.Nullary

open import Data.Nat
open import Data.Fin  as Fin using (Fin)
open import Data.Maybe  hiding (_>>=_)

open import Data.Bool using (Bool ; true ; false)
open import Data.List as List using (List ; [] ; _∷_ ; _∷ʳ_; sum)

ℓ₁   = Level.suc ℓ₀
#+end_src

** Quantifiers Π∶•/Σ∶• and Products/Sums

  We shall using Z-style quantifier notation cite:10.5555/235337 in which the
  quantifier dummy variables are separated from the body by a large bullet.

  In Agda, we use ~\:~ to obtain the “ghost colon” since standard colon ~:~ is an
  Agda operator.

#+begin_src agda :tangle Context.agda
open import Data.Empty using (⊥)
open import Data.Sum
open import Data.Product
open import Function using (_∘_)

Σ∶• : ∀ {a b} (A : Set a) (B : A → Set b) → Set _
Σ∶• = Σ

infix -666 Σ∶•
syntax Σ∶• A (λ x → B) = Σ x ∶ A • B

Π∶• : ∀ {a b} (A : Set a) (B : A → Set b) → Set _
Π∶• A B = (x : A) → B x

infix -666 Π∶•
syntax Π∶• A (λ x → B) = Π x ∶ A • B

record ⊤ {ℓ} : Set ℓ where
  constructor tt

𝟙 = ⊤ {ℓ₀}
𝟘 = ⊥
#+end_src

** Reflection

We form a few metaprogramming utilities we would have expected to be in the
standard library.

#+begin_src agda :tangle Context.agda
import Data.Unit as Unit
open import Reflection hiding (name; Type) renaming (_>>=_ to _>>=ₘ_)
#+end_src

*** Single argument application
#+begin_src agda :tangle Context.agda
_app_ : Term → Term → Term
(def f args) app arg′ = def f (args ∷ʳ arg (arg-info visible relevant) arg′)
(con f args) app arg′ = con f (args ∷ʳ arg (arg-info visible relevant) arg′)
{-# CATCHALL #-}
tm app arg′ = tm
#+end_src

#+latex: \noindent
Notice that we maintain existing applications:
| ~quoteTerm (f x) app quoteTerm y~ | ≈ | ~quoteTerm (f x y)~ |

*** Reify ℕ term encodings as ℕ values
#+begin_src agda :tangle Context.agda
toℕ : Term → ℕ
toℕ (lit (nat n)) = n
{-# CATCHALL #-}
toℕ _ = 0
#+end_src
*** The Length of a Term
#+begin_src agda :tangle Context.agda
arg-term : ∀ {ℓ} {A : Set ℓ} → (Term → A) → Arg Term → A
arg-term f (arg i x) = f x

{-# TERMINATING #-}
lengthₜ : Term → ℕ
lengthₜ (var x args)      = 1 + sum (List.map (arg-term lengthₜ ) args)
lengthₜ (con c args)      = 1 + sum (List.map (arg-term lengthₜ ) args)
lengthₜ (def f args)      = 1 + sum (List.map (arg-term lengthₜ ) args)
lengthₜ (lam v (abs s x)) = 1 + lengthₜ x
lengthₜ (pat-lam cs args) = 1 + sum (List.map (arg-term lengthₜ ) args)
lengthₜ (Π[ x ∶ A ] Bx)   = 1 + lengthₜ Bx
{-# CATCHALL #-}
-- sort, lit, meta, unknown
lengthₜ t = 0
#+end_src
#+latex: \noindent
Here is an example use:
#+begin_src agda :tangle Context.agda
_ : lengthₜ (quoteTerm (Σ x ∶ ℕ • x ≡ x)) ≡ 10
_ = refl
#+end_src

*** Decreasing de Brujin Indices
<<sec:decreasing-de-brujin>>
Given a quantification ~(⊕ x ∶ τ • fx)~, its body ~fx~ may refer to a free variable
~x~.  If we decrement all de Brujin indices ~fx~ contains, then there would be no
reference to ~x~.

#+begin_src agda :tangle Context.agda
var-dec₀ : (fuel : ℕ) → Term → Term
var-dec₀ zero t  = t
-- Let's use an “impossible” term.
var-dec₀ (suc n) (var zero args)      = def (quote ⊥) []
var-dec₀ (suc n) (var (suc x) args)   = var x args
var-dec₀ (suc n) (con c args)         = con c (map-Args (var-dec₀ n) args)
var-dec₀ (suc n) (def f args)         = def f (map-Args (var-dec₀ n) args)
var-dec₀ (suc n) (lam v (abs s x))    = lam v (abs s (var-dec₀ n x))
var-dec₀ (suc n) (pat-lam cs args)    = pat-lam cs (map-Args (var-dec₀ n) args)
var-dec₀ (suc n) (Π[ s ∶ arg i A ] B) = Π[ s ∶ arg i (var-dec₀ n A) ] var-dec₀ n B
{-# CATCHALL #-}
-- sort, lit, meta, unknown
var-dec₀ n t = t
#+end_src
#+latex: \noindent
In the paper proper, ~var-dec~ was mentioned once under the name ~⇊~.
#+begin_src agda :tangle Context.agda
var-dec : Term → Term
var-dec t = var-dec₀ (lengthₜ t) t
#+end_src
#+latex: \noindent
Notice that we made the decision that ~x~, the body of ~(⊕ x • x)~, will reduce to ~𝟘~,
the empty type. Indeed, in such a situation the only Debrujin index cannot be
reduced further. Here is an example:
#+begin_src agda :tangle Context.agda
_ : ∀ {x : ℕ} → var-dec (quoteTerm x) ≡ quoteTerm ⊥
_ = refl
#+end_src

** Context Monad
#+begin_src agda :tangle Context.agda
Context = λ ℓ → ℕ → Set ℓ

infix -1000 ‵_
‵_ : ∀ {ℓ} → Set ℓ → Context ℓ
‵ S = λ _ → S

End : ∀ {ℓ} → Context ℓ
End = ‵ ⊤

End₀ = End {ℓ₀}

_>>=_ : ∀ {a b}
      → (Γ : Set a)  -- Main diference
      → (Γ → Context b)
      → Context (a ⊍ b)
(Γ >>= f) ℕ.zero  = Σ γ ∶ Γ • f γ 0
(Γ >>= f) (suc n) = (γ : Γ) → f γ n
#+end_src

** ⟨⟩ Notation

As mentioned, grouping mechanisms are declared with ~do … End~, and instances of
them are constructed using ~⟨ … ⟩~.
#+begin_src agda :tangle Context.agda
-- Expressions of the form “⋯ , tt” may now be written “⟨ ⋯ ⟩”
infixr 5 ⟨ _⟩
⟨⟩ : ∀ {ℓ} → ⊤ {ℓ}
⟨⟩ = tt

⟨ : ∀ {ℓ} {S : Set ℓ} → S → S
⟨ s = s

_⟩ : ∀ {ℓ} {S : Set ℓ} → S → S × ⊤ {ℓ}
s ⟩ = s , tt
#+end_src

** DynamicSystem Context
#+begin_src agda :tangle Context.agda
DynamicSystem : Context (ℓsuc Level.zero)
DynamicSystem = do X ← Set
                   z ← X
                   s ← (X → X)
                   End {Level.zero}

-- Records with 𝓃-Parameters, 𝓃 : 0..3
A B C D : Set₁
A = DynamicSystem 0 -- Σ X ∶ Set  • Σ z ∶ X  • Σ s ∶ X → X  • ⊤
B = DynamicSystem 1 --  (X ∶ Set) → Σ z ∶ X  • Σ s ∶ X → X  • ⊤
C = DynamicSystem 2 --  (X ∶ Set)    (z ∶ X) → Σ s ∶ X → X  • ⊤
D = DynamicSystem 3 --  (X ∶ Set)    (z ∶ X) →  (s ∶ X → X) → ⊤

_ : A ≡ (Σ X ∶ Set  • Σ z ∶ X  • Σ s ∶ (X → X)  • ⊤) ; _ = refl
_ : B ≡ (Π X ∶ Set  • Σ z ∶ X  • Σ s ∶ (X → X)  • ⊤) ; _ = refl
_ : C ≡ (Π X ∶ Set  • Π z ∶ X  • Σ s ∶ (X → X)  • ⊤) ; _ = refl
_ : D ≡ (Π X ∶ Set  • Π z ∶ X  • Π s ∶ (X → X)  • ⊤) ; _ = refl

stability : ∀ {n} →   DynamicSystem (3 + n)
                   ≡ DynamicSystem  3
stability = refl

B-is-empty : ¬ B
B-is-empty b = proj₁( b ⊥)

𝒩₀ : DynamicSystem 0
𝒩₀ = ℕ , 0 , suc , tt

𝒩 : DynamicSystem 0
𝒩 = ⟨ ℕ , 0 , suc ⟩

B-on-ℕ : Set
B-on-ℕ = let X = ℕ in Σ z ∶ X  • Σ s ∶ (X → X)  • ⊤

ex : B-on-ℕ
ex = ⟨ 0 , suc ⟩
#+end_src

** Π→λ
   <<sec:pi-to-lambda>>
#+begin_src agda :tangle Context.agda
Π→λ-helper : Term → Term
Π→λ-helper (pi  a b)         = lam visible b
Π→λ-helper (lam a (abs x y)) = lam a (abs x (Π→λ-helper y))
{-# CATCHALL #-}
Π→λ-helper x = x

macro
  Π→λ : Term → Term → TC Unit.⊤
  Π→λ tm goal = normalise tm >>=ₘ λ tm′ → unify (Π→λ-helper tm′) goal
#+end_src

** COMMENT ~idᵢ₊₁ ≈ Π→λ idᵢ~
#+begin_src agda :tangle Context.agda
_ : Π→λ idτ ≡ id₁
_ = refl
#+end_src
** ~_:waist_~
#+begin_src agda :tangle Context.agda
waist-helper : ℕ → Term → Term
waist-helper zero t    = t
waist-helper (suc n) t = waist-helper n (Π→λ-helper t)

macro
  _:waist_ : Term → Term → Term → TC Unit.⊤
  _:waist_ t 𝓃 goal =      normalise (t app 𝓃)
                      >>=ₘ λ t′ → unify (waist-helper (toℕ 𝓃) t′) goal
#+end_src

** DynamicSystem :waist 𝒾
#+begin_src agda :tangle Context.agda
A′ : Set₁
B′ : ∀ (X : Set) → Set
C′ : ∀ (X : Set) (x : X) → Set
D′ : ∀ (X : Set) (x : X) (s : X → X) → Set

A′ = DynamicSystem :waist 0
B′ = DynamicSystem :waist 1
C′ = DynamicSystem :waist 2
D′ = DynamicSystem :waist 3

𝒩⁰ : A′
𝒩⁰ = ⟨ ℕ , 0 , suc ⟩

𝒩¹ : B′ ℕ
𝒩¹ = ⟨ 0 , suc ⟩

𝒩² : C′ ℕ 0
𝒩² = ⟨ suc ⟩

𝒩³ : D′ ℕ 0 suc
𝒩³ = ⟨⟩
#+end_src
#+latex: \noindent
It may be the case that ~Γ 0 ≡ Γ :waist 0~ for every context Γ.
#+begin_src agda :tangle Context.agda
_ : DynamicSystem 0 ≡ DynamicSystem :waist 0
_ = refl
#+end_src

** COMMENT Collection Context
#+begin_src agda :tangle Context.agda
Collection : ∀ ℓ → Context (ℓsuc ℓ)
Collection ℓ = do
  Elem    ← Set ℓ
  Carrier ← Set ℓ
  insert  ← (Elem → Carrier → Carrier)
  ∅       ← Carrier
  isEmpty ← (Carrier → Bool)
  insert-nonEmpty ← ∀ {e : Elem} {x : Carrier} → isEmpty (insert e x) ≡ false
  End {ℓ}

ListColl : {ℓ : Level} → Collection ℓ 1
ListColl E = ⟨ List E
             , _∷_
             , []
             , (λ { [] → true; _ → false})
             , (λ {x} {x = x₁} → refl)
             ⟩

ℕCollection = (Collection ℓ₀ :waist 2)
                ("Elem"    ≔ Digit)
                ("Carrier" ≔ ℕ)
--
-- i.e., (Collection ℓ₀ :waist 2) Digit ℕ

stack : ℕCollection
stack = ⟨ "insert"      ≔ (λ d s → suc (10 * s + #→ℕ d))
        , "empty stack" ≔ 0
        , "is-empty"    ≔ (λ { 0 → true; _ → false})
        -- Properties --
        , (λ {d : Digit} {s : ℕ} → refl {x = false})
        ⟩
#+end_src

** Field projections
#+begin_src agda :tangle Context.agda
Field₀ : ℕ → Term → Term
Field₀ zero c    = def (quote proj₁) (arg (arg-info visible relevant) c ∷ [])
Field₀ (suc n) c = Field₀ n (def (quote proj₂) (arg (arg-info visible relevant) c ∷ []))

macro
  Field : ℕ → Term → Term → TC Unit.⊤
  Field n t goal = unify goal (Field₀ n t)
#+end_src

** COMMENT Elem, Carrier, insert projections
#+begin_src agda :tangle Context.agda
Elem      : ∀ {ℓ} → Collection ℓ 0 → Set ℓ
Elem      = λ C   → Field 0 C

Carrier   : ∀ {ℓ} → Collection ℓ 0 → Set ℓ
Carrier₁  : ∀ {ℓ} → Collection ℓ 1 → (γ : Set ℓ) → Set ℓ
Carrier₁′ : ∀ {ℓ} {γ : Set ℓ} (C : (Collection ℓ :waist 1) γ) → Set ℓ

Carrier   = λ C   → Field 1 C
Carrier₁  = λ C γ → Field 0 (C γ)
Carrier₁′ = λ C   → Field 0 C

insert   : ∀ {ℓ} (C : Collection ℓ 0) → (Elem C → Carrier C → Carrier C)
insert₁  : ∀ {ℓ} (C : Collection ℓ 1) (γ : Set ℓ) →  γ → Carrier₁ C γ → Carrier₁ C γ
insert₁′ : ∀ {ℓ} {γ : Set ℓ} (C : (Collection ℓ :waist 1) γ) → γ → Carrier₁′ C → Carrier₁′ C

insert    = λ C   → Field 2 C
insert₁   = λ C γ → Field 1 (C γ)
insert₁′  = λ C   → Field 1 C

insert₂  : ∀ {ℓ} (C : Collection ℓ 2) (El Cr : Set ℓ) → El → Cr → Cr
insert₂′ : ∀ {ℓ} {El Cr : Set ℓ} (C : (Collection ℓ :waist 2) El Cr) → El → Cr → Cr

insert₂ = λ C El Cr → Field 0 (C El Cr)
insert₂′ = λ C → Field 0 C
#+end_src

** Termtypes

Using the guide, ref:termtypes-guide, outlined in the paper proper
we shall form ~Dᵢ~ for each stage in the calculation.
*** Stage 1: Records
#+begin_src agda :tangle Context.agda
D₁ = DynamicSystem 0

1-records : D₁ ≡ (Σ X ∶ Set • Σ z ∶ X • Σ s ∶ (X → X) • ⊤)
1-records = refl
#+end_src
*** Stage 2: Parameterised Records
#+begin_src agda :tangle Context.agda
D₂ = DynamicSystem :waist 1

2-funcs : D₂ ≡ (λ (X : Set) → Σ z ∶ X • Σ s ∶ (X → X) • ⊤)
2-funcs = refl
#+end_src

*** Stage 3: Sources
<<sec:sources>>
Let's begin with an example to motivate the definition of ~sources~.
    #+begin_src agda :tangle Context.agda
_ :   quoteTerm (∀ {x : ℕ} → ℕ)
    ≡ pi (arg (arg-info hidden relevant) (quoteTerm ℕ)) (abs "x" (quoteTerm ℕ))
_ = refl
#+end_src
#+latex: \noindent
We now form two sources-helper utilities, although we suspect they could be
combined into one function.
#+begin_src agda :tangle Context.agda
sources₀ : Term → Term
-- Otherwise:
sources₀ (Π[ a ∶ arg i A ] (Π[ b ∶ arg _ Ba ] Cab)) =
    def (quote _×_) (vArg A
                    ∷ vArg (def (quote _×_)
                                (vArg (var-dec Ba) ∷ vArg (var-dec (var-dec (sources₀ Cab))) ∷ []))
                    ∷ [])
sources₀ (Π[ a ∶ arg (arg-info hidden _) A ] Ba) = quoteTerm 𝟘
sources₀ (Π[ x ∶ arg i A ] Bx) = A
{-# CATCHALL #-}
-- sort, lit, meta, unknown
sources₀ t = quoteTerm 𝟙

{-# TERMINATING #-}
sources₁ : Term → Term
sources₁ (Π[ a ∶ arg (arg-info hidden _) A ] Ba) = quoteTerm 𝟘
sources₁ (Π[ a ∶ arg i A ] (Π[ b ∶ arg _ Ba ] Cab)) = def (quote _×_) (vArg A ∷
  vArg (def (quote _×_) (vArg (var-dec Ba) ∷ vArg (var-dec (var-dec (sources₀ Cab))) ∷ [])) ∷ [])
sources₁ (Π[ x ∶ arg i A ] Bx) = A
sources₁ (def (quote Σ) (ℓ₁ ∷ ℓ₂ ∷ τ ∷ body))
    = def (quote Σ) (ℓ₁ ∷ ℓ₂ ∷ map-Arg sources₀ τ ∷ List.map (map-Arg sources₁) body)
-- This function introduces 𝟙s, so let's drop any old occurances a la 𝟘.
sources₁ (def (quote ⊤) _) = def (quote 𝟘) []
sources₁ (lam v (abs s x))     = lam v (abs s (sources₁ x))
sources₁ (var x args) = var x (List.map (map-Arg sources₁) args)
sources₁ (con c args) = con c (List.map (map-Arg sources₁) args)
sources₁ (def f args) = def f (List.map (map-Arg sources₁) args)
sources₁ (pat-lam cs args) = pat-lam cs (List.map (map-Arg sources₁) args)
{-# CATCHALL #-}
-- sort, lit, meta, unknown
sources₁ t = t
#+end_src
#+latex: \noindent
We now form the macro and some unit tests.
#+begin_src agda :tangle Context.agda
macro
  sources : Term → Term → TC Unit.⊤
  sources tm goal = normalise tm >>=ₘ λ tm′ → unify (sources₁ tm′) goal

_ : sources (ℕ → Set) ≡ ℕ
_ = refl

_ : sources (Σ x ∶ (ℕ → Fin 3) • ℕ) ≡ (Σ x ∶ ℕ • ℕ)
_ = refl

_ : ∀ {ℓ : Level} {A B C : Set}
  → sources (Σ x ∶ (A → B) • C) ≡ (Σ x ∶ A • C)
_ = refl

_ : sources (Fin 1 → Fin 2 → Fin 3) ≡ (Σ _ ∶ Fin 1 • Fin 2 × 𝟙)
_ = refl

_ : sources (Σ f ∶ (Fin 1 → Fin 2 → Fin 3 → Fin 4) • Fin 5)
  ≡ (Σ f ∶ (Fin 1 × Fin 2 × Fin 3) • Fin 5)
_ = refl

_ : ∀ {A B C : Set} → sources (A → B → C) ≡ (A × B × 𝟙)
_ = refl

_ : ∀ {A B C D E : Set} → sources (A → B → C → D → E)
                        ≡ Σ A (λ _ → Σ B (λ _ → Σ C (λ _ → Σ D (λ _ → ⊤))))
_ = refl
#+end_src
#+latex: \noindent
Design decision: Types starting with implicit arguments are /invariants/, not /constructors/.
#+begin_src agda :tangle Context.agda
-- one implicit
_ : sources (∀ {x : ℕ} → x ≡ x) ≡ 𝟘
_ = refl

-- multiple implicits
_ : sources (∀ {x y z : ℕ} → x ≡ y) ≡ 𝟘
_ = refl
#+end_src
#+latex: \noindent
The third stage can now be formed.
#+begin_src agda :tangle Context.agda
D₃ = sources D₂

3-sources : D₃ ≡ λ (X : Set) → Σ z ∶ 𝟙 • Σ s ∶ X • 𝟘
3-sources = refl
#+end_src
*** Stage 4: ~Σ→⊎~ --Replacing Products with Sums
    <<sec:sigma-to-sum>>
#+begin_src agda :tangle Context.agda
{-# TERMINATING #-}
Σ→⊎₀ : Term → Term
Σ→⊎₀ (def (quote Σ) (𝒽₁ ∷ 𝒽₀ ∷ arg i A ∷ arg i₁ (lam v (abs s x)) ∷ []))
  =  def (quote _⊎_) (𝒽₁ ∷ 𝒽₀ ∷ arg i A ∷ vArg (Σ→⊎₀ (var-dec x)) ∷ [])
-- Interpret “End” in do-notation to be an empty, impossible, constructor.
Σ→⊎₀ (def (quote ⊤) _) = def (quote ⊥) []
 -- Walk under λ's and Π's.
Σ→⊎₀ (lam v (abs s x)) = lam v (abs s (Σ→⊎₀ x))
Σ→⊎₀ (Π[ x ∶ A ] Bx) = Π[ x ∶ A ] Σ→⊎₀ Bx
{-# CATCHALL #-}
Σ→⊎₀ t = t

macro
  Σ→⊎ : Term → Term → TC Unit.⊤
  Σ→⊎ tm goal = normalise tm >>=ₘ λ tm′ → unify (Σ→⊎₀ tm′) goal

-- Unit tests
_ : Σ→⊎ (Π X ∶ Set • (X → X))     ≡ (Π X ∶ Set • (X → X)); _ = refl
_ : Σ→⊎ (Π X ∶ Set • Σ s ∶ X • X) ≡ (Π X ∶ Set • X ⊎ X)  ; _ = refl
_ : Σ→⊎ (Π X ∶ Set • Σ s ∶ (X → X) • X) ≡ (Π X ∶ Set • (X → X) ⊎ X)  ; _ = refl
_ : Σ→⊎ (Π X ∶ Set • Σ z ∶ X • Σ s ∶ (X → X) • ⊤ {ℓ₀}) ≡ (Π X ∶ Set • X ⊎ (X → X) ⊎ ⊥)  ; _ = refl

D₄ = Σ→⊎ D₃

4-unions : D₄ ≡ λ X → 𝟙 ⊎ X ⊎ 𝟘
4-unions = refl
#+end_src
*** Stage 5: Fixpoint and proof that ~𝔻 ≅ ℕ~
#+begin_src agda :tangle Context.agda
{-# NO_POSITIVITY_CHECK #-}
data Fix {ℓ} (F : Set ℓ → Set ℓ) : Set ℓ where
  μ : F (Fix F) → Fix F

𝔻 = Fix D₄

-- Pattern synonyms for more compact presentation
pattern zeroD  = μ (inj₁ tt)       -- : 𝔻
pattern sucD e = μ (inj₂ (inj₁ e)) -- : 𝔻 → 𝔻

to : 𝔻 → ℕ
to zeroD    = 0
to (sucD x) = suc (to x)

from : ℕ → 𝔻
from zero    = zeroD
from (suc n) = sucD (from n)

to∘from : ∀ n → to (from n) ≡ n
to∘from zero    = refl
to∘from (suc n) = cong suc (to∘from n)

from∘to : ∀ d → from (to d) ≡ d
from∘to zeroD    = refl
from∘to (sucD x) = cong sucD (from∘to x)
#+end_src

*** ~termtype~ and ~Inj~ macros

We summarise the stages together into one macro:
~“termtype : UnaryFunctor → Type”~.
#+begin_src agda :tangle Context.agda
macro
  termtype : Term → Term → TC Unit.⊤
  termtype tm goal =
                normalise tm
           >>=ₘ λ tm′ → unify goal (def (quote Fix) ((vArg (Σ→⊎₀ (sources₁ tm′))) ∷ []))
 #+end_src
#+latex: \noindent
It is interesting to note that in place of ~pattern~ clauses, say for languages
that do not support them, we would resort to “fancy injections”.
#+begin_src agda :tangle Context.agda
Inj₀ : ℕ → Term → Term
Inj₀ zero c    = con (quote inj₁) (arg (arg-info visible relevant) c ∷ [])
Inj₀ (suc n) c = con (quote inj₂) (vArg (Inj₀ n c) ∷ [])

-- Duality!
-- 𝒾-th projection: proj₁ ∘ (proj₂ ∘ ⋯ ∘ proj₂)
-- 𝒾-th injection:  (inj₂ ∘ ⋯ ∘ inj₂) ∘ inj₁

macro
  Inj : ℕ → Term → Term → TC Unit.⊤
  Inj n t goal = unify goal ((con (quote μ) []) app (Inj₀ n t))
#+end_src
#+latex: \noindent
With this alternative, we regain the “user chosen constructor names” for ~𝔻~:
#+begin_src agda :tangle Context.agda
startD : 𝔻
startD = Inj 0 (tt {ℓ₀})

nextD′ : 𝔻 → 𝔻
nextD′ d = Inj 1 d
 #+end_src

** Monoids
*** Context
#+begin_src agda :tangle Context.agda
Monoid : ∀ ℓ → Context (ℓsuc ℓ)
Monoid ℓ = do Carrier ← Set ℓ
              Id      ← Carrier
              _⊕_     ← (Carrier → Carrier → Carrier)
              leftId  ← ∀ {x : Carrier} → x ⊕ Id ≡ x
              rightId ← ∀ {x : Carrier} → Id ⊕ x ≡ x
              assoc   ← ∀ {x y z} → (x ⊕ y) ⊕ z  ≡  x ⊕ (y ⊕ z)
              End {ℓ}
#+end_src
*** Termtypes
#+begin_src agda :tangle Context.agda
𝕄 : Set
𝕄 = termtype (Monoid ℓ₀ :waist 1)
{- ie Fix (λ X → 𝟙         -- Id, nil leaf
               ⊎ X × X × 𝟙 -- _⊕_, branch
               ⊎ 𝟘         -- src of leftId
               ⊎ 𝟘         -- src of rightId
               ⊎ X × X × 𝟘 -- src of assoc
               ⊎ 𝟘)        -- the “End {ℓ}”
-}

-- Pattern synonyms for more compact presentation
pattern emptyM      = μ (inj₁ tt)                      -- : 𝕄
pattern branchM l r = μ (inj₂ (inj₁ (l , r , tt)))     -- : 𝕄 → 𝕄 → 𝕄
pattern absurdM a   = μ (inj₂ (inj₂ (inj₂ (inj₂ a))))  -- absurd values of 𝟘

data TreeSkeleton : Set where
  empty  : TreeSkeleton
  branch : TreeSkeleton → TreeSkeleton → TreeSkeleton
#+end_src
*** ~𝕄 ≅ TreeSkeleton~
#+begin_src agda :tangle Context.agda
𝕄→Tree : 𝕄 → TreeSkeleton
𝕄→Tree emptyM = empty
𝕄→Tree (branchM l r) = branch (𝕄→Tree l) (𝕄→Tree r)
𝕄→Tree (absurdM (inj₁ ()))
𝕄→Tree (absurdM (inj₂ ()))

𝕄←Tree : TreeSkeleton → 𝕄
𝕄←Tree empty = emptyM
𝕄←Tree (branch l r) = branchM (𝕄←Tree l) (𝕄←Tree r)

𝕄←Tree∘𝕄→Tree : ∀ m → 𝕄←Tree (𝕄→Tree m) ≡ m
𝕄←Tree∘𝕄→Tree emptyM = refl
𝕄←Tree∘𝕄→Tree (branchM l r) = cong₂ branchM (𝕄←Tree∘𝕄→Tree l) (𝕄←Tree∘𝕄→Tree r)
𝕄←Tree∘𝕄→Tree (absurdM (inj₁ ()))
𝕄←Tree∘𝕄→Tree (absurdM (inj₂ ()))

𝕄→Tree∘𝕄←Tree : ∀ t → 𝕄→Tree (𝕄←Tree t) ≡ t
𝕄→Tree∘𝕄←Tree empty = refl
𝕄→Tree∘𝕄←Tree (branch l r) = cong₂ branch (𝕄→Tree∘𝕄←Tree l) (𝕄→Tree∘𝕄←Tree r)
#+end_src

** ~:kind~
#+begin_src agda :tangle Context.agda
data Kind : Set where
  ‵record    : Kind
  ‵typeclass : Kind
  ‵data      : Kind

macro
  _:kind_ : Term → Term → Term → TC Unit.⊤
  _:kind_ t (con (quote ‵record) _)    goal = normalise (t app (quoteTerm 0))
                      >>=ₘ λ t′ → unify (waist-helper 0 t′) goal
  _:kind_ t (con (quote ‵typeclass) _) goal = normalise (t app (quoteTerm 1))
                      >>=ₘ λ t′ → unify (waist-helper 1 t′) goal
  _:kind_ t (con (quote ‵data) _) goal = normalise (t app (quoteTerm 1))
                      >>=ₘ λ t′ → normalise (waist-helper 1 t′)
                      >>=ₘ λ t″ → unify goal (def (quote Fix) ((vArg (Σ→⊎₀ (sources₁ t″))) ∷ []))
  _:kind_ t _ goal = unify t goal
#+end_src
#+latex: \noindent
Informally, ~_:kind_~ behaves as follows:
#+begin_src agda :tangle Context.agda
𝒞 :kind ‵record    = 𝒞 :waist 0
𝒞 :kind ‵typeclass = 𝒞 :waist 1
𝒞 :kind ‵data      = termtype (𝒞 :waist 1)
#+end_src

** ~termtype PointedSet ≅ 𝟙~
   #+begin_src agda :tangle Context.agda
-- termtype (PointedSet) ≅ ⊤ !
One  : Context (ℓsuc ℓ₀)
One      = do Carrier ← Set ℓ₀
              point  ← Carrier
              End {ℓ₀}

𝕆𝕟𝕖 : Set
𝕆𝕟𝕖 = termtype (One :waist 1)

view₁ : 𝕆𝕟𝕖 → 𝟙
view₁ emptyM = tt
#+end_src
** The Termtype of Graphs is Edge Pairs
From simple graphs (relations) to a syntax about them:
One describes a simple graph by presenting edges as pairs of vertices!
#+begin_src agda :tangle Context.agda
PointedOver₂  : Set → Context (ℓsuc ℓ₀)
PointedOver₂ Ξ    = do Carrier ← Set ℓ₀
                       relation ← (Ξ → Ξ → Carrier)
                       End {ℓ₀}

ℙ₂ : Set → Set
ℙ₂ X = termtype (PointedOver₂ X :waist 1)

pattern _⇌_ x y = μ (inj₁ (x , y , tt))

view₂ : ∀ {X} → ℙ₂ X → X × X
view₂ (x ⇌ y) = x , y
#+end_src

** COMMENT Other experiments
#+begin_src agda :tangle Context.agda
-- No ‘constants’, whence a type of inifinitely branching terms.
PointedOver₃  : Set → Context (ℓ₀)
PointedOver₃ Ξ    = do relation ← (Ξ → Ξ → Ξ)
                       End {ℓ₀}

ℙ₃ : Set
ℙ₃ = termtype (λ X → PointedOver₃ X 0)

-- case₃ : ℙ₃ → Set₁
-- case₃ (px ⇌ py) = {!!}

--------------------------------------------------------------------------------

PointedOver₄  : Context (ℓsuc ℓ₀)
PointedOver₄       = do Ξ ← Set
                        Carrier ← Set ℓ₀
                        relation ← (Ξ → Ξ → Carrier)
                        End {ℓ₀}

-- The current implementation of “termtype” only allows for one “Set” in the body.
-- So we lift both out; thereby regaining ℙ₂!

ℙ₄ : Set → Set
ℙ₄ X = termtype ((PointedOver₄ :waist 2) X)

pattern _⇌_ x y = μ (inj₁ (x , y , tt))

case₄ : ∀ {X} → ℙ₄ X → Set₁
case₄ (x ⇌ y) = Set

-- Claim: Mention in paper.
--
--    P₁ : Set → Context = λ Ξ → do ⋯ End
-- ≅  P₂ :waist 1
-- where P₂ : Context = do Ξ ← Set; ⋯ End

--------------------------------------------------------------------------------

{- Yellow:

PointedOver₅  : Context (ℓsuc ℓ₀)
PointedOver₅   = do One ← Set
                    Two ← Set
                    Three ← (One → Two → Set)
                    End {ℓ₀}

ℙ₅ : Set → Set₁
ℙ₅ X = termtype ((PointedOver₅ :waist 2) X)
-- Fix (λ Two → One × Two)

pattern _∷₅_ x y = μ (inj₁ (x , y , tt))

case₅ : ∀ {X} → ℙ₅ X → Set₁
case₅ (x ∷₅ xs) = Set

-}

--------------------------------------------------------------------------------

{-- Dependent sums

PointedOver₆  : Context ℓ₁
PointedOver₆ = do Sort ← Set
                  Carrier ← (Sort → Set)
                  End {ℓ₀}

ℙ₆ : Set₁
ℙ₆ = termtype ((PointedOver₆ :waist 1) )
-- Fix (λ X → X)

-}

--------------------------------------------------------------------------------

-- Distinuighed subset algebra

open import Data.Bool renaming (Bool to 𝔹)

{-
PointedOver₇  : Context (ℓsuc ℓ₀)
PointedOver₇       = do Index ← Set
                        Is    ← (Index → 𝔹)
                        End {ℓ₀}

-- The current implementation of “termtype” only allows for one “Set” in the body.
-- So we lift both out; thereby regaining ℙ₂!

ℙ₇ : Set → Set
ℙ₇ X = termtype (λ (_ : Set) → (PointedOver₇ :waist 1) X)
-- ℙ₁ X ≅ X

pattern _⇌_ x y = μ (inj₁ (x , y , tt))

case₇ : ∀ {X} → ℙ₇ X → Set
case₇ {X} (μ (inj₁ x)) = X

-}

--------------------------------------------------------------------------------

-- indexed unary algebras; i.e., “actions”

PointedOver₈  : Context (ℓsuc ℓ₀)
PointedOver₈       = do Index     ← Set
                        Carrier   ← Set
                        Operation ← (Index → Carrier → Carrier)
                        End {ℓ₀}

ℙ₈ : Set → Set
ℙ₈ X = termtype ((PointedOver₈ :waist 2) X)

pattern _·_ x y = μ (inj₁ (x , y , tt))

case₈ : ∀ {I} → ℙ₈ I → Set₁
case₈ (i · e) = Set

-- This is just ℙ₄ again lol!

--------------------------------------------------------------------------------

{-
PointedOver₉  : Context ℓ₁
PointedOver₉       = do Carrier ← Set
                        End {ℓ₀}

-- The current implementation of “termtype” only allows for one “Set” in the body.
-- So we lift both out; thereby regaining ℙ₂!

ℙ₉ : Set
ℙ₉ = termtype (λ (X : Set) → (PointedOver₉ :waist 1) X)
-- ≅ 𝟘 ≅ Fix (λ X → 𝟘)
-}

--------------------------------------------------------------------------------

PointedOver₁₀  : Context ℓ₁
PointedOver₁₀       = do Carrier ← Set
                         next    ← (Carrier → Carrier)
                         End {ℓ₀}

-- The current implementation of “termtype” only allows for one “Set” in the body.
-- So we lift both out; thereby regaining ℙ₂!

ℙ₁₀ : Set
ℙ₁₀ = termtype (λ (X : Set) → (PointedOver₁₀ :waist 1) X)
-- Fix (λ X → X), which does not exist.

#+end_src

* COMMENT APPENDIX: What about the meta-language's parameters? :Maybe_Delete:

Besides ~:waist~, another way to introduce parameters into a context grouping
mechanism is to use the language's existing utility of parameterising a context
by another type ---as was done earlier in ~PointedOver~.

For example, a pointed set needn't necessarily be termined with ~End~.
#+begin_src agda
PointedSet : Context ℓ₁
PointedSet = do Carrier ← Set
                point   ← Carrier
                End {ℓ₁}
#+end_src
We instead form a grouping consisting of a single type and a value of that type,
along with an instance of the parameter type =Ξ=.
#+begin_src agda
PointedPF : (Ξ : Set₁) → Context ℓ₁
PointedPF Ξ = do Carrier ← Set
                 point   ← Carrier
                 ‵ Ξ
#+end_src
Clearly ~PointedPF 𝟙 ≈ PointedSet~, so we have a more generic grouping mechanism.
The natural next step is to consider other parameters such as ~PointedSet~
in-place of =Ξ=.
:AgdaCheckedEvidence:
#+begin_src agda
_ : ∀ {n} → PointedPF 𝟙 n ≡ PointedSet n
_ = refl
#+end_src
:End:
#+begin_src agda
-- Convenience names
PointedSetᵣ = PointedSet        :kind ‵record
PointedPFᵣ  = λ Ξ → PointedPF Ξ :kind ‵record

-- An extended record type: Two types with a point of each.
TwoPointedSets = PointedPFᵣ PointedSetᵣ

_ :   TwoPointedSets
    ≡ ( Σ Carrier₁ ∶ Set • Σ point₁ ∶ Carrier₁
      • Σ Carrier₂ ∶ Set • Σ point₂ ∶ Carrier₂ • 𝟙)
_ = refl

-- Here's an instance
one : PointedSet :kind ‵record
one = 𝔹 , false , tt

-- Another; a pointed natural extended by a pointed bool,
-- with particular choices for both.
two : TwoPointedSets
two = ℕ , 0 , one
#+end_src
More generally, /record *structure* can be dependent on values:/
#+begin_src agda
_PointedSets : ℕ → Set₁
zero  PointedSets = 𝟙
suc n PointedSets = PointedPFᵣ (n PointedSets)

_ :   4 PointedSets
    ≡ (Σ Carrier₁ ∶ Set • Σ point₁ ∶ Carrier₁
      • Σ Carrier₂ ∶ Set • Σ point₂ ∶ Carrier₂
      • Σ Carrier₃ ∶ Set • Σ point₃ ∶ Carrier₃
      • Σ Carrier₄ ∶ Set • Σ point₄ ∶ Carrier₄ • 𝟙)
_ = refl
#+end_src
Using traditional grouping mechanisms, it is difficult to create the family of
types =n PointedSets= since the number of fields, $2 × n$, depends on $n$.

It is interesting to note that the termtype of ~PointedPF~ is the same as the
termtype of ~PointedOver~, the ~Maybe~ type constructor!
#+begin_src agda :tangle no
PointedD : (X : Set) → Set₁
PointedD X = termtype (PointedPF (Lift _ X) :waist 1)

-- Pattern synonyms for more compact presentation
pattern nothingP = μ (inj₁ tt)
pattern justP x  = μ (inj₂ (lift x))

casingP : ∀ {X} (e : PointedD X)
        → (e ≡ nothingP) ⊎ (Σ x ∶ X • e ≡ justP x)
casingP nothingP  = inj₁ refl
casingP (justP x) = inj₂ (x , refl)
#+end_src

* COMMENT Other misc ideas
** Why syntax
   The archetype for records and termtypes ---algebraic data types--- are
   monoids. They describe untyped compositional structures, such as programs in
   dynamically type-checked language. In turn, their termtype is linked lists
   which reify a monoid value ---such as a program--- as a sequence of values
   ---i.e., a list of language instructions--- which ‘evaluate’ to the original
   value. The shift to syntax gives rise to evaluators, optimisers, and  constrained
   recursion-induction principles.

** Introduction

 In dependently-typed programming languages, such as Agda
 cite:Norell-2007,agda_overview, there is a tendency to define concepts
 repeatedly along syntactic constructs provided by the language.  In particular,
 one bundles up related data into a record structure, then considers the need to
 expose some of the fields as parameters and so provides a parameterised record
 construction, then for the need to have a description language for terms of
 these record types, one forms an associated algebraic datatype.  For example, we
 may form a type ~Monoid₀~ of monoids, which consists of a type along with an
 operation and some laws, but may want ~Monoid₁ M ⊕~ to speak of monoids over
 /particular/ types ~M~ and particular operations ~⊕~ ---the latter is handled, say in
 the Haskell standard library, by having isomorphic copies of types for each
 binary operation, such as ~Sum ≅ Prod ≅ Int~ for the classical additive and
 multiplicative monoidal structures on integers.  This is the problem we are
 solving: /How can parameterised records and their associated algebraic datatypes
 be obtained from a core declaration?/

 The humblest notion of a grouping mechanism is described by a pair type ~A × B ×
 C~, usually later values depend on earlier values and so we have the
 dependent-pair type src_agda[:exports code]{Σ a ∶ A • Σ b ∶ B a • Σ C a b}. The kind of these types is
 ~Set₁~, the type of small types. If we wish to speak of groupings where ~a ∶ A~ is
 /fixed/, then we must lift it from being a /field/ component to being a /parameter/,
 thereby arriving at the /function/ ~λ a ∶ A • Σ b ∶ B a • Σ C a b~ which has /type/ ~Π a ∶
 A • Set~. Similarly, we may expose ~b~ as a parameter to further indicate the
 possible grouping structure.

 | Grouping Description          |   | Kind                      |
 |-------------------------------+---+---------------------------|
 | =Σ a ∶ A • Σ b ∶ B a • Σ C a b= |   | ~Set~                       |
 | =λ a ∶ A • Σ b ∶ B a • Σ C a b= |   | ~Π a ∶ A • Set~             |
 | =λ a ∶ A • λ b ∶ B a • Σ C a b= |   | ~Π a ∶ A • Π b ∶ B a • Set~ |

 At each step, we “pull out” more information at the kind level; at first we have
 a ~Set~, an opaque grouping mechanism, then we obtain a ~Π a ∶ A • Set~ which is a
 grouping mechanism that somehow makes use of an ~A~-value.

 1. *Type constructor reification Π→λ:* Function /types/ like ~Π a ∶ A • Set~ cannot be
    applied since they are not functions, so how do we get to ~λ a : A • Set~?

    + λ-terms are values of Π-types, but in general there is no natural
      construction to transform a type into one of its values.

    + Given ~τ = Π (X : Set) • ⋯ : Set₁~, we want ~Π→λ τ = λ (X : Set) • ⋯ : Π (X :
      Set) • Set~; the former's type states it to be a =Set₁=, a grouping mechanism of
      which we know nothing, whereas the latter's type indicates it to be a
      parameterised grouping mechanism. Since ~Π→λ τ~ can be applied and is thus more
      concrete, we call ~Π→λ~ a reification combinator.

 2. *Unbundling* cite:packaging_mathematical_structures:
    How do we go from ~Set~ to ~Π a ∶ A • Set~?

    A function from function-types to functions-on-types necessarily requires a
    way to pattern match on the possible type constructions in a language.

    Perhaps an example will clarify the issue. The ubiquitous graph structure
    is contravariant in its collection of vertices. Recall that a multi-graph, or
    quiver, is a collection of vertices along with a collection of edges between
    any two vertices; here's the traditional record form:
    #+begin_src agda
Graph  : Context ℓ₁
Graph  = do Vertex ← Set
            Edges  ← (Vertex → Vertex → Set)
            End {ℓ₀}
 #+end_src

    Using the record form, it is akward to phrase contravariance, which simply
    “relabels the vertices”. Even worse, the awkward phrasing only serves to
    ensure certain constraints hold ---which are reified at the value level via
    the uninsightful ~refl~-exivity proof.
    #+begin_src agda
comap₀ : ∀ {A B : Set}
      → (f : A → B)
      → Σ G ∶ Graph :kind ‵record • Field 0 G ≡ B
      → Σ G ∶ Graph :kind ‵record • Field 0 G ≡ A
comap₀ {A} {B} f (⟨ .B , edgs ⟩ , refl) = (A , (λ a₁ a₂ → edgs (f a₁) (f a₂)) , tt) , refl
        #+end_src
    /Without redefining graphs/, we can phrase the definition at the typeclass
    level ---i.e., records parameterised by the vertices. This form is not only
    clearer and easier to implement at the value-level, it also makes it clear
    that we are “pulling back” the vertex type and so have also shown graphs are
    closed under reducts.
        #+begin_src agda
-- Way better and less awkward!
comap : ∀ {A B : Set}
     → (f : A → B)
     → (Graph :kind ‵typeclass) B
     → (Graph :kind ‵typeclass) A
comap f ⟨ edgs ⟩₁ = ⟨ (λ a₁ a₂ → edgs (f a₁) (f a₂)) ⟩₁
    #+end_src

    Later we show how to form ~Context~, its do-notation, and the ~:kind~ mechanism
    which shifts between records, typeclasses, and algebraic datatypes.

    It is important to note that we are using the word ‘typeclass’ as an
    abbreviation for “parameterised record”. In particular, we have no support
    for the traditional unification algorithm that makes typeclasses and
    canonical structures cite:coq_canonical_tutorial useful for ad-hoc
    polymorphism.
 # eval  : A × (A → B) → B
 # curry : (A × B → C) → (A → (B → C))
 # #
 # Π a ∶ A • (Π f ∶ (Π x ∶ A • B x)) • B a
 # Π f ∶ (Π p ∶ (Π x ∶ A • B x) • C p) • Π a ∶ A • Π b ∶ B a • C (a, b)
 # Π f ∶ Set • (Π x ∶ A • Set)

 We shall outline how this can be achieved in dependently-typed languages which
 have support for reflection. Our target language will be Agda, but the ideas
 easily transfer to other languages. In particular, the resulting in-language
 syntax we obtain is rather close to the existing Agda record syntax for
 declarations and Agda constructor tuples for instances.  In the next section, we
 begin by way of a more concrete example of a grouping mechanism, then we take a
 goal-driven approach to building the necessarily apparatus for a clean
 imperative-like declaration notation, then we conclude with a brief discussion
 on how the resulting framework can act as a simple theory for the Agda
 PackageFormer editor extension cite:DBLP:conf/gpce/Al-hassyCK19 ---which solves
 the =Monoidᵢ= problem mentioned earlier.

 In order to be language-agnostic and underscore the ideas, we shall present the
 core definitions along with Agda-checked examples. Details can be read at the
 following URL in a literate and reproducible fashion
 cite:DBLP:conf/europar/StanisicL14.
 # Details are left to an
 # appendix(?) or can be read below (MA: Haven't decided yet):
 | =https://github.com/alhassy/next-700-module-systems/tree/master/prototype= |

** OLD From Do-notation to (Parameterised) Record Types
   CLOSED: [2020-03-02 Mon 12:43]

 Traditionally a context is a list of name-type pairs, for us it will be a set
 ---namely the product of the types, since the names “do not matter”.  Moreover,
 contexts will be have a numeric ‘waist’ argument that indicates which of the
 first entries are ‘parameters’, leaving the remaining elements as ‘fields’.
 The subtlety of what is a ‘parameter’ ---exposed at the type level--- and what is a
 ‘field’ ---a component value--- has led to awkward formulations and
 the duplication of existing types for the sole purpose of different uses.
 We shall aim toward a monadic cite:DBLP:journals/iandc/Moggi91 interface
 to declare such grouping mechanisms.

 Let's see this in action, and for variety let's encode monoids.


 Notice that the elaborations are function types, but we want functions /on/ types
 ---as is the case with the ~DynamicSystemᵢ~ from the introduction.

** Unbundling: From Function Types to Functions /on/ Types

 Evaluation transforms functions to values and currying reorganises functions,
 but we want a combinator, call it ~Π→λ~, that takes a type and results in a value
 of that type.  In general, this is not feasible when the type is empty nor is it
 naturally canonical when there are multiple possible values to choose from.

 Let's see this in action. Here are our dynamical systems.
 #+begin_src agda :tangle no
DynamicSystem : Context (ℓsuc Level.zero)
DynamicSystem = do X ← Set
                   s ← X
                   n ← (X → X)
                   End {Level.zero}
 #+end_src

 Each type exposes more and more information about what kind of grouping
 structure we have at hand. The definitions could not be simpler.
 #+begin_src agda :tangle no
A′ : Set₁
B′ : Π X ∶ Set • Set
C′ : Π X ∶ Set • Π x ∶ X • Set
D′ : Π X ∶ Set • Π x ∶ X • Π s ∶ (X → X) • Set

A′ = DynamicSystem :waist 0
B′ = DynamicSystem :waist 1
C′ = DynamicSystem :waist 2
D′ = DynamicSystem :waist 3
 #+end_src

 If the language allows mixfix unicode identifiers, then one declares
 grouping mechanisms  with ~do ⋯ End~ then forms instances using, say, ~⟨⋯⟩~.
 #+begin_src agda :tangle no
-- Helpful syntactic sugar
⟨ : ∀ {ℓ} {S : Set ℓ} → S → S
⟨ s = s

_⟩ : ∀ {ℓ} {S : Set ℓ} → S → S × 𝟙 {ℓ}
s ⟩ = s , tt

⟨⟩ : ∀ {ℓ} → 𝟙 {ℓ}
⟨⟩ = tt
 #+end_src
 The following /instances/ of these grouping types demonstrate how /information moves from the body level to the parameter level./
 #+begin_src agda :tangle no
𝒩⁰ : A′
𝒩⁰ = ⟨ ℕ , 0 , suc ⟩

𝒩¹ : B′ ℕ
𝒩¹ = ⟨ 0 , suc ⟩

𝒩² : C′ ℕ 0
𝒩² = ⟨ suc ⟩

𝒩³ : D′ ℕ 0 suc
𝒩³ = ⟨⟩
 #+end_src

 It is interesting to note, that if a context =𝒞= has only 𝓃-many fields, then
 there are only 𝓃-many interesting unbundled forms, after which there are no new
 ones: ~𝒞 (𝓃 + k) ≡ 𝒞 𝓃~.

 With ~:waist~ we can fix parameters ahead of time.  For example, above the type =B′
 ℕ= is the type of “dynamic systems over carrier ℕ” whereas =C′ ℕ 0= is the type of
 “dynamic systems over carrier ℕ and start state 0”.  Without the unbundling
 mechanism we would have had to resort to awkward trivial constraints, as below,
 which are tolerable for one-off uses but clearly do not scale at all as
 indicated by the need to use equals-for-equals ~subst~-itutions of propositional
 equalities.
 #+begin_src agda
C″ : Π X ∶ Set • Π x ∶ X • Set₁
C″ X x = Σ 𝒟 ∶ DynamicSystem 0
       • Σ Carrier-is-X ∶ proj₁ 𝒟 ≡ X
       • proj₁ (proj₂ 𝒟) ≡ subst id (sym Carrier-is-X) x

𝒩²eek : C″ ℕ 0
𝒩²eek = (ℕ , 0 , suc , tt) , refl , refl
 #+end_src

 Traditionally cite:coq_cat_experiences, unbundling a record requires the use of
 transport along propositional equalities, with trivial ~refl~-exivity proofs.  The
 ~:waist~ approach presented here removes the boilerplate necessary at the type
 specialisation location as well as at the instance declaration location.

** =termtype=: Algebraic Datatypes are Fixpoints of Derived Functors
 With a bit of reflection, records and typeclasses have been coerced into a
 unified notation. It remains to bring algebraic datatypes into the fold.
** DSTerms

** Old Ideas
*** COMMENT Introduction [0/4]                               :boring:unclear:

    + [ ] Show example of a PackageFormer.
          - Demonstrate how: PackageFormer  ≈  named context + header.
    + [ ] Show example of how it can be used to give a record.
    + [ ] Show how it can be used to give us a homomorphism definition.
    + [ ] What are the pre- and post-conditions of the homomorphism construction?
          - This is what we are trying to solve.

*** COMMENT A Grammar for PackageFormer [0/5]              :rather:promising:

    + [ ] Grammar for PackageFormer heading.
    + [ ] Grammar for element datatype.
    + [ ] Grammar for “types”.
      - We clearly cannot use any Agda/MLTT types.
    + [ ] Define a fold for PackageFormer ---the homepage currently calls this ~graph-map~ due to
          the graph theoretic nature of element dependencies.
    + [ ] Prove that this fold preserves well-formedness & well-typedness of PackageFormers.
      - This is the semantics function!
      - *PackageFormers are an M-Set and fold is an M-Set homomorphism!*

        Call this M-Set “𝑷𝑭”.
        1. Two sorts: ~PackageFormer~ and ~Element~.
        2. Action: ~_◁_ : PackageFormer → Element → PackageFormer~
        3. Monoid on ~PackageFormer~
           - Unit: The empty PackageFormer
           - Bop: Union of contexts
             + If they agree on their intersection, then union of element lists;
               otherwise ‘crash’ by yielding ANN.
             + ANN is the annihilating PackageFormer: It is a postulated value
               that acts as the zero of union.
             - This ensures that a crash propagates and so a union of PF's
                 is ANN if any two items conflict.
             - E.g., “crash : PackageFormer⊥ → PackageFormer⊥ → Boolean”
                 is defined with “crash ⊥ x ≈ true” and symmetrically so.
             - Taking ANN = ⊥, as a bottom element; e.g., ~nothing~.
             + Proof outline of associativity:
             - Case 1: No crashes, then ordinary list catenation, which is associative.
             - Case 2: Some two items conflict, then ANN is propagated and both sides equal ANN.

**** Deriving Fold

     1. Define a “Right M-Set” ( close, but not really ):
        #+BEGIN_SRC agda
PackageFormer M-Set : Set₁ where
   Carrier₁     : Set
   Carrier₂     : Set
   _◁_          : Carrier₁ → Carrier₂ → Carrier₁
   ∅            : Carrier₁
   _∪_          : Carrier₁ → Carrier₁ → Carrier₁
   leftId       : {𝓋 : Carrier₂}  →  ∅ ◁ 𝓋  ≡  𝓋
   assoc        : {a b : Carrier₁} {𝓋 : Carrier₂} → (a ∪ b) ◁ 𝓋  ≡  a ∪ (b ◁ 𝓋)
  #+END_SRC

     2. Let ℳ denote an M-Set.

     3. For ~fold : 𝑷𝑭 ⟶ ℳ~ to be an M-Set homomorphism, we are *forced* to have …

     4. Two maps, ~foldᵢ : 𝑷𝑭.Carrierᵢ → ℳ.Carrierᵢ~
     5. ~fold₁~ is a monoid homomorphism
        1. Unit₁: ~fold₁ ∅ ≈ ∅~
        2. Assoc₁: ~fold₁ (p ∪ q) ≈ fold₁ p ∪ fold₁ q~
     6. Equivariance:
        ~fold₁ (p ◁ e) ≈ fold₁ p ◁ fold₂ e~

        \newpage

     7. Since a PackageFormer, by extensionality, can always be expressed
        as a finite sequence of extensions we find:
         #+BEGIN_SRC agda
  fold₁ p
= {- Extensionality, with eᵢ elements of p -}
  fold₁ (∅ ◁ e₁ ◁ e₂ ◁ ⋯ ◁ eₙ)
= {- Equivariance (6) -}
  fold₁ ∅ ◁ fold₂ e₁ ◁ ⋯ ◁ fold₂ eₙ
= {- Unit (5.1) -}
  ∅ ◁ fold₂ e₁ ◁ ⋯ ◁ fold₂ eₙ
= {- M-Set.leftId -}
  fold₂ e₁ ◁ ⋯ ◁ fold₂ eₙ
  #+END_SRC

     8. Whence it seems ~fold₁~ is defined uniquely in terms of ~fold₂~ ---which is unsurprising:
        *PackageFormers are an inductive type!*

     9. TODO: Realise this argument _within_ Agda!

*** COMMENT An Application to Universal Algebra               :super_sketchy:
    + [ ] Grammar for the minimal language necessary to form homomorphism contexts.
      - How? What? Huh!?
      - I'm not sure I know what I'm thinking here.
      - I'm trying to “know” what the ~hom~ variational, from the webpage does!
    + [ ] Define a function: ~𝑯 : PFSyntax → List HomoSyntax~.
    + [ ] Show a coherence such as ~𝑯(T ◁ e) = 𝑯 T ◁ 𝑯 e~
          where ◁ denotes context extension; i.e., append.
      - This would ensure that we have a ‘modular’ way to define homomorphisms.

    Applications to structures that CS people are interested in?
    - Monoids    ⇐ for-loops
    - Graphs     ⇐ databases
    - Lattices   ⇐ optimisation

      \vfill

*** COMMENT Conclusion & Next Steps                                 :sketchy:

    + Initial semantics is enough?
    + Limitations?
    + Dependent-type?
    + A counterexample not covered by the semantics?
    + Soundness?

*** space COMMENT newpage                                            :ignore:
    \newpage
*** OLD COMMENT Idea: Making Staging Accessible by Generating Partial Evaluators (Short Paper)
**** Abstract                                                        :ignore:
   # Do not use footnotes and references in the abstract!

   #+begin_abstract


     Interpreters are generally written with a syntax first then an interpretation second.
     The relationship between the two is sometimes made explicit by having the
     interpretation function target an existing record type ---e.g., syntactic
     datatype constructors are mapped to semantic projections of record values.
     However, this process only needs the record definition ---all else is needless
     duplication.

     Using ~PackageFormer~, a recent Emacs editor extension to the dependently typed language
     Agda, we demonstrate how partially-static data may be mechanically derived from
     theory presentations. Moreover, we also show how to mechanically obtain
     the necessary tools to work with staged interpreters; namely, automatically deriving
     evaluation functions and notions of ground terms.
   #+end_abstract

    \maketitle
**** Relevant Links
     + [[http://www.cs.tsukuba.ac.jp/~kam/papers/pepm2018.pdf][Program Generation for ML Modules]] --- Kameyama et al.
     + [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.438.6924&rep=rep1&type=pdf][A Gentle Introduction to Multi-stage Programming]] -- Walid Taha
     + [[https://www.cl.cam.ac.uk/~jdy22/papers/partially-static-data-as-free-extension-of-algebras.pdf][Partially-Static Data as Free Extension of Algebras]] -- Yallop et al.
     + [[http://okmij.org/ftp/meta-programming/StagingNG.pdf][Staging Beyond Terms: Prospects and Challenges]] --- Oleg et al.

**** Introduction: The Difficulties of Staging

   + Easy to get things wrong!

**** Automatically Introducing Dynamic Forms

   + A view that adds on variables and forms partial evaluators

   #+BEGIN_SRC agda
data BindingTime : Set where Static Dynamic : BindingTime

{- Aliases -}
Now   = Static
Later = Dynamic
           #+END_SRC

   Then:
   #+BEGIN_SRC agda
{- Given -}
record Magma : Set₁ where
  field
    Carrier : Set
    _⊕_     : Carrier → Carrier → Carrier

power₀ : {{ℳ : Magma }} (let M = Magma.Carrier ℳ)
      → M → ℕ → M
power₀ x zero    = x
power₀ x (suc n) = x ⊕ power₀ x n

instance
  𝒩 : Magma
  𝒩 = record {Carrier = ℕ; _⊕_ = _×_}

{- Obtain -}

---------------------------------------------------------------------------------------

{- Tree = Magma termtype with injection “Leaf” -}
data Tree (A : Set) → Set where
   Leaf   : A → Tree A
   Branch : Tree A → Tree A → Tree A

{- Proof obligation -}
instance
   tree-is-magma : ∀ {A} → Magma
   tree-is-magma {A} = record {Carrier = Tree A; _⊕_ = Branch}

{- Evaluator; terms reduce completely. -}
eval : (ℳ : Magma) → let M = Magma.Carrier ℳ
                      in  Tree M → M
eval (Leaf m) = m
eval (Branch l r) = eval l ⊕ evla r

{- An instance of power₀ -}
power₁ : {A : Set} → Tree A → ℕ → Tree A
power₁ x zero    = x
power₁ x (suc n) = Branch x (power₁ x n)

----------------------------------------------------------------------------------------
{- Terms with variables -}
data TreeV (A B : Set) → Set where
   Value    : A → TreeV A B
   Variable : B → TreeV A B
   Branch   : TreeV A B → TreeV A B → TreeV A B

{- Reduction for “TreeV String 𝒩” may be blocked by variables -}
evalV : (ℳ : Magma) {V : Set} →
          let M = Magma.Carrier ℳ
          in (V → M) → TreeV M V → M
evalV σ (Value m)    = m
evalV σ (Variable v) = σ v
evalV σ (Branch l r) = evalV σ l ⊕ evalV σ r

{- *NOT* an instance of power₀; but a generalisation thereof! -}
power : {{ℳ : Magma }} (let M = Magma.Carrier ℳ)
      → TreeV M V → ℕ → TreeV M V
power x zero    = x
power x (suc n) = x ⊕ power x n
   #+END_SRC

**** Multistaging via PackageFormers

     + How writing different PackageFormers allows us to merely select to what degree we want
       staging to occur; e.g., stageᵢ.
**** Conclusion and Next Steps

     + Theory?
     + Applications?
     + Pedagogy?

** OLD Abstract                                                      :ignore:
   CLOSED: [2020-03-02 Mon 16:00]

   #+begin_abstract org
   Folklore has held that any ‘semantic unit’ is essentially a type-theoretic
   context ---this includes, for example, records and algebraic datatypes.  We
   provide foundation for such an observation.

   We show that languages with a sufficiently powerful type system and reflection
   mechanism permit a /single declaration interface/ for functions, records, type
   classes, type constructors, and algebraic data types. Moreover, the interface
   is monadic and thus actually practical to use.

   Along the way, we solve the bundling problem: Record fields can be lifted to
   parameters as needed. Traditionally, unbundling a record requires the use of
   transport along propositional equalities, with trivial ~refl~-exivity proofs.
   The ~:waist~ approach presented here removes the boilerplate necessary at the
   type specialisation location as well as at the instance declaration location.

   An application of our setup will be to provide a semantics for the
   PackageFormer editor extension, which realises the aforementioned folklore
   observation by providing users with meta-primitives for making modules to
   allow arbitrary grouping mechanisms to be derived, such as obtaining the
   homomorphism type of a given record.
 #+end_abstract

  \maketitle

** Next Steps

   We have shown how a bit of reflection allows us to have a compact, yet
   practical, one-stop-shop notation for records, typeclasses, and algebraic
   data types. There are a number of interesting directions to pursue:

   + How to write a function working homogeneously over one variation and having
     it lift to other variations.
     - Recall the ~comap~ from the introductory section was written over
       ~Graph :kind ‵typeclass~; how could that particular implementation
        be massaged to work over ~Graph :kind 𝓀~ for any ~𝓀~.

   + The current implementation for deriving termtypes presupposes only one
     carrier set positioned as the first entity in the grouping mechanism.
     - How do we handle multiple carriers or choose a carrier from an arbitrary
       position or by name? =PackageFormer= handles this by comparing names.

   + How do we lift properties or invariants, simple ~≡~-types that ‘define’
     a previous entity to be top-level functions in their own right?

 Lots to do, so little time.

* Bib                                                        :ignore:

 #+latex: \bibliography{References}
 #+latex: \bibliographystyle{plainnat}
 # latex: \bibliographystyle{ACM-Reference-Format}

* footer                                                     :ignore:

# Local Variables:
# eval: (progn (org-babel-goto-named-src-block "make-acmart-class") (org-babel-execute-src-block))
# compile-command: (progn (org-babel-tangle) (org-latex-export-to-pdf) (async-shell-command "open Paper1.pdf"))
# End:
