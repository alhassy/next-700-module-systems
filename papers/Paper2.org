#+TITLE: Monadically Making Modules
#+SUBTITLE: 3-for-1 Monadic Notation: Do-it-yourself module types
# +Subtitle: ---ICFP Deadline: March 3, 2020---
#+DESCRIPTION: Paper for ICFP 2020.
#+AUTHOR: Musa Al-hassy, Jacques Carette, Wolfram Kahl
#+EMAIL: alhassy@gmail.com
#+OPTIONS: toc:nil d:nil author:t title:nil
#+PROPERTY: header-args :tangle no :comments link
#+TODO: TODO | OLD LaTeX README Remarks space
#+MACRO: PF \textsf{PackageFormer}
#+property: header-args :tangle paper2.agda :comments link

# src_agda[:exports code]{
:PDF:
For some reason â€œsrc agda2â€ crashes minted, but â€œsrc agdaâ€ works fine.

     #+BEGIN_SRC emacs-lisp  :tangle no
(setq org-latex-pdf-process
      '("pdflatex -shell-escape -output-directory %o %f"
        ;; "biber %b"
        "bibtex %b"
        "pdflatex -shell-escape -output-directory %o %f"
        "pdflatex -shell-escape -output-directory %o %f"))

(add-to-list 'org-src-lang-modes '("agda" . haskell))

(setq color t)
(when color     (setq org-latex-listings 'minted
                      org-latex-packages-alist '(("" "minted"))))
(unless color      (setq org-latex-listings nil
                         org-latex-packages-alist nil))
     #+END_SRC

     #+RESULTS:

#+BEGIN_SRC emacs-lisp :tangle no
(setq org-latex-compiler "pdflatex")
(setq-default TeX-engine 'default)

(setq org-latex-listings nil)
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("" "listings"))
(add-to-list 'org-latex-packages-alist '("" "color"))

(org-latex-export-to-pdf)
#+END_SRC

#+RESULTS:
: /Users/musa/thesis-proposal/papers/Paper2.pdf

:End:

:WK:
+ [ ] The ``Graph'' in ``data Graph'' seems to be a misnomer (should be ``Edge''?) --- poor example?

+ [ ] First occurrence of ``termtypes'' --> ``term datatypes'' or ``datatypes of expressions/terms''?

+ [ ] ``is thus a macro that acts on the syntactic term representations''
    Explanation of and reference for Agda's ``reflection'' mechanism necessary:
    This needs to be reasonably readable for Haskell programmers who have never looked into Agda.
    (Also explain pattern synonyms, and probably also some other Agda features.)

+ [ ] The ``definition'' of \Pi\to\lambda is presumably pseudo-Agda:
    Please be clear about that! Preferably put the full definition into an appendix.

+ [ ] After code blocks, \noindent.
    Consider indenting the code blocks instead, for more traditional
    literate programming appearance.

+ [ ] Avoid linebreak in thh middle of math --- \hbox{}.
  - src_agda[:exports code]{

+ [ ] |Maybe| is not a terribly high climax...

+ [ ] PointedSet/PointedPF: Currently does not look very attractive to me ---
    do you have any ``bigger'' examples?
:End:

* README COMMENT Dependencies of this org file

In the source blocks below, go into each one and press C-c C-c
to have it executed. Some â€˜resultsâ€™ will be echoed into the buffer
if everything went well.

Rather than executing the following blocks each time you edit this file,
consider adding them to your Emacs [[https://alhassy.github.io/init/][configuration file]].

 + org-mode :: This particular markup is called org-mode.

     Let's obtain Org-mode along with the extras that allow us to ignore
     heading names, but still utilise their contents --e.g., such as a heading
     named â€˜preambleâ€™ that contains org-mode setup for a file.
     #+begin_src emacs-lisp
;; first we get a handy-dandy package manager

(require 'package)
(setq package-archives '(("org"       . "https://orgmode.org/elpa/")
                         ("gnu"       . "https://elpa.gnu.org/packages/")
                         ("melpa"     . "https://melpa.org/packages/")
                         ("melpa-stable" . "https://stable.melpa.org/packages/")
                         ))
(package-initialize)

(package-refresh-contents)

(package-install 'use-package)
(require 'use-package)
(setq use-package-always-ensure t)

;; then we get the org-mode goodness

(use-package org
  :ensure org-plus-contrib
  :config
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines)))
#+end_src

     This lets us use the ~:ignore:~ tag on headlines you'd like to have ignored,
     while not ignoring their content --see [[https://emacs.stackexchange.com/a/17677/10352][here]].

     - Use the ~:noexport:~ tag to omit a headline /and/ its contents.

 + minted & bib :: Source blocks obtain colour.

     Execute the following for bib ref as well as minted
     Org-mode uses the Minted package for source code highlighting in PDF/LaTeX
     --which in turn requires the pygmentize system tool.
     #+BEGIN_SRC emacs-lisp
     (setq org-latex-listings 'minted
           org-latex-packages-alist '(("" "minted"))
           org-latex-pdf-process
           '("pdflatex -shell-escape -output-directory %o %f"
             ;; "biber %b"
             "bibtex %b"
             "pdflatex -shell-escape -output-directory %o %f"
             "pdflatex -shell-escape -output-directory %o %f")
     )
     #+END_SRC

     #+RESULTS:
     | pdflatex -shell-escape -output-directory %o %f | bibtex %b | pdflatex -shell-escape -output-directory %o %f | pdflatex -shell-escape -output-directory %o %f |

You can then refer to Table (tab-boring). The ref links are also clickable, and
they take you to the spot where the label is defined. You can enter ref links
with completion. Press C-c C-l, type ref, press enter, and then press tab. You
will get a list of the labels defined in the buffer you can choose from. There
are many things you can make a ref to including a tblname, a label link, an
explicit \label{}, and an org-mode #+label: line. (tab-boring)

Instead of C-c C-l, use org-ref-insert-ref-link; e.g., ref:make-acmart-class
refers to the table below. Use â€œrefâ€ to refer to Org entities.

See here for more: http://kitchingroup.cheme.cmu.edu/blog/2014/05/13/Using-org-ref-for-citations-and-references/

  # Enable the following to have small-font code blocks.
  # LATEX_HEADER: \RequirePackage{fancyvrb}
  # LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}

 + acmart :: Enable acmart latex class.

   #+NAME: make-acmart-class
   #+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("acmart" "\\documentclass{acmart}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

 (message "acmart has been loaded")
 #+END_SRC

 #+RESULTS: make-acmart-class
 : acmart has been loaded

  The GPCE 19 proceedings team needs us to submit the acmart.cls file along
  with our sources. So, let's bring that to our current directory.
#+BEGIN_SRC shell
(shell-command (s-collapse-whitespace (format "cp %s ."
                       (shell-command-to-string "kpsewhich acmart.cls"))))
#+END_SRC

#+RESULTS:
: 126

   The â€˜footerâ€™ at the end of this file currently executes only this code block for you
   ---if you enable the local vars. You can easily tweak it to execute the other blocks,
   if you like.

 + org-ref :: [[https://github.com/jkitchin/org-ref][An exquisite system]] for handling references.

    If everything works, the following entity will display useful data
    when the mouse hovers over it (â€¢Ì€á´—â€¢Ì)Ùˆ If you click on it, then you're
    in for a lot of super neat stuff, such as searching for the pdf online!

    cite:agda_overview

    #+BEGIN_SRC emacs-lisp
(use-package org-ref :demand t)

;; Files to look at when no â€œâ•²bibliography{â‹¯}â€ is not present in a file.
;; Most useful for non-LaTeX files.
(setq reftex-default-bibliography '("References.bib"))

(use-package helm-bibtex :demand t)
;; If you use helm-bibtex as the citation key completion method you should set these variables too.

(setq bibtex-completion-bibliography "References.bib")
#+END_SRC

#+RESULTS:
: References.bib

#+RESULTS:
: References.bib

  Execute ~M-x helm-bibtex~ and, say, enter ~agda~ and you will be presented with
  all the entries in the bib database that mention â€˜agdaâ€™. Super cool stuff.

* LaTeX setup                                                        :ignore:

#+latex_class_options: [10pt]

  # Visible editorial comments.
  # LATEX_HEADER: \usepackage{edcomms}
  # LATEX_HEADER: \edcommsfalse

  #+latex_header: \usepackage[font=itshape]{quoting}
  # Use quoting environment

** Document class options                                            :ignore:
  #+LATEX_CLASS: acmart
  # latex_class_options: [sigplan,screen]
  # latex_class_options: [sigplan,review,anonymous]
  # #+latex_class_options: [sigplan,review]
  # latex_class_options: [acmsmall,review,anonymous]

** Letter size and no page numbers or footers :ignore:
  # Letter-Size Paper Format, defaults
  #+latex_header: \pdfpagewidth=8.5in
  #+latex_header: \pdfpageheight=11in

  # switch off page numbering, â€œfoliosâ€
  # latex_header: \pagenumbering{gobble}

  # LATEX: \settopmatter{printccs=true, printfolios=false}

** Unicode & hyperlinks :ignore:
  # Dark green colour for links.
  #+LATEX_HEADER: \usepackage{color}
  #+LATEX_HEADER: \definecolor{darkgreen}{rgb}{0.0, 0.3, 0.1}
  #+LATEX_HEADER: \hypersetup{colorlinks,linkcolor=darkgreen,citecolor=darkgreen,urlcolor=darkgreen}

  #+LATEX_HEADER: \usepackage{../CheatSheet/UnicodeSymbols}

  #+LATEX_HEADER: \newcommand\boldblue[1]{\textcolor{blue}{\textbf{#1}}}
  #+LATEX_HEADER: \newcommand\boldred[1]{\textcolor{red}{\textbf{#1}}}
  #+LATEX_HEADER: \newcommand\boldgreen[1]{\textcolor{darkgreen}{\textbf{#1}}}

  #+LATEX_HEADER: \newunicodechar{Ê³}{\boldblue{\text{\ensuremath{^r}}}}

  #+LATEX_HEADER: \newunicodechar{Î£}{\boldblue{\text{\ensuremath{\Sigma}}}}
  #+LATEX_HEADER: \newunicodechar{âŠ}{\boldblue{\text{\ensuremath{\uplus}}}}
  #+LATEX_HEADER: \newunicodechar{Ã—}{\boldblue{\text{\ensuremath{\times}}}}
  #+LATEX_HEADER: \newunicodechar{Î }{\boldred{\text{\ensuremath{\Pi}}}}
  #+LATEX_HEADER: \newunicodechar{Î»}{\boldgreen{\text{\ensuremath{\lambda}}}}
  #+LATEX_HEADER: \newunicodechar{â‰…}{\boldblue{\text{\ensuremath{\cong}}}}
  #+LATEX_HEADER: \newunicodechar{â„•}{\boldblue{\text{\ensuremath{\mathbb{N}}}}}

  #+LATEX_HEADER: \DeclareMathOperator{\VCCompose}{\longrightarrow\hspace{-3ex}\oplus\;}
  #+LATEX_HEADER: \newunicodechar{âŸ´}{\ensuremath{\!\!\VCCompose}}
  #+LATEX_HEADER: \newunicodechar{ğ“‹}{\ensuremath{\!\!v}}
  #+LATEX_HEADER: \newunicodechar{ğ’±}{\ensuremath{\mathcal{V}}}
  #+LATEX_HEADER: \newunicodechar{Î±}{\ensuremath{\alpha}}

  #+LATEX_HEADER: \newunicodechar{â‰‡}{\ensuremath{\ncong}}

  #+LATEX_HEADER: \newunicodechar{â„“}{\ensuremath{\ell}}
  #+LATEX_HEADER: \newunicodechar{â€µ}{\ensuremath{`}}
  #+LATEX_HEADER: \newunicodechar{â†}{\ensuremath{\longrightarrow}}
  #+LATEX_HEADER: \newunicodechar{â‡Š}{\ensuremath{\downarrow\!\downarrow}}

  # ğ‘›ğ‘ğ‘šğ‘’
  #+LATEX_HEADER: \newunicodechar{ğ‘›}{\ensuremath{n}}
  #+LATEX_HEADER: \newunicodechar{ğ‘}{\ensuremath{a}}
  #+LATEX_HEADER: \newunicodechar{ğ‘š}{\ensuremath{m}}
  #+LATEX_HEADER: \newunicodechar{ğ‘’}{\ensuremath{e}}

  #+LATEX_HEADER: \newunicodechar{â°}{\ensuremath{^0}}
  #+LATEX_HEADER: \newunicodechar{â¿}{\ensuremath{^n}}
  #+LATEX_HEADER: \newunicodechar{Â³}{\ensuremath{^3}}

  #+LATEX_HEADER: \newunicodechar{Î}{\ensuremath{\Xi}}
  #+LATEX_HEADER: \newunicodechar{Î¾}{\ensuremath{\xi}}

  #+LATEX_HEADER: \newunicodechar{ğ•†}{\ensuremath{\textbb{O}}}
  #+LATEX_HEADER: \newunicodechar{ğ•Ÿ}{\ensuremath{\textbb{n}}}
  #+LATEX_HEADER: \newunicodechar{ğ•–}{\ensuremath{\textbb{e}}}

  #+LATEX_HEADER: \newunicodechar{â‡Œ}{\ensuremath{\rightleftharpoons}}

  #+LATEX_HEADER: \newunicodechar{ğ”¾}{\ensuremath{\textbb{G}}}
  #+LATEX_HEADER: \newunicodechar{ğ•£}{\ensuremath{\textbb{r}}}
  #+LATEX_HEADER: \newunicodechar{ğ•’}{\ensuremath{\textbb{a}}}
  #+LATEX_HEADER: \newunicodechar{ğ•¡}{\ensuremath{\textbb{p}}}
  #+LATEX_HEADER: \newunicodechar{ğ•™}{\ensuremath{\textbb{h}}}

  #+LATEX_HEADER: \newunicodechar{âŒ}{\ding{55}}
  #+LATEX_HEADER: \newunicodechar{âœ“}{\ding{51}}

  #+LATEX_HEADER: \newunicodechar{ğ”»}{\ensuremath{\textbb{D}}}
  #+LATEX_HEADER: \newunicodechar{â„‚}{\ensuremath{\textbb{C}}}
  #+LATEX_HEADER: \newunicodechar{ğ•„}{\ensuremath{\textbb{M}}}
  #+LATEX_HEADER: \newunicodechar{â„™}{\ensuremath{\textbb{P}}}
  #+LATEX_HEADER: \newunicodechar{ğŸ˜}{\ensuremath{\textbb{0}}}
  #+LATEX_HEADER: \newunicodechar{ğŸ™}{\ensuremath{\textbb{1}}}

  #+LATEX_HEADER: \newunicodechar{ğ‘·}{\ensuremath{\textbf{P}}}
  #+LATEX_HEADER: \newunicodechar{ğ‘­}{\ensuremath{\textbf{F}}}
  #+LATEX_HEADER: \newunicodechar{ğ‘¯}{\ensuremath{\textbf{H}}}

** COMMENT CCSXML and Keywords                                               :ignore:
   # This must be /before/ maketitle!
   #+begin_export latex
 %%
 %% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.

 \begin{CCSXML}
 <ccs2012>
 <concept>
 <concept_id>10011007.10011006.10011008.10011009.10011019</concept_id>
 <concept_desc>Software and its engineering~Extensible languages</concept_desc>
 <concept_significance>500</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011024.10011031</concept_id>
 <concept_desc>Software and its engineering~Modules / packages</concept_desc>
 <concept_significance>500</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
 <concept_desc>Software and its engineering~Functional languages</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011024.10011025</concept_id>
 <concept_desc>Software and its engineering~Polymorphism</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011041.10011047</concept_id>
 <concept_desc>Software and its engineering~Source code generation</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011066.10011069</concept_id>
 <concept_desc>Software and its engineering~Integrated and visual development environments</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 </ccs2012>
 \end{CCSXML}

 \ccsdesc[500]{Software and its engineering~Extensible languages}
 \ccsdesc[500]{Software and its engineering~Modules / packages}
 \ccsdesc[300]{Software and its engineering~Functional languages}
 \ccsdesc[300]{Software and its engineering~Polymorphism}
 \ccsdesc[300]{Software and its engineering~Source code generation}
 \ccsdesc[300]{Software and its engineering~Integrated and visual development environments}

 %%
 %% Keywords. The author(s) should pick words that accurately describe
 %% the work being presented. Separate the keywords with commas.
 \keywords{Agda, meta-program, extensible, Emacs, packages, modules, dependent-types}
   #+end_export

** COMMENT Authors & title                                                   :ignore:

 #+begin_export latex
 \author{Musa Al-hassy}
 \affiliation{McMaster University, Canada}
 \email{alhassy@gmail.com}

 \author{Jacques Carette}
 \orcid{0000-0001-8993-9804}
 \affiliation{McMaster University, Canada}
 \email{carette@mcmaster.ca}

 \author{Wolfram Kahl}
 \orcid{0000-0002-6355-214X}
 \affiliation{McMaster University, Canada}
 \email{kahl@cas.mcmaster.ca}

 % \author{Musa Al-hassy \\ {\small \url{alhassy@gmail.com} \\ McMaster University \\ Computing and Software \\ Hamilton, Ontario, Canada}}
 % \author{Jacques Carette \\ {\small \url{carette@mcmaster.ca} \\ McMaster University \\ Computing and Software \\ Hamilton, Ontario, Canada}}
 % \author{Wolfram Kahl \\ {\small \url{kahl@cas.mcmaster.ca} \\ McMaster University \\ Computing and Software \\ Hamilton, Ontario, Canada}}

 #+end_export

** Widows and Orphans                                                :ignore:
 # An "orphan" is an isolated line of text at the bottom of a page;
 # an "orphan heading" is a heading without following body text at the bottom of the page;
 # a "widow" is an isolated line of text at the top of a page.
 #
 # LaTeX: In order to eliminate widows and orphans, you can copy the following commands into the LaTeX source before \begin{document} :
 #
   #+latex_header:        \clubpenalty = 10000
   #+latex_header:        \widowpenalty = 10000
   #+latex_header:        \displaywidowpenalty = 10000

 # Sometimes, orphans and widows will survive these commands, in which case a \vspace command might help.

** Balanced Columns on Last Page                                     :ignore:
   #+latex_header: \usepackage{flushend}

 # The two columns of the last page need to have the same length.
 #
 # + LaTeX (Option 1) :: Insert the command \usepackage{flushend} into the LaTeX source before \begin{document}.
 #
 # + LaTeX (Option 2) :: Insert \usepackage{balance} into the LaTeX source before \begin{document}
 #      and the following in the text that would appear as left column on the last page without balancing: \balance.
 #
 # + LaTeX (Option 3) :: If the above options do not work, it seems that one of the used packages prevents
 #      the balancing from working properly. In case you do not want to spend time on finding out which
 #       package it is, you can manually balance the last page by inserting a \newpage between your
 #       references in the .bbl file at an appropriate position. (Attention: Running bibtex again
 #       will overwrite this; alternatively, the contents of the .bbl file can be copy-and-paste'ed
 #       into the main LaTeX file in place of the \bibliography command.)
 #
** COMMENT GPCEâ€™19 Copyright                                                 :ignore:

 # The following is specific to GPCE '19 and the paper
 # 'A Language Feature to Unbundle Data at Will (Short Paper)'
 # by Musa Al-hassy, Wolfram Kahl, and Jacques Carette.
 #
 #+latex_header: \setcopyright{acmcopyright}
 #+latex_header: \acmPrice{15.00}
 #+latex_header: \acmDOI{10.1145/3357765.3359523}
 #+latex_header: \acmYear{2019}
 #+latex_header: \copyrightyear{2019}
 #+latex_header: \acmISBN{978-1-4503-6980-0/19/10}
 #+latex_header: \acmConference[GPCE '19]{Proceedings of the 18th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences}{October 21--22, 2019}{Athens, Greece}
 #+latex_header: \acmBooktitle{Proceedings of the 18th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences (GPCE '19), October 21--22, 2019, Athens, Greece}
 #+latex_header:

* Abstract :ignore:

  #+begin_abstract org
  Can parameterised records and algebraic datatypes be derived from one
  pragmatic declaration?

  Record types give a universe of discourse, parameterised record types fix
  parts of that universe ahead of time, and algebraic datatypes give us
  first-class syntax, whence evaluators and optimisers.

  The answer is in the affirmative. Besides a practical
  shared declaration interface, which is extensible in the language,
  we also find that common data structures correspond to simple theories.
#+end_abstract

 \maketitle

* Header :noexport:

#+begin_src agda :tangle paper2.agda
module paper2 where

--------------------------------------------------------------------------------
-- (shell-command "ln -s /Users/musa/thesis-proposal/prototype/semantics-with-waist.agda semantics-with-waist.agda")

open import semantics-with-waist
open import Data.Product
open import Level renaming (zero to â„“â‚€) hiding (suc)
open import Relation.Binary.PropositionalEquality hiding ([_])
open import Data.Nat
open import Function using (id)
open import Data.Bool renaming (Bool to ğ”¹)
open import Data.Sum

open import Data.List
import Data.Unit as Unit
open import Reflection hiding (name; Type) renaming (_>>=_ to _>>=â‚˜_)

â„“â‚ = Level.suc â„“â‚€

-- Helpers for readability
pattern âŸ¨_âŸ©â‚ x    = x , tt
pattern âŸ¨_,_âŸ© x y = x , y , tt
#+end_src

* Introduction

  We routinely write algebraic datatypes to provide a first-class syntax for
  record values. We work with semantic values, but need syntax to provide
  serialisation and introspection capabilities.  A concept is thus rendered
  twice, once at the semantic level using records and again at the syntactic
  level using algebraic datatypes. Even worse, there is usually a need to expose
  fields of a record at the type level and so yet another variation of the same
  concept needs to be written.  Our idea is to unify the various type declarations
  into one ---using monadic do-notation and in-language meta-programming
  combinators to then extract possibly parameterised records and algebraic data
  types.

  For example, there are two ways to implement the type of graphs in the
  dependently-typed language Agda
 cite:Norell-2007,agda_overview: Having the vertices be a parameter or having
  them be a field of the record. Then there is also the syntax for graph vertex
  relationships.

#+begin_src agda
record Graphâ‚€ : Setâ‚ where
  constructor âŸ¨_,_âŸ©â‚€
  field
    Vertex : Set
    Edges : Vertex â†’ Vertex â†’ Set

record Graphâ‚ (Vertex : Set) : Setâ‚ where
  constructor âŸ¨_âŸ©â‚
  field
    Edges : Vertex â†’ Vertex â†’ Set

data ğ”¾ğ•£ğ•’ğ•¡ğ•™ (Vertex : Set) : Set where
  âŸ¨_,_âŸ©â‚› : Vertex â†’ Vertex â†’ ğ”¾ğ•£ğ•’ğ•¡ğ•™ Vertex
#+end_src

  #+latex: \noindent
  To illustrate the difference of the first two, consider the function ~comap~, which
  relabels the vertices of a graph, using a function ~f~ to transform vertices:
  :Hide:
  #+begin_src agda
open Graphâ‚€
#+end_src
  :End:
#+begin_src agda
comapâ‚€ : {A B : Set}
       â†’ (f : A â†’ B)
       â†’ (Î£ G âˆ¶ Graphâ‚€ â€¢ Vertex G â‰¡ B)
       â†’ (Î£ H âˆ¶ Graphâ‚€ â€¢ Vertex H â‰¡ A)
comapâ‚€ {A} f (G , refl) = âŸ¨ A , (Î» x y â†’ Edges G (f x) (f y)) âŸ©â‚€ , refl

comapâ‚ : {A B : Set}
       â†’ (f : A â†’ B)
       â†’ Graphâ‚ B
       â†’ Graphâ‚ A
comapâ‚ f âŸ¨ edges âŸ©â‚ = âŸ¨ (Î» x y â†’ edges (f x) (f y)) âŸ©â‚
  #+end_src

  #+latex: \noindent
  In ~comapâ‚€~, the input graph ~G~ and the output graph ~H~ have their vertex sets
  constrained to match the type of the relabelling function ~f~.  Without the
  constraints, we could not even write the function for ~Graphâ‚€~.
  With such an importance, it is surprising to see that the occurrences
  of the constraint proofs are uninsightful ~refl~-exivity proofs.
  In contrast, ~comapâ‚~ does not carry any excesses baggage at the type level
  nor at the implementation level.

  We will show an automatic technique for obtaining the above three definitions
  of graphs from a single declaration using similar notation.  Our contributions
  are to show:
  1. Languages with sufficiently powerful type systems and meta-programming can
     conflate record and term datatype declarations into one practical interface.  We
     identify the problem and the subtleties in shifting between representations
     in Section [[sec:problems]].

  2. Parameterised records can be obtained on-demand from non-parameterised
     records (Section [[sec:monadic-notation]]).
     - As with ~Graphâ‚€~, the traditional cite:coq_cat_experiences approach to
       unbundling a record requires the use of transport along propositional
       equalities, with trivial ~refl~-exivity proofs. In Section
       [[sec:monadic-notation]], we develop a combinator, ~_:waist_~, which removes
       the boilerplate necessary at the type specialisation location as well as
       at the instance declaration location.

  3. Programming with fixed-points of unary type constructors can be made
     as simple as programming with term datatypes (Section
     [[sec:termtypes-as-fixedpoints]]).

  4. Astonishingly, we mechanically regain ubiquitous data structures such as ~â„•,
     Maybe, List~ as the termtypes of simple pointed and monoidal theories
     (Section [[sec:free-datatypes]]).

  As an application, in Section [[sec:related-works]] we show that the resulting
  setup applies as a semantics for a declarative pre-processing tool that accomplishes the
  above tasks.

* The Problems
  <<sec:problems>>

There are a number of problems, with the number of parameters being exposed
being the pivotal concern. To exemplify the distinctions at the type level as
more parameters are exposed, consider the following approaches to formalising a
dynamical system ---a collection of states, a designated start state, and a
transition function.

#+begin_src agda :tangle paper2.agda
record DynamicSystemâ‚€ : Setâ‚ where
  field
    State : Set
    start  : State
    next   : State â†’ State

record DynamicSystemâ‚ (State : Set) : Set where
  field
    start : State
    next  : State â†’ State

record DynamicSystemâ‚‚ (State : Set) (start : State) : Set where
  field
    next : State â†’ State
#+end_src

#+latex: \noindent
Each =DynamicSystemáµ¢= is a type constructor of =i=-many arguments;
but it is the types of these constructors that provide insight
into the sort of data they contain:
| Type           | Kind                      |
|----------------+---------------------------|
| =DynamicSystemâ‚€= | =Setâ‚=                      |
| =DynamicSystemâ‚= | =Î  X âˆ¶ Set â€¢ Set=           |
| =DynamicSystemâ‚‚= | =Î  X âˆ¶ Set â€¢ Î  x âˆ¶ X â€¢ Set= |
:AgdaCheckedEvidence:
    #+begin_src agda :tangle paper2.agda
_ : Setâ‚
_ = DynamicSystemâ‚€

_ : Î  X âˆ¶ Set â€¢ Set
_ = DynamicSystemâ‚

_ : Î  X âˆ¶ Set â€¢ Î  x âˆ¶ X â€¢ Set
_ = DynamicSystemâ‚‚
#+end_src
:End:

We shall refer to the concern of moving from a record to a parameterised record
as *the unbundling problem* cite:packaging_mathematical_structures. For example,
moving from the /type/ ~Setâ‚~ to the /function type/ ~Î  X âˆ¶ Set â€¢ Set~ gets us from
~DynamicSystemâ‚€~ to something resembling ~DynamicSystemâ‚~, which we arrive at if we
can obtain a /type constructor/ ~Î» X âˆ¶ Set â€¢ â‹¯~. We shall refer to the latter change
as /reification/ since the result is more concrete, it can be applied; it will be
denoted by ~Î â†’Î»~. To clarify this subtlety, consider the following forms of the
polymorphic identity function. Notice that ~idáµ¢~ /exposes/ ğ’¾-many details at the
type level to indicate the sort it consists of. However, notice that ~idâ‚€~ is
a type of functions whereas ~idâ‚~ is a function on types. Indeed, the latter
two are derived from the first one: ~idáµ¢â‚Šâ‚ = Î â†’Î» idáµ¢~ ---this is proven by
reflexivity in the appendices.
#+begin_src agda :tangle no
idâ‚€ : Setâ‚
idâ‚€ = Î  X âˆ¶ Set â€¢ Î  e âˆ¶ X â€¢ X

idâ‚ : Î  X âˆ¶ Set â€¢ Set
idâ‚ = Î» (X : Set) â†’ Î  e âˆ¶ X â€¢ X

idâ‚‚ : Î  X âˆ¶ Set â€¢ Î  e âˆ¶ X â€¢ Set
idâ‚‚ = Î» (X : Set) (e : X) â†’ X
#+end_src

#+latex: \noindent
Of-course, there is also the need for descriptions of values, which leads to the
following termtypes. We shall refer to the shift from record types to algebraic
data types as *the termtype problem*.
#+begin_src agda :tangle paper2.agda
data DSTermsâ‚€ : Set where
  start : DSTermsâ‚€
  next  : DSTermsâ‚€ â†’ DSTermsâ‚€

data DSTermsâ‚ (State : Set) : Set where
  start : State â†’ DSTermsâ‚ State
  next  : DSTermsâ‚ State â†’ DSTermsâ‚ State

data DSTermsâ‚‚ (State : Set) (start : State) : Set where
  next : DSTermsâ‚‚ State start â†’ DSTermsâ‚‚ State start
#+end_src
:Ignore:
Yet another way to encode dynamical systems would be by their syntax, as it
would be desirable when serialising them ---i.e., to obtain first-class
descriptions of dynamical system values.


Notice that the first algebraic data type is isomorphic to ~â„•~, whereas the
remaining two are isomorphic to ~State Ã— â„•~ which keeps track of how many =next=
steps are necessary until a =State= value is reached ---this may be called
=Eventually State=.
The ~DSTermsáµ¢~ share the same pattern of kind exposure as the ~DynamicSystemáµ¢~ types.

AgdaCheckedEvidence
#+begin_src agda :tangle paper2.agda
_ : Set
_ = DSTermsâ‚€

_ : Î  X âˆ¶ Set â€¢ Set
_ = DSTermsâ‚

_ : Î  X âˆ¶ Set â€¢ Î  x âˆ¶ X â€¢ Set
_ = DSTermsâ‚‚
#+end_src
:End:

#+latex: \noindent
Our aim is to obtain all of these notions ---of ways to group data together---
from a single user-friendly context declaration, using monadic notation.

* Monadic Notation
  <<sec:monadic-notation>>

  There is little use in an idea that is difficult to use in practice.  As such,
  we conflate records and termtypes by starting with an ideal syntax they would
  share, then derive the necessary artefacts that permit it. Our choice of
  syntax is monadic do-notation cite:DBLP:journals/iandc/Moggi91,cite:DBLP:conf/haskell/MarlowJKM16:

#+begin_src agda :tangle no
  DynamicSystem : Context â„“â‚
  DynamicSystem = do X â† Set
                     z â† X
                     s â† (X â†’ X)
                     End
#+end_src
 #+latex: \noindent
 Here ~Context, End~, and the underlying monadic bind operator are unknown.  Since
 we want to be able to /expose/ a number of fields at will, we may take ~Context~ to
 be types indexed by a number denoting exposure.  Moreover, since records are a
 product type, we expect there to be a recursive definition whose base case will
 be the essential identity of products, the unit type ~ğŸ™~.

| Exposure |   | Elaboration                                |
|----------+---+--------------------------------------------|
|        0 |   | =Î£ X âˆ¶ Set  â€¢ Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ ğŸ™= |
|        1 |   | =Î  X âˆ¶ Set  â€¢ Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ ğŸ™= |
|        2 |   | =Î  X âˆ¶ Set  â€¢ Î  z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ ğŸ™= |
|        3 |   | =Î  X âˆ¶ Set  â€¢ Î  z âˆ¶ X  â€¢ Î  s âˆ¶ (X â†’ X)  â€¢ ğŸ™= |

With these elaborations of ~DynamicSystem~ to guide the way, we resolve
two of our unknowns.
#+begin_src agda :tangle no
{- â€œContextsâ€ are exposure-indexed types -}
Context = Î» â„“ â†’ â„• â†’ Set â„“

{- Every type is a context -}
â€µ_ : âˆ€ {â„“} â†’ Set â„“ â†’ Context â„“
â€µ S = Î» _ â†’ S

{- The â€œempty contextâ€ is the unit type -}
End : âˆ€ {â„“} â†’ Context â„“
End = â€µ ğŸ™
#+end_src

#+latex: \noindent
It remains to identify the definition of the underlying bind operation ~>>=~.
Classically, for a type constructor ~m~, bind is typed ~âˆ€ {X Y : Set} â†’ m X â†’ (X â†’
m Y) â†’ m Y~. It allows one to â€œextract an ~X~-value for later useâ€ in the ~m Y~
context. Since our ~m = Context~ is from levels to types, we need to slightly
alter bind's typing.
#+begin_src agda :tangle no
_>>=_ : âˆ€ {a b}
      â†’ (Î“ : Context a)
      â†’ (âˆ€ {n} â†’ Î“ n â†’ Context b)
      â†’ Context (a âŠ b)
(Î“ >>= f) â„•.zero  = Î£ Î³ âˆ¶ Î“ 0 â€¢ f Î³ 0
(Î“ >>= f) (suc n) = (Î³ : Î“ n) â†’ f Î³ n
#+end_src
#+latex: \noindent
The definition here accounts for the current exposure index: If zero, we have
/record types/, otherwise /function types/. Using this definition, the above
dynamical system context would need to be expressed using the lifting quote operation.
#+begin_src agda :tangle no
â€µ Set >>= Î» X â†’ â€µ X >>= Î» z â†’ â€µ (X â†’ X) >>= End
{- or -}
do X â† â€µ Set
   z â† â€µ X
   s â† â€µ (X â†’ X)
   End
#+end_src
# See page 275.
#+latex: \noindent
Interestingly cite:Bird_2009,DBLP:conf/hopl/HudakHJW07, use of ~do~-notation in
preference to bind, ~>>=~, was suggested by John Launchbury in 1993 and was first
implemented by Mark Jones in Gofer.  Anyhow, with our goal of practicality in
mind, we shall â€œbuild the lifting quote into the definitionâ€ of bind:
#+begin_src agda :tangle no
_>>=_ : âˆ€ {a b}
      â†’ (Î“ : Set a)  -- Main difference
      â†’ (Î“ â†’ Context b)
      â†’ Context (a âŠ b)
(Î“ >>= f) â„•.zero  = Î£ Î³ âˆ¶ Î“ â€¢ f Î³ 0
(Î“ >>= f) (suc n) = (Î³ : Î“) â†’ f Î³ n
#+end_src
#+latex: \noindent
With this definition, the above declaration ~DynamicSystem~ typechecks.  However,
~DynamicSystem ğ’¾ â‰‡ DynamicSystemáµ¢~, instead ~DynamicSystem ğ’¾~ are â€œfactoriesâ€: Given
~ğ’¾~-many arguments, a product value is formed. What if we want to /instantiate/ some
of the factory arguments ahead of time?
#+begin_src agda :tangle no
ğ’©â‚€ : DynamicSystem 0  {- â‰ˆ Î£ X âˆ¶ Set  â€¢ Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ ğŸ™ -}
ğ’©â‚€ = â„• , 0 , suc , tt

ğ’©â‚ : DynamicSystem 1 {- â‰ˆ Î  X âˆ¶ Set  â€¢ Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ ğŸ™ -}
ğ’©â‚ = Î» X â†’ ??? {- Impossible to complete if X is empty! -}

{- â€œInstantiaingâ€ X to be â„• in â€œDynamicSystem 1â€ -}
ğ’©â‚â€² : let X = â„• in Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ ğŸ™
ğ’©â‚â€² = 0 , suc , tt
#+end_src
#+latex: \noindent
It seems what we need is method, say ~Î â†’Î»~, that takes a ~Î ~-type and transforms it
into a ~Î»~-expression.  One could use a universe, an algebraic type of codes
denoting types, to define ~Î â†’Î»~. However, one can no longer then easily use
existing types since they are not formed from the universe's constructors,
thereby resulting in duplication of existing types via the universe
encoding. This is not practical nor pragmatic.

As such, we are left with pattern matching on the language's type formation
primitives as the only reasonable approach. The method ~Î â†’Î»~ is thus a macro that
acts on the syntactic term representations of types.
Below is main transformation ---the details can be found in Appendix
[[sec:pi-to-lambda]].
#+begin_src agda :tangle no
Î â†’Î» (Î  a âˆ¶ A â€¢ Ï„) = (Î» a âˆ¶ A â€¢ Ï„)
{- One then extends this homomorphically over all possible term formers. -}
#+end_src
#+latex: \noindent
That is, we walk along the term tree replacing occurrences of ~Î ~ with ~Î»~. For example,
#+begin_src agda :tangle no
  Î â†’Î» (Î â†’Î» (DynamicSystem 2))
â‰¡{- Definition of DynamicSystem at exposure level 2 -}
  Î â†’Î» (Î â†’Î» (Î  X âˆ¶ Set â€¢ Î  s âˆ¶ X  â€¢ Î£ n âˆ¶ X â†’ X  â€¢ ğŸ™))
â‰¡{- Definition of Î â†’Î» -}
  Î â†’Î» (Î» X âˆ¶ Set â€¢ Î  s âˆ¶ X  â€¢ Î£ n âˆ¶ X â†’ X  â€¢ ğŸ™)
â‰¡{- Homomorphy of Î â†’Î» -}
  Î» X âˆ¶ Set â€¢ Î â†’Î» (Î  s âˆ¶ X  â€¢ Î£ n âˆ¶ X â†’ X  â€¢ ğŸ™)
â‰¡{- Definition of Î â†’Î» -}
â‰¡ Î» X âˆ¶ Set â€¢ Î» s âˆ¶ X  â€¢ Î£ n âˆ¶ X â†’ X  â€¢ ğŸ™
#+end_src

For practicality, ~_:waist_~ is a macro acting on contexts that repeats ~Î â†’Î»~ a number of
times in order to lift a number of field components to the parameter level.
#+begin_src agda :tangle no
Ï„ :waist n     = Î â†’Î»â¿ n (Ï„ n)

Î â†’Î»â¿ 0       Ï„ = Ï„
Î â†’Î»â¿ (n + 1) Ï„ = Î â†’Î»â¿ n (Î â†’Î» Ï„)
#+end_src
#+latex: \noindent
We can now â€œfix arguments ahead of timeâ€. Before such demonstration, we need to
be mindful of our practicality goals: One declares a grouping mechanism with
~do â€¦ End~, which in turn has its instance values constructed with ~âŸ¨ â€¦ âŸ©~.
#+begin_src agda :tangle no
-- Expressions of the form â€œâ‹¯ , ttâ€ may now be written â€œâŸ¨ â‹¯ âŸ©â€
infixr 5 âŸ¨ _âŸ©
âŸ¨âŸ© : âˆ€ {â„“} â†’ ğŸ™ {â„“}
âŸ¨âŸ© = tt

âŸ¨ : âˆ€ {â„“} {S : Set â„“} â†’ S â†’ S
âŸ¨ s = s

_âŸ© : âˆ€ {â„“} {S : Set â„“} â†’ S â†’ S Ã— (ğŸ™ {â„“})
s âŸ© = s , tt
#+end_src
#+latex: \noindent
The following instances of grouping types demonstrate how information moves from
the body level to the parameter level.
#+BEGIN_SRC agda
ğ’©â° : DynamicSystem :waist 0
ğ’©â° = âŸ¨ â„• , 0 , suc âŸ©

ğ’©Â¹ : (DynamicSystem :waist 1) â„•
ğ’©Â¹ = âŸ¨ 0 , suc âŸ©

ğ’©Â² : (DynamicSystem :waist 2) â„• 0
ğ’©Â² = âŸ¨ suc âŸ©

ğ’©Â³ : (DynamicSystem :waist 3) â„• 0 suc
ğ’©Â³ = âŸ¨âŸ©
#+END_SRC
#+latex: \noindent
Using ~:waist ğ’¾~ we may fix the first ~ğ’¾~-parameters ahead of time.  Indeed, the
type ~(DynamicSystem :waist 1) â„•~ is /the type of dynamic systems over carrier â„•/,
whereas ~(DynamicSystem :waist 2) â„• 0~ is /the type of dynamic systems over
carrier â„• and start state 0/.

Examples of the need for such on-the-fly unbundling can be found in numerous
places in the Haskell standard library. For instance, the standard libraries cite:data_monoid
have two isomorphic copies of the integers, called ~Sum~ and ~Product~, whose reason
for being is to distinguish two common monoids: The former is for /integers with
addition/ whereas the latter is for /integers with multiplication/.
An orthogonal solution would be to use contexts:
#+begin_src agda :tangle no
Monoid : âˆ€ â„“ â†’ Context (â„“suc â„“)
Monoid â„“ = do Carrier â† Set â„“
              _âŠ•_     â† (Carrier â†’ Carrier â†’ Carrier)
              Id      â† Carrier
              leftId  â† âˆ€ {x : Carrier} â†’ x âŠ• Id â‰¡ x
              rightId â† âˆ€ {x : Carrier} â†’ Id âŠ• x â‰¡ x
              assoc   â† âˆ€ {x y z} â†’ (x âŠ• y) âŠ• z  â‰¡  x âŠ• (y âŠ• z)
              End {â„“}
#+end_src
#+latex: \noindent
With this context, (~Monoid â„“â‚€ :waist 2) M âŠ•~ is the type of monoids over
/particular/ types ~M~ and /particular/ operations ~âŠ•~.  Of-course, this is orthogonal,
since traditionally unification on the carrier type ~M~ is what makes typeclasses
and canonical structures cite:coq_canonical_tutorial useful for ad-hoc
polymorphism.

# since Haskell's use-case is for canonical typeclasses, which utilise unification
# on the carrier type ~M~ to find instance implementations.

* Termtypes as Fixed-points
  <<sec:termtypes-as-fixedpoints>>

  We have a practical monadic syntax for possibly parameterised record types
  that we would like to extend to termtypes. Algebraic data types are a means to
  declare concrete representations of the least fixed-point of a functor.

  In particular, the description language ~ğ”»~ for dynamical systems,
  ref:contexts-table, declares concrete constructors for the fixpoint of ~F~:

       | ~F : Set â†’ Set~                 |
       | ~F = Î» (D âˆ¶ Set) â†’ D âŠ D~       |

  That is, ~ğ”» â‰… Fix F~ where:
  #+begin_src agda :tangle no
data Fix (F : Set â†’ Set) : Set where
  Î¼ : F (Fix F) â†’ Fix F
#+end_src
#+latex: \noindent
 The problem is whether we can derive ~F~ from ~DynamicSystem~.
 Let us attempt a quick calculation.
#+name: termtypes-guide
#+caption: Guide to termtypes
#+BEGIN_SRC agda :tangle no
  do X â† Set; z â† X; s â† (X â†’ X); End
â‡’{- Use existing interpretation to obtain a record. -}
  Î£ X : Set â€¢ Î£ z : X â€¢ Î£ s : (X â†’ X) â€¢ ğŸ™
â‡’{- Pull out the carrier, â€œ:waist 1â€, to obtain a type constructor using â€œÎ â†’Î»â€. -}
  Î» X : Set â€¢ Î£ z : X â€¢ Î£ s : (X â†’ X) â€¢ ğŸ™
â‡’{- Termtype constructors target the declared type, so only their sources matter.
   E.g., â€˜z : Xâ€™ is a nullary constructor targeting the carrier â€˜Xâ€™.
   This introduces ğŸ™ types, so any existing occurances are dropped via ğŸ˜.
 -}
  Î» X : Set â€¢ Î£ z : ğŸ™ â€¢ Î£ s : X â€¢ ğŸ˜
â‡’{- Termtypes are sums of products. -}
  Î» X : Set â€¢       ğŸ™   âŠ     X  âŠ ğŸ˜
â‡’{- Termtypes are fixpoints of type constructors. -}
  Fix (Î» X â€¢ ğŸ™ âŠ X)  -- i.e., ğ”»
 #+END_SRC
#+latex: \noindent
 Since we may view an algebraic data-type as a fixed-point of the functor
  obtained from the union of the sources of its constructors, it suffices to
  treat the fields of a record as constructors, then obtain their sources, then
  union them.  That is, since algebraic-datatype constructors necessarily target
  the declared type, they are determined by their sources.  For example,
  considered as a unary constructor ~op : A â†’ B~ targets the type termtype ~B~ and
  so its source is ~A~.  The details on the operations ~â‡Š, Î£â†’âŠ, sources~ shown below
  can be found in appendices [[sec:decreasing-de-brujin]], [[sec:sigma-to-sum]], and
  [[sec:sources]], respectively.
  # ---since we're introducing
  # unit types, any existing unit types are dropped via ~ğŸ˜~.
  #+begin_src agda :tangle no
â‡Š Ï„ = â€œreduce all de brujin indices of Ï„ by 1â€

Î£â†’âŠ (Î£ a âˆ¶ A â€¢ Ba) = A âŠ Î£â†’âŠ (â‡Š Ba)

sources (Î» x âˆ¶ (Î  a âˆ¶ A â€¢ Ba) â€¢ Ï„) = (Î» x âˆ¶ A â€¢ sources Ï„)
sources (Î» x âˆ¶ A              â€¢ Ï„) = (Î» x âˆ¶ ğŸ™ â€¢ sources Ï„)

{- Extend â€œsources, Î£â†’âŠâ€ homomorphicly to other syntactic constructs -}

termtype Ï„ = Fix (Î£â†’âŠ (sources Ï„))
             #+end_src

# The hint ~â€œReplace products with sumsâ€~ in the above calculation is realised
# formally as ~Î£â†’âŠ (sources Ï„)~.
#+latex: \noindent
It is instructive to visually see how ~ğ”»~ is obtained from ~termtype~
in order to demonstrate that this approach to algebraic data types
is practical.
#+begin_src agda :tangle no
ğ”» = termtype (DynamicSystem :waist 1)

-- Pattern synonyms for more compact presentation
pattern startD  = Î¼ (injâ‚ tt)       -- : ğ”»
pattern nextD e = Î¼ (injâ‚‚ (injâ‚ e)) -- : ğ”» â†’ ğ”»
#+end_src
#+latex: \noindent
With the ~pattern~ declarations, we can actually use these more meaningful names,
when pattern matching, instead of the seemingly daunting Î¼-~inj~-ections.
For instance, we can immediately see that the natural numbers act as
the description language for dynamical systems:
#+begin_src agda :tangle no
to : ğ”» â†’ â„•
to startD    = 0
to (nextD x) = suc (to x)

from : â„• â†’ ğ”»
from zero    = startD
from (suc n) = nextD (from n)
#+end_src

* TODO Free Datatypes from Theories
  <<sec:free-datatypes>>

Astonishingly, useful programming datatypes arise from termtypes of theories
(contexts). That is, if src_agda[:exports code]{ğ’ : Set â†’ Context â„“â‚€} then
src_agda[:exports code]{â„‚â€² = Î» X â†’ termtype (ğ’ X :waist 1)} can be used to form
â€˜free, lawless, ğ’-instancesâ€™. For instance, earlier we witnessed that
the termtype of dynamical systems is essentially the natural numbers.
#+label: theories-data-structures
#+caption: Data structures as free theories
| Theory             | Termtype     |
|--------------------+--------------|
| Dynamical Systems  | â„•            |
| Pointed Structures | Maybe        |
| Monoids            | Binary Trees |

To obtain trees over some â€˜value typeâ€™ Î, one must start at the theory of
â€œmonoids containing a given set Îâ€. Similarly, by starting at â€œtheories of
pointed sets over a given set Îâ€, the resulting termtype is the ~Maybe~
type constructor ---another instructive exercise to the reader: Show that ~â„™ â‰… Maybe~.
#+begin_src agda :tangle no
PointedOver  : Set â†’ Context (â„“suc â„“â‚€)
PointedOver Î    = do Carrier â† Set â„“â‚€
                      point   â† Carrier
                      embed   â† (Î â†’ Carrier)
                      End

â„™ : Set â†’ Set
â„™ X = termtype (PointedOver X :waist 1)

-- Pattern synonyms for more compact presentation
pattern nothingP = Î¼ (injâ‚ tt)       -- : â„™
pattern justP e  = Î¼ (injâ‚‚ (injâ‚ e)) -- : â„™ â†’ â„™
#+end_src

#+latex: \noindent
The final entry in the table is a well known correspondence, that we
can, not only formally express, but also prove to be true. We present the setup
and leave it as an instructive exercise to the reader to present a
bijective pair of functions between =ğ•„= and =TreeSkeleton=. Hint: Interactively
case-split on values of =ğ•„= until the declared patterns appear, then associate them
with the constructors of ~TreeSkeleton~.
#+begin_src agda :tangle no
ğ•„ : Set
ğ•„ = termtype (Monoid â„“â‚€ :waist 1)

-- Pattern synonyms for more compact presentation
pattern emptyM      = Î¼ (injâ‚ tt)                      -- : ğ•„
pattern branchM l r = Î¼ (injâ‚‚ (injâ‚ (l , r , tt)))     -- : ğ•„ â†’ ğ•„ â†’ ğ•„
pattern absurdM a   = Î¼ (injâ‚‚ (injâ‚‚ (injâ‚‚ (injâ‚‚ a))))  -- absurd values of ğŸ˜

data TreeSkeleton : Set where
  empty  : TreeSkeleton
  branch : TreeSkeleton â†’ TreeSkeleton â†’ TreeSkeleton
#+end_src

* Related Works
  <<sec:related-works>>

  Surprisingly, conflating parameterised and non-parameterised record types
  with termtypes /within a language in a practical fashion/ has not been done before.

  The PackageFormer cite:DBLP:conf/gpce/Al-hassyCK19,alhassy_thesis_proposal
  editor extension reads contexts ---in nearly the same notation as ours---
  enclosed in dedicated comments, then generates and imports Agda code from them
  seamlessly in the background whenever typechecking transpires. The framework
  provides a fixed number of meta-primitives for producing arbitrary notions of
  grouping mechanisms, and allows arbitrary Emacs Lisp cite:10.5555/229872 to be
  invoked in the construction of complex grouping mechanisms.

  #+caption: Comparing the in-language Context mechanism with the PackageFormer editor extension
  |                          | PackageFormer      | Contexts             |
  |--------------------------+--------------------+----------------------|
  | Type of Entity           | Preprocessing Tool | Language Library     |
  | Specification Language   | Lisp + Agda        | Agda                 |
  | Well-formedness Checking | âŒ               | âœ“                    |
  | Termination Checking     | âœ“                  | âœ“                    |
  | Elaboration Tooltips     | âœ“                  | âŒ                 |
  | Rapid Prototyping        | âœ“                  | âœ“ (Slower)           |
  | Usability Barrier        | None               | None                 |
  | Extensibility Barrier    | Lisp               | Weak Metaprogramming |

  The original PackageFormer paper provided the syntax necessary to form useful
  grouping mechanisms but was shy on the semantics of such constructs.  We have
  chosen the names of our combinators to closely match those of PackageFormer's
  with an aim of furnishing the mechanism with semantics by construing the
  syntax as semantics-functions; i.e., we have a shallow embedding of
  PackageFormer's constructs as Agda entities:

#+caption: Contexts as a semantics for PackageFormer constructs
| Syntax          | Semantics                    |
|-----------------+------------------------------|
| ~PackageFormer~   | ~Context~                      |
| ~:waist~          | ~:waist~                       |
| ~âŸ´~               | Forward function application |
| ~:kind~           | ~:kind~, see below             |
| ~:level~          | Agda built-in                |
| ~:alter-elements~ | Agda macros                  |

# Moreover, it is nearly as readable
#  and is a library method, rather than an editor extension.

PackageFormer's ~_:kind_~ meta-primitive dictates how an abstract grouping
mechanism should be viewed in terms of existing Agda syntax.  However, unlike
PackageFormer, all of our syntax consists of legitimate Agda terms.
Since language syntax is being manipulated, we are forced to define it as a macro:

#+begin_src agda :tangle no
data Kind : Set where
  â€µrecord    : Kind
  â€µtypeclass : Kind
  â€µdata      : Kind

ğ’ :kind â€µrecord    = ğ’ 0
ğ’ :kind â€µtypeclass = ğ’ :waist 1
ğ’ :kind â€µdata      = termtype (ğ’ :waist 1)
#+end_src
# +latex: \noindent
We did not expect to be able to assign a full semantics to PackageFormer's
syntactic constructs due to Agda's substantially weak metaprogramming mechanism.
However, it is important to note that PackageFormer's Lisp extensibility
expedites the process of trying out arbitrary grouping mechanisms ---such as
partial-choices of pushouts and pullbacks along user-provided assignment
functions--- since it is all either string or symbolic list manipulation. On the
Agda side, using contexts, it would require exponentially more effort due to the
limited reflection mechanism and the intrusion of the stringent type system.

:Ignore:
For PackageFormer, we have implemented its primitives ~:waist~ and ~:kind~, the
other core meta-primitives are ~_âŸ´_~ and ~:alter-elements~. The former is a
syntactic form of function application, ~x âŸ´ f â‰ˆ f x~, which we already have by
juxtaposition in Agda. The latter, however, is a â€œhammerâ€ that alters the
constituents of a grouping mechanism in an arbitrary fashion using the entire
power of Emacs Lisp ---which includes a large portion of Common Lisp.  We have
currently presented a partial semantics of PackageFormer's syntactic entities by
presenting them here as semantic functions on contexts.
:End:

* Conclusion

Starting from the insight that related grouping mechanisms could be unified, we
showed how related structures can be obtained from a single declaration using a
practical interface. The resulting framework, based on contexts, still captures
the familiar record declaration syntax as well as the expressivity of usual
algebraic datatype declarations ---at the minimal cost of using ~pattern~
declarations to aide as user-chosen constructor names.  We believe that our
approach to using contexts as general grouping mechanisms /with/ a practical
interface are interesting contributions.

We used the focus on practicality to guide the design of our context interface,
and provided interpretations both for the rather intuitive â€œcontexts are
name-type recordsâ€ view, and for the novel â€œcontexts are fixed-pointsâ€ view for
termtypes.  In addition, to obtain parameterised variants, we needed to
explicitly form â€œcontexts whose contents are over a given ambient contextâ€
---e.g., contexts of vector spaces are usually discussed with the understanding
that there is a context of fields that can be referenced--- which we did using
monads. These relationships are summarised in the following table.

#+caption: Contexts embody all kinds of grouping mechanisms
| Concept            | Concrete Syntax                       | Description            |
|--------------------+---------------------------------------+------------------------|
| Context            | =do S â† Set; s â† S; n â† (S â†’ S); End=   | â€œname-type pairsâ€      |
|--------------------+---------------------------------------+------------------------|
| Record Type        | =Î£ S âˆ¶ Set â€¢ Î£ s âˆ¶ S â€¢ Î£ n âˆ¶ S â†’ S â€¢ ğŸ™= | â€œbundled-up dataâ€      |
| Function Type      | =Î  S â€¢ Î£ s âˆ¶ S â€¢ Î£ n âˆ¶ S â†’ S â€¢ ğŸ™=       | â€œa type of functionsâ€  |
| Type constructor   | =Î» S â€¢ Î£ s âˆ¶ S â€¢ Î£ n âˆ¶ S â†’ S â€¢ ğŸ™=       | â€œa function on typesâ€  |
| Algebraic datatype | ~data ğ”» : Set where s : ğ”»; n : ğ”» â†’ ğ”»~   | â€œa descriptive syntaxâ€ |

To those interested in exotic ways to group data together ---such as,
mechanically deriving product types and homomorphism types of theories---
we offer an interface that is extensible using Agda's reflection mechanism.
In comparison with, for example, special-purpose preprocessing tools, this
has obvious advantages in accessibility and semantics.

To Agda programmers, this offers a standard interface for grouping mechanisms
that had been sorely missing, with an interface that is so familiar that there
would be little barrier to its use. In particular, as we have shown, it acts as
an in-language library for exploring relationships between free theories and
data structures.  As we have only presented the high-level definitions of the
core combinators, leaving the Agda-specific details to the appendices, it is
also straightforward to translate the library into other dependently-typed
languages.

* appendix marker :ignore:
\appendix

:Musa:
The appendix marker must occur before the section on appendices.
:End:

* Appendices
#+latex_header: \usepackage[toc,page]{appendix}

Below is the entirety of the Context library discussed in the paper proper.

#+begin_src agda :tangle Context.agda
module Context where
#+end_src

** Imports
#+begin_src agda :tangle Context.agda
open import Level renaming (_âŠ”_ to _âŠ_; suc to â„“suc; zero to â„“â‚€)
open import Relation.Binary.PropositionalEquality
open import Relation.Nullary

open import Data.Nat
open import Data.Fin  as Fin using (Fin)
open import Data.Maybe  hiding (_>>=_)

open import Data.Bool using (Bool ; true ; false)
open import Data.List as List using (List ; [] ; _âˆ·_ ; _âˆ·Ê³_; sum)

â„“â‚   = Level.suc â„“â‚€
#+end_src

** Quantifiers Î âˆ¶â€¢/Î£âˆ¶â€¢ and Products/Sums

  We shall using Z-style quantifier notation cite:10.5555/235337 in which the
  quantifier dummy variables are separated from the body by a large bullet.

  In Agda, we use ~\:~ to obtain the â€œghost colonâ€ since standard colon ~:~ is an
  Agda operator.

#+begin_src agda :tangle Context.agda
open import Data.Empty using (âŠ¥)
open import Data.Sum
open import Data.Product
open import Function using (_âˆ˜_)

Î£âˆ¶â€¢ : âˆ€ {a b} (A : Set a) (B : A â†’ Set b) â†’ Set _
Î£âˆ¶â€¢ = Î£

infix -666 Î£âˆ¶â€¢
syntax Î£âˆ¶â€¢ A (Î» x â†’ B) = Î£ x âˆ¶ A â€¢ B

Î âˆ¶â€¢ : âˆ€ {a b} (A : Set a) (B : A â†’ Set b) â†’ Set _
Î âˆ¶â€¢ A B = (x : A) â†’ B x

infix -666 Î âˆ¶â€¢
syntax Î âˆ¶â€¢ A (Î» x â†’ B) = Î  x âˆ¶ A â€¢ B

record âŠ¤ {â„“} : Set â„“ where
  constructor tt

ğŸ™ = âŠ¤ {â„“â‚€}
ğŸ˜ = âŠ¥
#+end_src

** Reflection

We form a few metaprogramming utilities we would have expected to be in the
standard library.

#+begin_src agda :tangle Context.agda
import Data.Unit as Unit
open import Reflection hiding (name; Type) renaming (_>>=_ to _>>=â‚˜_)
#+end_src

*** Single argument application
#+begin_src agda :tangle Context.agda
_app_ : Term â†’ Term â†’ Term
(def f args) app argâ€² = def f (args âˆ·Ê³ arg (arg-info visible relevant) argâ€²)
(con f args) app argâ€² = con f (args âˆ·Ê³ arg (arg-info visible relevant) argâ€²)
{-# CATCHALL #-}
tm app argâ€² = tm
#+end_src

#+latex: \noindent
Notice that we maintain existing applications:
| ~quoteTerm (f x) app quoteTerm y~ | â‰ˆ | ~quoteTerm (f x y)~ |

*** Reify â„• term encodings as â„• values
#+begin_src agda :tangle Context.agda
toâ„• : Term â†’ â„•
toâ„• (lit (nat n)) = n
{-# CATCHALL #-}
toâ„• _ = 0
#+end_src
*** The Length of a Term
#+begin_src agda :tangle Context.agda
arg-term : âˆ€ {â„“} {A : Set â„“} â†’ (Term â†’ A) â†’ Arg Term â†’ A
arg-term f (arg i x) = f x

{-# TERMINATING #-}
lengthâ‚œ : Term â†’ â„•
lengthâ‚œ (var x args)      = 1 + sum (List.map (arg-term lengthâ‚œ ) args)
lengthâ‚œ (con c args)      = 1 + sum (List.map (arg-term lengthâ‚œ ) args)
lengthâ‚œ (def f args)      = 1 + sum (List.map (arg-term lengthâ‚œ ) args)
lengthâ‚œ (lam v (abs s x)) = 1 + lengthâ‚œ x
lengthâ‚œ (pat-lam cs args) = 1 + sum (List.map (arg-term lengthâ‚œ ) args)
lengthâ‚œ (Î [ x âˆ¶ A ] Bx)   = 1 + lengthâ‚œ Bx
{-# CATCHALL #-}
-- sort, lit, meta, unknown
lengthâ‚œ t = 0
#+end_src
#+latex: \noindent
Here is an example use:
#+begin_src agda :tangle Context.agda
_ : lengthâ‚œ (quoteTerm (Î£ x âˆ¶ â„• â€¢ x â‰¡ x)) â‰¡ 10
_ = refl
#+end_src

*** Decreasing de Brujin Indices
<<sec:decreasing-de-brujin>>
Given a quantification ~(âŠ• x âˆ¶ Ï„ â€¢ fx)~, its body ~fx~ may refer to a free variable
~x~.  If we decrement all de Brujin indices ~fx~ contains, then there would be no
reference to ~x~.

#+begin_src agda :tangle Context.agda
var-decâ‚€ : (fuel : â„•) â†’ Term â†’ Term
var-decâ‚€ zero t  = t
-- Let's use an â€œimpossibleâ€ term.
var-decâ‚€ (suc n) (var zero args)      = def (quote âŠ¥) []
var-decâ‚€ (suc n) (var (suc x) args)   = var x args
var-decâ‚€ (suc n) (con c args)         = con c (map-Args (var-decâ‚€ n) args)
var-decâ‚€ (suc n) (def f args)         = def f (map-Args (var-decâ‚€ n) args)
var-decâ‚€ (suc n) (lam v (abs s x))    = lam v (abs s (var-decâ‚€ n x))
var-decâ‚€ (suc n) (pat-lam cs args)    = pat-lam cs (map-Args (var-decâ‚€ n) args)
var-decâ‚€ (suc n) (Î [ s âˆ¶ arg i A ] B) = Î [ s âˆ¶ arg i (var-decâ‚€ n A) ] var-decâ‚€ n B
{-# CATCHALL #-}
-- sort, lit, meta, unknown
var-decâ‚€ n t = t
#+end_src
#+latex: \noindent
In the paper proper, ~var-dec~ was mentioned once under the name ~â‡Š~.
#+begin_src agda :tangle Context.agda
var-dec : Term â†’ Term
var-dec t = var-decâ‚€ (lengthâ‚œ t) t
#+end_src
#+latex: \noindent
Notice that we made the decision that ~x~, the body of ~(âŠ• x â€¢ x)~, will reduce to ~ğŸ˜~,
the empty type. Indeed, in such a situation the only Debrujin index cannot be
reduced further. Here is an example:
#+begin_src agda :tangle Context.agda
_ : âˆ€ {x : â„•} â†’ var-dec (quoteTerm x) â‰¡ quoteTerm âŠ¥
_ = refl
#+end_src

** Context Monad
#+begin_src agda :tangle Context.agda
Context = Î» â„“ â†’ â„• â†’ Set â„“

infix -1000 â€µ_
â€µ_ : âˆ€ {â„“} â†’ Set â„“ â†’ Context â„“
â€µ S = Î» _ â†’ S

End : âˆ€ {â„“} â†’ Context â„“
End = â€µ âŠ¤

Endâ‚€ = End {â„“â‚€}

_>>=_ : âˆ€ {a b}
      â†’ (Î“ : Set a)  -- Main diference
      â†’ (Î“ â†’ Context b)
      â†’ Context (a âŠ b)
(Î“ >>= f) â„•.zero  = Î£ Î³ âˆ¶ Î“ â€¢ f Î³ 0
(Î“ >>= f) (suc n) = (Î³ : Î“) â†’ f Î³ n
#+end_src

** âŸ¨âŸ© Notation

As mentioned, grouping mechanisms are declared with ~do â€¦ End~, and instances of
them are constructed using ~âŸ¨ â€¦ âŸ©~.
#+begin_src agda :tangle Context.agda
-- Expressions of the form â€œâ‹¯ , ttâ€ may now be written â€œâŸ¨ â‹¯ âŸ©â€
infixr 5 âŸ¨ _âŸ©
âŸ¨âŸ© : âˆ€ {â„“} â†’ âŠ¤ {â„“}
âŸ¨âŸ© = tt

âŸ¨ : âˆ€ {â„“} {S : Set â„“} â†’ S â†’ S
âŸ¨ s = s

_âŸ© : âˆ€ {â„“} {S : Set â„“} â†’ S â†’ S Ã— âŠ¤ {â„“}
s âŸ© = s , tt
#+end_src

** DynamicSystem Context
#+begin_src agda :tangle Context.agda
DynamicSystem : Context (â„“suc Level.zero)
DynamicSystem = do X â† Set
                   z â† X
                   s â† (X â†’ X)
                   End {Level.zero}

-- Records with ğ“ƒ-Parameters, ğ“ƒ : 0..3
A B C D : Setâ‚
A = DynamicSystem 0 -- Î£ X âˆ¶ Set  â€¢ Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ X â†’ X  â€¢ âŠ¤
B = DynamicSystem 1 --  (X âˆ¶ Set) â†’ Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ X â†’ X  â€¢ âŠ¤
C = DynamicSystem 2 --  (X âˆ¶ Set)    (z âˆ¶ X) â†’ Î£ s âˆ¶ X â†’ X  â€¢ âŠ¤
D = DynamicSystem 3 --  (X âˆ¶ Set)    (z âˆ¶ X) â†’  (s âˆ¶ X â†’ X) â†’ âŠ¤

_ : A â‰¡ (Î£ X âˆ¶ Set  â€¢ Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ âŠ¤) ; _ = refl
_ : B â‰¡ (Î  X âˆ¶ Set  â€¢ Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ âŠ¤) ; _ = refl
_ : C â‰¡ (Î  X âˆ¶ Set  â€¢ Î  z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ âŠ¤) ; _ = refl
_ : D â‰¡ (Î  X âˆ¶ Set  â€¢ Î  z âˆ¶ X  â€¢ Î  s âˆ¶ (X â†’ X)  â€¢ âŠ¤) ; _ = refl

stability : âˆ€ {n} â†’   DynamicSystem (3 + n)
                   â‰¡ DynamicSystem  3
stability = refl

B-is-empty : Â¬ B
B-is-empty b = projâ‚( b âŠ¥)

ğ’©â‚€ : DynamicSystem 0
ğ’©â‚€ = â„• , 0 , suc , tt

ğ’© : DynamicSystem 0
ğ’© = âŸ¨ â„• , 0 , suc âŸ©

B-on-â„• : Set
B-on-â„• = let X = â„• in Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ âŠ¤

ex : B-on-â„•
ex = âŸ¨ 0 , suc âŸ©
#+end_src

** Î â†’Î»
   <<sec:pi-to-lambda>>
#+begin_src agda :tangle Context.agda
Î â†’Î»-helper : Term â†’ Term
Î â†’Î»-helper (pi  a b)         = lam visible b
Î â†’Î»-helper (lam a (abs x y)) = lam a (abs x (Î â†’Î»-helper y))
{-# CATCHALL #-}
Î â†’Î»-helper x = x

macro
  Î â†’Î» : Term â†’ Term â†’ TC Unit.âŠ¤
  Î â†’Î» tm goal = normalise tm >>=â‚˜ Î» tmâ€² â†’ unify (Î â†’Î»-helper tmâ€²) goal
#+end_src

** COMMENT ~idáµ¢â‚Šâ‚ â‰ˆ Î â†’Î» idáµ¢~
#+begin_src agda :tangle Context.agda
_ : Î â†’Î» idÏ„ â‰¡ idâ‚
_ = refl
#+end_src
** ~_:waist_~
#+begin_src agda :tangle Context.agda
waist-helper : â„• â†’ Term â†’ Term
waist-helper zero t    = t
waist-helper (suc n) t = waist-helper n (Î â†’Î»-helper t)

macro
  _:waist_ : Term â†’ Term â†’ Term â†’ TC Unit.âŠ¤
  _:waist_ t ğ“ƒ goal =      normalise (t app ğ“ƒ)
                      >>=â‚˜ Î» tâ€² â†’ unify (waist-helper (toâ„• ğ“ƒ) tâ€²) goal
#+end_src

** DynamicSystem :waist ğ’¾
#+begin_src agda :tangle Context.agda
Aâ€² : Setâ‚
Bâ€² : âˆ€ (X : Set) â†’ Set
Câ€² : âˆ€ (X : Set) (x : X) â†’ Set
Dâ€² : âˆ€ (X : Set) (x : X) (s : X â†’ X) â†’ Set

Aâ€² = DynamicSystem :waist 0
Bâ€² = DynamicSystem :waist 1
Câ€² = DynamicSystem :waist 2
Dâ€² = DynamicSystem :waist 3

ğ’©â° : Aâ€²
ğ’©â° = âŸ¨ â„• , 0 , suc âŸ©

ğ’©Â¹ : Bâ€² â„•
ğ’©Â¹ = âŸ¨ 0 , suc âŸ©

ğ’©Â² : Câ€² â„• 0
ğ’©Â² = âŸ¨ suc âŸ©

ğ’©Â³ : Dâ€² â„• 0 suc
ğ’©Â³ = âŸ¨âŸ©
#+end_src
#+latex: \noindent
It may be the case that ~Î“ 0 â‰¡ Î“ :waist 0~ for every context Î“.
#+begin_src agda :tangle Context.agda
_ : DynamicSystem 0 â‰¡ DynamicSystem :waist 0
_ = refl
#+end_src

** COMMENT Collection Context
#+begin_src agda :tangle Context.agda
Collection : âˆ€ â„“ â†’ Context (â„“suc â„“)
Collection â„“ = do
  Elem    â† Set â„“
  Carrier â† Set â„“
  insert  â† (Elem â†’ Carrier â†’ Carrier)
  âˆ…       â† Carrier
  isEmpty â† (Carrier â†’ Bool)
  insert-nonEmpty â† âˆ€ {e : Elem} {x : Carrier} â†’ isEmpty (insert e x) â‰¡ false
  End {â„“}

ListColl : {â„“ : Level} â†’ Collection â„“ 1
ListColl E = âŸ¨ List E
             , _âˆ·_
             , []
             , (Î» { [] â†’ true; _ â†’ false})
             , (Î» {x} {x = xâ‚} â†’ refl)
             âŸ©

â„•Collection = (Collection â„“â‚€ :waist 2)
                ("Elem"    â‰” Digit)
                ("Carrier" â‰” â„•)
--
-- i.e., (Collection â„“â‚€ :waist 2) Digit â„•

stack : â„•Collection
stack = âŸ¨ "insert"      â‰” (Î» d s â†’ suc (10 * s + #â†’â„• d))
        , "empty stack" â‰” 0
        , "is-empty"    â‰” (Î» { 0 â†’ true; _ â†’ false})
        -- Properties --
        , (Î» {d : Digit} {s : â„•} â†’ refl {x = false})
        âŸ©
#+end_src

** Field projections
#+begin_src agda :tangle Context.agda
Fieldâ‚€ : â„• â†’ Term â†’ Term
Fieldâ‚€ zero c    = def (quote projâ‚) (arg (arg-info visible relevant) c âˆ· [])
Fieldâ‚€ (suc n) c = Fieldâ‚€ n (def (quote projâ‚‚) (arg (arg-info visible relevant) c âˆ· []))

macro
  Field : â„• â†’ Term â†’ Term â†’ TC Unit.âŠ¤
  Field n t goal = unify goal (Fieldâ‚€ n t)
#+end_src

** COMMENT Elem, Carrier, insert projections
#+begin_src agda :tangle Context.agda
Elem      : âˆ€ {â„“} â†’ Collection â„“ 0 â†’ Set â„“
Elem      = Î» C   â†’ Field 0 C

Carrier   : âˆ€ {â„“} â†’ Collection â„“ 0 â†’ Set â„“
Carrierâ‚  : âˆ€ {â„“} â†’ Collection â„“ 1 â†’ (Î³ : Set â„“) â†’ Set â„“
Carrierâ‚â€² : âˆ€ {â„“} {Î³ : Set â„“} (C : (Collection â„“ :waist 1) Î³) â†’ Set â„“

Carrier   = Î» C   â†’ Field 1 C
Carrierâ‚  = Î» C Î³ â†’ Field 0 (C Î³)
Carrierâ‚â€² = Î» C   â†’ Field 0 C

insert   : âˆ€ {â„“} (C : Collection â„“ 0) â†’ (Elem C â†’ Carrier C â†’ Carrier C)
insertâ‚  : âˆ€ {â„“} (C : Collection â„“ 1) (Î³ : Set â„“) â†’  Î³ â†’ Carrierâ‚ C Î³ â†’ Carrierâ‚ C Î³
insertâ‚â€² : âˆ€ {â„“} {Î³ : Set â„“} (C : (Collection â„“ :waist 1) Î³) â†’ Î³ â†’ Carrierâ‚â€² C â†’ Carrierâ‚â€² C

insert    = Î» C   â†’ Field 2 C
insertâ‚   = Î» C Î³ â†’ Field 1 (C Î³)
insertâ‚â€²  = Î» C   â†’ Field 1 C

insertâ‚‚  : âˆ€ {â„“} (C : Collection â„“ 2) (El Cr : Set â„“) â†’ El â†’ Cr â†’ Cr
insertâ‚‚â€² : âˆ€ {â„“} {El Cr : Set â„“} (C : (Collection â„“ :waist 2) El Cr) â†’ El â†’ Cr â†’ Cr

insertâ‚‚ = Î» C El Cr â†’ Field 0 (C El Cr)
insertâ‚‚â€² = Î» C â†’ Field 0 C
#+end_src

** Termtypes

Using the guide, ref:termtypes-guide, outlined in the paper proper
we shall form ~Dáµ¢~ for each stage in the calculation.
*** Stage 1: Records
#+begin_src agda :tangle Context.agda
Dâ‚ = DynamicSystem 0

1-records : Dâ‚ â‰¡ (Î£ X âˆ¶ Set â€¢ Î£ z âˆ¶ X â€¢ Î£ s âˆ¶ (X â†’ X) â€¢ âŠ¤)
1-records = refl
#+end_src
*** Stage 2: Parameterised Records
#+begin_src agda :tangle Context.agda
Dâ‚‚ = DynamicSystem :waist 1

2-funcs : Dâ‚‚ â‰¡ (Î» (X : Set) â†’ Î£ z âˆ¶ X â€¢ Î£ s âˆ¶ (X â†’ X) â€¢ âŠ¤)
2-funcs = refl
#+end_src

*** Stage 3: Sources
<<sec:sources>>
Let's begin with an example to motivate the definition of ~sources~.
    #+begin_src agda :tangle Context.agda
_ :   quoteTerm (âˆ€ {x : â„•} â†’ â„•)
    â‰¡ pi (arg (arg-info hidden relevant) (quoteTerm â„•)) (abs "x" (quoteTerm â„•))
_ = refl
#+end_src
#+latex: \noindent
We now form two sources-helper utilities, although we suspect they could be
combined into one function.
#+begin_src agda :tangle Context.agda
sourcesâ‚€ : Term â†’ Term
-- Otherwise:
sourcesâ‚€ (Î [ a âˆ¶ arg i A ] (Î [ b âˆ¶ arg _ Ba ] Cab)) =
    def (quote _Ã—_) (vArg A
                    âˆ· vArg (def (quote _Ã—_)
                                (vArg (var-dec Ba) âˆ· vArg (var-dec (var-dec (sourcesâ‚€ Cab))) âˆ· []))
                    âˆ· [])
sourcesâ‚€ (Î [ a âˆ¶ arg (arg-info hidden _) A ] Ba) = quoteTerm ğŸ˜
sourcesâ‚€ (Î [ x âˆ¶ arg i A ] Bx) = A
{-# CATCHALL #-}
-- sort, lit, meta, unknown
sourcesâ‚€ t = quoteTerm ğŸ™

{-# TERMINATING #-}
sourcesâ‚ : Term â†’ Term
sourcesâ‚ (Î [ a âˆ¶ arg (arg-info hidden _) A ] Ba) = quoteTerm ğŸ˜
sourcesâ‚ (Î [ a âˆ¶ arg i A ] (Î [ b âˆ¶ arg _ Ba ] Cab)) = def (quote _Ã—_) (vArg A âˆ·
  vArg (def (quote _Ã—_) (vArg (var-dec Ba) âˆ· vArg (var-dec (var-dec (sourcesâ‚€ Cab))) âˆ· [])) âˆ· [])
sourcesâ‚ (Î [ x âˆ¶ arg i A ] Bx) = A
sourcesâ‚ (def (quote Î£) (â„“â‚ âˆ· â„“â‚‚ âˆ· Ï„ âˆ· body))
    = def (quote Î£) (â„“â‚ âˆ· â„“â‚‚ âˆ· map-Arg sourcesâ‚€ Ï„ âˆ· List.map (map-Arg sourcesâ‚) body)
-- This function introduces ğŸ™s, so let's drop any old occurances a la ğŸ˜.
sourcesâ‚ (def (quote âŠ¤) _) = def (quote ğŸ˜) []
sourcesâ‚ (lam v (abs s x))     = lam v (abs s (sourcesâ‚ x))
sourcesâ‚ (var x args) = var x (List.map (map-Arg sourcesâ‚) args)
sourcesâ‚ (con c args) = con c (List.map (map-Arg sourcesâ‚) args)
sourcesâ‚ (def f args) = def f (List.map (map-Arg sourcesâ‚) args)
sourcesâ‚ (pat-lam cs args) = pat-lam cs (List.map (map-Arg sourcesâ‚) args)
{-# CATCHALL #-}
-- sort, lit, meta, unknown
sourcesâ‚ t = t
#+end_src
#+latex: \noindent
We now form the macro and some unit tests.
#+begin_src agda :tangle Context.agda
macro
  sources : Term â†’ Term â†’ TC Unit.âŠ¤
  sources tm goal = normalise tm >>=â‚˜ Î» tmâ€² â†’ unify (sourcesâ‚ tmâ€²) goal

_ : sources (â„• â†’ Set) â‰¡ â„•
_ = refl

_ : sources (Î£ x âˆ¶ (â„• â†’ Fin 3) â€¢ â„•) â‰¡ (Î£ x âˆ¶ â„• â€¢ â„•)
_ = refl

_ : âˆ€ {â„“ : Level} {A B C : Set}
  â†’ sources (Î£ x âˆ¶ (A â†’ B) â€¢ C) â‰¡ (Î£ x âˆ¶ A â€¢ C)
_ = refl

_ : sources (Fin 1 â†’ Fin 2 â†’ Fin 3) â‰¡ (Î£ _ âˆ¶ Fin 1 â€¢ Fin 2 Ã— ğŸ™)
_ = refl

_ : sources (Î£ f âˆ¶ (Fin 1 â†’ Fin 2 â†’ Fin 3 â†’ Fin 4) â€¢ Fin 5)
  â‰¡ (Î£ f âˆ¶ (Fin 1 Ã— Fin 2 Ã— Fin 3) â€¢ Fin 5)
_ = refl

_ : âˆ€ {A B C : Set} â†’ sources (A â†’ B â†’ C) â‰¡ (A Ã— B Ã— ğŸ™)
_ = refl

_ : âˆ€ {A B C D E : Set} â†’ sources (A â†’ B â†’ C â†’ D â†’ E)
                        â‰¡ Î£ A (Î» _ â†’ Î£ B (Î» _ â†’ Î£ C (Î» _ â†’ Î£ D (Î» _ â†’ âŠ¤))))
_ = refl
#+end_src
#+latex: \noindent
Design decision: Types starting with implicit arguments are /invariants/, not /constructors/.
#+begin_src agda :tangle Context.agda
-- one implicit
_ : sources (âˆ€ {x : â„•} â†’ x â‰¡ x) â‰¡ ğŸ˜
_ = refl

-- multiple implicits
_ : sources (âˆ€ {x y z : â„•} â†’ x â‰¡ y) â‰¡ ğŸ˜
_ = refl
#+end_src
#+latex: \noindent
The third stage can now be formed.
#+begin_src agda :tangle Context.agda
Dâ‚ƒ = sources Dâ‚‚

3-sources : Dâ‚ƒ â‰¡ Î» (X : Set) â†’ Î£ z âˆ¶ ğŸ™ â€¢ Î£ s âˆ¶ X â€¢ ğŸ˜
3-sources = refl
#+end_src
*** Stage 4: ~Î£â†’âŠ~ --Replacing Products with Sums
    <<sec:sigma-to-sum>>
#+begin_src agda :tangle Context.agda
{-# TERMINATING #-}
Î£â†’âŠâ‚€ : Term â†’ Term
Î£â†’âŠâ‚€ (def (quote Î£) (ğ’½â‚ âˆ· ğ’½â‚€ âˆ· arg i A âˆ· arg iâ‚ (lam v (abs s x)) âˆ· []))
  =  def (quote _âŠ_) (ğ’½â‚ âˆ· ğ’½â‚€ âˆ· arg i A âˆ· vArg (Î£â†’âŠâ‚€ (var-dec x)) âˆ· [])
-- Interpret â€œEndâ€ in do-notation to be an empty, impossible, constructor.
Î£â†’âŠâ‚€ (def (quote âŠ¤) _) = def (quote âŠ¥) []
 -- Walk under Î»'s and Î 's.
Î£â†’âŠâ‚€ (lam v (abs s x)) = lam v (abs s (Î£â†’âŠâ‚€ x))
Î£â†’âŠâ‚€ (Î [ x âˆ¶ A ] Bx) = Î [ x âˆ¶ A ] Î£â†’âŠâ‚€ Bx
{-# CATCHALL #-}
Î£â†’âŠâ‚€ t = t

macro
  Î£â†’âŠ : Term â†’ Term â†’ TC Unit.âŠ¤
  Î£â†’âŠ tm goal = normalise tm >>=â‚˜ Î» tmâ€² â†’ unify (Î£â†’âŠâ‚€ tmâ€²) goal

-- Unit tests
_ : Î£â†’âŠ (Î  X âˆ¶ Set â€¢ (X â†’ X))     â‰¡ (Î  X âˆ¶ Set â€¢ (X â†’ X)); _ = refl
_ : Î£â†’âŠ (Î  X âˆ¶ Set â€¢ Î£ s âˆ¶ X â€¢ X) â‰¡ (Î  X âˆ¶ Set â€¢ X âŠ X)  ; _ = refl
_ : Î£â†’âŠ (Î  X âˆ¶ Set â€¢ Î£ s âˆ¶ (X â†’ X) â€¢ X) â‰¡ (Î  X âˆ¶ Set â€¢ (X â†’ X) âŠ X)  ; _ = refl
_ : Î£â†’âŠ (Î  X âˆ¶ Set â€¢ Î£ z âˆ¶ X â€¢ Î£ s âˆ¶ (X â†’ X) â€¢ âŠ¤ {â„“â‚€}) â‰¡ (Î  X âˆ¶ Set â€¢ X âŠ (X â†’ X) âŠ âŠ¥)  ; _ = refl

Dâ‚„ = Î£â†’âŠ Dâ‚ƒ

4-unions : Dâ‚„ â‰¡ Î» X â†’ ğŸ™ âŠ X âŠ ğŸ˜
4-unions = refl
#+end_src
*** Stage 5: Fixpoint and proof that ~ğ”» â‰… â„•~
#+begin_src agda :tangle Context.agda
{-# NO_POSITIVITY_CHECK #-}
data Fix {â„“} (F : Set â„“ â†’ Set â„“) : Set â„“ where
  Î¼ : F (Fix F) â†’ Fix F

ğ”» = Fix Dâ‚„

-- Pattern synonyms for more compact presentation
pattern zeroD  = Î¼ (injâ‚ tt)       -- : ğ”»
pattern sucD e = Î¼ (injâ‚‚ (injâ‚ e)) -- : ğ”» â†’ ğ”»

to : ğ”» â†’ â„•
to zeroD    = 0
to (sucD x) = suc (to x)

from : â„• â†’ ğ”»
from zero    = zeroD
from (suc n) = sucD (from n)

toâˆ˜from : âˆ€ n â†’ to (from n) â‰¡ n
toâˆ˜from zero    = refl
toâˆ˜from (suc n) = cong suc (toâˆ˜from n)

fromâˆ˜to : âˆ€ d â†’ from (to d) â‰¡ d
fromâˆ˜to zeroD    = refl
fromâˆ˜to (sucD x) = cong sucD (fromâˆ˜to x)
#+end_src

*** ~termtype~ and ~Inj~ macros

We summarise the stages together into one macro:
~â€œtermtype : UnaryFunctor â†’ Typeâ€~.
#+begin_src agda :tangle Context.agda
macro
  termtype : Term â†’ Term â†’ TC Unit.âŠ¤
  termtype tm goal =
                normalise tm
           >>=â‚˜ Î» tmâ€² â†’ unify goal (def (quote Fix) ((vArg (Î£â†’âŠâ‚€ (sourcesâ‚ tmâ€²))) âˆ· []))
 #+end_src
#+latex: \noindent
It is interesting to note that in place of ~pattern~ clauses, say for languages
that do not support them, we would resort to â€œfancy injectionsâ€.
#+begin_src agda :tangle Context.agda
Injâ‚€ : â„• â†’ Term â†’ Term
Injâ‚€ zero c    = con (quote injâ‚) (arg (arg-info visible relevant) c âˆ· [])
Injâ‚€ (suc n) c = con (quote injâ‚‚) (vArg (Injâ‚€ n c) âˆ· [])

-- Duality!
-- ğ’¾-th projection: projâ‚ âˆ˜ (projâ‚‚ âˆ˜ â‹¯ âˆ˜ projâ‚‚)
-- ğ’¾-th injection:  (injâ‚‚ âˆ˜ â‹¯ âˆ˜ injâ‚‚) âˆ˜ injâ‚

macro
  Inj : â„• â†’ Term â†’ Term â†’ TC Unit.âŠ¤
  Inj n t goal = unify goal ((con (quote Î¼) []) app (Injâ‚€ n t))
#+end_src
#+latex: \noindent
With this alternative, we regain the â€œuser chosen constructor namesâ€ for ~ğ”»~:
#+begin_src agda :tangle Context.agda
startD : ğ”»
startD = Inj 0 (tt {â„“â‚€})

nextDâ€² : ğ”» â†’ ğ”»
nextDâ€² d = Inj 1 d
 #+end_src

** Monoids
*** Context
#+begin_src agda :tangle Context.agda
Monoid : âˆ€ â„“ â†’ Context (â„“suc â„“)
Monoid â„“ = do Carrier â† Set â„“
              Id      â† Carrier
              _âŠ•_     â† (Carrier â†’ Carrier â†’ Carrier)
              leftId  â† âˆ€ {x : Carrier} â†’ x âŠ• Id â‰¡ x
              rightId â† âˆ€ {x : Carrier} â†’ Id âŠ• x â‰¡ x
              assoc   â† âˆ€ {x y z} â†’ (x âŠ• y) âŠ• z  â‰¡  x âŠ• (y âŠ• z)
              End {â„“}
#+end_src
*** Termtypes
#+begin_src agda :tangle Context.agda
ğ•„ : Set
ğ•„ = termtype (Monoid â„“â‚€ :waist 1)
{- ie Fix (Î» X â†’ ğŸ™         -- Id, nil leaf
               âŠ X Ã— X Ã— ğŸ™ -- _âŠ•_, branch
               âŠ ğŸ˜         -- src of leftId
               âŠ ğŸ˜         -- src of rightId
               âŠ X Ã— X Ã— ğŸ˜ -- src of assoc
               âŠ ğŸ˜)        -- the â€œEnd {â„“}â€
-}

-- Pattern synonyms for more compact presentation
pattern emptyM      = Î¼ (injâ‚ tt)                      -- : ğ•„
pattern branchM l r = Î¼ (injâ‚‚ (injâ‚ (l , r , tt)))     -- : ğ•„ â†’ ğ•„ â†’ ğ•„
pattern absurdM a   = Î¼ (injâ‚‚ (injâ‚‚ (injâ‚‚ (injâ‚‚ a))))  -- absurd values of ğŸ˜

data TreeSkeleton : Set where
  empty  : TreeSkeleton
  branch : TreeSkeleton â†’ TreeSkeleton â†’ TreeSkeleton
#+end_src
*** ~ğ•„ â‰… TreeSkeleton~
#+begin_src agda :tangle Context.agda
ğ•„â†’Tree : ğ•„ â†’ TreeSkeleton
ğ•„â†’Tree emptyM = empty
ğ•„â†’Tree (branchM l r) = branch (ğ•„â†’Tree l) (ğ•„â†’Tree r)
ğ•„â†’Tree (absurdM (injâ‚ ()))
ğ•„â†’Tree (absurdM (injâ‚‚ ()))

ğ•„â†Tree : TreeSkeleton â†’ ğ•„
ğ•„â†Tree empty = emptyM
ğ•„â†Tree (branch l r) = branchM (ğ•„â†Tree l) (ğ•„â†Tree r)

ğ•„â†Treeâˆ˜ğ•„â†’Tree : âˆ€ m â†’ ğ•„â†Tree (ğ•„â†’Tree m) â‰¡ m
ğ•„â†Treeâˆ˜ğ•„â†’Tree emptyM = refl
ğ•„â†Treeâˆ˜ğ•„â†’Tree (branchM l r) = congâ‚‚ branchM (ğ•„â†Treeâˆ˜ğ•„â†’Tree l) (ğ•„â†Treeâˆ˜ğ•„â†’Tree r)
ğ•„â†Treeâˆ˜ğ•„â†’Tree (absurdM (injâ‚ ()))
ğ•„â†Treeâˆ˜ğ•„â†’Tree (absurdM (injâ‚‚ ()))

ğ•„â†’Treeâˆ˜ğ•„â†Tree : âˆ€ t â†’ ğ•„â†’Tree (ğ•„â†Tree t) â‰¡ t
ğ•„â†’Treeâˆ˜ğ•„â†Tree empty = refl
ğ•„â†’Treeâˆ˜ğ•„â†Tree (branch l r) = congâ‚‚ branch (ğ•„â†’Treeâˆ˜ğ•„â†Tree l) (ğ•„â†’Treeâˆ˜ğ•„â†Tree r)
#+end_src

** ~:kind~
#+begin_src agda :tangle Context.agda
data Kind : Set where
  â€µrecord    : Kind
  â€µtypeclass : Kind
  â€µdata      : Kind

macro
  _:kind_ : Term â†’ Term â†’ Term â†’ TC Unit.âŠ¤
  _:kind_ t (con (quote â€µrecord) _)    goal = normalise (t app (quoteTerm 0))
                      >>=â‚˜ Î» tâ€² â†’ unify (waist-helper 0 tâ€²) goal
  _:kind_ t (con (quote â€µtypeclass) _) goal = normalise (t app (quoteTerm 1))
                      >>=â‚˜ Î» tâ€² â†’ unify (waist-helper 1 tâ€²) goal
  _:kind_ t (con (quote â€µdata) _) goal = normalise (t app (quoteTerm 1))
                      >>=â‚˜ Î» tâ€² â†’ normalise (waist-helper 1 tâ€²)
                      >>=â‚˜ Î» tâ€³ â†’ unify goal (def (quote Fix) ((vArg (Î£â†’âŠâ‚€ (sourcesâ‚ tâ€³))) âˆ· []))
  _:kind_ t _ goal = unify t goal
#+end_src
#+latex: \noindent
Informally, ~_:kind_~ behaves as follows:
#+begin_src agda :tangle Context.agda
ğ’ :kind â€µrecord    = ğ’ :waist 0
ğ’ :kind â€µtypeclass = ğ’ :waist 1
ğ’ :kind â€µdata      = termtype (ğ’ :waist 1)
#+end_src

** ~termtype PointedSet â‰… ğŸ™~
   #+begin_src agda :tangle Context.agda
-- termtype (PointedSet) â‰… âŠ¤ !
One  : Context (â„“suc â„“â‚€)
One      = do Carrier â† Set â„“â‚€
              point  â† Carrier
              End {â„“â‚€}

ğ•†ğ•Ÿğ•– : Set
ğ•†ğ•Ÿğ•– = termtype (One :waist 1)

viewâ‚ : ğ•†ğ•Ÿğ•– â†’ ğŸ™
viewâ‚ emptyM = tt
#+end_src
** The Termtype of Graphs is Edge Pairs
From simple graphs (relations) to a syntax about them:
One describes a simple graph by presenting edges as pairs of vertices!
#+begin_src agda :tangle Context.agda
PointedOverâ‚‚  : Set â†’ Context (â„“suc â„“â‚€)
PointedOverâ‚‚ Î    = do Carrier â† Set â„“â‚€
                       relation â† (Î â†’ Î â†’ Carrier)
                       End {â„“â‚€}

â„™â‚‚ : Set â†’ Set
â„™â‚‚ X = termtype (PointedOverâ‚‚ X :waist 1)

pattern _â‡Œ_ x y = Î¼ (injâ‚ (x , y , tt))

viewâ‚‚ : âˆ€ {X} â†’ â„™â‚‚ X â†’ X Ã— X
viewâ‚‚ (x â‡Œ y) = x , y
#+end_src

** COMMENT Other experiments
#+begin_src agda :tangle Context.agda
-- No â€˜constantsâ€™, whence a type of inifinitely branching terms.
PointedOverâ‚ƒ  : Set â†’ Context (â„“â‚€)
PointedOverâ‚ƒ Î    = do relation â† (Î â†’ Î â†’ Î)
                       End {â„“â‚€}

â„™â‚ƒ : Set
â„™â‚ƒ = termtype (Î» X â†’ PointedOverâ‚ƒ X 0)

-- caseâ‚ƒ : â„™â‚ƒ â†’ Setâ‚
-- caseâ‚ƒ (px â‡Œ py) = {!!}

--------------------------------------------------------------------------------

PointedOverâ‚„  : Context (â„“suc â„“â‚€)
PointedOverâ‚„       = do Î â† Set
                        Carrier â† Set â„“â‚€
                        relation â† (Î â†’ Î â†’ Carrier)
                        End {â„“â‚€}

-- The current implementation of â€œtermtypeâ€ only allows for one â€œSetâ€ in the body.
-- So we lift both out; thereby regaining â„™â‚‚!

â„™â‚„ : Set â†’ Set
â„™â‚„ X = termtype ((PointedOverâ‚„ :waist 2) X)

pattern _â‡Œ_ x y = Î¼ (injâ‚ (x , y , tt))

caseâ‚„ : âˆ€ {X} â†’ â„™â‚„ X â†’ Setâ‚
caseâ‚„ (x â‡Œ y) = Set

-- Claim: Mention in paper.
--
--    Pâ‚ : Set â†’ Context = Î» Î â†’ do â‹¯ End
-- â‰…  Pâ‚‚ :waist 1
-- where Pâ‚‚ : Context = do Î â† Set; â‹¯ End

--------------------------------------------------------------------------------

{- Yellow:

PointedOverâ‚…  : Context (â„“suc â„“â‚€)
PointedOverâ‚…   = do One â† Set
                    Two â† Set
                    Three â† (One â†’ Two â†’ Set)
                    End {â„“â‚€}

â„™â‚… : Set â†’ Setâ‚
â„™â‚… X = termtype ((PointedOverâ‚… :waist 2) X)
-- Fix (Î» Two â†’ One Ã— Two)

pattern _âˆ·â‚…_ x y = Î¼ (injâ‚ (x , y , tt))

caseâ‚… : âˆ€ {X} â†’ â„™â‚… X â†’ Setâ‚
caseâ‚… (x âˆ·â‚… xs) = Set

-}

--------------------------------------------------------------------------------

{-- Dependent sums

PointedOverâ‚†  : Context â„“â‚
PointedOverâ‚† = do Sort â† Set
                  Carrier â† (Sort â†’ Set)
                  End {â„“â‚€}

â„™â‚† : Setâ‚
â„™â‚† = termtype ((PointedOverâ‚† :waist 1) )
-- Fix (Î» X â†’ X)

-}

--------------------------------------------------------------------------------

-- Distinuighed subset algebra

open import Data.Bool renaming (Bool to ğ”¹)

{-
PointedOverâ‚‡  : Context (â„“suc â„“â‚€)
PointedOverâ‚‡       = do Index â† Set
                        Is    â† (Index â†’ ğ”¹)
                        End {â„“â‚€}

-- The current implementation of â€œtermtypeâ€ only allows for one â€œSetâ€ in the body.
-- So we lift both out; thereby regaining â„™â‚‚!

â„™â‚‡ : Set â†’ Set
â„™â‚‡ X = termtype (Î» (_ : Set) â†’ (PointedOverâ‚‡ :waist 1) X)
-- â„™â‚ X â‰… X

pattern _â‡Œ_ x y = Î¼ (injâ‚ (x , y , tt))

caseâ‚‡ : âˆ€ {X} â†’ â„™â‚‡ X â†’ Set
caseâ‚‡ {X} (Î¼ (injâ‚ x)) = X

-}

--------------------------------------------------------------------------------

-- indexed unary algebras; i.e., â€œactionsâ€

PointedOverâ‚ˆ  : Context (â„“suc â„“â‚€)
PointedOverâ‚ˆ       = do Index     â† Set
                        Carrier   â† Set
                        Operation â† (Index â†’ Carrier â†’ Carrier)
                        End {â„“â‚€}

â„™â‚ˆ : Set â†’ Set
â„™â‚ˆ X = termtype ((PointedOverâ‚ˆ :waist 2) X)

pattern _Â·_ x y = Î¼ (injâ‚ (x , y , tt))

caseâ‚ˆ : âˆ€ {I} â†’ â„™â‚ˆ I â†’ Setâ‚
caseâ‚ˆ (i Â· e) = Set

-- This is just â„™â‚„ again lol!

--------------------------------------------------------------------------------

{-
PointedOverâ‚‰  : Context â„“â‚
PointedOverâ‚‰       = do Carrier â† Set
                        End {â„“â‚€}

-- The current implementation of â€œtermtypeâ€ only allows for one â€œSetâ€ in the body.
-- So we lift both out; thereby regaining â„™â‚‚!

â„™â‚‰ : Set
â„™â‚‰ = termtype (Î» (X : Set) â†’ (PointedOverâ‚‰ :waist 1) X)
-- â‰… ğŸ˜ â‰… Fix (Î» X â†’ ğŸ˜)
-}

--------------------------------------------------------------------------------

PointedOverâ‚â‚€  : Context â„“â‚
PointedOverâ‚â‚€       = do Carrier â† Set
                         next    â† (Carrier â†’ Carrier)
                         End {â„“â‚€}

-- The current implementation of â€œtermtypeâ€ only allows for one â€œSetâ€ in the body.
-- So we lift both out; thereby regaining â„™â‚‚!

â„™â‚â‚€ : Set
â„™â‚â‚€ = termtype (Î» (X : Set) â†’ (PointedOverâ‚â‚€ :waist 1) X)
-- Fix (Î» X â†’ X), which does not exist.

#+end_src

* COMMENT APPENDIX: What about the meta-language's parameters? :Maybe_Delete:

Besides ~:waist~, another way to introduce parameters into a context grouping
mechanism is to use the language's existing utility of parameterising a context
by another type ---as was done earlier in ~PointedOver~.

For example, a pointed set needn't necessarily be termined with ~End~.
#+begin_src agda
PointedSet : Context â„“â‚
PointedSet = do Carrier â† Set
                point   â† Carrier
                End {â„“â‚}
#+end_src
We instead form a grouping consisting of a single type and a value of that type,
along with an instance of the parameter type =Î=.
#+begin_src agda
PointedPF : (Î : Setâ‚) â†’ Context â„“â‚
PointedPF Î = do Carrier â† Set
                 point   â† Carrier
                 â€µ Î
#+end_src
Clearly ~PointedPF ğŸ™ â‰ˆ PointedSet~, so we have a more generic grouping mechanism.
The natural next step is to consider other parameters such as ~PointedSet~
in-place of =Î=.
:AgdaCheckedEvidence:
#+begin_src agda
_ : âˆ€ {n} â†’ PointedPF ğŸ™ n â‰¡ PointedSet n
_ = refl
#+end_src
:End:
#+begin_src agda
-- Convenience names
PointedSetáµ£ = PointedSet        :kind â€µrecord
PointedPFáµ£  = Î» Î â†’ PointedPF Î :kind â€µrecord

-- An extended record type: Two types with a point of each.
TwoPointedSets = PointedPFáµ£ PointedSetáµ£

_ :   TwoPointedSets
    â‰¡ ( Î£ Carrierâ‚ âˆ¶ Set â€¢ Î£ pointâ‚ âˆ¶ Carrierâ‚
      â€¢ Î£ Carrierâ‚‚ âˆ¶ Set â€¢ Î£ pointâ‚‚ âˆ¶ Carrierâ‚‚ â€¢ ğŸ™)
_ = refl

-- Here's an instance
one : PointedSet :kind â€µrecord
one = ğ”¹ , false , tt

-- Another; a pointed natural extended by a pointed bool,
-- with particular choices for both.
two : TwoPointedSets
two = â„• , 0 , one
#+end_src
More generally, /record *structure* can be dependent on values:/
#+begin_src agda
_PointedSets : â„• â†’ Setâ‚
zero  PointedSets = ğŸ™
suc n PointedSets = PointedPFáµ£ (n PointedSets)

_ :   4 PointedSets
    â‰¡ (Î£ Carrierâ‚ âˆ¶ Set â€¢ Î£ pointâ‚ âˆ¶ Carrierâ‚
      â€¢ Î£ Carrierâ‚‚ âˆ¶ Set â€¢ Î£ pointâ‚‚ âˆ¶ Carrierâ‚‚
      â€¢ Î£ Carrierâ‚ƒ âˆ¶ Set â€¢ Î£ pointâ‚ƒ âˆ¶ Carrierâ‚ƒ
      â€¢ Î£ Carrierâ‚„ âˆ¶ Set â€¢ Î£ pointâ‚„ âˆ¶ Carrierâ‚„ â€¢ ğŸ™)
_ = refl
#+end_src
Using traditional grouping mechanisms, it is difficult to create the family of
types =n PointedSets= since the number of fields, $2 Ã— n$, depends on $n$.

It is interesting to note that the termtype of ~PointedPF~ is the same as the
termtype of ~PointedOver~, the ~Maybe~ type constructor!
#+begin_src agda :tangle no
PointedD : (X : Set) â†’ Setâ‚
PointedD X = termtype (PointedPF (Lift _ X) :waist 1)

-- Pattern synonyms for more compact presentation
pattern nothingP = Î¼ (injâ‚ tt)
pattern justP x  = Î¼ (injâ‚‚ (lift x))

casingP : âˆ€ {X} (e : PointedD X)
        â†’ (e â‰¡ nothingP) âŠ (Î£ x âˆ¶ X â€¢ e â‰¡ justP x)
casingP nothingP  = injâ‚ refl
casingP (justP x) = injâ‚‚ (x , refl)
#+end_src

* COMMENT Other misc ideas
** Why syntax
   The archetype for records and termtypes ---algebraic data types--- are
   monoids. They describe untyped compositional structures, such as programs in
   dynamically type-checked language. In turn, their termtype is linked lists
   which reify a monoid value ---such as a program--- as a sequence of values
   ---i.e., a list of language instructions--- which â€˜evaluateâ€™ to the original
   value. The shift to syntax gives rise to evaluators, optimisers, and  constrained
   recursion-induction principles.

** Introduction

 In dependently-typed programming languages, such as Agda
 cite:Norell-2007,agda_overview, there is a tendency to define concepts
 repeatedly along syntactic constructs provided by the language.  In particular,
 one bundles up related data into a record structure, then considers the need to
 expose some of the fields as parameters and so provides a parameterised record
 construction, then for the need to have a description language for terms of
 these record types, one forms an associated algebraic datatype.  For example, we
 may form a type ~Monoidâ‚€~ of monoids, which consists of a type along with an
 operation and some laws, but may want ~Monoidâ‚ M âŠ•~ to speak of monoids over
 /particular/ types ~M~ and particular operations ~âŠ•~ ---the latter is handled, say in
 the Haskell standard library, by having isomorphic copies of types for each
 binary operation, such as ~Sum â‰… Prod â‰… Int~ for the classical additive and
 multiplicative monoidal structures on integers.  This is the problem we are
 solving: /How can parameterised records and their associated algebraic datatypes
 be obtained from a core declaration?/

 The humblest notion of a grouping mechanism is described by a pair type ~A Ã— B Ã—
 C~, usually later values depend on earlier values and so we have the
 dependent-pair type src_agda[:exports code]{Î£ a âˆ¶ A â€¢ Î£ b âˆ¶ B a â€¢ Î£ C a b}. The kind of these types is
 ~Setâ‚~, the type of small types. If we wish to speak of groupings where ~a âˆ¶ A~ is
 /fixed/, then we must lift it from being a /field/ component to being a /parameter/,
 thereby arriving at the /function/ ~Î» a âˆ¶ A â€¢ Î£ b âˆ¶ B a â€¢ Î£ C a b~ which has /type/ ~Î  a âˆ¶
 A â€¢ Set~. Similarly, we may expose ~b~ as a parameter to further indicate the
 possible grouping structure.

 | Grouping Description          |   | Kind                      |
 |-------------------------------+---+---------------------------|
 | =Î£ a âˆ¶ A â€¢ Î£ b âˆ¶ B a â€¢ Î£ C a b= |   | ~Set~                       |
 | =Î» a âˆ¶ A â€¢ Î£ b âˆ¶ B a â€¢ Î£ C a b= |   | ~Î  a âˆ¶ A â€¢ Set~             |
 | =Î» a âˆ¶ A â€¢ Î» b âˆ¶ B a â€¢ Î£ C a b= |   | ~Î  a âˆ¶ A â€¢ Î  b âˆ¶ B a â€¢ Set~ |

 At each step, we â€œpull outâ€ more information at the kind level; at first we have
 a ~Set~, an opaque grouping mechanism, then we obtain a ~Î  a âˆ¶ A â€¢ Set~ which is a
 grouping mechanism that somehow makes use of an ~A~-value.

 1. *Type constructor reification Î â†’Î»:* Function /types/ like ~Î  a âˆ¶ A â€¢ Set~ cannot be
    applied since they are not functions, so how do we get to ~Î» a : A â€¢ Set~?

    + Î»-terms are values of Î -types, but in general there is no natural
      construction to transform a type into one of its values.

    + Given ~Ï„ = Î  (X : Set) â€¢ â‹¯ : Setâ‚~, we want ~Î â†’Î» Ï„ = Î» (X : Set) â€¢ â‹¯ : Î  (X :
      Set) â€¢ Set~; the former's type states it to be a =Setâ‚=, a grouping mechanism of
      which we know nothing, whereas the latter's type indicates it to be a
      parameterised grouping mechanism. Since ~Î â†’Î» Ï„~ can be applied and is thus more
      concrete, we call ~Î â†’Î»~ a reification combinator.

 2. *Unbundling* cite:packaging_mathematical_structures:
    How do we go from ~Set~ to ~Î  a âˆ¶ A â€¢ Set~?

    A function from function-types to functions-on-types necessarily requires a
    way to pattern match on the possible type constructions in a language.

    Perhaps an example will clarify the issue. The ubiquitous graph structure
    is contravariant in its collection of vertices. Recall that a multi-graph, or
    quiver, is a collection of vertices along with a collection of edges between
    any two vertices; here's the traditional record form:
    #+begin_src agda
Graph  : Context â„“â‚
Graph  = do Vertex â† Set
            Edges  â† (Vertex â†’ Vertex â†’ Set)
            End {â„“â‚€}
 #+end_src

    Using the record form, it is akward to phrase contravariance, which simply
    â€œrelabels the verticesâ€. Even worse, the awkward phrasing only serves to
    ensure certain constraints hold ---which are reified at the value level via
    the uninsightful ~refl~-exivity proof.
    #+begin_src agda
comapâ‚€ : âˆ€ {A B : Set}
      â†’ (f : A â†’ B)
      â†’ Î£ G âˆ¶ Graph :kind â€µrecord â€¢ Field 0 G â‰¡ B
      â†’ Î£ G âˆ¶ Graph :kind â€µrecord â€¢ Field 0 G â‰¡ A
comapâ‚€ {A} {B} f (âŸ¨ .B , edgs âŸ© , refl) = (A , (Î» aâ‚ aâ‚‚ â†’ edgs (f aâ‚) (f aâ‚‚)) , tt) , refl
        #+end_src
    /Without redefining graphs/, we can phrase the definition at the typeclass
    level ---i.e., records parameterised by the vertices. This form is not only
    clearer and easier to implement at the value-level, it also makes it clear
    that we are â€œpulling backâ€ the vertex type and so have also shown graphs are
    closed under reducts.
        #+begin_src agda
-- Way better and less awkward!
comap : âˆ€ {A B : Set}
     â†’ (f : A â†’ B)
     â†’ (Graph :kind â€µtypeclass) B
     â†’ (Graph :kind â€µtypeclass) A
comap f âŸ¨ edgs âŸ©â‚ = âŸ¨ (Î» aâ‚ aâ‚‚ â†’ edgs (f aâ‚) (f aâ‚‚)) âŸ©â‚
    #+end_src

    Later we show how to form ~Context~, its do-notation, and the ~:kind~ mechanism
    which shifts between records, typeclasses, and algebraic datatypes.

    It is important to note that we are using the word â€˜typeclassâ€™ as an
    abbreviation for â€œparameterised recordâ€. In particular, we have no support
    for the traditional unification algorithm that makes typeclasses and
    canonical structures cite:coq_canonical_tutorial useful for ad-hoc
    polymorphism.
 # eval  : A Ã— (A â†’ B) â†’ B
 # curry : (A Ã— B â†’ C) â†’ (A â†’ (B â†’ C))
 # #
 # Î  a âˆ¶ A â€¢ (Î  f âˆ¶ (Î  x âˆ¶ A â€¢ B x)) â€¢ B a
 # Î  f âˆ¶ (Î  p âˆ¶ (Î  x âˆ¶ A â€¢ B x) â€¢ C p) â€¢ Î  a âˆ¶ A â€¢ Î  b âˆ¶ B a â€¢ C (a, b)
 # Î  f âˆ¶ Set â€¢ (Î  x âˆ¶ A â€¢ Set)

 We shall outline how this can be achieved in dependently-typed languages which
 have support for reflection. Our target language will be Agda, but the ideas
 easily transfer to other languages. In particular, the resulting in-language
 syntax we obtain is rather close to the existing Agda record syntax for
 declarations and Agda constructor tuples for instances.  In the next section, we
 begin by way of a more concrete example of a grouping mechanism, then we take a
 goal-driven approach to building the necessarily apparatus for a clean
 imperative-like declaration notation, then we conclude with a brief discussion
 on how the resulting framework can act as a simple theory for the Agda
 PackageFormer editor extension cite:DBLP:conf/gpce/Al-hassyCK19 ---which solves
 the =Monoidáµ¢= problem mentioned earlier.

 In order to be language-agnostic and underscore the ideas, we shall present the
 core definitions along with Agda-checked examples. Details can be read at the
 following URL in a literate and reproducible fashion
 cite:DBLP:conf/europar/StanisicL14.
 # Details are left to an
 # appendix(?) or can be read below (MA: Haven't decided yet):
 | =https://github.com/alhassy/next-700-module-systems/tree/master/prototype= |

** OLD From Do-notation to (Parameterised) Record Types
   CLOSED: [2020-03-02 Mon 12:43]

 Traditionally a context is a list of name-type pairs, for us it will be a set
 ---namely the product of the types, since the names â€œdo not matterâ€.  Moreover,
 contexts will be have a numeric â€˜waistâ€™ argument that indicates which of the
 first entries are â€˜parametersâ€™, leaving the remaining elements as â€˜fieldsâ€™.
 The subtlety of what is a â€˜parameterâ€™ ---exposed at the type level--- and what is a
 â€˜fieldâ€™ ---a component value--- has led to awkward formulations and
 the duplication of existing types for the sole purpose of different uses.
 We shall aim toward a monadic cite:DBLP:journals/iandc/Moggi91 interface
 to declare such grouping mechanisms.

 Let's see this in action, and for variety let's encode monoids.


 Notice that the elaborations are function types, but we want functions /on/ types
 ---as is the case with the ~DynamicSystemáµ¢~ from the introduction.

** Unbundling: From Function Types to Functions /on/ Types

 Evaluation transforms functions to values and currying reorganises functions,
 but we want a combinator, call it ~Î â†’Î»~, that takes a type and results in a value
 of that type.  In general, this is not feasible when the type is empty nor is it
 naturally canonical when there are multiple possible values to choose from.

 Let's see this in action. Here are our dynamical systems.
 #+begin_src agda :tangle no
DynamicSystem : Context (â„“suc Level.zero)
DynamicSystem = do X â† Set
                   s â† X
                   n â† (X â†’ X)
                   End {Level.zero}
 #+end_src

 Each type exposes more and more information about what kind of grouping
 structure we have at hand. The definitions could not be simpler.
 #+begin_src agda :tangle no
Aâ€² : Setâ‚
Bâ€² : Î  X âˆ¶ Set â€¢ Set
Câ€² : Î  X âˆ¶ Set â€¢ Î  x âˆ¶ X â€¢ Set
Dâ€² : Î  X âˆ¶ Set â€¢ Î  x âˆ¶ X â€¢ Î  s âˆ¶ (X â†’ X) â€¢ Set

Aâ€² = DynamicSystem :waist 0
Bâ€² = DynamicSystem :waist 1
Câ€² = DynamicSystem :waist 2
Dâ€² = DynamicSystem :waist 3
 #+end_src

 If the language allows mixfix unicode identifiers, then one declares
 grouping mechanisms  with ~do â‹¯ End~ then forms instances using, say, ~âŸ¨â‹¯âŸ©~.
 #+begin_src agda :tangle no
-- Helpful syntactic sugar
âŸ¨ : âˆ€ {â„“} {S : Set â„“} â†’ S â†’ S
âŸ¨ s = s

_âŸ© : âˆ€ {â„“} {S : Set â„“} â†’ S â†’ S Ã— ğŸ™ {â„“}
s âŸ© = s , tt

âŸ¨âŸ© : âˆ€ {â„“} â†’ ğŸ™ {â„“}
âŸ¨âŸ© = tt
 #+end_src
 The following /instances/ of these grouping types demonstrate how /information moves from the body level to the parameter level./
 #+begin_src agda :tangle no
ğ’©â° : Aâ€²
ğ’©â° = âŸ¨ â„• , 0 , suc âŸ©

ğ’©Â¹ : Bâ€² â„•
ğ’©Â¹ = âŸ¨ 0 , suc âŸ©

ğ’©Â² : Câ€² â„• 0
ğ’©Â² = âŸ¨ suc âŸ©

ğ’©Â³ : Dâ€² â„• 0 suc
ğ’©Â³ = âŸ¨âŸ©
 #+end_src

 It is interesting to note, that if a context =ğ’= has only ğ“ƒ-many fields, then
 there are only ğ“ƒ-many interesting unbundled forms, after which there are no new
 ones: ~ğ’ (ğ“ƒ + k) â‰¡ ğ’ ğ“ƒ~.

 With ~:waist~ we can fix parameters ahead of time.  For example, above the type =Bâ€²
 â„•= is the type of â€œdynamic systems over carrier â„•â€ whereas =Câ€² â„• 0= is the type of
 â€œdynamic systems over carrier â„• and start state 0â€.  Without the unbundling
 mechanism we would have had to resort to awkward trivial constraints, as below,
 which are tolerable for one-off uses but clearly do not scale at all as
 indicated by the need to use equals-for-equals ~subst~-itutions of propositional
 equalities.
 #+begin_src agda
Câ€³ : Î  X âˆ¶ Set â€¢ Î  x âˆ¶ X â€¢ Setâ‚
Câ€³ X x = Î£ ğ’Ÿ âˆ¶ DynamicSystem 0
       â€¢ Î£ Carrier-is-X âˆ¶ projâ‚ ğ’Ÿ â‰¡ X
       â€¢ projâ‚ (projâ‚‚ ğ’Ÿ) â‰¡ subst id (sym Carrier-is-X) x

ğ’©Â²eek : Câ€³ â„• 0
ğ’©Â²eek = (â„• , 0 , suc , tt) , refl , refl
 #+end_src

 Traditionally cite:coq_cat_experiences, unbundling a record requires the use of
 transport along propositional equalities, with trivial ~refl~-exivity proofs.  The
 ~:waist~ approach presented here removes the boilerplate necessary at the type
 specialisation location as well as at the instance declaration location.

** =termtype=: Algebraic Datatypes are Fixpoints of Derived Functors
 With a bit of reflection, records and typeclasses have been coerced into a
 unified notation. It remains to bring algebraic datatypes into the fold.
** DSTerms

** Old Ideas
*** COMMENT Introduction [0/4]                               :boring:unclear:

    + [ ] Show example of a PackageFormer.
          - Demonstrate how: PackageFormer  â‰ˆ  named context + header.
    + [ ] Show example of how it can be used to give a record.
    + [ ] Show how it can be used to give us a homomorphism definition.
    + [ ] What are the pre- and post-conditions of the homomorphism construction?
          - This is what we are trying to solve.

*** COMMENT A Grammar for PackageFormer [0/5]              :rather:promising:

    + [ ] Grammar for PackageFormer heading.
    + [ ] Grammar for element datatype.
    + [ ] Grammar for â€œtypesâ€.
      - We clearly cannot use any Agda/MLTT types.
    + [ ] Define a fold for PackageFormer ---the homepage currently calls this ~graph-map~ due to
          the graph theoretic nature of element dependencies.
    + [ ] Prove that this fold preserves well-formedness & well-typedness of PackageFormers.
      - This is the semantics function!
      - *PackageFormers are an M-Set and fold is an M-Set homomorphism!*

        Call this M-Set â€œğ‘·ğ‘­â€.
        1. Two sorts: ~PackageFormer~ and ~Element~.
        2. Action: ~_â—_ : PackageFormer â†’ Element â†’ PackageFormer~
        3. Monoid on ~PackageFormer~
           - Unit: The empty PackageFormer
           - Bop: Union of contexts
             + If they agree on their intersection, then union of element lists;
               otherwise â€˜crashâ€™ by yielding ANN.
             + ANN is the annihilating PackageFormer: It is a postulated value
               that acts as the zero of union.
             - This ensures that a crash propagates and so a union of PF's
                 is ANN if any two items conflict.
             - E.g., â€œcrash : PackageFormerâŠ¥ â†’ PackageFormerâŠ¥ â†’ Booleanâ€
                 is defined with â€œcrash âŠ¥ x â‰ˆ trueâ€ and symmetrically so.
             - Taking ANN = âŠ¥, as a bottom element; e.g., ~nothing~.
             + Proof outline of associativity:
             - Case 1: No crashes, then ordinary list catenation, which is associative.
             - Case 2: Some two items conflict, then ANN is propagated and both sides equal ANN.

**** Deriving Fold

     1. Define a â€œRight M-Setâ€ ( close, but not really ):
        #+BEGIN_SRC agda
PackageFormer M-Set : Setâ‚ where
   Carrierâ‚     : Set
   Carrierâ‚‚     : Set
   _â—_          : Carrierâ‚ â†’ Carrierâ‚‚ â†’ Carrierâ‚
   âˆ…            : Carrierâ‚
   _âˆª_          : Carrierâ‚ â†’ Carrierâ‚ â†’ Carrierâ‚
   leftId       : {ğ“‹ : Carrierâ‚‚}  â†’  âˆ… â— ğ“‹  â‰¡  ğ“‹
   assoc        : {a b : Carrierâ‚} {ğ“‹ : Carrierâ‚‚} â†’ (a âˆª b) â— ğ“‹  â‰¡  a âˆª (b â— ğ“‹)
  #+END_SRC

     2. Let â„³ denote an M-Set.

     3. For ~fold : ğ‘·ğ‘­ âŸ¶ â„³~ to be an M-Set homomorphism, we are *forced* to have â€¦

     4. Two maps, ~foldáµ¢ : ğ‘·ğ‘­.Carrieráµ¢ â†’ â„³.Carrieráµ¢~
     5. ~foldâ‚~ is a monoid homomorphism
        1. Unitâ‚: ~foldâ‚ âˆ… â‰ˆ âˆ…~
        2. Assocâ‚: ~foldâ‚ (p âˆª q) â‰ˆ foldâ‚ p âˆª foldâ‚ q~
     6. Equivariance:
        ~foldâ‚ (p â— e) â‰ˆ foldâ‚ p â— foldâ‚‚ e~

        \newpage

     7. Since a PackageFormer, by extensionality, can always be expressed
        as a finite sequence of extensions we find:
         #+BEGIN_SRC agda
  foldâ‚ p
= {- Extensionality, with eáµ¢ elements of p -}
  foldâ‚ (âˆ… â— eâ‚ â— eâ‚‚ â— â‹¯ â— eâ‚™)
= {- Equivariance (6) -}
  foldâ‚ âˆ… â— foldâ‚‚ eâ‚ â— â‹¯ â— foldâ‚‚ eâ‚™
= {- Unit (5.1) -}
  âˆ… â— foldâ‚‚ eâ‚ â— â‹¯ â— foldâ‚‚ eâ‚™
= {- M-Set.leftId -}
  foldâ‚‚ eâ‚ â— â‹¯ â— foldâ‚‚ eâ‚™
  #+END_SRC

     8. Whence it seems ~foldâ‚~ is defined uniquely in terms of ~foldâ‚‚~ ---which is unsurprising:
        *PackageFormers are an inductive type!*

     9. TODO: Realise this argument _within_ Agda!

*** COMMENT An Application to Universal Algebra               :super_sketchy:
    + [ ] Grammar for the minimal language necessary to form homomorphism contexts.
      - How? What? Huh!?
      - I'm not sure I know what I'm thinking here.
      - I'm trying to â€œknowâ€ what the ~hom~ variational, from the webpage does!
    + [ ] Define a function: ~ğ‘¯ : PFSyntax â†’ List HomoSyntax~.
    + [ ] Show a coherence such as ~ğ‘¯(T â— e) = ğ‘¯ T â— ğ‘¯ e~
          where â— denotes context extension; i.e., append.
      - This would ensure that we have a â€˜modularâ€™ way to define homomorphisms.

    Applications to structures that CS people are interested in?
    - Monoids    â‡ for-loops
    - Graphs     â‡ databases
    - Lattices   â‡ optimisation

      \vfill

*** COMMENT Conclusion & Next Steps                                 :sketchy:

    + Initial semantics is enough?
    + Limitations?
    + Dependent-type?
    + A counterexample not covered by the semantics?
    + Soundness?

*** space COMMENT newpage                                            :ignore:
    \newpage
*** OLD COMMENT Idea: Making Staging Accessible by Generating Partial Evaluators (Short Paper)
**** Abstract                                                        :ignore:
   # Do not use footnotes and references in the abstract!

   #+begin_abstract


     Interpreters are generally written with a syntax first then an interpretation second.
     The relationship between the two is sometimes made explicit by having the
     interpretation function target an existing record type ---e.g., syntactic
     datatype constructors are mapped to semantic projections of record values.
     However, this process only needs the record definition ---all else is needless
     duplication.

     Using ~PackageFormer~, a recent Emacs editor extension to the dependently typed language
     Agda, we demonstrate how partially-static data may be mechanically derived from
     theory presentations. Moreover, we also show how to mechanically obtain
     the necessary tools to work with staged interpreters; namely, automatically deriving
     evaluation functions and notions of ground terms.
   #+end_abstract

    \maketitle
**** Relevant Links
     + [[http://www.cs.tsukuba.ac.jp/~kam/papers/pepm2018.pdf][Program Generation for ML Modules]] --- Kameyama et al.
     + [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.438.6924&rep=rep1&type=pdf][A Gentle Introduction to Multi-stage Programming]] -- Walid Taha
     + [[https://www.cl.cam.ac.uk/~jdy22/papers/partially-static-data-as-free-extension-of-algebras.pdf][Partially-Static Data as Free Extension of Algebras]] -- Yallop et al.
     + [[http://okmij.org/ftp/meta-programming/StagingNG.pdf][Staging Beyond Terms: Prospects and Challenges]] --- Oleg et al.

**** Introduction: The Difficulties of Staging

   + Easy to get things wrong!

**** Automatically Introducing Dynamic Forms

   + A view that adds on variables and forms partial evaluators

   #+BEGIN_SRC agda
data BindingTime : Set where Static Dynamic : BindingTime

{- Aliases -}
Now   = Static
Later = Dynamic
           #+END_SRC

   Then:
   #+BEGIN_SRC agda
{- Given -}
record Magma : Setâ‚ where
  field
    Carrier : Set
    _âŠ•_     : Carrier â†’ Carrier â†’ Carrier

powerâ‚€ : {{â„³ : Magma }} (let M = Magma.Carrier â„³)
      â†’ M â†’ â„• â†’ M
powerâ‚€ x zero    = x
powerâ‚€ x (suc n) = x âŠ• powerâ‚€ x n

instance
  ğ’© : Magma
  ğ’© = record {Carrier = â„•; _âŠ•_ = _Ã—_}

{- Obtain -}

---------------------------------------------------------------------------------------

{- Tree = Magma termtype with injection â€œLeafâ€ -}
data Tree (A : Set) â†’ Set where
   Leaf   : A â†’ Tree A
   Branch : Tree A â†’ Tree A â†’ Tree A

{- Proof obligation -}
instance
   tree-is-magma : âˆ€ {A} â†’ Magma
   tree-is-magma {A} = record {Carrier = Tree A; _âŠ•_ = Branch}

{- Evaluator; terms reduce completely. -}
eval : (â„³ : Magma) â†’ let M = Magma.Carrier â„³
                      in  Tree M â†’ M
eval (Leaf m) = m
eval (Branch l r) = eval l âŠ• evla r

{- An instance of powerâ‚€ -}
powerâ‚ : {A : Set} â†’ Tree A â†’ â„• â†’ Tree A
powerâ‚ x zero    = x
powerâ‚ x (suc n) = Branch x (powerâ‚ x n)

----------------------------------------------------------------------------------------
{- Terms with variables -}
data TreeV (A B : Set) â†’ Set where
   Value    : A â†’ TreeV A B
   Variable : B â†’ TreeV A B
   Branch   : TreeV A B â†’ TreeV A B â†’ TreeV A B

{- Reduction for â€œTreeV String ğ’©â€ may be blocked by variables -}
evalV : (â„³ : Magma) {V : Set} â†’
          let M = Magma.Carrier â„³
          in (V â†’ M) â†’ TreeV M V â†’ M
evalV Ïƒ (Value m)    = m
evalV Ïƒ (Variable v) = Ïƒ v
evalV Ïƒ (Branch l r) = evalV Ïƒ l âŠ• evalV Ïƒ r

{- *NOT* an instance of powerâ‚€; but a generalisation thereof! -}
power : {{â„³ : Magma }} (let M = Magma.Carrier â„³)
      â†’ TreeV M V â†’ â„• â†’ TreeV M V
power x zero    = x
power x (suc n) = x âŠ• power x n
   #+END_SRC

**** Multistaging via PackageFormers

     + How writing different PackageFormers allows us to merely select to what degree we want
       staging to occur; e.g., stageáµ¢.
**** Conclusion and Next Steps

     + Theory?
     + Applications?
     + Pedagogy?

** OLD Abstract                                                      :ignore:
   CLOSED: [2020-03-02 Mon 16:00]

   #+begin_abstract org
   Folklore has held that any â€˜semantic unitâ€™ is essentially a type-theoretic
   context ---this includes, for example, records and algebraic datatypes.  We
   provide foundation for such an observation.

   We show that languages with a sufficiently powerful type system and reflection
   mechanism permit a /single declaration interface/ for functions, records, type
   classes, type constructors, and algebraic data types. Moreover, the interface
   is monadic and thus actually practical to use.

   Along the way, we solve the bundling problem: Record fields can be lifted to
   parameters as needed. Traditionally, unbundling a record requires the use of
   transport along propositional equalities, with trivial ~refl~-exivity proofs.
   The ~:waist~ approach presented here removes the boilerplate necessary at the
   type specialisation location as well as at the instance declaration location.

   An application of our setup will be to provide a semantics for the
   PackageFormer editor extension, which realises the aforementioned folklore
   observation by providing users with meta-primitives for making modules to
   allow arbitrary grouping mechanisms to be derived, such as obtaining the
   homomorphism type of a given record.
 #+end_abstract

  \maketitle

** Next Steps

   We have shown how a bit of reflection allows us to have a compact, yet
   practical, one-stop-shop notation for records, typeclasses, and algebraic
   data types. There are a number of interesting directions to pursue:

   + How to write a function working homogeneously over one variation and having
     it lift to other variations.
     - Recall the ~comap~ from the introductory section was written over
       ~Graph :kind â€µtypeclass~; how could that particular implementation
        be massaged to work over ~Graph :kind ğ“€~ for any ~ğ“€~.

   + The current implementation for deriving termtypes presupposes only one
     carrier set positioned as the first entity in the grouping mechanism.
     - How do we handle multiple carriers or choose a carrier from an arbitrary
       position or by name? =PackageFormer= handles this by comparing names.

   + How do we lift properties or invariants, simple ~â‰¡~-types that â€˜defineâ€™
     a previous entity to be top-level functions in their own right?

 Lots to do, so little time.

* Bib                                                        :ignore:

 #+latex: \bibliography{References}
 #+latex: \bibliographystyle{plainnat}
 # latex: \bibliographystyle{ACM-Reference-Format}

* footer                                                     :ignore:

# Local Variables:
# eval: (progn (org-babel-goto-named-src-block "make-acmart-class") (org-babel-execute-src-block))
# compile-command: (progn (org-babel-tangle) (org-latex-export-to-pdf) (async-shell-command "open Paper1.pdf"))
# End:
