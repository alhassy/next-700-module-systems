#+TITLE: 3-for-1 Monadic Notation: Do-it-yourself module types
#+Subtitle: ---ICFP Deadline: March 3, 2020---
#+DESCRIPTION: Paper for ICFP 2020.
#+AUTHOR: Musa Al-hassy, Jacques Carette, Wolfram Kahl
#+EMAIL: alhassy@gmail.com
#+OPTIONS: toc:nil d:nil author:nil title:nil
#+PROPERTY: header-args :tangle no :comments link
#+TODO: TODO | OLD LaTeX README Remarks space
#+MACRO: PF \textsf{PackageFormer}
#+property: header-args :tangle paper2.agda :comments link

:push_all_remotely:
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-latex-packages-alist nil)
(setq org-latex-listings nil)
(setq org-latex-pdf-process
      '(;; "pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f"
        "pdflatex -output-directory %o %f"
        "biber %b"
        "pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f"
        "pdflatex -interaction nonstopmode -shell-escape -output-directory %o %f"
        ))

(add-to-list 'org-src-lang-modes '("agda2" . haskell))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(setq org-latex-compiler "pdflatex")
(setq-default TeX-engine 'default)

(setq org-latex-listings nil)
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("" "listings"))
(add-to-list 'org-latex-packages-alist '("" "color"))

(org-latex-export-to-pdf)
#+END_SRC

#+RESULTS:
: /Users/musa/thesis-proposal/papers/Paper2.pdf

:End:

* README COMMENT Dependencies of this org file

In the source blocks below, go into each one and press C-c C-c
to have it executed. Some â€˜resultsâ€™ will be echoed into the buffer
if everything went well.

Rather than executing the following blocks each time you edit this file,
consider adding them to your Emacs [[https://alhassy.github.io/init/][configuration file]].

 + org-mode :: This particular markup is called org-mode.

     Let's obtain Org-mode along with the extras that allow us to ignore
     heading names, but still utilise their contents --e.g., such as a heading
     named â€˜preambleâ€™ that contains org-mode setup for a file.
     #+begin_src emacs-lisp
;; first we get a handy-dandy package manager

(require 'package)
(setq package-archives '(("org"       . "https://orgmode.org/elpa/")
                         ("gnu"       . "https://elpa.gnu.org/packages/")
                         ("melpa"     . "https://melpa.org/packages/")
                         ("melpa-stable" . "https://stable.melpa.org/packages/")
                         ))
(package-initialize)

(package-refresh-contents)

(package-install 'use-package)
(require 'use-package)
(setq use-package-always-ensure t)

;; then we get the org-mode goodness

(use-package org
  :ensure org-plus-contrib
  :config
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines)))
#+end_src

     This lets us use the ~:ignore:~ tag on headlines you'd like to have ignored,
     while not ignoring their content --see [[https://emacs.stackexchange.com/a/17677/10352][here]].

     - Use the ~:noexport:~ tag to omit a headline /and/ its contents.

 + minted & bib :: Source blocks obtain colour.

     Execute the following for bib ref as well as minted
     Org-mode uses the Minted package for source code highlighting in PDF/LaTeX
     --which in turn requires the pygmentize system tool.
     #+BEGIN_SRC emacs-lisp
     (setq org-latex-listings 'minted
           org-latex-packages-alist '(("" "minted"))
           org-latex-pdf-process
           '("pdflatex -shell-escape -output-directory %o %f"
             ;; "biber %b"
             "bibtex %b"
             "pdflatex -shell-escape -output-directory %o %f"
             "pdflatex -shell-escape -output-directory %o %f")
     )
     #+END_SRC

     #+RESULTS:
     | pdflatex -shell-escape -output-directory %o %f | bibtex %b | pdflatex -shell-escape -output-directory %o %f | pdflatex -shell-escape -output-directory %o %f |

  # Enable the following to have small-font code blocks.
  # LATEX_HEADER: \RequirePackage{fancyvrb}
  # LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}

 + acmart :: Enable acmart latex class.

   #+NAME: make-acmart-class
   #+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("acmart" "\\documentclass{acmart}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

 (message "acmart has been loaded")
 #+END_SRC

 #+RESULTS: make-acmart-class
 : acmart has been loaded

  The GPCE 19 proceedings team needs us to submit the acmart.cls file along
  with our sources. So, let's bring that to our current directory.
#+BEGIN_SRC shell
(shell-command (s-collapse-whitespace (format "cp %s ."
                       (shell-command-to-string "kpsewhich acmart.cls"))))
#+END_SRC

#+RESULTS:
: 126

   The â€˜footerâ€™ at the end of this file currently executes only this code block for you
   ---if you enable the local vars. You can easily tweak it to execute the other blocks,
   if you like.

 + org-ref :: [[https://github.com/jkitchin/org-ref][An exquisite system]] for handling references.

    If everything works, the following entity will display useful data
    when the mouse hovers over it (â€¢Ì€á´—â€¢Ì)Ùˆ If you click on it, then you're
    in for a lot of super neat stuff, such as searching for the pdf online!

    cite:agda_overview

    #+BEGIN_SRC emacs-lisp
(use-package org-ref :demand t)

;; Files to look at when no â€œâ•²bibliography{â‹¯}â€ is not present in a file.
;; Most useful for non-LaTeX files.
(setq reftex-default-bibliography '("References.bib"))

(use-package helm-bibtex :demand t)
;; If you use helm-bibtex as the citation key completion method you should set these variables too.

(setq bibtex-completion-bibliography "References.bib")
#+END_SRC

  Execute ~M-x helm-bibtex~ and, say, enter ~agda~ and you will be presented with
  all the entries in the bib database that mention â€˜agdaâ€™. Super cool stuff.

* LaTeX setup                                                        :ignore:

#+latex_class_options: [10pt]

  # Visible editorial comments.
  # LATEX_HEADER: \usepackage{edcomms}
  # LATEX_HEADER: \edcommsfalse

  #+latex_header: \usepackage[font=itshape]{quoting}
  # Use quoting environment

** Document class options                                            :ignore:
  #+LATEX_CLASS: acmart
  # latex_class_options: [sigplan,screen]
  # latex_class_options: [sigplan,review,anonymous]
  # #+latex_class_options: [sigplan,review]
  # latex_class_options: [acmsmall,review,anonymous]

** Letter size and no page numbers or footers :ignore:
  # Letter-Size Paper Format, defaults
  #+latex_header: \pdfpagewidth=8.5in
  #+latex_header: \pdfpageheight=11in

  # switch off page numbering, â€œfoliosâ€
  # latex_header: \pagenumbering{gobble}

  # LATEX: \settopmatter{printccs=true, printfolios=false}

** Unicode & hyperlinks :ignore:
  # Dark green colour for links.
  #+LATEX_HEADER: \usepackage{color}
  #+LATEX_HEADER: \definecolor{darkgreen}{rgb}{0.0, 0.3, 0.1}
  #+LATEX_HEADER: \hypersetup{colorlinks,linkcolor=darkgreen,citecolor=darkgreen,urlcolor=darkgreen}

  #+LATEX_HEADER: \usepackage{../CheatSheet/UnicodeSymbols}

  #+LATEX_HEADER: \DeclareMathOperator{\VCCompose}{\longrightarrow\hspace{-3ex}\oplus\;}
  #+LATEX_HEADER: \newunicodechar{âŸ´}{\ensuremath{\!\!\VCCompose}}
  #+LATEX_HEADER: \newunicodechar{ğ“‹}{\ensuremath{\!\!v}}
  #+LATEX_HEADER: \newunicodechar{ğ’±}{\ensuremath{\mathcal{V}}}
  #+LATEX_HEADER: \newunicodechar{Î±}{\ensuremath{\alpha}}

  #+LATEX_HEADER: \newunicodechar{â„“}{\ensuremath{\ell}}
  #+LATEX_HEADER: \newunicodechar{â€µ}{\ensuremath{`}}
  #+LATEX_HEADER: \newunicodechar{â†}{\ensuremath{\longrightarrow}}
  #+LATEX_HEADER: \newunicodechar{â‡Š}{\ensuremath{\downarrow\!\downarrow}}

  # ğ‘›ğ‘ğ‘šğ‘’
  #+LATEX_HEADER: \newunicodechar{ğ‘›}{\ensuremath{n}}
  #+LATEX_HEADER: \newunicodechar{ğ‘}{\ensuremath{a}}
  #+LATEX_HEADER: \newunicodechar{ğ‘š}{\ensuremath{m}}
  #+LATEX_HEADER: \newunicodechar{ğ‘’}{\ensuremath{e}}

  #+LATEX_HEADER: \newunicodechar{â°}{\ensuremath{^0}}
  #+LATEX_HEADER: \newunicodechar{â¿}{\ensuremath{^n}}
  #+LATEX_HEADER: \newunicodechar{Â³}{\ensuremath{^3}}

  #+LATEX_HEADER: \newunicodechar{Î}{\ensuremath{\Xi}}
  #+LATEX_HEADER: \newunicodechar{Î¾}{\ensuremath{\xi}}

  #+LATEX_HEADER: \newunicodechar{ğ”»}{\ensuremath{\textbb{D}}}
  #+LATEX_HEADER: \newunicodechar{â„‚}{\ensuremath{\textbb{C}}}
  #+LATEX_HEADER: \newunicodechar{ğ•„}{\ensuremath{\textbb{M}}}
  #+LATEX_HEADER: \newunicodechar{â„™}{\ensuremath{\textbb{P}}}
  #+LATEX_HEADER: \newunicodechar{ğŸ˜}{\ensuremath{\textbb{0}}}
  #+LATEX_HEADER: \newunicodechar{ğŸ™}{\ensuremath{\textbb{1}}}

  #+LATEX_HEADER: \newunicodechar{ğ‘·}{\ensuremath{\textbf{P}}}
  #+LATEX_HEADER: \newunicodechar{ğ‘­}{\ensuremath{\textbf{F}}}
  #+LATEX_HEADER: \newunicodechar{ğ‘¯}{\ensuremath{\textbf{H}}}

** COMMENT CCSXML and Keywords                                               :ignore:
   # This must be /before/ maketitle!
   #+begin_export latex
 %%
 %% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.

 \begin{CCSXML}
 <ccs2012>
 <concept>
 <concept_id>10011007.10011006.10011008.10011009.10011019</concept_id>
 <concept_desc>Software and its engineering~Extensible languages</concept_desc>
 <concept_significance>500</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011024.10011031</concept_id>
 <concept_desc>Software and its engineering~Modules / packages</concept_desc>
 <concept_significance>500</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
 <concept_desc>Software and its engineering~Functional languages</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011024.10011025</concept_id>
 <concept_desc>Software and its engineering~Polymorphism</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011041.10011047</concept_id>
 <concept_desc>Software and its engineering~Source code generation</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011066.10011069</concept_id>
 <concept_desc>Software and its engineering~Integrated and visual development environments</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 </ccs2012>
 \end{CCSXML}

 \ccsdesc[500]{Software and its engineering~Extensible languages}
 \ccsdesc[500]{Software and its engineering~Modules / packages}
 \ccsdesc[300]{Software and its engineering~Functional languages}
 \ccsdesc[300]{Software and its engineering~Polymorphism}
 \ccsdesc[300]{Software and its engineering~Source code generation}
 \ccsdesc[300]{Software and its engineering~Integrated and visual development environments}

 %%
 %% Keywords. The author(s) should pick words that accurately describe
 %% the work being presented. Separate the keywords with commas.
 \keywords{Agda, meta-program, extensible, Emacs, packages, modules, dependent-types}
   #+end_export

** COMMENT Authors & title                                                   :ignore:

 #+begin_export latex
 \author{Musa Al-hassy}
 \affiliation{McMaster University, Canada}
 \email{alhassy@gmail.com}

 \author{Jacques Carette}
 \orcid{0000-0001-8993-9804}
 \affiliation{McMaster University, Canada}
 \email{carette@mcmaster.ca}

 \author{Wolfram Kahl}
 \orcid{0000-0002-6355-214X}
 \affiliation{McMaster University, Canada}
 \email{kahl@cas.mcmaster.ca}

 % \author{Musa Al-hassy \\ {\small \url{alhassy@gmail.com} \\ McMaster University \\ Computing and Software \\ Hamilton, Ontario, Canada}}
 % \author{Jacques Carette \\ {\small \url{carette@mcmaster.ca} \\ McMaster University \\ Computing and Software \\ Hamilton, Ontario, Canada}}
 % \author{Wolfram Kahl \\ {\small \url{kahl@cas.mcmaster.ca} \\ McMaster University \\ Computing and Software \\ Hamilton, Ontario, Canada}}

 #+end_export

** Widows and Orphans                                                :ignore:
 # An "orphan" is an isolated line of text at the bottom of a page;
 # an "orphan heading" is a heading without following body text at the bottom of the page;
 # a "widow" is an isolated line of text at the top of a page.
 #
 # LaTeX: In order to eliminate widows and orphans, you can copy the following commands into the LaTeX source before \begin{document} :
 #
   #+latex_header:        \clubpenalty = 10000
   #+latex_header:        \widowpenalty = 10000
   #+latex_header:        \displaywidowpenalty = 10000

 # Sometimes, orphans and widows will survive these commands, in which case a \vspace command might help.

** Balanced Columns on Last Page                                     :ignore:
   #+latex_header: \usepackage{flushend}

 # The two columns of the last page need to have the same length.
 #
 # + LaTeX (Option 1) :: Insert the command \usepackage{flushend} into the LaTeX source before \begin{document}.
 #
 # + LaTeX (Option 2) :: Insert \usepackage{balance} into the LaTeX source before \begin{document}
 #      and the following in the text that would appear as left column on the last page without balancing: \balance.
 #
 # + LaTeX (Option 3) :: If the above options do not work, it seems that one of the used packages prevents
 #      the balancing from working properly. In case you do not want to spend time on finding out which
 #       package it is, you can manually balance the last page by inserting a \newpage between your
 #       references in the .bbl file at an appropriate position. (Attention: Running bibtex again
 #       will overwrite this; alternatively, the contents of the .bbl file can be copy-and-paste'ed
 #       into the main LaTeX file in place of the \bibliography command.)
 #
** COMMENT GPCEâ€™19 Copyright                                                 :ignore:

 # The following is specific to GPCE '19 and the paper
 # 'A Language Feature to Unbundle Data at Will (Short Paper)'
 # by Musa Al-hassy, Wolfram Kahl, and Jacques Carette.
 #
 #+latex_header: \setcopyright{acmcopyright}
 #+latex_header: \acmPrice{15.00}
 #+latex_header: \acmDOI{10.1145/3357765.3359523}
 #+latex_header: \acmYear{2019}
 #+latex_header: \copyrightyear{2019}
 #+latex_header: \acmISBN{978-1-4503-6980-0/19/10}
 #+latex_header: \acmConference[GPCE '19]{Proceedings of the 18th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences}{October 21--22, 2019}{Athens, Greece}
 #+latex_header: \acmBooktitle{Proceedings of the 18th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences (GPCE '19), October 21--22, 2019, Athens, Greece}
 #+latex_header:

* Abstract                                                           :ignore:
#+begin_abstract org
  Folklore has held that any â€˜semantic unitâ€™ is essentially a type-theoretic
  context ---this includes, for example, records and algebraic datatypes.  We
  provide foundation for such an observation.

  We show that languages with a sufficiently powerful type system and reflection
  mechanism permit a /single declaration interface/ for functions, records, type
  classes, type constructors, and algebraic data types. Moreover, the interface
  is monadic and thus actually practical to use.

  Along the way, we solve the bundling problem: Record fields can be lifted to
  parameters as needed. Traditionally, unbundling a record requires the use of
  transport along propositional equalities, with trivial ~refl~-exivity proofs.
  The ~:waist~ approach presented here removes the boilerplate necessary at the
  type specialisation location as well as at the instance declaration location.

  A third contribution of this paper is to provide a semantics for the
  PackageFormer editor extension, which realises the folklore observation by
  providing users with meta-primitives for making modules to allow arbitrary
  grouping mechanisms to be derived, such as obtaining the homomorphism type of
  a given record.
#+end_abstract

 \maketitle

* Header :noexport:

#+begin_src agda2 :tangle paper2.agda
module paper2 where

--------------------------------------------------------------------------------
-- (shell-command "ln -s /Users/musa/thesis-proposal/prototype/semantics-with-waist.agda semantics-with-waist.agda")

open import semantics-with-waist
open import Data.Product
open import Level renaming (zero to â„“â‚€) hiding (suc)
open import Relation.Binary.PropositionalEquality hiding ([_])
open import Data.Nat
open import Function using (id)
open import Data.Bool renaming (Bool to ğ”¹)
open import Data.Sum

open import Data.List
import Data.Unit as Unit
open import Reflection hiding (name; Type) renaming (_>>=_ to _>>=â‚˜_)

â„“â‚ = Level.suc â„“â‚€

-- Helpers for readability
pattern âŸ¨_âŸ©â‚ x    = x , tt
pattern âŸ¨_,_âŸ© x y = x , y , tt
#+end_src

* Introduction

The humblest notion of a grouping mechanism is described by a pair type ~A Ã— B Ã—
C~, usually later values depend on earlier values and so we have the
dependent-pair type ~Î£ a âˆ¶ A â€¢ Î£ b âˆ¶ B a â€¢ Î£ C a b~. The kind of these types is
~Setâ‚~, the type of small types. If we wish to speak of groupings where ~a âˆ¶ A~ is
/fixed/, then we must lift it from being a /field/ component to being a /parameter/,
thereby arriving at the /function/ ~Î» a âˆ¶ A â€¢ b âˆ¶ B a â€¢ C a b~ which has /type/ ~Î  a âˆ¶
A â€¢ Set~. Similarly, we may expose ~b~ as a parameter to further indicate the
possible grouping structure.

| Grouping Description          |   | Kind                      |
|-------------------------------+---+---------------------------|
| =Î£ a âˆ¶ A â€¢ Î£ b âˆ¶ B a â€¢ Î£ C a b= |   | ~Set~                       |
| =Î» a âˆ¶ A â€¢ Î£ b âˆ¶ B a â€¢ Î£ C a b= |   | ~Î  a âˆ¶ A â€¢ Set~             |
| =Î» a âˆ¶ A â€¢ Î» b âˆ¶ B a â€¢ Î£ C a b= |   | ~Î  a âˆ¶ A â€¢ Î  b âˆ¶ B a â€¢ Set~ |

At each step, we â€œpull outâ€ more information at the kind level; at first we have
a ~Set~, an opaque grouping mechanism, then we obtain a ~Î  a âˆ¶ A â€¢ Set~ which is a
grouping mechanism that somehow makes use of an ~A~-value.

1. *Type constructor reification Î â†’Î»:* Function /types/ like ~Î  a âˆ¶ A â€¢ Set~ cannot be
   applied since they are not functions, so how do we get to ~Î» a : A â€¢ Set~?

   + Î»-terms are values of Î -types, but in general there is no natural
     construction to transform a type into one of its values.

   + Given ~Ï„ = Î  (X : Set) â€¢ â‹¯ : Setâ‚~, we want ~Î â†’Î» Ï„ = Î» (X : Set) â€¢ â‹¯ : Î  (X :
     Set) â€¢ Set~; the former's type states it to be a =Setâ‚=, a grouping mechanism of
     which we know nothing, whereas the latter's type indicates it to be a
     parameterised grouping mechanism. Since ~Î â†’Î» Ï„~ can be applied and is thus more
     concrete, we call ~Î â†’Î»~ a reification combinator.

2. *Unbundling*: How do we go from ~Set~ to ~Î  a âˆ¶ A â€¢ Set~?

   A function from function-types to functions-on-types necessarily
   requires a way to pattern match on the possible type constructions in a language.

   Perhaps an example will clarify the issue. The ubiquitous graph structure
   is contravariant in its collection of vertices. Recall that a multi-graph, or
   quiver, is a collection of vertices along with a collection of edges between
   any two vertices; here's the traditional record form:
   #+begin_src agda2
Graphâ‚€ : Context â„“â‚
Graphâ‚€ = do Vertex â† Set
            Edges  â† (Vertex â†’ Vertex â†’ Set)
            End {â„“â‚€}
#+end_src

   Using the record form, it is akward to phrase contravariance, which simply
   â€œrelabels the verticesâ€. Even worse, the awkward phrasing only serves to
   ensure certain constraints hold ---which are reified at the value level via
   the uninsightful ~refl~-exivity proof.
   #+begin_src agda2
comapâ‚€ : âˆ€ {A B : Set}
      â†’ (f : A â†’ B)
      â†’ Î£ G âˆ¶ Graphâ‚€ :kind â€µrecord â€¢ Field 0 G â‰¡ B
      â†’ Î£ G âˆ¶ Graphâ‚€ :kind â€µrecord â€¢ Field 0 G â‰¡ A
comapâ‚€ {A} {B} f (âŸ¨ .B , edgs âŸ© , refl) = (A , (Î» aâ‚ aâ‚‚ â†’ edgs (f aâ‚) (f aâ‚‚)) , tt) , refl
       #+end_src
   /Without redefining graphs/, we can phrase the definition at the typeclass
   level ---i.e., records parameterised by the vertices. This form is not only
   clearer and easier to implement at the value-level, it also makes it clear
   that we are â€œpulling backâ€ the vertex type and so have also shown graphs are
   closed under reducts.
       #+begin_src agda2
-- Way better and less akward!
comap : âˆ€ {A B : Set}
     â†’ (f : A â†’ B)
     â†’ (Graphâ‚€ :kind â€µtypeclass) B
     â†’ (Graphâ‚€ :kind â€µtypeclass) A
comap f âŸ¨ edgs âŸ©â‚ = âŸ¨ (Î» aâ‚ aâ‚‚ â†’ edgs (f aâ‚) (f aâ‚‚)) âŸ©â‚
   #+end_src

   Later we show how to form ~Context~, its do-notation, and the ~:kind~ mechanism
   which shifts between records, typeclasses, and algebraic datatypes.


# eval  : A Ã— (A â†’ B) â†’ B
# curry : (A Ã— B â†’ C) â†’ (A â†’ (B â†’ C))
# #
# Î  a âˆ¶ A â€¢ (Î  f âˆ¶ (Î  x âˆ¶ A â€¢ B x)) â€¢ B a
# Î  f âˆ¶ (Î  p âˆ¶ (Î  x âˆ¶ A â€¢ B x) â€¢ C p) â€¢ Î  a âˆ¶ A â€¢ Î  b âˆ¶ B a â€¢ C (a, b)
# Î  f âˆ¶ Set â€¢ (Î  x âˆ¶ A â€¢ Set)

We shall outline how this can be achieved in dependently-typed languages which
have support for reflection. Our target language will be Agda, but the ideas
easily transfer to other languages. In particular, the resulting in-language
syntax we obtain is rather close to the existing Agda record syntax for
declarations and Agda constructor tuples for instances.  In the next section, we
begin by way of a more concrete example of a grouping mechanism, then we take a
goal-driven approach to building the necessarily apparatus for a clean
imperative-like declaration notation, then we conclude with a brief discussion
on how the resulting framework can act as a simple theory for the Agda
PackageFormer editor extension.

In order to be language-agnostic and underscore the ideas, we shall present the
core definitions along with Agda-checked examples. Details are left to an
appendix(?) or can be read below (MA: Haven't decided yet):
| https://github.com/alhassy/next-700-module-systems/tree/master/prototype |

* A Grouping Mechanism: Automata

We begin by way of example.

The humblest of automata is a dynamical system ---a collection of states, a
designated start state, and a transition function. For example, a machine with
an initial display and only one button that changes the display.  In
dependently-typed languages, there are at least three ways to encode such a
structure ---via records possibly with parameters, which are sometimes called
typeclasses.

#+begin_src agda2 :tangle paper2.agda
record DynamicSystemâ‚€ : Setâ‚ where
  field
    States : Set
    start  : States
    next   : States â†’ States

record DynamicSystemâ‚ (States : Set) : Set where
  field
    start : States
    next  : States â†’ States

record DynamicSystemâ‚‚ (States : Set) (start : States) : Set where
  field
    next : States â†’ States
    #+end_src

The kinds of these types provide insight into the sort of data they contain:
| Type           | Kind                      |
|----------------+---------------------------|
| =DynamicSystemâ‚€= | =Setâ‚=                      |
| =DynamicSystemâ‚= | =Î  X âˆ¶ Set â€¢ Set=           |
| =DynamicSystemâ‚‚= | =Î  X âˆ¶ Set â€¢ Î  x âˆ¶ X â€¢ Set= |
:AgdaCheckedEvidence:
    #+begin_src agda2 :tangle paper2.agda
_ : Setâ‚
_ = DynamicSystemâ‚€

_ : Î  X âˆ¶ Set â€¢ Set
_ = DynamicSystemâ‚

_ : Î  X âˆ¶ Set â€¢ Î  x âˆ¶ X â€¢ Set
_ = DynamicSystemâ‚‚
#+end_src
:End:

Observe that =DynamicSystemáµ¢= is a type constructor of =i=-many arguments.

Yet another way to encode dynamical systems would be by their syntax, as it
would be desirable when serialising them ---i.e., to obtain first-class
descriptions of dynamical system values.
#+begin_src agda2 :tangle paper2.agda
data DSTermsâ‚€ : Set where
  start : DSTermsâ‚€
  next  : DSTermsâ‚€ â†’ DSTermsâ‚€

data DSTermsâ‚ (States : Set) : Set where
  start : States â†’ DSTermsâ‚ States
  next  : DSTermsâ‚ States â†’ DSTermsâ‚ States

data DSTermsâ‚‚ (States : Set) (start : States) : Set where
  next : DSTermsâ‚‚ States start â†’ DSTermsâ‚‚ States start
#+end_src

Notice that the first algebraic data type is isomorphic to ~â„•~, whereas the
remaining two are isomorphic to ~States Ã— â„•~ which keeps track of how many =next=
steps are necessary until a =State= value is reached ---this may be called
=Eventually States=.
The ~DSTermsáµ¢~ share the same pattern of kind exposure as the ~DynamicSystemáµ¢~ types.
:AgdaCheckedEvidence:
#+begin_src agda2 :tangle paper2.agda
_ : Set
_ = DSTermsâ‚€

_ : Î  X âˆ¶ Set â€¢ Set
_ = DSTermsâ‚

_ : Î  X âˆ¶ Set â€¢ Î  x âˆ¶ X â€¢ Set
_ = DSTermsâ‚‚
#+end_src
:End:

# #
Using monadic notation, we can obtain all of these notions from a single user-friendly
context declaration.
#+name: contexts-table
#+caption: Contexts embody all kinds of grouping mechanisms
| Concept            | Concrete Syntax                       | Description            |
|--------------------+---------------------------------------+------------------------|
| Context            | =do S â† Set; s â† X; n â† (X â†’ X); End=   | â€œname-type pairsâ€      |
|--------------------+---------------------------------------+------------------------|
| Record Type        | =Î£ S âˆ¶ Set â€¢ Î£ s âˆ¶ S â€¢ Î£ n âˆ¶ S â†’ S â€¢ âŠ¤= | â€œbundled-up dataâ€      |
| Function Type      | =Î  S â€¢ Î£ s âˆ¶ S â€¢ Î£ n âˆ¶ S â†’ S â€¢ âŠ¤=       | â€œa type of functionsâ€  |
| Type constructor   | =Î» S â€¢ Î£ s âˆ¶ S â€¢ Î£ n âˆ¶ S â†’ S â€¢ âŠ¤=       | â€œa function on typesâ€  |
| Algebraic datatype | ~data ğ”» : Set where s : ğ”»; n : ğ”» â†’ ğ”»~   | â€œa descriptive syntaxâ€ |

* From Do-notation to (Parameterised) Record Types

Traditionally a context is a list of name-type pairs, for us it will be a set
---namely the product of the types, since the names â€œdo not matterâ€.  Moreover,
contexts will be have a numeric â€˜waistâ€™ argument that indicates which of the
first entries are â€˜parametersâ€™, leaving the remaining elements as â€˜fieldsâ€™.

#+begin_example agda2
-- Contexts are waist-indexed types
Context = Î» â„“ â†’ â„• â†’ Set â„“

-- The â€œempty contextâ€ is the unit type
End : âˆ€ {â„“} â†’ Context â„“
End = â€µ âŠ¤

-- Every type is a context
â€µ_ : âˆ€ {â„“} â†’ Set â„“ â†’ Context â„“
â€µ S = Î» _ â†’ S
#+end_example

In order to use do-notation we must provide a definition of a bind operator
~_>>=_~.
#+begin_example agda2
  do X â† Set
     z â† X
     s â† (X â†’ X)
     End

â†âŸ¨ Removing syntactic sugar âŸ©

  â€µ Set >>= Î» X â†’ â€µ X >>= Î» z â†’ â€µ (X â†’ X) >>= End
#+end_example
Notice the quote method is forced due to the typing of bind: ~_>>= : âˆ€ {X Y} â†’ m
X â†’ (X â†’ m Y) â†’ m Y~.  The definition of the bind operator accounts for the
current waist: If zero, we have records, otherwise functions.
#+begin_example agda2
_>>=_ : âˆ€ {a b}
      â†’ (Î“ : Context a)
      â†’ (âˆ€ {n} â†’ Î“ n â†’ Context b)
      â†’ Context (a âŠ b)
(Î“ >>= f) â„•.zero  = Î£ Î³ âˆ¶ Î“ 0 â€¢ f Î³ 0
(Î“ >>= f) (suc n) = (Î³ : Î“ n) â†’ f Î³ n
#+end_example
Unfortunately, this would require too many calls to quote; e.g.,
#+begin_example agda2
do X â† â€µ Set
   z â† â€µ X
   s â† â€µ (X â†’ X)
   End
#+end_example
So letâ€™s â€œbuild it into the definitionâ€ of ~_>>=_~:
#+begin_example agda2
_>>=_ : âˆ€ {a b}
      â†’ (Î“ : Set a)  -- Main difference
      â†’ (Î“ â†’ Context b)
      â†’ Context (a âŠ b)
(Î“ >>= f) â„•.zero  = Î£ Î³ âˆ¶ Î“ â€¢ f Î³ 0
(Î“ >>= f) (suc n) = (Î³ : Î“) â†’ f Î³ n
#+end_example

Let's see this in action, and for variety let's encode monoids.
#+begin_example agda2
Monoid : âˆ€ â„“ â†’ Context (â„“suc â„“)
Monoid â„“ = do Carrier â† Set â„“
              Id      â† Carrier
              _âŠ•_     â† (Carrier â†’ Carrier â†’ Carrier)
              leftId  â† âˆ€ {x : Carrier} â†’ x âŠ• Id â‰¡ x
              rightId â† âˆ€ {x : Carrier} â†’ Id âŠ• x â‰¡ x
              assoc   â† âˆ€ {x y z} â†’ (x âŠ• y) âŠ• z  â‰¡  x âŠ• (y âŠ• z)
              End {â„“}
#+end_example

Likewise, we encode a context ~DynamicSystem~, cite:contexts-table,
which we tabulate its elaboration at particular waists:

| Waist |   | Elaboration                                |
|-------+---+--------------------------------------------|
|     0 |   | =Î£ X âˆ¶ Set  â€¢ Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ âŠ¤= |
|     1 |   | =Î  X âˆ¶ Set  â€¢ Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ âŠ¤= |
|     2 |   | =Î  X âˆ¶ Set  â€¢ Î  z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ âŠ¤= |
|     3 |   | =Î  X âˆ¶ Set  â€¢ Î  z âˆ¶ X  â€¢ Î  s âˆ¶ (X â†’ X)  â€¢ âŠ¤= |

Notice that the elaborations are function types, but we want functions /on/ types
---as is the case with the ~DynamicSystemáµ¢~ from the introduction.

* Unbundling: From Function Types to Functions /on/ Types

Evaluation transforms functions to values and currying reorganises functions,
but we want a combinator, call it ~Î â†’Î»~, that takes a type and results in a value
of that type.  In general, this is not feasible when the type is empty nor is it
naturally canonical when there are multiple possible values to choose from.

One could use a universe, an algebraic type of codes denoting types, to define
~Î â†’Î»~. However, one can no longer then easily use existing types since they are
not formed from the universe's constructors, thereby resulting in duplication of
existing types via the universe encoding. This is not practical nor pragmatic.

As such, we are left with pattern matching on the language's type formation
primitives as the only reasonable approach. The method ~Î â†’Î»~ is thus a macro that
acts on the syntactic term representations of types.
#+begin_example agda2
Î â†’Î» (Î  a âˆ¶ A â€¢ Ba) = (Î» a âˆ¶ A â€¢ Ba)
Î â†’Î» Ï„              = Ï„  {- otherwise -}
#+end_example
Similarly, ~_:waist_~ is a macro acting on contexts that repeats ~Î â†’Î»~ a number of
times in order to lift a number of field components to the parameter level.
#+begin_example agda2
Ï„ :waist n     = Î â†’Î»â¿ n (Ï„ n)

Î â†’Î»â¿ 0       Ï„ = Ï„
Î â†’Î»â¿ (n + 1) Ï„ = Î â†’Î»â¿ n (Î â†’Î» Ï„)
#+end_example

Let's see this in action. Here are our dynamical systems.
#+begin_example agda2
DynamicSystem : Context (â„“suc Level.zero)
DynamicSystem = do X â† Set
                   s â† X
                   n â† (X â†’ X)
                   End {Level.zero}
#+end_example

Then using our macros:
#+begin_example agda2
DynamicSystem 1        â‰¡  Î  X âˆ¶ Set â€¢ Î£ s âˆ¶ X  â€¢ Î£ n âˆ¶ X â†’ X  â€¢ âŠ¤
DynamicSystem :waist 1 â‰¡  Î» X âˆ¶ Set â€¢ Î£ s âˆ¶ X  â€¢ Î£ n âˆ¶ X â†’ X  â€¢ âŠ¤
#+end_example

Each type exposes more and more information about what kind of grouping
structure we have at hand. The definitions could not be simpler.
#+begin_example agda2
Aâ€² : Setâ‚
Bâ€² : Î  X âˆ¶ Set â€¢ Set
Câ€² : Î  X âˆ¶ Set â€¢ Î  x âˆ¶ X â€¢ Set
Dâ€² : Î  X âˆ¶ Set â€¢ Î  x âˆ¶ X â€¢ Î  s âˆ¶ (X â†’ X) â€¢ Set

Aâ€² = DynamicSystem :waist 0
Bâ€² = DynamicSystem :waist 1
Câ€² = DynamicSystem :waist 2
Dâ€² = DynamicSystem :waist 3
#+end_example

If the language allows mixfix unicode identifiers, then one declares
grouping mechanisms  with ~do â‹¯ End~ then forms instances using, say, ~âŸ¨â‹¯âŸ©~.
#+begin_example agda2
-- Helpful syntactic sugar
âŸ¨ : âˆ€ {â„“} {S : Set â„“} â†’ S â†’ S
âŸ¨ s = s

_âŸ© : âˆ€ {â„“} {S : Set â„“} â†’ S â†’ S Ã— âŠ¤ {â„“}
s âŸ© = s , tt

âŸ¨âŸ© : âˆ€ {â„“} â†’ âŠ¤ {â„“}
âŸ¨âŸ© = tt
#+end_example
The following /instances/ of these grouping types demonstrate how /information moves from the body level to the parameter level./
#+begin_example agda2
ğ’©â° : Aâ€²
ğ’©â° = âŸ¨ â„• , 0 , suc âŸ©

ğ’©Â¹ : Bâ€² â„•
ğ’©Â¹ = âŸ¨ 0 , suc âŸ©

ğ’©Â² : Câ€² â„• 0
ğ’©Â² = âŸ¨ suc âŸ©

ğ’©Â³ : Dâ€² â„• 0 suc
ğ’©Â³ = âŸ¨âŸ©
#+end_example

It is interesting to note, that if a context =ğ’= has only ğ“ƒ-many fields, then
there are only ğ“ƒ-many interesting unbundled forms, after which there are no new
ones: ~ğ’ (ğ“ƒ + k) â‰¡ ğ’ ğ“ƒ~.

With ~:waist~ we can fix parameters ahead of time.  For example, above the type =Bâ€²
â„•= is the type of â€œdynamic systems over carrier â„•â€ whereas =Câ€² â„• 0= is the type of
â€œdynamic systems over carrier â„• and start state 0â€.  Without the unbundling
mechanism we would have had to resort to awkward trivial constraints, as below,
which are tolerable for one-off uses but clearly do not scale at all as
indicated by the need to use equals-for-equals ~subst~-itutions of propositional
equalities.
#+begin_src agda2
Câ€³ : Î  X âˆ¶ Set â€¢ Î  x âˆ¶ X â€¢ Setâ‚
Câ€³ X x = Î£ ğ’Ÿ âˆ¶ DynamicSystem 0
       â€¢ Î£ Carrier-is-X âˆ¶ projâ‚ ğ’Ÿ â‰¡ X
       â€¢ projâ‚ (projâ‚‚ ğ’Ÿ) â‰¡ subst id (sym Carrier-is-X) x

ğ’©Â²eek : Câ€³ â„• 0
ğ’©Â²eek = (â„• , 0 , suc , tt) , refl , refl
#+end_src

Traditionally, unbundling a record requires the use of transport along
propositional equalities, with trivial ~refl~-exivity proofs.
The ~:waist~ approach presented here removes the boilerplate necessary at
the type specialisation location as well as at the instance declaration location.

* COMMENT =termtype=: Algebraic Datatypes are Fixpoints of Derived Functors
With a bit of reflection, records and typeclasses have been coerced into a
unified notation. It remains to bring algebraic datatypes into the fold.

* Semantics for PackageFormer

  The PackageFormer editor extension reads contexts ---in nearly the same
  notation as above--- enclosed in dedicated comments, then generates and
  imports Agda code from them seamlessly in the background whenever typechecking
  transpires. The framework provides a fixed number of meta-primitives for
  producing arbitrary notions of grouping mechanisms, and allows arbitrary
  Emacs Lisp to be invoked in the construction of complex grouping mechanisms.

  One of PackageFormer's primitives is called ~:waist~ and behaves exactly as ours
  above. As such, our current setup provides a formalisation of PackageFormer
  limited to only the ~:waist~ meta-primitive. Moreover, it is nearly as readable
  and is a library method, rather than an editor extension.

  PackageFormer is extensible via Emacs Lisp and one of its possible uses is to
  obtain algebraic data types from a context. With Agda's current reflection
  mechanism, even this is possible! For example, we may obtain a type ~ğ”»~ from
  =DynamicSystem= with user-defined constructors =zeroD= and =sucD= as if it where
  defined:
#+begin_example agda2
data ğ”» : Set where
     zeroD : ğ”»
     sucD  : ğ”» â†’ ğ”»
#+end_example

  #

  Here are the core pieces necessary to form ~termtype~; obtained by viewing an
  algebraic data-type as a fixed-point of the functor obtained from union of the
  sources of its constructors. For example, the above =ğ”»= is the fixpoint of ~Î» ğ”» â†’
  ğŸ™ âŠ ğ”»~, where the summands are the sources of =ğ”»='s constructors.
  #+begin_example agda2
â‡Š Ï„ = â€œreduce all de brujin indices by 1â€

Î£â†’âŠ (Î£ a âˆ¶ A â€¢ Ba) = A âŠ Î£â†’âŠ (â‡Š Ba)
{- Extend â€˜Î£â†’âŠâ€™ homomorphicly to other syntactic constructs -}

sources (Î» x âˆ¶ (Î  a âˆ¶ A â€¢ Ba) â€¢ â‹¯) = (Î» x âˆ¶ A â€¢ â‹¯)
sources (Î» x âˆ¶ A              â€¢ â‹¯) = (Î» x âˆ¶ âŠ¤ â€¢ â‹¯)
{- Extend â€˜sourcesâ€™ homomorphicly to other syntactic constructs -}

data Fix (F : Set â†’ Set) : Set where
  Î¼ : F (Fix F) â†’ Fix F

termtype Ï„ = Fix (Î£â†’âŠ (sources Ï„))
#+end_example

One can then declare ~ğ”» = termtype (DynamicSystem :waist 1)~.

With ~termtype~ in hand, we have provided a theoretical basis for yet another
meta-primitive of PackageFormer, the ~_:kind_~ primitive which dictates how an
abstract grouping mechanism should be viewed in terms of existing Agda syntax.
However, unlike PackageFormer all of our syntax is legitimate Agda syntax.

#+begin_src agda2 :tangle no
data Kind : Set where
  â€µrecord    : Kind
  â€µtypeclass : Kind
  â€µdata      : Kind
#+end_src

Since syntax is being manipulated, we have yet another macro:
#+begin_src agda2 :tangle no
ğ’ :kind â€µrecord    = ğ’ 0
ğ’ :kind â€µtypeclass = ğ’ :waist 1
ğ’ :kind â€µtypeclass = termtype (ğ’ :waist 1)
#+end_src

Interestingly, useful programming datatypes arise from termtypes of theories
(contexts). That is, if =ğ’ : Set â†’ Context â„“â‚€= then =â„‚â€² = Î» X â†’ ğ’ X :kind â€µdata= can
be used to form â€˜free, lawless, ğ’-instancesâ€™.  For example,
| Theory             | Termtype     |
|--------------------+--------------|
| Dynamical Systems  | â„•            |
| Pointed Structures | Maybe        |
| Monoids            | Binary Trees |

The final correspondence in the table is a claim mentioned briefly in the first
PackageFormer paper. With our setup we can not only formally express the
relationship but also prove it true. We present the setup and
leave it as a tremendously easy exercise to the reader to present a bijective
pair of functions between =ğ•„= and =TreeSkeleton=. Hint: Interactively case-split on values
of =ğ•„= until the declared patterns appear, then replace them with the constructors
of ~TreeSkeleton~.

#+begin_example agda2
ğ•„ : Set
ğ•„ = termtype (Monoid â„“â‚€ :waist 1)

-- Pattern synonyms for more compact presentation
pattern emptyM      = Î¼ (injâ‚ tt)                      -- : ğ•„
pattern branchM l r = Î¼ (injâ‚‚ (injâ‚ (l , r , tt)))     -- : ğ•„ â†’ ğ•„ â†’ ğ•„
pattern absurdM a   = Î¼ (injâ‚‚ (injâ‚‚ (injâ‚‚ (injâ‚‚ a))))  -- absurd values of ğŸ˜

data TreeSkeleton : Set where
  empty  : TreeSkeleton
  branch : TreeSkeleton â†’ TreeSkeleton â†’ TreeSkeleton
#+end_example

To obtain trees over some â€˜value typeâ€™ Î, one must start at the theory of
â€œmonoids containing a given set Îâ€. Similarly, by starting at â€œtheories of
pointed sets over a given set Îâ€, the resulting termtype is the ~Maybe~
type constructor ---another simple exercise to the reader: Show ~â„™ â‰… Maybe~.
#+begin_example agda2
PointedOver  : Set â†’ Context (â„“suc â„“â‚€)
PointedOver Î    = do Carrier â† Set â„“â‚€
                      point   â† Carrier
                      embed   â† (Î â†’ Carrier)
                      End

â„™ : Set â†’ Set
â„™ X = termtype (PointedOver X :waist 1)

-- Pattern synonyms for more compact presentation
pattern nothingP = Î¼ (injâ‚ tt)       -- : â„™
pattern justP e  = Î¼ (injâ‚‚ (injâ‚ e)) -- : â„™ â†’ â„™
#+end_example

For PackageFormer, we have implemented its primitives ~:waist~ and ~:kind~, the
other core meta-primitives are ~_âŸ´_~ and ~:alter-elements~. The former is a
syntactic form of function application, ~x âŸ´ f â‰ˆ f x~, which we already have by
juxtaposition in Agda. The latter, however, is a â€œhammerâ€ that alters the
constituents of a grouping mechanism in an arbitrary fashion using the entire
power of Emacs Lisp ---which includes a large portion of Common Lisp.  We have
currently presented a partial semantics of PackageFormer's syntactic entities by
presenting them here as semantic functions on contexts.

* What about the meta-language's parameters?

Besides ~:waist~, another way to introduce parameters into a context grouping
mechanism is to use the language's existing utility of parameterising a context
by another type ---as was done earlier in ~PointedOver~.

For example, a pointed set needn't necessarily be termined with ~End~.
#+begin_src agda2
PointedSet : Context â„“â‚
PointedSet = do Carrier â† Set
                point   â† Carrier
                End {â„“â‚}
#+end_src
We instead form a grouping consisting of a single type and a value of that type,
along with an instance of the parameter type =Î=.
#+begin_src agda2
PointedPF : (Î : Setâ‚) â†’ Context â„“â‚
PointedPF Î = do Carrier â† Set
                 point   â† Carrier
                 â€µ Î
#+end_src
Clearly ~PointedPF âŠ¤ â‰ˆ PointedSet~, so we have a more generic grouping mechanism.
The natural next step is to consider other parameters such as ~PointedSet~
in-place of =Î=.
:AgdaCheckedEvidence:
#+begin_src agda2
_ : âˆ€ {n} â†’ PointedPF âŠ¤ n â‰¡ PointedSet n
_ = refl
#+end_src
:End:
#+begin_src agda2
-- Convenience names
PointedSetáµ£ = PointedSet        :kind â€µrecord
PointedPFáµ£  = Î» Î â†’ PointedPF Î :kind â€µrecord

-- An extended record type: Two types with a point of each.
TwoPointedSets = PointedPFáµ£ PointedSetáµ£

_ :   TwoPointedSets
    â‰¡ ( Î£ Carrierâ‚ âˆ¶ Set â€¢ Î£ pointâ‚ âˆ¶ Carrierâ‚
      â€¢ Î£ Carrierâ‚‚ âˆ¶ Set â€¢ Î£ pointâ‚‚ âˆ¶ Carrierâ‚‚ â€¢ âŠ¤)
_ = refl

-- Here's an instance
one : PointedSet :kind â€µrecord
one = ğ”¹ , false , tt

-- Another; a pointed natural extended by a pointed bool,
-- with particular choices for both.
two : TwoPointedSets
two = â„• , 0 , one
#+end_src
More generally, /record *structure* can be dependent on values:/
#+begin_src agda2
_PointedSets : â„• â†’ Setâ‚
zero  PointedSets = âŠ¤
suc n PointedSets = PointedPFáµ£ (n PointedSets)

_ :   4 PointedSets
    â‰¡ (Î£ Carrierâ‚ âˆ¶ Set â€¢ Î£ pointâ‚ âˆ¶ Carrierâ‚
      â€¢ Î£ Carrierâ‚‚ âˆ¶ Set â€¢ Î£ pointâ‚‚ âˆ¶ Carrierâ‚‚
      â€¢ Î£ Carrierâ‚ƒ âˆ¶ Set â€¢ Î£ pointâ‚ƒ âˆ¶ Carrierâ‚ƒ
      â€¢ Î£ Carrierâ‚„ âˆ¶ Set â€¢ Î£ pointâ‚„ âˆ¶ Carrierâ‚„ â€¢ âŠ¤)
_ = refl
#+end_src
Using traditional grouping mechanisms, it is difficult to create the family of
types =n PointedSets= since the number of fields, $2 Ã— n$, depends on $n$.

It is interesting to note that the termtype of ~PointedPF~ is the same as the
termtype of ~PointedOver~, the ~Maybe~ type constructor!
#+begin_src agda2
PointedD : (X : Set) â†’ Setâ‚
PointedD X = termtype (PointedPF (Lift _ X) :waist 1)

-- Pattern synonyms for more compact presentation
pattern nothingP = Î¼ (injâ‚ tt)
pattern justP x  = Î¼ (injâ‚‚ (lift x))

casingP : âˆ€ {X} (e : PointedD X)
        â†’ (e â‰¡ nothingP) âŠ (Î£ x âˆ¶ X â€¢ e â‰¡ justP x)
casingP nothingP  = injâ‚ refl
casingP (justP x) = injâ‚‚ (x , refl)
#+end_src

* Next Steps

  We have shown how a bit of reflection allows us to have a compact, yet
  practical, one-stop-shop notation for records, typeclasses, and algebraic
  data types. There are a number of interesting directions to pursue:

  + How to write a function working homogeneously over one variation and having
    it lift to other variations.
    - Recall the ~comap~ from the introductory section was written over
      ~Graph :kind â€µtypeclass~; how could that particular implementation
       be massaged to work over ~Graph :kind ğ“€~ for any ~ğ“€~.

  + The current implementation for deriving termtypes presupposes only one
    carrier set positioned as the first entity in the grouping mechanism.
    - How do we handle multiple carriers or choose a carrier from an arbitrary
      position or by name? =PackageFormer= handles this by comparing names.

  + How do we lift properties or invariants, simple ~â‰¡~-types that â€˜defineâ€™
    a previous entity to be top-level functions in their own right?

Lots to do, so little time.

* COMMENT DSTerms

* COMMENT Old Ideas
** COMMENT Introduction [0/4]                                :boring:unclear:

   + [ ] Show example of a PackageFormer.
         - Demonstrate how: PackageFormer  â‰ˆ  named context + header.
   + [ ] Show example of how it can be used to give a record.
   + [ ] Show how it can be used to give us a homomorphism definition.
   + [ ] What are the pre- and post-conditions of the homomorphism construction?
         - This is what we are trying to solve.

** COMMENT A Grammar for PackageFormer [0/5]               :rather:promising:

   + [ ] Grammar for PackageFormer heading.
   + [ ] Grammar for element datatype.
   + [ ] Grammar for â€œtypesâ€.
     - We clearly cannot use any Agda/MLTT types.
   + [ ] Define a fold for PackageFormer ---the homepage currently calls this ~graph-map~ due to
         the graph theoretic nature of element dependencies.
   + [ ] Prove that this fold preserves well-formedness & well-typedness of PackageFormers.
     - This is the semantics function!
     - *PackageFormers are an M-Set and fold is an M-Set homomorphism!*

       Call this M-Set â€œğ‘·ğ‘­â€.
       1. Two sorts: ~PackageFormer~ and ~Element~.
       2. Action: ~_â—_ : PackageFormer â†’ Element â†’ PackageFormer~
       3. Monoid on ~PackageFormer~
          - Unit: The empty PackageFormer
          - Bop: Union of contexts
            + If they agree on their intersection, then union of element lists;
              otherwise â€˜crashâ€™ by yielding ANN.
            + ANN is the annihilating PackageFormer: It is a postulated value
              that acts as the zero of union.
            - This ensures that a crash propagates and so a union of PF's
                is ANN if any two items conflict.
            - E.g., â€œcrash : PackageFormerâŠ¥ â†’ PackageFormerâŠ¥ â†’ Booleanâ€
                is defined with â€œcrash âŠ¥ x â‰ˆ trueâ€ and symmetrically so.
            - Taking ANN = âŠ¥, as a bottom element; e.g., ~nothing~.
            + Proof outline of associativity:
            - Case 1: No crashes, then ordinary list catenation, which is associative.
            - Case 2: Some two items conflict, then ANN is propagated and both sides equal ANN.

*** Deriving Fold

    1. Define a â€œRight M-Setâ€ ( close, but not really ):
       #+BEGIN_SRC agda
PackageFormer M-Set : Setâ‚ where
   Carrierâ‚     : Set
   Carrierâ‚‚     : Set
   _â—_          : Carrierâ‚ â†’ Carrierâ‚‚ â†’ Carrierâ‚
   âˆ…            : Carrierâ‚
   _âˆª_          : Carrierâ‚ â†’ Carrierâ‚ â†’ Carrierâ‚
   leftId       : {ğ“‹ : Carrierâ‚‚}  â†’  âˆ… â— ğ“‹  â‰¡  ğ“‹
   assoc        : {a b : Carrierâ‚} {ğ“‹ : Carrierâ‚‚} â†’ (a âˆª b) â— ğ“‹  â‰¡  a âˆª (b â— ğ“‹)
 #+END_SRC

    2. Let â„³ denote an M-Set.

    3. For ~fold : ğ‘·ğ‘­ âŸ¶ â„³~ to be an M-Set homomorphism, we are *forced* to have â€¦

    4. Two maps, ~foldáµ¢ : ğ‘·ğ‘­.Carrieráµ¢ â†’ â„³.Carrieráµ¢~
    5. ~foldâ‚~ is a monoid homomorphism
       1. Unitâ‚: ~foldâ‚ âˆ… â‰ˆ âˆ…~
       2. Assocâ‚: ~foldâ‚ (p âˆª q) â‰ˆ foldâ‚ p âˆª foldâ‚ q~
    6. Equivariance:
       ~foldâ‚ (p â— e) â‰ˆ foldâ‚ p â— foldâ‚‚ e~

       \newpage

    7. Since a PackageFormer, by extensionality, can always be expressed
       as a finite sequence of extensions we find:
        #+BEGIN_SRC agda
  foldâ‚ p
= {- Extensionality, with eáµ¢ elements of p -}
  foldâ‚ (âˆ… â— eâ‚ â— eâ‚‚ â— â‹¯ â— eâ‚™)
= {- Equivariance (6) -}
  foldâ‚ âˆ… â— foldâ‚‚ eâ‚ â— â‹¯ â— foldâ‚‚ eâ‚™
= {- Unit (5.1) -}
  âˆ… â— foldâ‚‚ eâ‚ â— â‹¯ â— foldâ‚‚ eâ‚™
= {- M-Set.leftId -}
  foldâ‚‚ eâ‚ â— â‹¯ â— foldâ‚‚ eâ‚™
 #+END_SRC

    8. Whence it seems ~foldâ‚~ is defined uniquely in terms of ~foldâ‚‚~ ---which is unsurprising:
       *PackageFormers are an inductive type!*

    9. TODO: Realise this argument _within_ Agda!

** COMMENT An Application to Universal Algebra                :super_sketchy:
   + [ ] Grammar for the minimal language necessary to form homomorphism contexts.
     - How? What? Huh!?
     - I'm not sure I know what I'm thinking here.
     - I'm trying to â€œknowâ€ what the ~hom~ variational, from the webpage does!
   + [ ] Define a function: ~ğ‘¯ : PFSyntax â†’ List HomoSyntax~.
   + [ ] Show a coherence such as ~ğ‘¯(T â— e) = ğ‘¯ T â— ğ‘¯ e~
         where â— denotes context extension; i.e., append.
     - This would ensure that we have a â€˜modularâ€™ way to define homomorphisms.

   Applications to structures that CS people are interested in?
   - Monoids    â‡ for-loops
   - Graphs     â‡ databases
   - Lattices   â‡ optimisation

     \vfill

** COMMENT Conclusion & Next Steps                                  :sketchy:

   + Initial semantics is enough?
   + Limitations?
   + Dependent-type?
   + A counterexample not covered by the semantics?
   + Soundness?

** space COMMENT newpage                                             :ignore:
   \newpage
** COMMENT Bib                                                       :ignore:

  #+latex: \bibliography{References}
  #+latex: \bibliographystyle{plainnat}
  # latex: \bibliographystyle{ACM-Reference-Format}

** OLD COMMENT Idea: Making Staging Accessible by Generating Partial Evaluators (Short Paper)
*** Abstract                                                         :ignore:
  # Do not use footnotes and references in the abstract!

  #+begin_abstract


    Interpreters are generally written with a syntax first then an interpretation second.
    The relationship between the two is sometimes made explicit by having the
    interpretation function target an existing record type ---e.g., syntactic
    datatype constructors are mapped to semantic projections of record values.
    However, this process only needs the record definition ---all else is needless
    duplication.

    Using ~PackageFormer~, a recent Emacs editor extension to the dependently typed language
    Agda, we demonstrate how partially-static data may be mechanically derived from
    theory presentations. Moreover, we also show how to mechanically obtain
    the necessary tools to work with staged interpreters; namely, automatically deriving
    evaluation functions and notions of ground terms.
  #+end_abstract

   \maketitle
*** Relevant Links
    + [[http://www.cs.tsukuba.ac.jp/~kam/papers/pepm2018.pdf][Program Generation for ML Modules]] --- Kameyama et al.
    + [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.438.6924&rep=rep1&type=pdf][A Gentle Introduction to Multi-stage Programming]] -- Walid Taha
    + [[https://www.cl.cam.ac.uk/~jdy22/papers/partially-static-data-as-free-extension-of-algebras.pdf][Partially-Static Data as Free Extension of Algebras]] -- Yallop et al.
    + [[http://okmij.org/ftp/meta-programming/StagingNG.pdf][Staging Beyond Terms: Prospects and Challenges]] --- Oleg et al.

*** Introduction: The Difficulties of Staging

  + Easy to get things wrong!

*** Automatically Introducing Dynamic Forms

  + A view that adds on variables and forms partial evaluators

  #+BEGIN_SRC agda
data BindingTime : Set where Static Dynamic : BindingTime

{- Aliases -}
Now   = Static
Later = Dynamic
          #+END_SRC

  Then:
  #+BEGIN_SRC agda
{- Given -}
record Magma : Setâ‚ where
  field
    Carrier : Set
    _âŠ•_     : Carrier â†’ Carrier â†’ Carrier

powerâ‚€ : {{â„³ : Magma }} (let M = Magma.Carrier â„³)
      â†’ M â†’ â„• â†’ M
powerâ‚€ x zero    = x
powerâ‚€ x (suc n) = x âŠ• powerâ‚€ x n

instance
  ğ’© : Magma
  ğ’© = record {Carrier = â„•; _âŠ•_ = _Ã—_}

{- Obtain -}

---------------------------------------------------------------------------------------

{- Tree = Magma termtype with injection â€œLeafâ€ -}
data Tree (A : Set) â†’ Set where
   Leaf   : A â†’ Tree A
   Branch : Tree A â†’ Tree A â†’ Tree A

{- Proof obligation -}
instance
   tree-is-magma : âˆ€ {A} â†’ Magma
   tree-is-magma {A} = record {Carrier = Tree A; _âŠ•_ = Branch}

{- Evaluator; terms reduce completely. -}
eval : (â„³ : Magma) â†’ let M = Magma.Carrier â„³
                      in  Tree M â†’ M
eval (Leaf m) = m
eval (Branch l r) = eval l âŠ• evla r

{- An instance of powerâ‚€ -}
powerâ‚ : {A : Set} â†’ Tree A â†’ â„• â†’ Tree A
powerâ‚ x zero    = x
powerâ‚ x (suc n) = Branch x (powerâ‚ x n)

----------------------------------------------------------------------------------------
{- Terms with variables -}
data TreeV (A B : Set) â†’ Set where
   Value    : A â†’ TreeV A B
   Variable : B â†’ TreeV A B
   Branch   : TreeV A B â†’ TreeV A B â†’ TreeV A B

{- Reduction for â€œTreeV String ğ’©â€ may be blocked by variables -}
evalV : (â„³ : Magma) {V : Set} â†’
          let M = Magma.Carrier â„³
          in (V â†’ M) â†’ TreeV M V â†’ M
evalV Ïƒ (Value m)    = m
evalV Ïƒ (Variable v) = Ïƒ v
evalV Ïƒ (Branch l r) = evalV Ïƒ l âŠ• evalV Ïƒ r

{- *NOT* an instance of powerâ‚€; but a generalisation thereof! -}
power : {{â„³ : Magma }} (let M = Magma.Carrier â„³)
      â†’ TreeV M V â†’ â„• â†’ TreeV M V
power x zero    = x
power x (suc n) = x âŠ• power x n
  #+END_SRC

*** Multistaging via PackageFormers

    + How writing different PackageFormers allows us to merely select to what degree we want
      staging to occur; e.g., stageáµ¢.
*** Conclusion and Next Steps

    + Theory?
    + Applications?
    + Pedagogy?

** COMMENT footer                                                    :ignore:

 # Local Variables:
 # eval: (progn (org-babel-goto-named-src-block "make-acmart-class") (org-babel-execute-src-block))
 # compile-command: (progn (org-babel-tangle) (org-latex-export-to-pdf) (async-shell-command "open Paper1.pdf"))
 # End:
