:Construction_site:
#+BEGIN_SRC emacs-lisp :tangle no
(origami-mode)


;; Below ‚Äúmeta-variables‚Äù are quoted...?
(ùí± for x from xs let res become body where local is definition
 = "noice

XS must be a valid Lisp expression denoting a list; e.g.,
(list 1 2 3) or '(1 2 3), but just (1 2 3) would be erroneous.
Likewise, (number-sequence 1 3) is a valid expression denoting a list.

As usual, if DEFINITION is a string, it cannot contain the ‚Äò\‚Äô character;
which is sidestepped via the Unicode character ‚Äò‚ï≤‚Äô.

The arguments FROM, LET, BECOME, WHERE, IS are completely irrelevant.
They only serve to allow users to have *readable* syntax ---and flexibly so.
Here are examples of a valid invocations.

Wordy as in Python:

_ = declare for x in (ùüô ùüö ùüõ) let (format \"CarrierU%s\" x) = (Carrier renaming \"U to ùí∞\") where ùí∞ = (format \"U%s\" x)

Terse as in Haskell:
_ = declare for x ‚àà (ùüô ùüö ùüõ) ‚à∑ (format \"CarrierU%s\" x) = (Carrier renaming \"U to ùí∞\")  ‚áê  ùí∞ = (format \"U%s\" x)

It is important to remember that ‚Äúdeclare‚Äù is not a builtin keyword, it is the name of a PackageFormer
---we have chosen to name the empty PackageFormer ‚Äúdeclare‚Äù as it makes the resulting invocation readable.
The LHS ‚Äú_‚Äù means that this invocation is used for its side-effects, to produce new PackageFormers,
rather than for producing a PackageFormer by altering the given one, ‚Äúdeclare‚Äù.

The LHS could be given any name which then serves to *document* the purpose of the loop;
e.g., ‚ÄúCarrierUùíæ‚üµùíæ‚à∂1‚Ä¶3‚Äù for the above clauses. This is cool: WE HAVE NAMED DECLARATIONS.
"
   :alter-elements (Œª _ ‚Üí

                      (loop for x in xs
                            for local = (regexp-quote (format "%s" 'local)) ;; The quote is in-case the variable name is a regexp operator such as +,?,*, etc.
                            for value = (s-replace "" (regexp-quote "") definition) ;; The quote is in-case the definition results in a regexp callback, such as \1, \\ùíæ, etc.
                            ;; A variable may, ‚Äò?‚Äô, have a quote before or after it;
                            ;; Which we reproduce in the resulting string via ‚Äò\\ùíæ‚Äô, for each match ùíæ.
                            ;; Otherwise, it is a whole word; as delimited by ‚Äò\\b‚Äô.
                            do (pf--load-instance-declaration (format "%s = %s" res (replace-regexp-in-string (format "\\b\\(\"\\)?%s\\(\"\\)?\\b" local) (format "\\1%s\\2" value) (s-join " " (mapcar #'pp 'body))))))

                      ;; return value; LHS has no constiuents.
                      nil))


;; -- defaults
(setq gc-cons-percentage 0.1 gc-cons-threshold 800000 pf-waiting-for-agda-threshhold 14 pf-consider-newly-named-declarations-only nil no-typechecking-please nil pf-multiple-files nil)
;; (setq pf-consider-newly-named-declarations-only t)

;; (profiler-stop) ‚áí Only defined whence profiler start called.
(profiler-start 'cpu) (profiler-stop)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(defun pf--reify-package-formers (orig-fun &rest args)
  "Parse package-former syntax and produce Agda when possible.

ORIG-FUN is intended to be the Agda loading process with arguments ARGS."
  (interactive)
  (let* ((start-time (current-time))
         printed-pfs
        (parent-dir (s-join "/"
                            (-drop-last 1 (s-split "/" buffer-file-truename))))
        (generatedmodule  (pf--generated-file-name))
        (newfile (concat parent-dir "/" generatedmodule ".agda"))
        (parent-imports (pf--extract-imports)))

    ;; ‚Äº
    (profiler-stop)
    (profiler-start 'cpu)

    ;; Load variationals, PackageFormers, instantiations, and porting list.
    ;; Setting the following to nil each time is not ideal.
    (setq	pf--variationals
             (-take-last ‚ôØstandard-variationals pf--variationals)
             ;; take last n items, those being exported into the .el.
             pf--package-formers       (when (or pf-consider-newly-named-declarations-only pf-multiple-files) pf--package-formers)
             pf--annotations           nil)

    (pf--load-pf--annotations)

    (with-temp-buffer
      (goto-char (point-min))

      ;; Copy/paste imports from parent file.
      (insert (s-join "\n" `(
         "{- This file is generated ;; do not alter. -}\n"
         ,parent-imports
         "open import Level as Level using (Level)"
         ,(format "module %s where " generatedmodule))))

     ;; Print the package-formers
      (setq printed-pfs
            (--map (cond
               ((equal 'porting (car it)) (format "%s" (cdr it)))
               ((equal "_" (car it))      "") ;; Anonymous PackageFormers
               (t (format
                (if (equal "PackageFormer" (pf--package-former-kind (cdr it)))
                    (concat "{- Kind ‚ÄúPackageFormer‚Äù does not correspond "
                            " to a concrete Agda type. \n%s\n -}")
                       "%s") (pf--show-package-former (cdr it)))))
             (reverse pf--package-formers)))
      ;;
      (insert (s-join "\n\n\n" printed-pfs))
      ;; (setq package-formers nil) ;; So no accidental

      ;; Replace tabs with spaces
      (untabify (point-min) (point-max))

      (write-region (goto-char (point-min)) (goto-char (point-max)) newfile))

    (pf--insert-generated-import generatedmodule)

    ;; Need to revert buffer to discard old colours.
    ;; (save-buffer) (revert-buffer t t t)

    ;; call agda2-load
    (unless no-typechecking-please ;; ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶
    (apply orig-fun args)

  ;; Agda attaches ‚Äújump to definition‚Äù tooltips; we add to those.
  ;; For some reason we need a slight delay between when Agda is done checking
  ;; and when we can add on our tooltips.
  ;; Attach tooltips only for existing occurrences; update happens with C-c C-l.
  ;; Wait until Agda is finished highlighting, then do ours (‡∏á‡≤†_‡≤†)‡∏á
  (-let [counter 0] ; agda2-in-progress
    (while agda2-highlight-in-progress
      (when (> counter pf-waiting-for-agda-threshhold)
        (error (concat "PackageFormer ‚à∑ "
                       "Items generated, but not coloured; "
                       "Agda seems busy...")))
        (incf counter)
        (sleep-for 0.5))) ;; In case Agda errors on a term, no more waiting.
    (loop for (name . pf) in pf--package-formers
          do (unless (equal 'porting name)
               (pf--tooltipify name (pf--show-package-former pf))))
    ;; Special anonymous names.
    (pf--tooltipify "_" "‚Äú_‚Äù is the name of anonymous PackageFormers, which cannot be elaborated.")

    ;; Let's also add tooltips for the variationals & colour them.
    (loop for (v . docs) in pf--variationals
          do (pf--tooltipify (format "%s" v) docs)
          ;; For beauty, let's colour variational names green.
          ;; Only colour occurances that have a space before or after.
          (when pf-highlighting
            (highlight-phrase (format "[- \\| ]%s " v) 'hi-green)))

) ;; the nil
    ;; (find-file "math-scheme-generated.agda")
    ;; (end-of-buffer)

    ;; ‚Äº
    (profiler-report)

    ;; ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶  ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶ ‚á¶
    (message "PackageFormer (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà All the best coding! %.06f" (float-time (time-since start-time)))))
#+END_SRC
:End:

:Issue:
{-700
PackageFormer RightMonoidAction : Set‚ÇÅ where
    e     : U
    identity_‚ü´_e : U
    toX : let View X = X in View toX ; toX = record {U = U;_*_ = _*_;e = e;S = S;_‚ü´_ = _‚ü´_;identity_‚ü´_e = identity_‚ü´_e}
    toRightUnitalAction     : let View X = X in View RightUnitalAction ;    toRightUnitalAction = record {U = U;_*_ = _*_;e = e;S = S;_‚ü´_ = _‚ü´_;identity_‚ü´_e = identity_‚ü´_e}

RightMonoidùüôAction = RightMonoidAction renaming‚Ä≤ "e to ùüô"
-}
:End:

# paper idea: that manifest idea from the summer!
#
# ~# extended-by ds~
# ‚ü¥ Allow ‚Äòds‚Äô to be a list of elements!
# ‚ü¥ Whence, ~extended-by (elements-of pf)~ tantamount to an unsafe disjoint sum.
#
# ‚ü¥ Look at the NEW tpc semantics.
# ‚ü¥ ‚ÄúTheory {x : ‚Ñï} extended-by {x : ‚Ñù}‚Äù ‚à∑ fails, is undefined; new things must have new names.
# ‚ü¥ magmas to function-magmas via pointwise ‚à∑ need map to do this? See Bill's papers re: IMP and instantiation.
#
# Idea: An elemented may be qualified by private and by field, why not by ‚Äúparameter‚Äù as well?
# This would remove the need for :waist.

# Re: union, what if we wanted to do a pushout on a smaller shared source; smaller than the intersection?
# Need to include an optional argument to account for this!

:Changelog:
+ [X] Remove eval-and-compile and close melpa PR.
+ [X] Reconfigured how instate mixfix support; e.g., AbealianMonoidR to go through.
+ [X] NEW, section on contributions and current state of affairs.
+ [X] NEW, variational for substructures; not yet publicly documented.
+ [X] Switched some variationals to use symbolic names instead of strings as arguments.
      This' achieved by the following approach: All arguments to variationals are
      automatically ‚Äúquote‚Äùed before being passed to the underlying, ùí±- prefixed, lisp function.
+ [X] Accounted for a clever renaming scheme: when R ‚Ü¶ R‚Ä≤, then element names
      such as R-this automatically map to R‚Ä≤-this, and so are consistent
      with expected uses.
+ [X] NEW, 200+ mathscheme theories formalised, elaborating into typecheckable Agda ^_^
+ [X] Added some ideas on semantics to section 2.

- [X] subscript levels are supported in types of PackageFormers.
:End:

# + [ ] C-u C-c C-l ‚áí Generate PackageFormers but do not typecheck.
# + [ ] Provide support for no colouring; in menu.

# ADJOIN-RETRACT·µ¢, for i : 1..2, are the optional names of the resulting morphisms.
# Provide nil if you do not want the morphisms adjoined.

# From Agda's standard library:
# Within IsSemiringWithoutAnnihilatingZero we essentially have ‚ÄúIsCommutativeMonoid opening (Œª n ‚Üí (concat "+-" n))‚Äù,
# as well as ‚ÄúIsMonoid opening (Œª n ‚Üí (concat "*-" n))‚Äù.
# Likewise in IsRing which has the DUPLICATED open-renaming for IsMonoid as mentioned beforehand.

:FIXME:
-- MR‚ÇÅ‚ÇÇ   = M-Set-Record decorated "‚ÇÅ" ‚ü¥ decorated "‚ÇÇ" :adjoin-retract nil
the-MR = M-Set-Record co-decorated "the-"
-- MR‚ÇÉ‚ÇÑ   = M-Set-Record subscripted‚ÇÉ ‚ü¥ subscripted‚ÇÑ :adjoin-retract nil
-- M-Set-R-SV = M-Set-R opening "Scalar to S; Vector to V"

-- Three bugs: extended-by should not allow non-unique names
-- ‚àß should allow definitions of existing names [easy, by showing-existing elements catenated in front of new extensions]
-- ‚àß parse-elements seems to duplicate regexp name ‚Äú_+_‚Äù as also its qualifier!
M‚àû  = Magma extended-by "_¬∑_ : Set; _¬∑_ = ‚ä•" ‚ü¥ PackageFormer
M‚àû‚Ä≤ = Magma extended-by "_+_ : Set" ‚ü¥ PackageFormer
:END:
:more_ideas:
[ ] In abstract, mention how the meta-primitives and provided interface allow the current system
    to be used as a quick-n-dirty sandbox for experimenting on novel concepts of grouping mechanisms
    and operations upon them.

[ ] Provide support for multi-line element parsing, so that ùïÄ-unique looks nice!

[ ] Add to abstract words about extensions, union, flipping, freely created views, PL research is about getting stuff for free,
    and support for equations ---i.e., transport of results via variationals.

[ ] All M-Set-Record instantiations have their resulting Agda, in the user manual, missing the new elements. Go fix this.

[ ] Mention how we solve RATH's duality issue, such as join and meet semilattices using a flipping variational.

[ ] Simplify ùí±-map's ‚Äúf = f‚Äù issue using the ‚Äúlet f = f in‚Äù trick; c.f. ùí±-flip.

[ ] Idea: Add ;-to-lists to union that take optional pushout maps (‡∏á‡≤†_‡≤†)‡∏á
     ‚û© Maybe union takes actual maps, while unioning takes ;-to-list so as to be consisting with renaming and opening.

[ ] In the case of ‚Äúdata‚Äù, ‚äô, we could provide a semantics mapping.
:end:
:org-ref:
 + org-ref :: [[https://github.com/jkitchin/org-ref][An exquisite system]] for handling references.

    If everything works, the following entity will display useful data
    when the mouse hovers over it (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà If you click on it, then you're
    in for a lot of super neat stuff, such as searching for the pdf online!

    cite:agda_overview,tpc
#    cite:agda_overview,tpc,little_theories,mathscheme,RATH,design-patterns-solid

        #+BEGIN_SRC emacs-lisp
(use-package org-ref :demand t)

;; Files to look at when no ‚Äú‚ï≤bibliography{‚ãØ}‚Äù is not present in a file.
;; Most useful for non-LaTeX files.
(setq reftex-default-bibliography (list (f-full "../papers/References.bib")))

(use-package helm-bibtex :demand t)
;; If you use helm-bibtex as the citation key completion method you should set these variables too.

(setq bibtex-completion-bibliography (f-full "../papers/References.bib"))
#+END_SRC

  Execute ~M-x helm-bibtex~ and, say, enter ~agda~ and you will be presented with
  all the entries in the bib database that mention ‚Äòagda‚Äô. Super cool stuff.

:end:

# BEGIN_SRC agda :prologue "{-700" :epilogue "-}"
# ‚Äº User manual: Sections primed-decoration onwards need to account for equations!
# (setq test outsidetest)
# MA: Switch to spacemacs light theme before export.
# (shell-command "ln -s agda-next-700-module-systems.el ~/.emacs.d/agda-next-700-module-systems.el")
# TODO User Manual :Incomplete: ‚á® equations!

#+MACRO: goal @@html:<center><em>@@ $1 @@html:</center></em>@@
:CaseStudy_agda:
{- (load-file "PackageFormer.el") -}

module CaseStudy where
open import CaseStudy_Generated
open import Level
open import Data.Bool renaming (Bool to ùîπ)
open import Relation.Binary.PropositionalEquality using (_‚â°_)

{- To make the exposition easier to read.
   The ‚Äò???‚Äô is whatever the user whishes to
   accomplish in the task at hand; i.e., it's a hole.
-}
postulate ??? : ‚àÄ {‚Ñì} {A : Set ‚Ñì} ‚Üí A

{-700
variable
   ‚Ñì : Level

PackageFormer Monoid (v : Variation) : Set where
    _‚®æ_     : Monoid v ‚Üí Monoid v ‚Üí Monoid v
    Id      : Monoid v
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Monoid v} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Monoid v} ‚Üí x ‚®æ Id ‚â° x

Classical = Monoid typeclass
MonoidOp = Monoid record unbundling 2
MonoidId = Monoid record exposing (Carrier; Id)
Monoid-false = Monoid record with (Carrier to ùîπ; Id to false)

Monoid-m = Monoid typeclass renaming (Carrier to m)
-}

{- M-. on these to see their elaborated forms. -}
_ = Classical
_ = MonoidOp
_ = MonoidId

open Classical using () renaming (_‚®æ_ to Op)

yuck-one :    (X Y : Classical ùîπ)
         ‚Üí  Op X  ‚â° _‚àß_
         ‚Üí  Op Y  ‚â° _‚à®_
         ‚Üí  Set
yuck-one = ???

first-problem : MonoidOp ùîπ _‚àß_  ‚Üí  MonoidOp ùîπ _‚à®_  ‚Üí Set
first-problem = ???

second-problem-okay : (X Y : MonoidId ùîπ false) ‚Üí Set
second-problem-okay = ???

second-problem-better : (X Y : Monoid-false) ‚Üí Set
second-problem-better = ???
:End:
:empty_docs:
#+NAME: docs
#+BEGIN_SRC emacs-lisp :var name = "" :var sep = "\n\n" :results replace :tangle no
#+END_SRC
:end:

# [ ] We have morphisms from children presentations to their parents, but sometimes these are invertible.
#    We can also form the inverses. Something to consider.

# [ ] primed is broken!
#
# -- Magma‚Ä≤    = Magma primed  ‚ü¥ record
# -- SumMagmas = Magma union Magma‚Ä≤ :adjoin-retract‚ÇÅ nil ‚ü¥ record

# [ ] ‚Äú-ensure‚Äù and ‚Äú-wf‚Äù ??? Prefix ‚Äúpf-‚Äù?
#
# [ ] mention unbundling in user pt I; see case study above.

* COMMENT Experiments
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-Experiments
  :END:
** A Better ‚Äúensure‚Äù operation
   :PROPERTIES:
   :CUSTOM_ID: A-Better--ensure--operation
   :END:
#+BEGIN_SRC emacs-lisp
; ($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì "Magma")
; (format "%s" (nth 1 (backtrace-frame 2))) ;; get's name of most recent function called

  (defmacro Dpf--ensure (condition message context &rest suggestions)
  "Ensure provided CONDITION is true, otherwise report an error.
<<docs('ensure)>>"
  `(let* ((·Éö\(‡≤†Áõä‡≤†\)·Éö
           (format "700: %s\n\n\t‚á®\t%s%s%s" ,message ,context
                   (if (quote ,suggestions) "\n" "")
                   (s-join "\n" (--map (format "\t‚á®\t%s" (s-collapse-whitespace it))
                                       (list ,@suggestions)))))
          ;; Try to evaluate the condition.
          (res (condition-case nil ,condition (error ·Éö\(‡≤†Áõä‡≤†\)·Éö))))

     ;; If we've made it here, then the condition is defined.
     ;; It remains to check that it's true.
     (or res (error ·Éö\(‡≤†Áõä‡≤†\)·Éö))))

(defmacro ALTERNATE-pf--ensure (condition message context &rest suggestions)
  "Ensure provided CONDITION is true, otherwise report an error.
nil"
  `(let* ((debug-on-error t)) ;; Errors are shown in mini-buffer, not in *Backtrace* buffer.

     (or (condition-case nil ,condition
         (error            (format "700: %s\n\n\t‚á®\t%s%s%s" ,message
                   (if (not (consp ,context))
                       ,context
                     (goto-char (point-min)) (search-forward (car ,context)) (s-trim (thing-at-point 'line 'no-properties))) ;; if context is singleton list, use car as keyphrase for current line ^_^
                   (if (quote ,suggestions) "\n" "")
                   (s-join "\n" (--map (format "\t‚á®\t%s" it)
                                       (list ,@suggestions))))
         )))))

#+END_SRC

** anonymouse PF -- wip
   :PROPERTIES:
   :CUSTOM_ID: anonymouse-PF----wip
   :END:
#+BEGIN_SRC agda
{-lisp
(defmacro the-pf (decls)
  `(progn (pf--load-package-former (cons "PackageFormer _ : Set where" (s-split ";" ,decls)))
  "_") ;; return name of the anonymous PackageFormer
)
-}

{- 700
-- ‚û© NEW, Support for anonymous PackageFormers.

PackageFormer the : Set where
-- ùí±-pf decls = extended-by 'decls :adjoin-retract nil

_ = M-Set
A = Empty union (the-pf "A : Set")
-- A = the-pf "A : Set" ‚ü¥ union (the pf "B : Set")

-- re: shift to auto-quoting args:
-- union checks its argument: if consp, then eval; else invoke directly.
-}
#+END_SRC

* COMMENT Issues to fix
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-Issues-to-fix
  :END:

+ [ ] Crashes for some reason, why !? Somethingto do with the printing of pfs?

      This won't work, why? Something to do with printing?

       MR   = M-Set primed
       MS‚ÇÉ‚ÇÑ = M-Set ‚ü¥ subscripted‚ÇÉ

+ [ ] hom: ‚û© $ùëùùëéùëüùëíùëõùë°‚Ä≤ should be defined as a module opening. eek!
+ [ ] Remove *parent-context*!
  * There is an implementation key, ~*parent-context*~, which is used to
   capture the current context for error-reporting purposes and should
   not be altered by the user ---otherwise they may obtain less than helpful
   error messages.
+ [ ] One of the allowable ‚Äútypes‚Äù should be any PackageFormer kind?
+ [ ] That way we have a basic form of nested modules?
+ [ ] the flattening of hierarchical structures can be formed;
+ [ ] ‚Äº Nesting of PackageFormers; e.g., data declarations delimited by module declarations.
+ [ ] Maybe an element may be an item that begins with PackageFormer/record/data/module?
+ [ ] *Super Important*

     ‚áã For now, in this document, I will demonstrate how the provided meta-primitives
     may be used to form the above excluded the following, which the reader may
     form their self, or await the next edition of this document. ‚áã

     ‚ü± Not demonstrated: Syntax, UntypedSyntax, Stream, VectorSyntax.

     ‚ü∞ I doubt the outermost two would be any difficulty for the reader;
     the inner two may require some familiarity with the code-base or Lisp.

** Wish List :Not_Immediate:
   :PROPERTIES:
   :CUSTOM_ID: Wish-List
   :END:

+ [ ] Fix_porting_issue:

  {- (Ideally, does not yet work)

  -- The next two lines are not 700-syntax and so are ported over to the generated file.
  variable
     the-‚Ñì : Level
  -}

+ [ ] Changing a variational, then loading still has the old tooltip?

+ [ ] \begin{lisp} & \begin{700}

+ [ ] Add :precondition key so that variational users can perform a check
  on the coherency of a variational. E.g., the homomorphism construction
   needs to be invoked on a record.

  Maybe not; something to consider.?

** Experiments for User Manual and a TODO
   :PROPERTIES:
   :CUSTOM_ID: Experiments-for-User-Manual-and-a-TODO
   :END:

-- TODO: FIXME: !!!!!!
{- 00
ùüô-et-al = M-Set record ‚ü¥ keeping :those "ùüô; _√ó_"
-}

-- _ = ùüô-et-al

-----------------------------------------------------------------------------------------

-- Here's some cuteness. ;; need to fix porting to happen in-place rather than at the top.

-- Desired:
{- 00
variable
  Src Tgt : M-Set-R

-- this comment should be ignored; why is it being ported!?
-}

{-
-- PackageFormer place-holder-so-next-line-doesnt-get-ported : Set where

Remember that ‚Äòopening‚Äô is a lossy operation; it is terminal and so
something like
‚ÄúHom-D = Hom opening :with "map‚ÇÅ to _D‚ÇÄ_" ‚ü¥ :waist 3‚Äù
has no meaning. We cannot lift ‚Äòfields‚Äô to ‚Äòparameters‚Äô since an ‚Äúopening‚Äù
has lost the necessary type information for the elements.

If we want something to be parametersied; we will use Agda's generalised variables mechanism. (For now).
-}

-- _ = Hom-$

{- works

variable
  A B : M-Set-R

module Hom-D (‚Ñõ : Hom A B) where
  ‚ãØ
-}

-----------------------------------------------------------------------------------------
--- ¬ß9. Algebraic Data Types

{-lisp
(ùí± data carrier
  = :kind data
    :level dec
    :alter-elements (lambda (fs)
      (thread-last fs
        (--filter (s-contains? carrier (target (get-type it))))
        (--map (map-type (s-replace carrier $ùëõùëéùëöùëí type) it))))
)
-}

{-00
ScalarSyntax  = M-Set primer ‚ü¥ data :carrier "Scalar‚Ä≤"
ScalarTerm    = M-Set data :carrier "Scalar" ‚ü¥ primer

-- Example of erroenous invocations.
-- Crashes since type No‚Ä≤ is not defined!
-- No = M-Set primer ‚ü¥ data :carrier "Scalar"

-}
-- _ = ScalarSyntax
-- _ = ScalarTerm

-- TODO:
-- What about syntax of vectors? Well that depends on scalars!

{-lisp
(ùí± data-with-params carrier
  = :kind data
    :level dec
    :alter-elements (lambda (fs)
      (thread-last fs
        (--filter (s-contains? carrier (target (get-type it))))
        (--map (map-type (s-replace carrier $ùëõùëéùëöùëí type) it))))
)
-}

-- ‚Äúdata with params‚Äù
-- VectorSyntax  = M-Set data :carrier "Vector" ‚ü¥ primer

------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
-- Experiments follow --

{-
-- ùí±-data-with-identified carrier = :kind data :level dec :alter-elements (lambda (fs) (thread-last fs (--filter (-any? (lambda (c) (s-contains? c (target (get-type it)))) carrier)) (loop for c in carrier do (--map (map-type (s-replace c $ùëõùëéùëöùëí type) it)) )))

ùí±-data-with-identified carrier = :alter-functions (lambda (f) (message-box "HELLO"))

M-Set‚Ä≤ = M-Set record ‚ü¥ primed

M-Set-Syntax = M-Set‚Ä≤ data-with-identified :carrier (list '(list "Scalar"))
-}


{-00

ùí±-data-with carrier      = map :elements (lambda (f) (when (s-contains? carrier (target (get-type f))) (map-type (s-replace carrier $ùëõùëéùëöùëí type) f)))

MonoidD   =  MonoidP data-with :carrier "Carrier"

-}

{- TODO
PackageFormer MonoidP : Set‚ÇÅ where
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier

    left-‚®æ  : Carrier ‚Üí Carrier ‚Üí Carrier ‚Üí Carrier
    left-‚®æ x y z = (x ‚®æ y) ‚®æ z

    assoc   : ‚àÄ {x y z} ‚Üí left-‚®æ x y z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x

- record ‚áí local intersped with fields
- data  ‚áí rewrite [syntax sugar] and possibly global operation afterwards as an additional new method, and possibly adding it in as a constructor to the data-type, eg. See Isabelle's distinctions of definition vs abbrevation where the former rewuires an explicit tactic to apply as in coq's intro and the latter is definitional.
- module ‚áí local let, or possibly rewrite with local declaration inside module

-- MonoidR   =  MonoidP :kind record :waist 2 :level dec ‚ü¥ :waist-strings ("private" "n : Set‚ÇÅ" "n = Set" "field")
-- MonoidD = data-with :carrier Carrier
-}

{-
ùí±-record‚Å∑             = :kind record :waist-strings (when (package-former-elements self) '("field"))

ùí±-data-with carrier      = :kind data :level dec :alter-elements (lambda (f) (if (s-contains? carrier (target (get-type f))) (map-type (s-replace carrier $ùëõùëéùëöùëí type) f) ""))

ùí±-filter-attempt by = map :elements (lambda (f) (if (funcall by f) f ""))
MonoidF   = MonoidP filter :by (lambda (f) nil)

-- TODO: 7 crashes things --yikes! This is because agda keyword field cannot occur barren --c.f. ùì•-record‚Å∑.
-- MonoidT‚Å∑ = MonoidP record ‚ü¥ :waist 4
-}

------------------------------------------------------------------------------------------
-- Observations

{-00
-- MA: TODO: Useful example to know how to do. Maybe fix this whole quotation issue!
ùí±-try this = decorated :by '(car this)
Ni = M-Set record ‚ü¥ try :this '(list "·µ¢" "‚±º" "‚Çñ")

-}
-- _ = Ni

-- Passed functions need the quote.
-- E.g.,
-- ùí±-keeping those = generated :by 'those

** Matter ripped out from Paper0 -- may be useful
   :PROPERTIES:
   :CUSTOM_ID: Matter-ripped-out-from-Paper0----may-be-useful
   :END:
(ùí± record (discard-equations nil)
  = "Reify a variational as an Agda ‚Äúrecord‚Äù.

     Elements with equations are construed as
     derivatives of fields  ---the elements
     without any equations.

     Or do we want to treat them as fields, some
     or all?
    "
  :kind record
  :alter-elements
     (Œª es ‚Üí
       (thread-last
       (if discard-equations
           (--map (map-equations (Œª _ ‚Üí nil) it) es)
          es)
       (--map (map-qualifier
         (Œª _ ‚Üí (unless (element-equations it) "field")) it) es))))

-- ripped out of Paper0.agda
--
-- may have useful content
--
{-  lisp
(ùí± maybemap elements = :alter-elements (lambda (fs)
   (let* ((fsnew (mapcar elements fs))
          sep
          it‚Ä≤
          (names  (--map (s-replace "_" "" (get-name it)) fs))
          (names‚Ä≤ (--map (s-replace "_" "" (get-name it)) fsnew)))
     (loop for old in names
           for new in names‚Ä≤
           for i from 0 to (length fs)
           do
           (setq fsnew
                 (--map
                   (progn
                     (setq sep (if (s-contains? "=" it) "=" ":"))
                     (setq it‚Ä≤ (s-split sep it))
                     (setf (cdr it‚Ä≤) (s-join sep (cdr it‚Ä≤)))
                     ;; If old has _ in it, then account for forms with all _ in them or none in them (which is handled by the previous clause.)
                     (setf (cdr it‚Ä≤) (replace-regexp-in-string (format "\\b%s\\b" (regexp-quote old)) new (cdr it‚Ä≤) t))
                     (when (s-contains? "_" (nth i fs))
                          (setf (cdr it‚Ä≤) (s-replace (get-name (nth i fs)) (get-name (funcall elements (nth i fs))) (cdr it‚Ä≤))))
                     (format "%s%s%s" (car it‚Ä≤) sep (cdr it‚Ä≤))) fsnew)))
     ;; return value
     fsnew
     )))
-}
--
-- ‚Äú\\b‚Äù matches the empty string, but only at the beginning or end of a word.
-- Thus, ‚Äú\\bfoo\\b‚Äù matches any occurence of ‚Äúfoo‚Äù as a seperate word, without any
-- prefix or suffix.
-- E.g., (replace-regexp-in-string "\\bT\\b" "NEW" "T and T‚ÇÄ ‚àÄ {and : T} but not ‚ÄµT End." t)

** Changelog
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-Changelog
   :END:

‚û© NEW variational: Extension.
  The resulting extended theory comes with a FREE view to the old, parent, theory.

‚û© NEW variational: Union.
  The resulting extended theory comes with two FREE views to the old, parent, theories.

‚û© NEW variational: Flipping.
  The variational supports renaming of dualised concepts.
  The resulting extended theory comes with a FREE view to the old, parent, theory.

‚û© Resurrected variational: keeping.
  Essentially an opposite of extend-by.
  This lets us perform little theories after the fact; c.f. user manual part I.

‚û© Fixed bug regarding barren top-level PackageFormers; e.g.,
  ‚ÄúPackageFormer Empty : Set‚ÇÅ where‚Äù now parses correctly.

‚û© Split up user manual into multiple sections.
  First section is motivational; inspired by ¬ß2 of Theory Presentation Combinators paper.
  Second section is now for more ‚Äòadvanced‚Äô issues.

‚û© A listing of variationals borne from the 5 meta-primitives is added to the user manual.

‚û© Fixed bug with renaming: It was an issue with ùí±-map.

‚û© ùí±-map now accounts for view morphisms: Items of the form ‚Äúf = f‚Äù only have RHS instance altered.
  Moreover, it /optionally/ produces retract morphisms! ^_^

‚û© Experimented with Emacs Lisp namespacing.
  I wish Elisp had proper modules; this issue will stall the melpa release of this system.

 ### Backend ###

 + [X] Added ‚ÄúŒª x ‚Üí ‚ãØ‚Äù macro to reduce burden for Agda users in using Lisp.
 + [X] Typed-name string pairs have been replaced with the ‚Äúelement‚Äù datatype.
       Which comes with projections ‚Äúelement-X‚Äù and map operations ‚Äúmap-X‚Äù,
       as well as a number of other useful functions I needed: replace, parse, etc.
       ‚û© Updated prototype to make use of this type instead of string typed-name pairs.
 + [X] Awkward ‚Äúwaist-strings‚Äù replaced by natural ‚Äúelement‚Äù datatype.
 + [X] The ‚Äú:key value‚Äù syntax is no longer forced onto the user.
       Instead, all arguments are positional unless enclosed in parenthesis
       possibly along with a default value, then they are accessed as key-value pairs.
       ‚û© The telescope style to arguments was suggested by Wolfram.
 + [X] Have begun using ‚Äúdeclare-type‚Äù as a typing mechanism; unsure about this
       since it cannot yet handle arguments mentioning ‚Äú:‚Äù, and also no convenient
       way to temporarily rid a function of a fixed type. Things to consider improving.
 + [X] Switched to /copying/ $ùíÜùëôùëíùëöùëíùëõùë°ùë† rather than exposing them directly, so that
       shared memory locations are not altered accidentally.
 + [ ] Tried to add support for lagda files ---still does not work as desired; not exposed.
 + [X] Tooltips do not affect subwords, only whole words.

 ### User manual ###
 + [X] Switched to a literate approach for examples: All examples tangle to legitimate
       Agda files, which can easily be checked with C-c C-l.
       As such, it's easy to ensure all examples are up-to-date ^_^
 + [X] New section on empty variationals that aims to document all possible things
       with variationals ---including user documentation and optional arguments ^_^
 + [X] Updated nearly all of user manual to reflect the new structure of the
       prototype.
 + [X] Keeping track of a ‚Äústandard library‚Äù of useful variationals to export with
       the prototype (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà
       ‚û© They all come with useful documentation as well as some optional arguments
         for exceptional circumstances.
 + [X] New variationals:
   - [co-]decorated :: Renaming by simple provided decorations.
   - subscripted·µ¢ :: Renaming by a subscript ùíæ.
   - primed :: Renaming by a prime.
   - single-sorted :: Collapse a multisorted structure by identifying all sorts.
   - data :: What the gpce19 paper calls termtype; perhaps ought to provide it as an alias.
   - exposing :: Which is misnamed, it should be unbundling, as in the gpce19 paper.

 ## Webpage ###
 + [X] New and stylish webpage style ^_^
 + [X] All headings now have reasonable HTML anchors.


 TODO:
 + [ ] Noticed ~M-Set ‚ü¥ subscripted‚ÇÉ~ crashes for some reason, possibly due to a printing
       error.

 + [ ] Remove global ~*parent-context*~; it's unsued.

 + [ ] Incorporate record-with-discard-equations into user manual.
       ‚û© What about all the existing variationals.
       ‚û© Revise main example to include equations, as in the gpce19 paper.
         ‚û© Perhaps some derived properties of M-Sets?

 + [ ] Add the necessary ‚Äúquote‚Äù in the definition of ùí±ùí∏ so that arguments passed to
       other variationals need not be quoted. This is a bug that exposes how ùì• works!

 + [ ] Add support for \begin{lisp}   and \begin{700}
  -----------------------------------------------------------------------------------------

 [X] Formed variationals ~termtype~ and ~termtype-with-variables~ for syntactic types.
 [X] Variationals may now have optional documentation, viewable with ‚ÄúC-h o‚Äù ^_^
     [X] Even better, such docs are displayed as tooltips (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà
 [X] Elaborated code is attached to its named declaration via tooltips.
 [X] Formed variationals ~record‚Çë~ and ~termtype‚Çë~ that extend the non-‚Çë counterparts by accounting for equations.
 [X] Paper0.agda now contains real working code for all the examples mentioned in Paper0, and then some ;-)
   - E.g., the ‚Äúconcat·µ¢‚Äù are now generated from a *single* definition (‡∏á‡≤†_‡≤†)‡∏á
   - Added an appendix in response to editorial remarks.
 [X] Extended the ‚Äúmap‚Äù variational to accomodate PackageFormers with equations. ‚ô•‚Äø‚ô•

 -----------------------------------------------------------------------------------------

   All issues have been addressed.

   [X] Added a top-level link to this document from 700 github.io website.

   [X] Added new menu item: A bare-bones presentation of a file, with 700-annotations
       stripped out, is now provided.

   [X] Moved prototype material into its own directory ---tackling issue #5.

   [X] Included a comment in ¬ß2.9 addressing issue #10 to reduce ambiguity.

   [X] Trying a different colour scheme for the exported HTML
       ---exporting in spacemacs-light theme.

   [X] The meta-primitive is ‚Äú:kind‚Äù, not  ‚Äú:type‚Äù which is an overloaded word.
       The codebase and examples now refer to the former exclusively;
       addersing issue #7.

   [X] Added further docs to ¬ß2.5/2.6 to clarify that the main difference between
       the two is that the former does things directly, whereas the latter uses
       composition instead. This addresses issue #9.

   [X] Issue #8 has been addressed. A new todo has been added:
       ‚Üí Examples from the user-manual
         should be exported into an Agda file which is then easily checked;
         or the resulting generated code should be generated when export happens.

 -----------------------------------------------------------------------------------------

   [X] Lots of cleaning at the backend.
       ‚Üí *Sequential* porting currently broken.

   [X] Added two new menu items for locating variationals and PackageFormers.

   [X] Added menu item for folding away ‚Äú700‚Äù and ‚Äúlisp‚Äù blocks.

   [X] Begun updating Paper0

   [X] NEW, Paper0.agda for implementations of the code in Paper0.agda (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

   [X] Colouring in PackageFormer syntax is now enabled.

 -----------------------------------------------------------------------------------------

   [X] Updated user manual; new derived constructs include ~open, open-with~.
       These required we expose a new reference: $ùëùùëéùëüùëíùëõùë°.

   [X] Demonstrated how homomorphism constructions may be automated; as well
       as how /easily/ alter automted names with user-provided names!

   [X] Introduced ~rename_~ and ~renaming_~ for rewrites that provide no special attention to underscores.

   [X] ~waist-strings~ expressions now needen't be quoted /and/ may have
       arbitrary Lisp expressions as elements (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

       This was necessary for the homomorphism construction to be
       sufficiently generic.

 -----------------------------------------------------------------------------------------

   [X] Now parsing {-lisp -} comments; which must contain a single Lisp form
       ---or multiple if enclosed in a progn.

   [X] Updated user manual; improved definition of /derived/ construct ~map~.
       New derived constructs include: ~renaming, rename, [co]decorated~;
       as well as ~single-sorted, generated~.

   [X] Composition, ‚ü¥, now actually composes variationals!
       Non-functional primitives are overwritten,
       alteration primitive is composed sequentially.

   [X] Introduced reference $ùëíùëôùëíùëöùëíùëõùë°ùë†. Used this to derive primitive ~signature~.

 -----------------------------------------------------------------------------------------

 1. Dropped the *builtin* variation tags, ‚Äòv‚Äô,
    in-favour of *extensible* ‚Äúvariationals‚Äù
    ---which may even have arguments! ‚ô•‚Äø‚ô•

    ‚Üí ¬ß2.3 demonstrates how to use meta-primitives to
      form common built-in operations.
    ‚Üí ¬ß2.4 uses the variationals from ¬ß2.3 to solve
      a common problem.

    The monster functions ‚Äúinstantiate‚Äù and ‚Äúreify-package-formers‚Äù
    are now much much more manageable: All the built-in logic to
    cater to particular operations on grouping mechanisms has been
    thrown away in favour of a general template.

 2. Solve the single-sorted problem.
    ‚Üí Motivating example in ¬ß1 is now two sorted!
    ‚Üí ¬ß2.3 shows how it can be used and even reduced to a single sort.

 3. Massive re-organisation:
    ‚Üí At the document level
    ‚Üí At the code level
    ‚Üí At the design level
      ‚û± The presentation of PackageFormers has changed from that in
        the thesis proposal and in Paper0.

** TODO Feedback
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-Feedback
   :END:
   :PROPERTIES:

   :END:

 [X] Could I get an option to generate a more 'bare' agda, i.e. stripping
 out the 700-commands? [I agree with the default of keeping them in]

 [X] I really like the care in the error reporting (section 2.3)

 [X] the very 90s-web colour choices do get quite tiring...  The colour
 differences of the 3 lines of text at the end of 2.3 is almost
 imperceptible.

    ‚û± MA: Switch to spacemacs theme before export.

 [ ] the "level dec" (and "level inc") feature is nice and also too
 low-level. This one is definitely worth thinking about more.

 [ ] I still heavily disagree with your naming of this as 'typeclass'. It
 is as much an illusion as input/output in relations.

 [ ] :alter-elements is some serious syntactic meta-programming! That one's
 going to be hard to generalize. But it is also worth thinking about.

 [ ] 2.7 "Records provide a semantics, what if we want the syntax?" While I
 100% agree with you, this is kind of a short-hand means of communication
 that works within a small group of people at McMaster, and that might be
 it. For external understandability, you're going to greatly expand on
 what you mean here.

 [ ] The reasoning in "Forming syntax" is sound - but how to go from that
 into something that makes sense at a higher level is tricky. You might
 want to read a textbook or two on Universal Algebra, and see how they
 deal with Term Algebras.

 [ ] 2.8 Nice. And many of the comments above apply.

 [ ] 2.9 ":level none" seems to be a serious hack to deal with modules vs
 records!  But the feature is very cool.

 [ ] 2.10 does clearly points to the need of dealing with "dependency
 graphs" when you move beyond syntactic meta-programming. But the reward
 is definitely non-trivial.

 [ ] 2.11 nice. You should compare with the same idea in Universal Algebra.
 And think of how to do this without so much syntax munging.
    But I agree, quite cool.

    Here's a very (very!) hard test: From Category, apply homomorphism
 once to get Functor, again to get NaturalTransformation, again to get
 Modification, again to get perturbation (Functor is a 0-transfor,
 pertubations are 3-transfors; there's a nice periodic table at
 https://ncatlab.org/nlab/show/transfor).

 [X] Won't comment on sections 3,4,5,6,7 in detail as these are
 implementation details of the prototype. They are excellent to see all
 spelled out like this. The important part is to really understand the
 meaning of the stuff in section 2.

 [ ] It's going to be worth prioritizing that Future Work section.

 [ ] Last meta-comment: this is a very operational description of the work,
 which is great for a tutorial. You need to also start thinking about
 bringing in stronger motivation for the usefulness of the various
 pieces. All your examples might be self-evident to you, but never assume
 that of your reader.

 [X] Summary: very cool. Solid progress in the right direction. Continue!

** Random content to inspect
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-Random-content-to-inspect
   :END:

  # Breaks since I'm not allowing ‚Äú:‚Äù in variationals since it acts as an invocation to the meta-primitives.
  #
  # :alter-elements (Œª f ‚Üí (s-contains? pf-name (target (cadr (s-split \":\" f))))) "

  # Old tests
 :all_argument_test:
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"ùí±-test arg‚ÇÄ arg‚ÇÅ arg‚ÇÇ a‚ÇÉ a‚ÇÑ = :kind arg‚ÇÄ :waist arg‚ÇÅ :waist-strings arg‚ÇÇ :level a‚ÇÉ :alter-elements a‚ÇÑ "))
  (setq variationals nil)
  (pf--load-variationals)

(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "NewName = M-Set test :a‚ÇÑ ((lambda (x) (concat \"‚ÇÇ\" x))) :a‚ÇÉ (inc) :arg‚ÇÄ (record) :arg‚ÇÅ (1) :arg‚ÇÇ ((\"field BdRO\"))")))

  ; (instance-declaration-alterations mid)
  (instantiate mid)
))
 #+END_SRC

 #+RESULTS:
 #+BEGIN_src results-agda
{- NewName = M-Set test :a‚ÇÑ ((lambda (x) (concat "‚ÇÇ" x))) :a‚ÇÉ (inc) :arg‚ÇÄ (record) :arg‚ÇÅ (1) :arg‚ÇÇ (("field BdRO")) -}
record NewName (‚ÇÇScalar : Set) : Set‚ÇÇ where
 field BdRO
   ‚ÇÇVector  : Set
   ‚ÇÇ_¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
   ‚ÇÇùüô       : Scalar
   ‚ÇÇ_√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
   ‚ÇÇleftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   ‚ÇÇassoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
 #+END_src
 :End:
 :using_‚ü¥_:
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"ùí±-test kind  = :kind kind
ùí±-test‚Ä≤ height = :waist height
"))
  (setq variationals nil)
  (pf--load-variationals)

(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "NewName = M-Set test :kind 'module ‚ü¥ test‚Ä≤ :height (3)")))

  ; (instance-declaration-alterations mid)
  (instantiate mid)
))
 #+END_SRC

 #+RESULTS:
 #+BEGIN_src results-agda
{- NewName = M-Set test :kind (module) ‚ü¥ test‚Ä≤ :height (3) -}
module NewName (Scalar : Set) (Vector : Set) (_¬∑_ : Scalar ‚Üí Vector ‚Üí Vector) : Set‚ÇÅ where
   ùüô       : Scalar
   _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
 #+END_src
 :End:
 :more_anonymous_testing:
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"ùí±-test        = :kind record ‚ü¥ test‚Ä≤ :height 2
ùí±-test‚Ä≤ height = :waist height
"))
  (setq variationals nil)
  (pf--load-variationals)
)
(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "LHS = M-Set test ‚ü¥ :level dec")))

  ; (instance-declaration-alterations mid)
  (instantiate mid)
))
 #+END_SRC

 #+RESULTS:
 #+begin_src results-agda
{- LHS = M-Set test ‚ü¥ :level dec -}
record LHS : Set where
   Scalar  : Set
   Vector  : Set
   _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
   ùüô       : Scalar
   _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
 #+end_src
 :End:

 TODO: Put with user manual.
 Re: renames/maps
 #+BEGIN_SRC emacs-lisp
;; Could ty this into renaming, but avoiding such entaglement for now.
;; Stick all renames ‚Äúso far‚Äù in front of each declaration.

;; (setq x a y b) ‚áí b

; (setq _xs nil)
;; (push x xs)  ‚áí  updated xs

(insert (format "%s"
(funcall
(lambda (fs)
    (-as-> (-unzip (--zip-with `(,other  ,(format "let %s = %s in " (get-name it) (get-name other))) fs (--map (map-name (concat name "‚Ä≤") it) fs))) yup
           (--zip-with (map-type (concat (s-join "" it) type) other) (-inits (cadr yup)) (car yup))))

'( "a : Set" "b : Set" "c : Set"))))


(a‚Ä≤ : Set
 b‚Ä≤ : let a = a‚Ä≤ in Set
 c‚Ä≤ : let a = a‚Ä≤ in let b = b‚Ä≤ in Set)
 #+END_SRC

 TODO: Dropping after a map wont work well since the map would have created a local let; so need to remove from the lets!
 To accomodate for let-clauses we need to get the type, then drop all clauses of the form ‚Äúlet l = r in‚Äù
 where ‚Äúl‚Äù is not in the yeses list.

 #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
;   "ùí±-primed-record = :kind record :waist-strings (\"field\")
(pf--load-variational "ùí±-primed-record = :kind 'module ‚ü¥ :level 'inc :alter-elements (lambda (f) (map-name (concat name \"‚Ä≤\") f))")
(setq package-formers nil)
(load-package-former (second (get-children "PackageFormer" test)))
(load-instance-declaration "NewNamfe = M-Set primed-record ‚ü¥ :kind 'record :waist 2 :waist-strings (\"field\")")
 #+END_SRC

 HERE TODO: testing data HERE
    #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(setq package-formers nil)
(load-package-former (second (get-children "PackageFormer" test)))

;; TODO: UHOH: Write now I'm overwriting things rather than composing!
;; The following are exepcted to be equal but are only the last variational!
; (load-instance-declaration "M‚ÇÅ  =  M-Set ‚ü¥ primed ‚ü¥ data :carrier \"Scalar\"" 'show-me)
(load-instance-declaration "M‚ÇÇ  =  M-Set ‚ü¥ data :carrier \"Vector\" ‚ü¥ primed" 'show-me)

(load-instance-declaration "M‚ÇÅ‚ÇÇ  =  M-Set decorated :by \"‚ÇÅ\" ‚ü¥ decorated :by \"‚ÇÇ\"" 'show-me)
 #+END_SRC

 #+RESULTS:
 #+begin_src results-agda
{- M‚ÇÅ‚ÇÇ  =  M-Set decorated :by "‚ÇÅ" ‚ü¥ decorated :by "‚ÇÇ" -}
PackageFormer M‚ÇÅ‚ÇÇ : Set‚ÇÅ where
   Scalar‚ÇÅ‚ÇÇ : Set
   Vector‚ÇÅ‚ÇÇ : Set
   _¬∑‚ÇÅ‚ÇÇ_ : Scalar‚ÇÅ‚ÇÇ ‚Üí Vector‚ÇÅ‚ÇÇ ‚Üí Vector‚ÇÅ‚ÇÇ
   ùüô‚ÇÅ‚ÇÇ : Scalar‚ÇÅ‚ÇÇ
   _√ó‚ÇÅ‚ÇÇ_ : Scalar‚ÇÅ‚ÇÇ ‚Üí Scalar‚ÇÅ‚ÇÇ ‚Üí Scalar‚ÇÅ‚ÇÇ
   leftId‚ÇÅ‚ÇÇ : {ùìã : Vector‚ÇÅ‚ÇÇ}  ‚Üí  ùüô‚ÇÅ‚ÇÇ ¬∑‚ÇÅ‚ÇÇ ùìã  ‚â°  ùìã
   assoc‚ÇÅ‚ÇÇ : {a b : Scalar‚ÇÅ‚ÇÇ} {ùìã : Vector‚ÇÅ‚ÇÇ} ‚Üí (a √ó‚ÇÅ‚ÇÇ b) ¬∑‚ÇÅ‚ÇÇ ùìã  ‚â°  a ¬∑‚ÇÅ‚ÇÇ (b ¬∑‚ÇÅ‚ÇÇ ùìã)
 #+end_src

 TODO: testing renames
 #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(pf--load-variational "ùí±-rename expr = :alter-elements '(lambda (fs) (-as-> (-unzip (--zip-with `(,other  ,(format \"let %s = %s in \" (get-name it) (get-name other))) fs (mapcar (eval expr) fs))) yup (--zip-with (map-type (concat (s-join "" it) type) other) (-inits (cadr yup)) (car yup))))")
(setq package-formers nil)
(load-package-former (second (get-children "PackageFormer" test)))
(load-instance-declaration "NewNamfe = M-Set :waist 2")
 #+END_SRC

 TODO:
 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
;; (load-instance-declaration "LHS = PF :arg‚ÇÄ val‚ÇÄ ‚ü¥ test‚ÇÅ :heightish 23")

     ;; PackageFormer names are in yellow; instances are are bolded.
     ;; (highlight-phrase (format "%s " (nth 2 pieces)) 'hi-yellow)
     ;; (highlight-phrase (nth 0 pieces) 'bold) ;; 'warning) ;; i.e., orange
     ;;
     ;; MA: Replace with a hook.
 #+END_SRC

 TODO: load instance declaratin tests.
 {{{fold(Tests)}}}
 #+BEGIN_SRC emacs-lisp :tangle no
(ert-deftest lid ()

  (let (id)

  ;; Anonymous variational
  (setq id (load-instance-declaration "LHS = PF :arg‚ÇÄ val‚ÇÄ ‚ü¥ var‚ÇÅ :arg‚ÇÅ val‚ÇÅ"))

  ;; Basic invocation shape
  ;; ‚Äúto‚Äù! (setq id (load-instance-declaration "NewName = PF var‚ÇÅ :arg (Œª x‚ÇÅ ‚Üí B‚ÇÅ) ‚ü¥ var‚ÇÇ :arg (a to b; Œª x‚ÇÇ ‚Üí B‚ÇÇ)"))
  (setq id (load-instance-declaration "NewName = PF var‚ÇÅ :arg‚ÇÄ (Œª x‚ÇÅ ‚Üí B‚ÇÅ) :val‚ÇÄ nice ‚ü¥ var‚ÇÇ :arg (Œª x‚ÇÇ ‚Üí B‚ÇÇ)"))
  (cdr (instance-declaration-alterations id))
  (should (equal "NewName" (instance-declaration-name id)))
  (should (equal "PF" (instance-declaration-package-former id)))
  (should (equal "((var‚ÇÇ ((a . b)) (lambda (x‚ÇÇ) (concat B‚ÇÇ))) (var‚ÇÅ nil (lambda (x‚ÇÅ) (concat B‚ÇÅ))))"
         (format "%s" (instance-declaration-alterations id))))

  ;; Ill-formed: LHS name is empty string.
  (should (not (load-instance-declaration " = PF var")))

  ;; Ill-formed: Not even a declaration.
  (should (not (load-instance-declaration "private n : ‚Ñï")))

  ;; Variation has no args.
  (should (load-instance-declaration "LHS = PF var ()"))

  ;; Arbitrary variational
  ;; There are parens around each arg since each should be a pair.
  (should (equal "((some-variational ((arg‚ÇÄ) (‚Ä¶) (arg‚Çô)) identity))" (format "%s" (instance-declaration-alterations (load-instance-declaration
   "LHS = Magma some-variational (arg‚ÇÄ; ‚Ä¶; arg‚Çô)")))))
  (should (equal "((some-variational nil (lambda (x) (concat x ‚Ä≤))))" (format "%s" (instance-declaration-alterations (load-instance-declaration
  "LHS = Magma some-variational (Œª x ‚Üí x ++ \"‚Ä≤\")")))))
))
 #+END_SRC
 {{{end-fold}}}

*** COMMENT Let's put the pieces together.      :deprecated:_useful_examples:
    :PROPERTIES:
    :CUSTOM_ID: COMMENT-Let-s-put-the-pieces-together-
    :END:

  OLD:
  #+BEGIN_SRC emacs-lisp  :tangle agda-next-700-module-systems.el
(cl-defun instantiate (id)

  "Given an instance-declaration ‚Äòid‚Äô, produce a new PackageFormer.

   Don‚Äôt bother generating non-working Agda code: Better see the error now rather than at Agda typechecking.
  "

  (should (instance-declaration-p id))
  (letf ((self (copy-package-former (cdr (assoc (instance-declaration-package-former id) package-formers))))
        (variation nil) (op nil) ($ùëõùëéùëöùëí nil)
        ((symbol-function '‚ü∞)
         ;; Check to see if ‚Äúc‚Äù has a value, if it does then assert it satisfies the property ‚Äúp‚Äù otherwise error with
         ;; message ‚Äúm‚Äù. If all good, then update the PackageFormer at that component.
         ;; Property ‚Äúp‚Äù and message ‚Äúm‚Äù are quoted expressions mentioning ‚Äúit‚Äù.
         ;; ‚Äúmore‚Äù is any auxialry code that ought to be run; it is a quoted list.
         (lambda (c p m &optional str more) (when-let ((it (cdr (assoc (intern (format ":%s" c)) (instance-declaration-alterations id)))))
                           (unless (eval p) (error (format "700: %s\n\n\t‚á®\t%s\n\t‚á®\t%s ‚âà %s" (eval m) (instance-declaration-docstring id) variation op)))
                           (eval `(progn ,@more))
                           (when str (setq it (format "%s" it)))
                           (eval `(setf (,(car (read-from-string (format "package-former-%s" c))) self) it))))

        ))

    (unless self (error (format "700: %s\n\n\t‚á®\t%s\n\t‚á®\t%s ‚âà %s"
                                (format "Parent ‚Äú%s‚Äù not defined." (instance-declaration-package-former id))
                                (instance-declaration-docstring id) variation op)))

      (setf (package-former-docstring self) (instance-declaration-docstring id))
      (setq $ùëõùëéùëöùëí (instance-declaration-name id))
      (setf (package-former-name self) $ùëõùëéùëöùëí)

      ;; :kind ‚âà The vocabulary that replaces ‚ÄúPackageFormer‚Äù.
      (‚ü∞ 'kind '(-contains? '(record data module PackageFormer) it)
         '(format "This kind ‚Äú%s‚Äù is not supported by Agda!\n     Valid kinds: record, data, module, PackageFormer." it)
         'string-please
         )

      ;; :waist ‚âà The division between parameters and remaining elements.
      (‚ü∞ 'waist '(numberp it) '(format "The waist should be a number; which ‚Äú%s‚Äù is not." it))

      ;; :waist-strings ‚âà Extra strings to insert at the waist position.
      (‚ü∞ 'waist-strings '(listp it) '(format "The waist-strings should be a Lisp list of strings; which ‚Äú%s‚Äù is not." it))

      ;; :level ‚âà Either 'inc or 'dec, for increment or decrementing the level.
      (‚ü∞ 'level '(-contains? '(inc dec) it) '(format "The ‚Äúlevel‚Äù must be ‚Äúinc‚Äù or ‚Äúdec‚Äù; which ‚Äú%s‚Äù is not." it) 'string-please
         '((let* ((lvl (package-former-level self))
                  (toLevel (lambda (n) (s-join "" (-concat
                        (-repeat n "Level.suc (") (list "Level.zero") (-repeat n ")")))))
                 (subs `("" "‚ÇÅ" "‚ÇÇ" "‚ÇÉ" "‚ÇÑ" "‚ÇÖ" "‚ÇÜ" "‚Çá" "‚Çà" "‚Çâ" ,(funcall toLevel 10)))
                 (here (-elem-index (s-trim lvl) subs)))

             (setq it
                   (if here

                       (pcase it
                         ('inc (nth (1+ here) subs))
                         ('dec (nth (1- here) subs)))

                     (pcase it
                       ('inc (format "Level.suc (%s)" lvl))
                       ('dec (s-join "suc" (cdr (s-split "suc" lvl :omit-nulls))))))))))

      ;; TODO: FIXME: Propogate map to remaining elements.
      ;; :alter-elements ‚âà Map over the typed name constituents.
      (when-let ((ae (cdr (assoc ':alter-elements (instance-declaration-alterations id)))))
        (setf (package-former-elements self)
              (-map ae (package-former-elements self))))
      ;; (setq fsnew (funcall op otherwise fs)) ;; MA: TODO: Incorporate ‚Äòargs‚Äô!

      ;; We've just formed a new PackageFormer, which can be modified, specialised, later on.
      (add-to-list 'package-formers (cons (instance-declaration-name id) self))

      (show-package-former self)
))
  #+END_SRC

  # DONE:
  Let's instantiate our test example from earlier to produce a super simple record;
  i.e., legitimate Agda. Moreover, let's decorate each field name with a prime
  and lift-up the first two items to be parameters.

  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
;   "ùí±-primed-record = :kind record :waist-strings (\"field\")
(pf--load-variational "ùí±-primed-record = :kind record ‚ü¥ :level nice :alter-elements (lambda (f) (map-name (concat name \"‚Ä≤\") f))")
(setq package-formers nil)
(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "NewName = M-Set primed-record ‚ü¥ :waist 2 :waist-strings (\"field\")")))
  (instantiate mid)
)
  #+END_SRC

  #+RESULTS:
  #+begin_src results-agda
{- NewName = M-Set primed-record ‚ü¥ :waist 2 :waist-strings ("field") -}
PackageFormer NewName : Set‚ÇÅ where
   Scalar  : Set
   Vector  : Set
   _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
   ùüô       : Scalar
   _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
  #+end_src

  #RESULTS:
  #+begin_src results-agda
{- NewName = M-Set primed-record ‚ü¥ :waist 2 :waist-strings ("field") -}
record NewName (Scalar‚Ä≤ : Set) (Vector‚Ä≤ : Set) : Set‚ÇÇ where
 field
   _¬∑‚Ä≤_ : Scalar ‚Üí Vector ‚Üí Vector
   ùüô‚Ä≤ : Scalar
   _√ó‚Ä≤_ : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId‚Ä≤ : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc‚Ä≤ : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
  #+end_src

  # RESULTS:
  #+begin_src results-agda
{- NewNasme = M-Set primed-record ‚ü¥ :waist 2 -}
record NewNasme (Scalar‚Ä≤ : Set) (Vector‚Ä≤ : Set) : Set‚ÇÅ where
 field
   _¬∑‚Ä≤_ : Scalar ‚Üí Vector ‚Üí Vector
   ùüô‚Ä≤ : Scalar
   _√ó‚Ä≤_ : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId‚Ä≤ : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc‚Ä≤ : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
  #+end_src

  :asserts:
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"

(assert (equal "NewNasme = {! Undefined Parent: M-Sset !}"
        (instantiate (load-instance-declaration "NewNasme = M-Sset var"))))

(assert (equal "NewNasme = {! Undefined Variational: do-the-thing !}"
        (instantiate (load-instance-declaration "NewNasme = M-Set do-the-thing"))))
  #+END_SRC
  :End:

  # DONE:
  Let's form a Haskell-like typeclass; more precisely, a record where the first two
  fields are exposed as parameters.
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
  "ùí±-typeclass‚ÇÇ = :kind record :level dec :waist-strings (\"field\") :waist 2"))
  (setq variationals nil)
  (pf--load-variationals)

(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "NewName = M-Set typeclass‚ÇÇ")))

  (instantiate mid)
))
  #+END_SRC

  #+RESULTS:
  #+BEGIN_src results-agda
{- NewName = M-Set typeclass‚ÇÇ -}
record NewName (Scalar : Set) (Vector : Set) : Set where
 field
   _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
   ùüô       : Scalar
   _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
  #+END_src

  The Vector & Scalar sorts are exposed!
  Moreover, the level of the resulting record is as minimal as possible ^_^ Neato! üê∫

  # What about a bundled up record declaration? Simple, we leave the waist with default value zero.

  Records provide a semantics, what if we want the syntax?
  Since ~data~ declarations consist of constructors, whose target type necessarily
  begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.

  First, a helper function.
  #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defun target (field)
  "Given a declaration ‚Äúname : type0 ‚Üí ‚ãØ ‚Üí typeN‚Äù, yield ‚ÄútypeN‚Äù. "
  (ignore-errors (car (-take-last 1 (s-split "‚Üí" field))))
  ;; Ignore errors since field may be nil.
)
  #+END_SRC

  Let's test it out:
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace
(-let [pf-name "Semigroup-syntax"]

  (list (s-contains? pf-name (target "Id    :  Semigroup-syntax"))
    (s-contains? pf-name (target "_‚®æ_   :  Semigroup-syntax ‚Üí Semigroup-syntax ‚Üí Semigroup-syntax"))
    (s-contains? pf-name (target "assoc :  ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)"))
    (s-contains? pf-name (target "Semigroup-syntax : Set")))
)
  #+END_SRC

  #+RESULTS:
  | t | t | nil | t |

  As the last test case shows, the name position of a declaration could have
  a data-type name --which is not allowed in Agda since constructors share the
  same namespace as types, yet this property is not ensured in our generation;
  so let's sanitise for it.

  Now a real use case.

  # DONE:
   #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"ùí±-data-with carrier = :kind data :level dec :alter-elements (Œª f ‚Üí (if (s-contains? carrier (target (get-type f))) (map-type (s-replace carrier $ùëõùëéùëöùëí type) f) \"\"))"))
  (setq variationals nil)
  (pf--load-variationals)
  (setq package-formers nil)

(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "ScalarSyntax = M-Set data-with :carrier (\"Scalar\")")))

  ; (instance-declaration-alterations mid)
  (instantiate mid)
  ))
  #+END_SRC

  #+RESULTS:
  #+BEGIN_src results-agda
{- ScalarSyntax = M-Set data-with :carrier ("Scalar") -}
data ScalarSyntax : Set where



   ùüô : ScalarSyntax
   _√ó_ : ScalarSyntax ‚Üí ScalarSyntax ‚Üí ScalarSyntax


  #+END_src

  Notice that $ùëõùëéùëöùëí is a special variable that refers to the newly defined PackageFormer's name.
  - It is written using ~\Mi~ with Agda input; e.g., ~\Min~ gives ~ùëõ~.
  - The ‚Äò$‚Äô is intended to further mark the special nature of this variable.

  Yeehaw! We've got three variations and possibly much more from a small core interface
  ü§† We can emulate generative modules this way too! üòª

  Let's package these particular toggle configurations into their own functions.

  :TODO:
  That's a lot of mumbo jumbo, let's have a sanity check.
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(s-join "\n\n" (list
 (instantiate-as-unbundled 1 test :name-suffix "On") ;; typeclass
 (instantiate-as-unbundled 0 test :name-suffix "semantics") ;; record
 (instantiate-as-data test)
))
  #+END_SRC

  #+RESULTS:
  #+begin_src results-agda
{- This was generated from the PackageFormer Semigroup . -}
record Semigroup-On (Carrier : Set) : Set where
  field
    _‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier
    Id  : Carrier
    assoc : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)

{- This was generated from the PackageFormer Semigroup . -}
record Semigroup-semantics : Set (Level.suc Level.zero) where
  field
    Carrier : Set
    _‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier
    Id  : Carrier
    assoc : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)

{- This was generated from the PackageFormer Semigroup . -}
data Semigroup-syntax : Set where
    _‚®æ_ : Semigroup-syntax ‚Üí Semigroup-syntax ‚Üí Semigroup-syntax
    Id  : Semigroup-syntax
  #+end_src

  Notice that the results contained generated names since no names were provided.

  Woah, look at that: This' reminiscent of that 200% increase from earlier ;-)
  *Moreover*, with ~unbundled~ we may expose any or all constituents of a package
  at will.

  {{{fold(Unit Tests)}}}
  #+BEGIN_SRC emacs-lisp :var test = test :tangle no
(ert-deftest inst ()

  ;; Parameterised record
  (should (equal (instantiate test :carrier "Carrier" :docstring "" :waist-strings (list "field") :waist 2)
         "{-  -}
record Semigroup- (Carrier : Set) (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier) : Set where
  field
    Id  : Carrier
    assoc : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)"))

  (should (equal  (instantiate-as-unbundled 1 test :name-suffix "On")
          "{- This was generated from the PackageFormer Semigroup . -}
record Semigroup-On (Carrier : Set) : Set where
  field
    _‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier
    Id  : Carrier
    assoc : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)"))

  ;; ADT, data declaration
  (should (equal  (instantiate test :kind "data" :new-name "ùíÆ" :docstring "" :inc-level nil
                   :keep-fields (lambda (f) (s-contains? "ùíÆ" (target (cadr (s-split ":" f))))))
          "{-  -}
data ùíÆ : Set where
    _‚®æ_ : ùíÆ ‚Üí ùíÆ ‚Üí ùíÆ
    Id  : ùíÆ"))

   (should (equal (instantiate-as-data test)
          "{- This was generated from the PackageFormer Semigroup . -}
data Semigroup-syntax : Set where
    _‚®æ_ : Semigroup-syntax ‚Üí Semigroup-syntax ‚Üí Semigroup-syntax
    Id  : Semigroup-syntax")))

  #+END_SRC
  {{{end-fold}}}
  :END:
  ** COMMENT Module instantions

 We can emit module declarations as follows; which may be useful for ADT instantions
 of PackageFormers that contain derived operations.
 #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(instantiate test   :new-name "Semantics‚ÇÅ"
            :kind "module"
            :carrier "Carrier"
            :omit-level-decl t
            :waist 4
            )
 #+END_SRC

 #+RESULTS:
 #+begin_src results-agda
{- This was generated from the PackageFormer Semigroup . -}
module Semantics‚ÇÅ (Carrier : Set) (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier) (Id : Carrier) (assoc : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)) where
 #+end_src

 For now, a common scenario is forming modules that re-export a type under a new superficial disguise;
 e.g., in the setting where we want to have multiple references to a structure, as in when defining homomorphisms.
 #  :tangle agda-next-700-module-systems.el
 #+BEGIN_SRC emacs-lisp exports both :results replace :wrap "src results-agda"
(cl-defun instantiate-as-opening (decls inst)

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - ‚Äòdecls‚Äô is immediately provided to ‚Äòget-children‚Äô, so it may be a string,
      a list, or a value of type ‚Äòpackage-former‚Äô.

   - ‚Äòinst‚Äô is an instance declaration value whose ‚Äòopenings‚Äô componenet is non-nil.
  "

  (let* ((openings (instance-declaration-openings inst))
     (new-name (instance-declaration-name inst))
     (kind (car openings))
     (renames (cadr openings))
     (otherwise (caddr openings)))

    (s-replace "\t" "    " ;; replace rabs with spaces
    (instantiate decls    :new-name new-name
            :kind "module"
            :docstring (instance-declaration-docstring inst)
            :omit-level-decl t
            :waist 1
            :alter-fields (lambda (fs)
             (let (fsnew)


               (loop for (old . new) in renames
                 do (push (format "%s to %s" old new) fsnew))

               ;; TODO: MA: To consider default ‚Äòotherwise‚Äô via opening Œª x ‚Üí x ++ "‚Ä≤"
               ;; (read-from-string "(lambda (x) xt)")
               ;;

               ;; HACK: Terrible.
               (setq fs (cons (map-name "Carrier" (car fs)) (cdr fs)))

               (loop for f in fs
                 do (unless (assoc (get-name f) renames)
                  (push (format "%s to %s" (get-name f)
                        (rename-mixfix otherwise (get-name f)))
                    fsnew)))

               (thread-last
            ;; Resulting elements must be a list, so we make a singleton list.
            (format "\t\t( %s\n\t\t\t)" (s-join "\n\t\t\t; " (reverse fsnew)))
            list

            ;; Stick on the renaming, which in turn requires an opening clause;
            ;; which in turn requires a module parameter.
            (cons "\t renaming")
            (cons (format "open %s ‚Ñõ public" kind))
            (cons (format "‚Ñõ : %s" kind))
               )

    ))))))
 #+END_SRC

 #+RESULTS:
 #+begin_src results-agda
instantiate-as-opening
 #+end_src

 Let's test it out.
 #+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
(-let [inst (load-instance-declaration "Monoid‚Ä≤ = MonoidPF opening Monoid (Carrier to ùíÆ; _‚®æ_ to _‚äï_; Œª x ‚Üí x ++ \"‚Ä≤\")")]
  (instantiate-as-opening test inst))
 #+END_SRC

 #+RESULTS:
 #+begin_src results-agda
{- Monoid‚Ä≤ = MonoidPF opening Monoid (Carrier to ùíÆ; _‚®æ_ to _‚äï_; Œª x ‚Üí x ++ "‚Ä≤") -}
module Monoid‚Ä≤ (‚Ñõ : Monoid) where
    open Monoid ‚Ñõ public
     renaming
        ( Carrier to ùíÆ
        ; _‚®æ_ to _‚äï_
        ; Id to Id‚Ä≤
        ; assoc to assoc‚Ä≤
        )
 #+end_src

 This utility shines when we use it wholesale; as follows.
 #+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
(let ((inst‚ÇÅ (load-instance-declaration "Monoid‚ÇÅ = MonoidPF opening Monoid (Œª x ‚Üí x ++ \"‚ÇÅ\")"))
      (inst‚ÇÇ (load-instance-declaration "Monoid‚ÇÇ = MonoidPF opening Monoid (Œª x ‚Üí x ++ \"‚ÇÇ\")")))
  (s-join "\n\n" (list (instantiate-as-opening test inst‚ÇÅ) (instantiate-as-opening test inst‚ÇÇ))))
 #+END_SRC

 #+RESULTS:
 #+begin_src results-agda
{- Monoid‚ÇÅ = MonoidPF opening Monoid (Œª x ‚Üí x ++ "‚ÇÅ") -}
module Monoid‚ÇÅ (‚Ñõ : Monoid) where
    open Monoid ‚Ñõ public
     renaming
        ( Carrier to Carrier‚ÇÅ
        ; _‚®æ_ to _‚®æ‚ÇÅ_
        ; Id to Id‚ÇÅ
        ; assoc to assoc‚ÇÅ
        )

{- Monoid‚ÇÇ = MonoidPF opening Monoid (Œª x ‚Üí x ++ "‚ÇÇ") -}
module Monoid‚ÇÇ (‚Ñõ : Monoid) where
    open Monoid ‚Ñõ public
     renaming
        ( Carrier to Carrier‚ÇÇ
        ; _‚®æ_ to _‚®æ‚ÇÇ_
        ; Id to Id‚ÇÇ
        ; assoc to assoc‚ÇÇ
        )
 #+end_src

 We have written this kind of boilerplate so often that we welcome the
 sweet relief provided by the editor tactic being developed herein.

* Preamble :ignore:
  :PROPERTIES:
  :CUSTOM_ID: Preamble
  :END:

:Idea:
TODO: Maintain a list of instantations-loaded, then use that to obtain
the elements of an instance to determine how an ‚Äòopening‚Äô should be
performed. For example, given ‚ü™params ‚ùô fields‚ü´ we know that the
opening module must have ‚ü™params, ‚Ñõ : instance‚ü´ as parameters,
and the remaining list of fields will then avilable for renaming.
This scheme will work for arbitrary typeclasses ^_^
:End:

#+TITLE: Making Modules with Meta-Programmed Meta-Primitives
#+SUBTITLE: @@html: <h2> <center> Liberating Package Formation from the Backend </center> </h2> @@
# Prototyping PackageFormers with Elisp
#+DESCRIPTION: Generalising ADTS, records, typeclasses to ‚Äúpackage formers‚Äù.
#+AUTHOR: Musa Al-hassy
#+EMAIL: alhassy@gmail.com
#+PROPERTY: header-args :results none :tangle no :comments nil :noweb yes

#+CATEGORIES: Agda MetaProgramming Lisp
#+OPTIONS: html-postamble:nil toc:nil d:nil tag:nil

# IMAGE: ../assets/img/org_logo.png
# SOURCE: https://raw.githubusercontent.com/alhassy/org-agda-mode/master/literate.lagda

#+TODO: TODO | Future
:Threading_Remarks:

;; The ‚Äúthread-first x forms‚Äù syntax feeds initial value ‚Äòx‚Äô as the first argument into the
;; next form, which in-turn is then fed as the first argument to the form following it, and so on.
;; It provides a nice way to avoid lots of parenthesising on a particular argument; thereby being clearer.
;;
;; (insert (format "\n‚áí %s" (macroexpand '(thread-first x‚ÇÄ (f‚ÇÅ x‚ÇÅ¬π ‚Ä¶ x¬π‚Çò) ‚ãØ (f‚Çô x‚Çô¬π ‚Ä¶ x‚Åø‚Çñ)))))
;; ‚áí (f‚Çô (‚ãØ (f‚ÇÅ x‚ÇÄ x‚ÇÅ¬π ‚Ä¶ x¬π‚Çò)) x‚Çô¬π ‚Ä¶ x‚Åø‚Çñ)
;;
;; A simple implementation can be found [[https://www.emacswiki.org/emacs/ThreadMacroFromClojure][here]].
;;
;; Dually, thread-last behaves the same but being at the final-most
;; form position;
;; that is, it is essentially ‚Äúforwards function application‚Äù.
;; More generally, the dash library provides ‚Äò-as->‚Äô which allows us to bind a name
;; such as ‚Äòres‚Äô, which is then an alias for all intermediate results.
;;
;; (insert (format "\n‚áí %s" (macroexpand '(-as-> x‚ÇÄ res (f‚ÇÅ x‚ÇÅ¬π ‚Ä¶ res ‚ãØ x¬π‚Çò) ‚ãØres‚ãØ))))
;; ‚áí (let ((res x‚ÇÄ)) (-as-> (f‚ÇÅ x‚ÇÅ¬π ‚Ä¶ res ‚ãØ x¬π‚Çò) res ‚ãØres‚ãØ))
;;
;; It is defined recursively to make use of the same name.
;;
;; The operator ‚Äò-->‚Äô uses the name ‚Äòit‚Äô by default.
:End:
:Testing_Remarks:
#+BEGIN_SRC emacs-lisp
 ;; ‚áí crashes since equality is nil.
 ; (assert (= (+ 1 2) 4))

;; M-x ert RET t ‚áí crashes explaining that (3 = 4) ‚â° nil; much better!
;; ‚Äòshould‚Äô shows intermediate values.
(ert-deftest addition-test ()
  ;; ‚ÄúI know it fails, tell me but don't provide report.‚Äù
  ;; :expected-result :failed
    (should (equal (+ 2 2) 4)))

;; There are also ‚Äòshould-not‚Äô and ‚Äòshould-error‚Äô.

;; ‚ÄòMocking‚Äô: We can elimitate side-effects from functions we wish to test by using Lisp's dynamic
;; binding to locally redefine the side-effects to, say, do nothing and yield true.
(defun go () (if (file-exists-p "nice.txt") 'yay 'boom))
(ert-deftest eg-mock ()
  (flet ((file-exists-p (file) t))
    (should (equal (go) 'yay))))

;; Run all tests; run tests t·µ¢ with: (ert (or 't0 ... 'tN))
;; (ert t)

;; Execute all blocks, then run all tests.
;; (progn (org-babel-execute-buffer) (ert t))

;; Shortcut
(local-set-key (kbd "C-x e")
  (lambda () (interactive) (ert t)))
#+END_SRC

In the ~*ert*~ buffer, press ~r~ on a test to re-run it.
+ Re-run failed tests to ensure that they are deterministic before trying to find
  the cause for the failure.
  - ~m~ to see the messages that the test may have emitted, and ~b~ to see the backtrace.
+ The logical error may be in the test, rather than the code.
+ See [[https://www.gnu.org/software/emacs/manual/html_node/ert/Interactive-Debugging.html#Interactive-Debugging][here]] for more tips.
  + [ ] See [[http://www.gigamonkeys.com/book/][Practical Common Lisp]]'s Chapter 9 on [[http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html][Practical: Building a Unit Test Framework]].
:End:

#+EXCLUDE_TAGS: :noexport:

** COMMENT org/ob-agda setup                                        :load_me:
   :PROPERTIES:
   :CUSTOM_ID: org-ob-agda-setup
   :END:

 Just C-c C-c this block (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà
 #+begin_src emacs-lisp
(add-to-list 'org-src-lang-modes '("results-agda" . org-agda))

;; No code execution on export
;; ‚ü™ For a particular block, we use ‚Äú:eval never-export‚Äù ‚ü´
;;
(setq org-export-use-babel nil)

(progn "Set up some colours *before* loading org-agda-mode"

  (setq org-agda-extra-word-colours nil)
(add-to-list 'org-agda-extra-word-colours '("typeclass" 0 'agda2-highlight-keyword-face))
(add-to-list 'org-agda-extra-word-colours '("PackageFormer" 0 'font-lock-type-face))
(add-to-list 'org-agda-extra-word-colours '("_‚®æ_" 0 'font-lock-type-face))
(add-to-list 'org-agda-extra-word-colours '("assoc" 0 'font-lock-type-face))

;; Treat the following words as if they were ‚Äòtypes‚Äô; i.e., bold red.
(dolist (word (s-split " " "PackageFormer _‚®æ_ assoc rightId leftId Semigroup-semantics Semigroup-syntax SemigroupOn M.*") org-agda-extra-word-colours)
  (add-to-list 'org-agda-extra-word-colours `(,word 0 'font-lock-type-face))
  )

  ; (load-file "~/org-agda-mode/org-agda-mode.el")
  (load-file "~/org-agda-mode/literate.el")
)

;; org-agda-mode.el has now deviated as follows:
;;
; (defvar org-agda-extra-word-colours nil "other words that user of org-mode wants coloured, along with their specified font-lock-type-face")
;
; (define-generic-mode
;     'org-agda-mode                      ;; name of the mode
;     (list '("{-" . "-}"))               ;; comments delimiter
;     org-agda-keywords
;     ;; font lock list: Order of colouring matters;
;     ;; the numbers refer to the subpart, or the whole(0), that should be coloured.
;     (-concat  ;; ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ org-agda-extra-word-colours is a free variable, user should define it /before/ loading org-agda-mode ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ
           (if (boundp (quote org-agda-extra-word-colours)) org-agda-extra-word-colours nil)
;     (list ‚ãØ) ‚ãØ))

;; Also this so people use ‚Äúagda‚Äù instead of being forced to use ‚Äúorg-agda‚Äù
;;
;;  If an Emacs major-mode named <lang>-mode exists, where <lang> is the language identifier from code block‚Äôs header line, then the edit buffer uses that major-mode. Use this variable to arbitrarily map language identifiers to major modes.
;;
(add-to-list 'org-src-lang-modes '("agda" . ob-agda))

;; The following allows me to do ‚ÄúC-c C-c‚Äù on agda org-src blocks.
;; The result is just the src body parroted to us, no ‚Äúevaluation‚Äù performed.
;;
;;
;; (async-shell-command "cp  ~/.emacs.d/elpa/org-9.2.3/ob-C.el ~/org-agda-mode/ob-agda.el")

; (async-shell-command "ln -s ~/org-agda-mode/ob-agda.el ~/.emacs.d/elpa/org-plus-contrib-20190408/ob-agda.el")
(load-file "~/org-agda-mode/ob-agda.el")

;; Execute this for alias:
(add-to-list 'org-src-lang-modes '("results-agda" . ob-agda))
;; (defalias 'results-agda 'org-agda)

;;
;; (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((agda . t)))
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Tangleing happens for each language, one at a time, but I want to tangle
;; lisp blocks into an agda file AND in an org-file I want them to be coloured like lisp.
;; Here's my workaround.
(when nil  ; does not work

(add-to-list 'org-src-lang-modes '("agda-lisp" . emacs-lisp))

(defalias 'agda-lisp nil)

(defun momentarily-pretend-lisp-is-agda (orig-fun &rest args)
  ; (setq org-src-lang-modes (delete '("agda-lisp" . emacs-lisp) org-src-lang-modes))
  ; (add-to-list 'org-src-lang-modes '("agda-lisp" . ob-agda))
  (-let [result (apply orig-fun args)]
  ; (pop org-src-lang-modes)
  ; (add-to-list 'org-src-lang-modes '("agda-lisp" . emacs-lisp))
  result))

(advice-add #'org-babel-tangle :around #'momentarily-pretend-lisp-is-agda)

)
 #+end_src

 #+RESULTS:

** HTML Stuffs                                                       :ignore:
   :PROPERTIES:
   :CUSTOM_ID: HTML-Stuffs
   :END:
   :PROPERTIES:

   :END:
 # super brief intro to tables: https://www.w3schools.com/html/html_tables.asp
 # See here for a nice intro to tables: https://www.w3.org/TR/CSS2/tables.html
 # Here for borders: https://www.w3schools.com/css/css_border.asp
 #
 #
 #+begin_export html
 <style>

 /* wrap lengthy lines for code blocks */
 pre{white-space:pre-wrap}

 /* inline code; see here for other colours: https://www.w3schools.com/colors/colors_names.asp */
 code { background: Cyan;
        border-radius: 5px; /* How curvy the borders should be. */
 }

 table {
     background: pink;
     border-radius: 10px; /* How curvy the borders should be. */
     /* width:90% */

     border-bottom: hidden;
     border-top: hidden;

     /* Put table in the center of the page, horizontally. */
     margin-left:auto;margin-right:auto;

     font-family:"Courier New";
     font-size:90%;
 }

 /* table ‚Äòd‚Äôata elements

   no padding
 */
 td {
     border: 0px solid red; padding: 1em;
     /* border: none;
     border-left: 1px solid transparent;
     border-right: 1px solid transparent; */
 }

 /* Alter visible labels of source blocks */
 pre.src-agda:before { content: 'Agda'; }
 pre.src-haskell:before { content: 'Agda'; }
 pre.src-org:before { content: 'Text'; }

 /* Using source blocks ‚Äúagda-results‚Äù as pink-background coloured blocks in HTML. */
 /* pre.src-results-agda:before { content: 'Results: Agda'; } */
 pre.src-results-agda { background: pink;}
 /* Execute this for alias: (add-to-list 'org-src-lang-modes '("results-agda" . org-agda)) */

 </style>
 #+end_export

*** Macro: fold                                                      :ignore:
    :PROPERTIES:
    :CUSTOM_ID: Macro--fold
    :END:
    :PROPERTIES:

    :END:
 # Folding up some code blocks in the resulting html.
 #
 # Usage: {{{fold(title here)}}} contents {{{end-fold}}}
 #
 #+MACRO: end-fold  #+HTML: </details>
 #+MACRO: fold      #+HTML: <details class="code-details"> <summary> <strong> <font face="Courier" size="3" color="green"> $1 </font> </strong> </summary>

*** org-notes-style setup                                            :ignore:
    :PROPERTIES:
    :CUSTOM_ID: org-notes-style-setup
    :END:
    :PROPERTIES:

    :END:

  # Turn off default internal styles
  #+OPTIONS: html-style:nil html5-fancy:t

  # Exporting to HTML5
  #+HTML_DOCTYPE: html5
  #+HTML_HEAD: <meta http-equiv="X-UA-Compatible" content="IE=edge">
  #+HTML_HEAD: <meta name="viewport" content="width=device-width, initial-scale=1">

  # Add notes.css here
  #+HTML_HEAD: <link href="./org-notes-style.css" rel="stylesheet" type="text/css" />
* Abstract                                                           :ignore:
  :PROPERTIES:
  :CUSTOM_ID: Abstract
  :END:
#+BEGIN_CENTER org
*Abstract*
#+END_CENTER
#+begin_quote org
This article is about implementing a prototype supporting [[https://alhassy.github.io/next-700-module-systems/][‚Äúthe next 700 module systems‚Äù proposal]]
as an editor extension. In particular, we show how intimately related presentations of a type
can be /derived automatically/ from a single generic declaration which we call a ~PackageFormer~.

Think of a language that does not support currying and you need to have a function of
10 arguments that needs to support accepting any number of arguments less than 10, say
for partial application. In such languages, one must utilise the builder design pattern,
or quickly copy-paste the function 10 times, altering it slightly each time.
In general, if such a function definition requires /N/ lines and /M/ forms of the function
are needed, then nearly /N √ó M/ lines of code are written manually.

Our prototype deals with this problem, among others, for functions on /types/
---i.e., type constructors--- and reduces this quadratic count to a linear
count /N + M/: One declaration of /N/ lines, then /M/ lines, each being an instantiation
of the desired form. These ideas are discussed in the pre-print
[[../papers/gpce19_a_language_feature_to_unbundle_data_at_will.pdf][A Language Feature to Unbundle Data at Will]].

*Design patterns for theories become library methods!*
An interesting side-effect of having meta-primitives for packages
is that traditional patterns for theories
---e.g., homomorphisms, syntax, interpretation functions---
can now be codified as general re-usable methods.

The ideas are targeted to the dependently-typed language Agda.
However, with little alterations they could easily be made to target
other languages, such as Haskell and Coq. The ideas transcend the presentation
language, Agda. Ideally, variational definitions would also be in the host
language rather than in Lisp but that would require alteration to the host
language itself, and Lisp with Emacs hooks is much easier to do; for now.
/This is an Emacs centric language extension./

The [[Aim: /Scrap the Repetition/][first section]] below quickly elaborates on our goal,
after that is a ‚Äò[[#User-Manual][user manual]]‚Äô then the remainder of
the article serves as literate documentation of the prototype;
as well as an opportunity for me to explore emojis.
To follow along, it may be useful to look at an [[https://alhassy.github.io/ElispCheatSheet/][Elisp Cheat Sheet]].

The user manual, among other things, shows how we can avoid the
~open ‚ãØ public ‚ãØ renaming ‚ãØ~ pattern which [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Structures.html#2757][plagues]] Agda's standard library
---and is much more pronounced in the [[http://relmics.mcmaster.ca/RATH-Agda/RATH-Agda-2.2.pdf][RATH-Agda]], which devotes p27-39 for simple setoid renaming
and does much more elsewhere---,
as well as showing how to avoid [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Morphism.html#1][laborious]], yet tedious, definitions of homomorphisms
in Agda's library. Moreover, the motivating factor of this work is to avoid
the pattern of [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Structures.html#1][defining a predicate]] ~IsX c‚ÇÄ ‚ãØ c‚Çô~ on constituents ~c·µ¢~
[[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.html#1][then packaging]] the constituents along with a proof of this predicate as a record ~X~.


Tedium is for machines; interesting problems are for people.
#+end_quote

# In some sense, we are ‚Äúcontinuing‚Äù the story of Z's schemas.

#+BEGIN_CENTER org
/Everything here works with Agda version 2.6.0./
#+END_CENTER

| Results of tests and [[file:package-former.agda][examples]] will be in pink, like this. |

#+TOC: headlines 3

* Aim: /Scrap the Repetition/
  :PROPERTIES:
  :CUSTOM_ID: Aim---Scrap-the-Repetition-
  :END:

We're going to write a code generator in Lisp that is going to interpret
fictitious Agda code ---henceforth referred to as ‚Äú700 code‚Äù---
into currently legitimate Agda code.

For example, something like the following, henceforth referred to as ~test~:
#+NAME: test
#+BEGIN_Src agda :results replace :exports code
PackageFormer M-Set : Set‚ÇÅ where
   Scalar  : Set
   Vector  : Set
   _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
   ùüô       : Scalar
   _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)

Semantics     = M-Set record
Syntax        = M-Set data with tags (Scalar; Vector)
UntypedSyntax = M-Set data with identified carrier (Scalar; Vector)
ScalarSyntax  = M-Set data with identified carrier (Scalar)
Stream        = M-Set parameterised codata with identified carrier (Vector) renaming (_¬∑_‚ÇÅ to head; _¬∑_‚ÇÇ to tail)
VectorSyntax  = M-Set data with identified carrier (Vector) and variables (embed) from (Scalar)
NearMonoid    = M-Set record renaming (Scalar to Carrier; Vector to Carrier; _¬∑_ to _‚®æ_; _√ó_ to _‚®æ_)
#+END_Src

:Hide:
#+RESULTS: test
#+begin_example
PackageFormer M-Set : Set‚ÇÅ where
   Scalar  : Set
   Vector  : Set
   _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
   ùüô       : Scalar
   _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)

Semantics     = M-Set record
Syntax        = M-Set data with tags (Scalar; Vector)
UntypedSyntax = M-Set data with identified carrier (Scalar; Vector)
ScalarSyntax  = M-Set data with identified carrier (Scalar)
Stream        = M-Set parameterised codata with identified carrier (Vector) renaming (_¬∑_‚ÇÅ to head; _¬∑_‚ÇÇ to tail)
VectorSyntax  = M-Set data with identified carrier (Vector) and variables (embed) from (Scalar)
NearMonoid    = M-Set record renaming (Scalar to Carrier; Vector to Carrier; _¬∑_ to _‚®æ_; _√ó_ to _‚®æ_)
#+end_example

#
# The ‚Äú:results replace‚Äù is since we actually want the results of this
# block later on when using ‚Äútest‚Äù as a org-provided variable to org-src blocks.
:End:

:Hide_Needs_CcCvCb:
# Someplaces I want to use ‚Äòtest‚Äô without having it in the header, whence:
#+BEGIN_SRC emacs-lisp :var outsidetest = test :exports both :results none
(setq test outsidetest)
#+END_SRC
:End:

Will behave as if it were written:
#+BEGIN_Src agda
record Semantics : Set‚ÇÅ where
  field
    Scalar  : Set
    Vector  : Set
    _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
    ùüô       : Scalar
    _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
    leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
    assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)

data SyntaxTag : Set where Scalar Vector : SyntaxTag
data Syntax : SyntaxTag ‚Üí Set‚ÇÅ where
    _¬∑_     : Syntax Scalar ‚Üí Syntax Vector ‚Üí Syntax Vector
    ùüô       : Syntax Scalar
    _√ó_     : Syntax Scalar ‚Üí Syntax Scalar ‚Üí Syntax Scalar

data UntypedSyntax : Set‚ÇÅ where
    _¬∑_     : UntypedSyntax ‚Üí UntypedSyntax ‚Üí UntypedSyntax
    ùüô       : UntypedSyntax
    _√ó_     : UntypedSyntax ‚Üí UntypedSyntax ‚Üí UntypedSyntax

data ScalarSyntax : Set‚ÇÅ where
    ùüô       : ScalarSyntax
    _√ó_     : ScalarSyntax ‚Üí ScalarSyntax ‚Üí ScalarSyntax

{- Nutshell: Keep items ending in ‚ÄúStream Carrier‚Äù, then discard that ending,
         then form a subscripted version for each argument.
-}
record Stream (Carrier : Set) : Set‚ÇÅ where
  coinductive
  field
    head : Carrier
    tail : Stream Carrier

data VectorSyntax (Scalar : Set) : Set‚ÇÅ where
    embed   : Scalar ‚Üí VectorSyntax
    _¬∑_     : Scalar ‚Üí VectorSyntax ‚Üí VectorSyntax

record NearMonoid : Set‚ÇÅ where
  field
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    ùüô       : Carrier
    leftId  : {ùìã : Carrier}  ‚Üí  ùüô ‚®æ ùìã  ‚â°  ùìã
    assoc   : {a b : Carrier} {ùìã : Carrier} ‚Üí (a ‚®æ b) ‚®æ ùìã  ‚â°  a ‚®æ (b ‚®æ ùìã)
#+END_Src
This is a more than a <<<200% increase>>> in size; that is, our fictitious code will
save us a lot of repetition.

The above is ideal syntax: In Lisp fashion, we are not limiting our vision to what
we can currently be done. The actual syntax that is currently supported by this
program is surprisingly close to the above, with an occasional ~-~ or ~:~ inserted.
Just look at the following source file and resulting generated code!

{{{fold(package-former.agda)}}}
#+INCLUDE: "package-former.agda" src agda
{{{end-fold}}}

{{{fold(package-former-generated.agda)}}}
#+INCLUDE: "package-former-generated.agda" src agda
{{{end-fold}}}

Above is a sample source file which contains special comments that are picked up
by the prototype which then copy-paste-cuts to produce a generated file.
The above code is discussed below, in the user manual
---in fact, it's generated from the user-manual below.

 For this prototype, we have the following <<<constraints>>>:

1. The type of a PackageFormer is ~Set ‚Ñì~ where ~‚Ñì~ is the empty string
   or a parenthesised expression of type ~Level~.
   - Subscript levels are supported.

2. The ~where~ keyword appears on the same line as the ~PackageFormer~ key-phrase.

3. The name of the PackageFormer should not contain ~PackageFormer~ as a sub-identifier.

4. Each element of a PackageFormer spans only /one/ physical line.

There are many useful features outlined in the proposal, such as default implementations, that we
hope to include in the future. For now, we just want something that works, is decently documented, and
can be useful.

* Contributions
  :PROPERTIES:
  :CUSTOM_ID: Contributions
  :END:
  # Motivation

*Current state of affairs:*

1. Expressive & extendable specification language for the library developer.
   - We demonstrate that our meta-primitives permit this below by demonstrating
     that ubiquitous module combinators can be easily formalised /and/ easily used.
   - E.g., from a theory we can derive its homomorphism type, signature, its termtype, etc;
     we generate useful constructions inspired from universal algebra.
   - An example of the freedom allotted by the extensible nature of the system is that
     combinators defined by library developers can, say, utilise auto-generated names
     when names are irrelevant, use ‚Äòclever‚Äô default names, and allow end-users to supply
     desirable names on demand.

2. Unobtrusive and a tremendously simple interface to the end user.
   - Once a library is developed using (the current implementation of) PackageFormers, the
     end user only needs to reference the resulting generated Agda, without any knowledge of the existence
     of PackageFormers.
     * Generated modules are necessarily ‚Äòflattened‚Äô for typechecking with Agda.
   - We demonstrate below how end-users can build upon a library by using /one line/ specifications,
     by showing over over 200 specifications of mathematical structures.

3. Efficient: Our current implementation processes over 200 specifications in ~3 seconds; yielding typechecked Agda code.
   - It is the typechecking that takes time.

4. Pragmatic: We demonstrate how common combinators can be defined for library developers, but also how they can
   be furnished with concrete syntax ---inspired by Agda's--- for use by end-users.

5. Minimal: The system is essentially invariant over the underlying type system; with the exception of
   the meta-primitive ~:waist~ which requires a dependent type theory to express ‚Äòunbundling‚Äô component fields as parameters.

6. Demonstrated expressive power /and/ use-cases.
   - Common boiler-plate idioms in the standard Agda library, and other places,
     are provided with terse solutions using the PackageFormer system.
     * E.g., automatically generating homomorphism types and wholesale renaming fields
       using a single function.
   - Over 200 modules are formalised as one-line specifications.

7. Immediately useable to end-users /and/ library developers.
   + We have provided a large library to experiment with
     ---thanks to the MathScheme group for providing an adaptable source file.
   + In the second part of the user manual, we show how to formulate module
     combinators using a simple and straightforward subset of Emacs Lisp ---a terse introduction is provided.

*Intuitively, the nature of the meta-primitives:*
1. A ~PackageFormer~ is a context, a signature, an essentially algebraic theory of Freyd, or a generalised algebraic theory of Cartmell.
   Moreover, it is tagged by some values for practical purposes; e.g., the kind of concrete realisation that is possible in Agda ---namely, ~record, data, module,~ or
   the abstract ~PackageFormer~.
2. A ‚Äòvariational‚Äô is a morphism between PackageFormers ---taking signatures to signatures.

   Built up from the grammar:
   #+BEGIN_SRC haskell :tangle no
ùìã ‚à∑=                   -- empty, identity, variational
   | ùìã ‚ü¥ ùìã            -- composition
   | :kind  ùìÄ          -- ùìÄ ‚àà {record, data, module, PackageFormer}
   | :waist ùìÉ          -- n ‚àà ‚Ñï, number of initial items to be considered as ‚Äòparameters‚Äô
   | :alter-elements ùíª -- f : List Elements ‚Üí List Elements
   #+END_SRC

   ~:alter-elements~ is a sledgehammer that may result in ill-formed signatures, but we leave it in the system due to its power.
   Instead, we recommend using the following derivied primitives for signature catenation, map, and filter:
   #+BEGIN_SRC haskell :tangle no
   | extended-by ds  -- Adjoin declarations ds, ‚Äúname : type‚Äù, to a PackageFormer
   | map         f   -- Alter each element by f : Element ‚Üí Element
   | generated   f   -- Keep the largest well-formed PackageFormer whose elements satisfy predicate f
#+END_SRC

   Why are these sufficient? The first homomorphism theorem of lists ---i.e., the fact that lists are free monoids---
   informs us that all well-behaved functions from a list monoid are determined as folds after maps. Since our signatures
   are essentially free monoids and the target of our functions are again the same free monoids, the fold is determined and only
   the map remains. We conjecture this is enough; we are not yet certain.

   Interestingly, we are mostly generic over the underlying type theory.

   #  Œì extended-by x‚ÇÄ:œÑ‚ÇÄ,‚Ä¶,x‚Çô:œÑ‚Çô  -- where Œì,x‚ÇÄ:œÑ‚ÇÄ,‚Ä¶,x‚Çñ‚Çã‚ÇÅ:œÑ‚Çñ‚Çã‚ÇÅ ‚ä¢ œÑ‚Çñ Type

   Since a ~PackageFormer~ corresponds to a signature, then these variationals
   ---at least the well-behaved ones--- correspond to signature morphisms.
   Great difficulty lies in providing semantics for ~alter-elements~; if
   we demand a well-typedness judgement, ‚Äú‚ä¢‚Äù, from our underlying type theory
   then we could define ~(x‚ÇÄ : œÑ‚ÇÄ, ‚Ä¶, x‚Çô ‚à∂ œÑ‚Çô) = Œì :alter-elements f~ to be well-typed iff
   ~f : List Elements ‚Üí List Elements~ and ~x‚ÇÄ:œÑ‚ÇÄ,‚Ä¶,x‚Çñ‚Çã‚ÇÅ:œÑ‚Çñ‚Çã‚ÇÅ ‚ä¢ œÑ‚Çñ Type~ for ~k : 0..n~;
   likewise if we admit defined constants in our contexts.

   :functorial_semantics:
Object-level Semantics -- ‚Äúfunctorial semantics‚Äù
- ‚ü¶_‚üß : PF ‚ü∂ |‚ÑÇ|
- ‚ü¶Empty‚üß = ()  -- the empty context
- ‚ü¶Œì extended-by Œî‚üß = ‚ü¶Œì‚üß ++ Œî
- ‚ü¶Œì :waist n‚üß = ???
- ‚ü¶Œì :kind k‚üß  = ???
- ‚ü¶Œì :map f‚üß   = map f ‚ü¶Œì‚üß
- ‚ü¶Œì :filter p‚üß = filter p ‚ü¶Œì‚üß
- ‚ü¶Œì A ‚ü¥ B‚üß = ‚ü¶ ‚ü¶Œì A‚üß B ‚üß -- get a context, then apply B to that.
:end:

3. We have a categorical structure consisting of PackageFormers as objects and those variationals that are signature morphisms.

*Research outcomes:*
1. Narrow down the meta-primitives that permit a variety of algorithms for generating universal
   algebra consructions ---the former being the kerneal which has application the latter.
2. Realise this for Agda, likely using an editor-extension.
3. Provide a semantics to the existing syntax.
4. Ensure the resulting semantics is consistent with that of Agda's.

| Any questions or feedback are welcome! |

* User Manual I: Simple Use of the System
:PROPERTIES:
:header-args: :tangle "package-former-user-manual-i.agda"
:CUSTOM_ID: User-Manual
:END:

If the previous section is unclear regarding the aims and uses of this prototype,
please consult the pre-print [[../papers/gpce19_a_language_feature_to_unbundle_data_at_will.pdf][A Language Feature to Unbundle Data at Will]]
or [[https://alhassy.github.io/next-700-module-systems/][the next 700 module systems proposal]].

Herein we demonstrate how to use this system from the perspective of /library designers/.
We use constructs that are discussed in the next section ---which are examples of how
users may extend the system to produce grouping mechanisms for any desired purpose.
The exposition here follows section 2 of the /Theory Presentation Combinators/ [cite:tpc]
paper, reiterating many the ideas therein.

The few constructs demonstrated in this section not only create new grouping mechanisms
from old ones, but also create maps from the new, child, presentations to the old parent
presentations. Maps between grouping mechanisms are sometimes called /views/.
For example, a theory extended by new declarations comes equipped with
a map that forgets the new declarations to obtain an instance of the original theory.
Such morphisms are tedious to write out, and our system provides them for free.
How? You, the user, can implement such features using our 5 meta-primitives
---but we have implemented a few for you as examples.

:Header:
#+BEGIN_SRC agda
module package-former-user-manual-i where
import Relation.Binary.PropositionalEquality as ‚â°; open ‚â° using (_‚â°_)

-- Run the following commands:
-- M-x load-file ENTER agda-next-700-module-systems.el
-- M-x agda-next-700-module-systems-mode
#+END_SRC
:End:

#+begin_center
It is important to clarify that *the purpose of this work is the development of a core kernel of meta-primitives for modules*. This section demonstrates the power and
expressivity of the meta-primitives by showcasing a series of ubiquitous combinators
/which may be defined using the meta-primitives and Lisp/. The section afterwards goes into the detail of how to *extend the system to build any desired operations on any notion of grouping mechanism*.
#+end_center

# As such, some of the definitions of combinators are biased or have some shortcomings:
# Our goal is to show the meta-primitives allow for such definitions, and to provide
# examples (mostly in the second part of the user manual) for users to build what they want.

** Installation
   :PROPERTIES:
   :CUSTOM_ID: Installation
   :END:

{{{goal(Obtaining the system!)}}}

# Click here to obtain [[https://raw.githubusercontent.com/alhassy/next-700-module-systems-proposal/master/prototype/PackageFormer.el][PackageFormer.el]], place it somewhere, open an Agda file, execute
# ~M-x your/location/PackageFormer.el~, then enable the mode by executing ~M-x 700-mode~.

Add the following to the top of your Emacs configuration file, i.e., the ~~/.emacs~ file.
#+BEGIN_SRC emacs-lisp :tangle no
;; Connect to internet repositories for Emacs packages.
(require 'package)
(push '("melpa-stable" . "http://stable.melpa.org/packages/") package-archives)
(package-initialize)
(package-refresh-contents)

;; Obtain & setup installation interface.
(unless (package-installed-p 'use-package)
  (package-install 'use-package))
(require 'use-package)
(setq use-package-always-ensure t)

;; Necessary libraries for producing the prototype
(use-package s)                  ;; ‚ÄúThe long lost Emacs string manipulation library‚Äù.
(use-package dash)               ;; ‚ÄúA modern list library for Emacs‚Äù.
(use-package dash-functional)    ;; Function combinators; e.g., -partial/-cut, -const, -compose, -orfn & -andfn for generalised ‚àÉ/‚àÄ.
(use-package origami)            ;; Folding away regions of text.
(use-package hydra)              ;; Helpful menus.
(require 'subr-x)                ;; Extra Lisp functions; e.g., when-let.
;; Eye-candy
(use-package spacemacs-common
    :ensure spacemacs-theme
    :config (load-theme 'spacemacs-light t))

;; Next, obtain the Elisp file, load it, and attach it to Agda.
(shell-command (concat "curl "
    "https://raw.githubusercontent.com/alhassy/next-700-module-systems/master/prototype/agda-next-700-module-systems.el"
    ">> ~/.emacs.d/agda-next-700-module-systems.el"))
(load-file "~/.emacs.d/agda-next-700-module-systems.el")

;; Uncomment if you want this extenssion to ALWAYS be active on .agda files.
;; (add-hook 'agda2-mode-hook #'agda-next-700-module-systems-mode)

;; You likely have this in your ~/.emacs file already
(load-file (let ((coding-system-for-read 'utf-8))
                (shell-command-to-string "/usr/local/bin/agda-mode locate")))
#+END_SRC

When you enable ~agda-next-700-module-systems-mode~,

0. A menu-bar ~PackageFormers~ will be added.

1. It will allow you to temporarily disable and enable this new feature,
   as well as providing a help menu. Invoke ~M-x agda-next-700-module-systems-mode~ to toggle turning off this feature
   completely.

2. The string icon ~PackageFormer (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà~ is displayed in the mode line ---near the bottom of Emacs.

3. You may use ~C-c c-l~ as usual, but it will now recognise 700-comments and generate
   legitimate Agda code from them ---more on this later.

   - PackageFormer syntactical items are coloured green, PackageFormer names are
     coloured yellow, and their instantiation are simply bolded.
     # To update a coloured
     # item, simply save then ~revert-buffer~ (F5), then reload with ~C-c C-l~.

If you need any assistance, please contact me!

** Syntax
   :PROPERTIES:
   :CUSTOM_ID: Syntax
   :END:

{{{goal(Superficial glance at the system's syntax.)}}}

The prototype works by translating fictitious 700-syntax into legitimate Agda;
as follows:
#+BEGIN_SRC agda :tangle no
...agda code here...
{-700
       ...700-syntactical items here...
-}
...more agda code...
#+END_SRC
Since the first section provides an example source fragment with both 700-comments as well
as instantiations, we shall only enclose 700-syntax in 700-comments when it is surrounded
by other Agda code, and otherwise leave it free standing.

/We will provide full source listings at the end of discussions that only display fragments!/

 <<<700-syntax>>> is defined informally as follows:
#+BEGIN_EXAMPLE text
‚ü™700-syntax‚ü´    ::=  ‚ü™PackageFormer‚ü´ | ‚ü™Instantiation‚ü´ | ‚ü™Agda‚ü´

‚ü™PackageFormer‚ü´ ::= PackageFormer ‚ü™Identifier‚ü´ : Set (‚ü™level‚ü´) where
               ‚ü™newline-with-indentation‚ü´ ‚ü™Element‚ü´*

‚ü™Element‚ü´       ::=  ‚ü™Identifier‚ü´ : ‚ü™Any-Agda-Type‚ü´

‚ü™Instantiation‚ü´ ::= ‚ü™Identifier‚ü´ = ‚ü™Identifier‚ü´ ‚ü™VariationalClause‚ü´

‚ü™VariationalClause‚ü´ ::= [‚ü™Identifier‚ü´] (:key (value))* (‚ü¥ ‚ü™VariationalClause‚ü´)*
#+END_EXAMPLE

:Old:
#+BEGIN_EXAMPLE text
{- Only listing the currently implemented -}
‚ü™Variation‚ü´     ::= typeclass | data | record
‚ü™VOp‚ü´           ::=   renaming ‚ü™ToList‚ü´
            | unbundling ‚ü™‚Ñï‚ü´
            | exposing (‚ü™Semicolon-seperated-list-of-Identifiers‚ü´)
            | with     ‚ü™ToList‚ü´

‚ü™ToList‚ü´ ::= (‚ü™Identifier‚ÇÄ‚ü´ to ‚ü™Identifier‚ÇÄ‚ü´; ‚ãØ; ‚ü™Identifier‚Çô‚ü´ to ‚ü™Identifier‚Çô‚ü´) {- for any n : ‚Ñï -}
#+END_EXAMPLE
:End:

+ One derives many presentations of a grouping mechanism by what we call ‚Äòvariational clauses‚Äô.
  - In a 700-comment, one declares ‚Äòvariational‚Äô such as
     | ~ùí±-typeclass height = :kind record :level dec :waist-strings ("field") :waist height~   |

     These are functions whose names begin with ~ùí±-~, they may have arguments on the left-hand-side,
     and their right hand side may invoke any of the 5 meta-primitives
     ~kind, waist, waist-strings, level, alter-elements~ with any mixture of
     arguments and concrete values.

     # - These is limited Agda syntax support; in doubt, Lisp syntax is used.

     - To invoke a variational in an instantiation clause, arguments are not positional
       but instead are passed by name ---e.g., ~:key value~.

#   Note that package formation has been liberated from the backend and brought to the user
#   via our 5 meta-primitives: preamble, kind, waist, waist-strings, level, alter-elements.

+ Example uses of the variational clauses could be seen in the ~package-former.agda~ listing in the first section above.
** Extension
   :PROPERTIES:
   :CUSTOM_ID: Extension
   :END:

   The simplest situation is where the presentation of one theory is included, verbatim, in another.
   Concretely, consider ~Monoid~ and ~CommutativeMonoid~.

#+BEGIN_SRC agda
{-700
PackageFormer Monoid : Set‚ÇÅ where
   Carrier : Set
   _¬∑_     : Carrier ‚Üí Carrier ‚Üí Carrier
   assoc   : {x y z : Carrier} ‚Üí (x ¬∑ y) ¬∑ z  ‚â°  x ¬∑ (y ¬∑ z)
   ùïÄ       : Carrier
   leftId  : {x : Carrier} ‚Üí ùïÄ ¬∑ x  ‚â° x
   rightId : {x : Carrier} ‚Üí x ¬∑ ùïÄ  ‚â° x
   ùïÄ-unique : ‚àÄ {e} (lid : ‚àÄ {x} ‚Üí e ¬∑ x ‚â° x) (rid : ‚àÄ {x} ‚Üí x ¬∑ e ‚â° x) ‚Üí e ‚â° ùïÄ
   ùïÄ-unique lid rid = ‚â°.trans (‚â°.sym leftId) rid

PackageFormer CommutativeMonoid‚ÇÄ : Set‚ÇÅ where
   Carrier : Set
   _¬∑_     : Carrier ‚Üí Carrier ‚Üí Carrier
   assoc   : {x y z : Carrier} ‚Üí (x ¬∑ y) ¬∑ z  ‚â°  x ¬∑ (y ¬∑ z)
   ùïÄ       : Carrier
   leftId  : {x : Carrier} ‚Üí  ùïÄ ¬∑ x  ‚â° x
   rightId : {x : Carrier} ‚Üí  x ¬∑ ùïÄ  ‚â° x
   comm    : {x y : Carrier} ‚Üí  x ¬∑ y  ‚â°  y ¬∑ x
   ùïÄ-unique : ‚àÄ {e} (lid : ‚àÄ {x} ‚Üí e ¬∑ x ‚â° x) (rid : ‚àÄ {x} ‚Üí x ¬∑ e ‚â° x) ‚Üí e ‚â° ùïÄ
   ùïÄ-unique lid rid = ‚â°.trans (‚â°.sym leftId) rid
-}
#+END_SRC

As expected, the only difference is that ~CommutativeMonoid‚ÇÄ~ adds a ~comm~-utative axiom.
Thus, given ~Monoid~, it would be more economical to define:
#+BEGIN_SRC agda
{-700
CommutativeMonoid = Monoid extended-by "comm : {x y : Carrier} ‚Üí  x ¬∑ y  ‚â°  y ¬∑ x"
-}
#+END_SRC

Hovering over the left-hand-side gives a tooltip showing the resulting elaboration,
which is identical to ~CommutativeMonoid‚ÇÄ~ along with a forgetful operation üòÑ
The tooltip shows the /expanded/ version of the theory, which is
*what we want to specify but not what we want to enter manually*.
To obtain this specification of ~CommutativeMonoid~ in the current implementation
of Agda, one would likely declare a record with two fields ---one being a ~Monoid~
and the other being the commutativity constraint--- however, this _only_ gives
the appearance of the above specification for consumers; those who produce instances
of ~CommutativeMonoid~ are then _forced_ to know the particular hierarchy and must provide
a ~Monoid~ value first. It is a happy coincidence that our system alleviates such an issue.

Alternatively, we may reify the new syntactical items as concrete Agda supported ~record~-s as follows.
#+BEGIN_SRC agda
{-700
MonoidR            = Monoid ‚ü¥ record
CommutativeMonoidR = MonoidR extended-by "comm : {x y : Carrier} ‚Üí  x ¬∑ y  ‚â°  y ¬∑ x" ‚ü¥ record
-}

neato : CommutativeMonoidR ‚Üí MonoidR
neato = CommutativeMonoidR.toMonoidR
#+END_SRC

*‚ÄúTransport‚Äù*
It is important to notice that the /derived/ result ~ùïÄ-unique~, while proven in the setting of ~Monoid~,
is not only available via the morphism ~toMonoidR~ but is also available directly since it is also
a member of ~CommutativeMonoidR~.

As a teaser, here's how the ~extended-by~ variational is defined ---we leave the details of which
to the second part of the user manual.
{{{fold(Definition of extended-by)}}}
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(eval-and-compile
(cl-defun element-retract (parent es &key (new es) name contravariant)
  "Realise a list of elements as an Agda no-op record.

E.g., list ‚ÄúCarrier : Set; e : Carrier‚Äù
maps to the following element value.

      toParent : parent
      toParent = record {Carrier = Carrier; e = e}

See also ùí±-renaming, which may be useful to change ‚ÄòtoParent‚Äô.

NEW is a new updated version of ES, if any.

NAME is the name of the new retract element; by default it's ‚ÄútoParent‚Äù or ‚ÄúfromParent‚Äù
depending on whether CONTRAVARIANT is true or not.
"

  ;; the name of the newly defined PackageFormer ---which we may access using the special identifier ~$ùëõùëéùëöùëí~.
  (let* ((toParent (or (unless (equal t name) name) (format "%s%s" (if contravariant "from" "to") parent)))
         ;; NAME may be "t", but not the symbol t. This is useful in any ùí±artional that has an optional adjoin-retract
         ;; argument, which the user may set to be nil, t, or a string to obtain nothing, default name, and given name for the morphism; respectively.
        (œÑarg     (if contravariant (format "%s ‚Üí " parent) ""))
        (Œ¥var     (gensym)) ;; unique argument name to avoid accidental shawdowing of any ‚Äúe in es‚Äù.
        (Œ¥arg     (if contravariant (format "Œª %s ‚Üí " Œ¥var) ""))
        )
    (car (parse-elements (list
      (format "%s : let View X = X in %sView %s" toParent œÑarg (if contravariant $ùëõùëéùëöùëí parent))
      (format "%s = %srecord {%s}" toParent Œ¥arg

        (s-join ";"
        (loop for e  in es
              for e‚Ä≤ in new
              unless (or (s-contains-p "let View X = X" (element-type e)) ;; Ignore source view morphisms
                         (element-equations e))                           ;; Ignore ‚Äúderived‚Äù elements
              collect (if (not contravariant)
                          (format "%s = %s" (element-name e) (element-name e‚Ä≤))
                        (format "%s = %s.%s %s" (element-name e) parent (element-name e‚Ä≤) Œ¥var))))))))))

(ùí± extended-by ds (adjoin-retract t)
   = "Extend a given presentation by a list of ;-separated declarations.

      The resuling presentation has a ‚ÄútoX‚Äù retract method,
      where ‚ÄòX‚Äô is the parent presentation. To avoid this,
      set ADJOIN-RETRACT to be nil. To provide a preferred name for
      the morphism, then set ADJOIN-RETRACT to the desired string.
     "
     :alter-elements (Œª es ‚Üí (-concat es (parse-elements (mapcar #'s-trim (s-split ";" ds))) (when adjoin-retract (list (element-retract $ùëùùëéùëüùëíùëõùë° es :name adjoin-retract))))))
)
     #+END_SRC

#+RESULTS:
: ùí±-extended-by

{{{end-fold}}}

+ Simple exercise: Play with this setup to observe that ~extended-by~ is an idempotent operation.
+ Advanced exercise: Read the user manual, parts I and II, then produce a variational ~commuting~
  such that ~CommutativeMagma~ can be regained by ~Magma commuting "¬∑"~.

  See the ~flipping~ variational below.

Anyhow, notice that we may define ~GroupR~ ---a record-presentation of groups--- as an extension of ~MonoidR~
using a /single/ ~extended-by~ clause where the necessary items are separated by ~;~.
#+BEGIN_SRC agda
{-700
GroupR = MonoidR extended-by "_‚Åª¬π : Carrier ‚Üí Carrier; left‚Åª¬π : ‚àÄ {x} ‚Üí (x ‚Åª¬π) ¬∑ x ‚â° ùïÄ; right‚Åª¬π : ‚àÄ {x} ‚Üí x ¬∑ (x ‚Åª¬π) ‚â° ùïÄ" ‚ü¥ record
-}
#+END_SRC

A more fine grained approach may be as follows.
#+BEGIN_SRC agda
{-700
PackageFormer Empty : Set‚ÇÅ where {- No elements -}
Type  = Empty extended-by "Carrier : Set" :adjoin-retract nil ‚ü¥ record
Magma = Type  extended-by "_¬∑_ : Carrier ‚Üí Carrier ‚Üí Carrier" ‚ü¥ record
CommutativeMagma = Magma extended-by "comm : {x y : Carrier} ‚Üí  x ¬∑ y  ‚â°  y ¬∑ x" ‚ü¥ record
-}
#+END_SRC

** Defining a Concept Only Once
   :PROPERTIES:
   :CUSTOM_ID: Defining-a-Concept-Only-Once
   :END:

   From a library-designer's perspective, our definition of ~CommutativeMonoid~ has the commutativity property ‚Äòhard coded‚Äô into it.
   If we wish to speak of commutative magmas ---types with a single commutative operation--- we need to hard-code the property once again.
   If, at a later time, we wish to move from having arguments be implicit to being explicit then we need to track down every hard-coded
   instance of the property then alter them ---having them in-sync becomes an issue.

   Instead, the system lets us ‚Äòbuild upon‚Äô the ~extended-by~ combinator: We make an associative list of
   names and properties, then string-replace the meta-names /op, op‚Ä≤, rel/ with the provided user names.

#+BEGIN_SRC emacs-lisp  :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(ùí± postulating bop prop (using bop) (adjoin-retract t)
 = "Adjoin a property PROP for a given binary operation BOP.

   PROP may be a string: associative, commutative, idempotent, etc.

   Some properties require another operator or a relation; which may
   be provided via USING.

   ADJOIN-RETRACT is the optional name of the resulting retract morphism.
   Provide nil if you do not want the morphism adjoined.

   With this variational, a definition is only written once.
   "
   extended-by (s-replace "op" bop (s-replace "rel" using (s-replace "op‚Ä≤" using
    (pcase prop
     ("associative"   "assoc : ‚àÄ x y z ‚Üí op (op x y) z ‚â° op x (op y z)")
     ("commutative"   "comm  : ‚àÄ x y   ‚Üí op x y ‚â° op y x")
     ("idempotent"    "idemp : ‚àÄ x     ‚Üí op x x ‚â° x")
     ("involutive"    "inv   : ‚àÄ x     ‚Üí op (op x) ‚â° x") ;; assuming bop is unary
     ("left-unit"     "unitÀ° : ‚àÄ x y z ‚Üí op e x ‚â° e")
     ("right-unit"    "unit ≥ : ‚àÄ x y z ‚Üí op x e ‚â° e")
     ("distributiveÀ°" "distÀ° : ‚àÄ x y z ‚Üí op x (op‚Ä≤ y z) ‚â° op‚Ä≤ (op x y) (op x z)")
     ("distributive ≥" "dist ≥ : ‚àÄ x y z ‚Üí op (op‚Ä≤ y z) x ‚â° op‚Ä≤ (op y x) (op z x)")
     ("absorptive"    "absorp  : ‚àÄ x y  ‚Üí op x (op‚Ä≤ x y) ‚â° x")
     ("reflexive"     "refl    : ‚àÄ x y  ‚Üí rel x x")
     ("transitive"    "trans   : ‚àÄ x y z ‚Üí rel x y ‚Üí rel y z ‚Üí rel x z")
     ("antisymmetric" "antisym : ‚àÄ x y ‚Üí rel x y ‚Üí rel y x ‚Üí x ‚â° z")
     ("congruence"    "cong    : ‚àÄ x x‚Ä≤ y y‚Ä≤ ‚Üí rel x x‚Ä≤ ‚Üí rel y y‚Ä≤ ‚Üí rel (op x x‚Ä≤) (op y y‚Ä≤)")
     ;; (_ (error "ùí±-postulating does not know the property ‚Äú%s‚Äù" prop))
     )))) :adjoin-retract 'adjoin-retract)
#+END_SRC

#+RESULTS:
: ùí±-postulating

  We can extend this database of properties as needed with relative ease. Here is an example use along with its elaboration.
#+BEGIN_SRC agda
{-700
PackageFormer Magma : Set‚ÇÅ where
  Carrier : Set
  _¬∑_      : Carrier ‚Üí Carrier ‚Üí Carrier

RawRelationalMagma = Magma extended-by "_‚âà_ : Carrier ‚Üí Carrier ‚Üí Set" ‚ü¥ record

RelationalMagma    = RawRelationalMagma postulating "_¬∑_" "congruence" :using "_‚âà_" ‚ü¥ record
-}
#+END_SRC

#+BEGIN_SRC results-agda :tangle no
record RawRelationalMagma : Set‚ÇÅ where
    field Carrier       : Set
    field op        : Carrier ‚Üí Carrier ‚Üí Carrier
    toType      : let View X = X in View Type ; toType = record {Carrier = Carrier}
    field _‚âà_       : Carrier ‚Üí Carrier ‚Üí Set
    toMagma     : let View X = X in View Magma ;    toMagma = record {Carrier = Carrier;op = op}

record RelationalMagma : Set‚ÇÅ where
    field Carrier       : Set
    field op        : Carrier ‚Üí Carrier ‚Üí Carrier
    toType      : let View X = X in View Type ; toType = record {Carrier = Carrier}
    field _‚âà_       : Carrier ‚Üí Carrier ‚Üí Set
    toMagma     : let View X = X in View Magma ;    toMagma = record {Carrier = Carrier;op = op}
    field cong      : ‚àÄ x x‚Ä≤ y y‚Ä≤ ‚Üí _‚âà_ x x‚Ä≤ ‚Üí _‚âà_ y y‚Ä≤ ‚Üí _‚âà_ (op x x‚Ä≤) (op y y‚Ä≤)
    toRawRelationalMagma        : let View X = X in View RawRelationalMagma ;   toRawRelationalMagma = record {Carrier = Carrier;op = op;_‚âà_ = _‚âà_}
#+END_SRC

    + Regarding the idea that /‚Äúeach piece of mathematical knowledge should be formalized only once‚Äù,/
      see the paper [[https://inf.ug.edu.pl/~schwarzw/papers/mkm2010.pdf][On Duplication in Mathematical Repositories]].

    + The above Lisp serves as an accessible example of extending the system by users.
      - See this [[https://alhassy.github.io/ElispCheatSheet/][Elisp Cheat Sheet]] to get the basics of Lisp.

** Renaming
   :PROPERTIES:
   :CUSTOM_ID: Renaming
   :END:

   From an end-user perspective, our ~CommutativeMonoid~ has one flaw: Such monoids are
   frequently written /additively/ rather than multiplicatively. Such a change can be
   rendered conveniently:

#+BEGIN_SRC agda
{-700
AbealianMonoidR = CommutativeMonoidR renaming "_¬∑_ to _+_"
-}
#+END_SRC

   An Abealian monoid is /both/ a commutative monoid and also, simply, a monoid.
   The above declaration freely maintains these relationships: The resulting record
   comes with a new projection ~toCommutativeMonoidR~, and still has the inherited projection ~toMonoidR~.

   Since renaming and extension (including postulating) both adjoin retract morphisms, by default,
   we are lead to wonder how about the result of performing these operations in sequence ‚Äòon the fly‚Äô,
   rather than naming each application. Since ~P renaming X ‚ü¥ postulating Y~ comes with a retract ~toP~ via
   the renaming and another, distinctly defined, ~toP~ via the postulating, we have that the operations
   commute if /only/ the first permits the creation of a retract. Here's a concrete example:
#+BEGIN_SRC agda
{-700
IdempotentMagma  = Magma renaming "_¬∑_ to _‚äî_" ‚ü¥ postulating "_‚äî_" "idempotent"   :adjoin-retract nil ‚ü¥ record
-}
#+END_SRC

  These both elaborate to the same thing, up to order of constituents.

  It is important to realise that the renaming and postulating combinators are /user-defined/, and
  could have been defined without adjoining a retract by default; consequently, we would have unconditional
  commutativity of these combinators. You, as the user, can make these alternative combinators as follows:
#+BEGIN_SRC agda
{-700

ùí±-renaming‚Ä≤ by = renaming 'by :adjoin-retract nil

ùí±-postulating‚Ä≤ p bop (using) = postulating 'p 'bop :using 'using :adjoin-retract nil

-- Example use: We need the ‚Äúùí±-‚Äù in the declaration site, but not in use sites, as below.

IdempotentMagma‚Ä≥ = Magma postulating‚Ä≤ "_‚äî_" "idempotent" ‚ü¥ renaming‚Ä≤ "_¬∑_ to _‚äî_" ‚ü¥ record
-}
#+END_SRC

Super near stuff!

As expected, simultaneous renaming works too ^_^
#+BEGIN_SRC agda
{-700
PackageFormer Two : Set‚ÇÅ where
  Carrier : Set
  ùüò       : Carrier
  ùüô       : Carrier

TwoR = Two record ‚ü¥ renaming‚Ä≤ "ùüò to ùüô; ùüô to ùüò"
-}
#+END_SRC
~TwoR~ is just ~Two~ but as an Agda record, so it typechecks.

Finally, renaming is an invertible operation ---ignoring the adjoined retracts,
~Magma ≥ ≥~ is identical to ~Magma~.
#+BEGIN_SRC agda
{-700
Magma ≥  = Magma  renaming "_¬∑_  to op"
Magma ≥ ≥ = Magma ≥ renaming "op   to _¬∑_"
-}
#+END_SRC

Alternatively, ~renaming~ has an optional argument ~:adjoin-coretract~ which can be provided
with ~t~ to use a default name or provided with a string to use a desired name for
the inverse part of a projection, ~fromMagma~ below.
#+BEGIN_SRC agda
{-700
Sequential = Magma renaming "op to _‚®æ_" :adjoin-coretract t
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record Sequential : Set‚ÇÅ where
    field Carrier : Set
    field _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier

    toType : let View X = X in View Type
    toType = record {Carrier = Carrier}

    toMagma : let View X = X in View Magma
    toMagma = record {Carrier = Carrier;op = _‚®æ_}

    fromMagma : let View X = X in Magma ‚Üí View Sequential
    fromMagma = Œª g227742 ‚Üí record {Carrier = Magma.Carrier g227742;_‚®æ_ = Magma.op g227742}
#+END_SRC
We are using gensym's for Œª-arguments to avoid name clashes.

** Union (and intersection)
   :PROPERTIES:
   :CUSTOM_ID: Union
   :END:

But even with these features, given ~GroupR~, we would find ourselves writing:
#+BEGIN_SRC agda
{-700
CommutativeGroupR‚ÇÄ = GroupR extended-by "comm : {x y : Carrier} ‚Üí  x ¬∑ y  ‚â°  y ¬∑ x" ‚ü¥ record
-}
#+END_SRC

This is *problematic*: We lose the /relationship/ that every commutative group is a commutative monoid.
This is not an issue of erroneous hierarchical design: From ~Monoid~, we could orthogonally
add a commutativity property or inverse operation; ~CommutativeGroupR‚ÇÄ~ then closes this diamond-loop
by adding both features. The simplest way to share structure is to union two presentations:
#+BEGIN_SRC agda
{-700
CommutativeGroupR = GroupR union CommutativeMonoidR ‚ü¥ record
-}
#+END_SRC

The resulting record, ~CommutativeMonoidR~, comes with three derived fields
---~toMonoidR, toGroupR, toCommutativeMonoidR~--- that retain the results relationships
with its hierarchical construction.

This approach ‚Äúworks‚Äù to build a sizeable library, say of the order of 500 concepts, in
a fairly economical way [cite:tpc]. The union operation is an instance of a /pushout/
operation, which consists of 5 arguments ---three objects and two morphisms--- which may
be included into the ~union~ operation as optional keyword arguments.
The more general notion of pushout is required if we were to combine ~GroupR~ with ~AbealianMonoidR~,
which have non-identical syntactic copies of ~MonoidR~.

{{{fold(Definition of union & intersection -- Ignore for now)}}}
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(defun find-duplicates (list)
"Return a list that contains each element from LIST that occurs more than once.

Source: https://emacs.stackexchange.com/a/31449/10352"
  (--> list
       (-group-by #'identity it)
       (-filter (lambda (ele) (> (length ele) 2)) it)
       (mapcar #'car it)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(cl-defmacro alter-elements (elements variational &body rest)
  "Alter ELEMENTS using a given VARIATIONAL along with its arguments, REST.

   The result is a list of elements.

   This is essentially ‚Äú:alter-elements‚Äù but with the ability to work on the elements
   of **any** PackageFormer by using ‚Äú($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì pf)‚Äù.

   This method is only well-defined within the RHS of a variational, or instantiation, declaration.
   E.g., use it to alter elements in an ‚Äú:alter-elements‚Äù clause using a predefined variational;
   see ùí±-union and ùí±-intersect for sample uses.
  "
  `(funcall (cdr (assoc :alter-elements (,(ùí±- variational) ,@rest))) ,elements))
#+END_SRC

# Add to user manual, pt2
#
# Raw names as inputs: or just use (symbol-name 'it)
# ùí±-go it = :alter-elements (Œª _ ‚Üí (parse-elements (list (format "%s" 'it))))
# M = Magma go noice

#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(ùí± union pf (renaming‚ÇÅ "") (renaming‚ÇÇ "") (adjoin-retract‚ÇÅ t) (adjoin-retract‚ÇÇ t) (error-on-name-clashes t) (fix-conflict (Œª left right name ‚Üí (cons (format "%s-via-%s" name left)
                                                                                                                                                    (format "%s-via-%s" name right))))

 = "Union parent PackageFormer with given PF.

    Union the elements of the parent PackageFormer with those of
    the provided PF symbolic name, then adorn the result with two views:
    One to the parent and one to the provided PF.

    If an identifer is shared but has different types, then crash.

    ADJOIN-RETRACT·µ¢, for i : 1..2, are the optional names of the resulting morphisms.
    Provide nil if you do not want the morphisms adjoined.

    ERROR-ON-NAME-CLASHES toggles whether the program should crash if the PackageFormers
    have items with the same name but different types or definitions,
    or otherwise it should simply, and sliently, rename the conflicting names according to FIX-CONFLICT;
    a function that takes 3 string arguments and yields two, the former being the names of the PackageFormer arguments
    along with the conflicting name, and yiedling two new names.

    Also, ERROR-ON-NAME-CLASHES toggles whether the program should crash if retract
    names already exist, or otherwise it should simply silently not include clashing retract names.
    "
   :alter-elements (Œª es ‚Üí
     (let* ((p (symbol-name 'pf))
            (es‚ÇÅ (alter-elements es renaming renaming‚ÇÅ :adjoin-retract nil))
            (es‚ÇÇ (alter-elements ($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì p) renaming renaming‚ÇÇ :adjoin-retract nil))
            (es‚Ä≤ (-concat es‚ÇÅ es‚ÇÇ))
            (name-clashes (loop for n in (find-duplicates (mapcar #'element-name es‚Ä≤))
                                for e = (--filter (equal n (element-name it)) es‚Ä≤)
                                unless (--all-p (equal (car e) it) e)
                                collect e))
            (er‚ÇÅ (if (equal t adjoin-retract‚ÇÅ) (format "to%s" $ùëùùëéùëüùëíùëõùë°) adjoin-retract‚ÇÅ))
            (er‚ÇÇ (if (equal t adjoin-retract‚ÇÇ) (format "to%s" p)    adjoin-retract‚ÇÇ))
            )

      ;; Ensure no name clashes!
      (if error-on-name-clashes
          (if name-clashes
            (-let [debug-on-error nil]
              (error "%s = %s union %s \n\n\t\t ‚û© Error: Elements ‚Äú%s‚Äù conflict!\n\n\t\t\t%s"
                     $ùëõùëéùëöùëí $ùëùùëéùëüùëíùëõùë° p (element-name (caar name-clashes)) (s-join "\n\t\t\t" (mapcar #'show-element (car name-clashes))))))
        ;; Else handle clashes
        (loop for n in (mapcar #'element-name (apply #'-concat name-clashes))
              do (setq es‚ÇÅ (--map (map-name (Œª m ‚Üí (if (equal n m) (car (fix-conflict $ùëùùëéùëüùëíùëõùë° p n)) m)) it) es‚ÇÅ))
                 (setq es‚ÇÇ (--map (map-name (Œª m ‚Üí (if (equal n m) (cdr (fix-conflict $ùëùùëéùëüùëíùëõùë° p n)) m)) it) es‚ÇÇ)))
        (setq es‚Ä≤ (-concat es‚ÇÅ es‚ÇÇ)))

   ;; Are the retract names already present?
   (setq er‚ÇÅ (member er‚ÇÅ (mapcar #'element-name es‚Ä≤)))
   (setq er‚ÇÇ (member er‚ÇÇ (mapcar #'element-name es‚Ä≤)))
   (and (or er‚ÇÅ er‚ÇÇ) error-on-name-clashes
        (error "%s = %s union %s \n\n\t\t ‚û© Error: Element retract names ‚Äú%s/%s‚Äù conflict!\n\n\t\t\t%s"
                     $ùëõùëéùëöùëí $ùëùùëéùëüùëíùëõùë° p (car er‚ÇÅ) (car er‚ÇÇ) "Use ‚Äò:adjoin-retract·µ¢‚Äô for new names, or set ‚Äò:error-on-retract-name-clashes‚Äô to nil to silently avoid creating such retracts."))

   ;; return value
   (-concat
       es‚Ä≤
       (and adjoin-retract‚ÇÅ (not er‚ÇÅ) (list (element-retract $ùëùùëéùëüùëíùëõùë° es :new es‚ÇÅ :name adjoin-retract‚ÇÅ)))
       (and adjoin-retract‚ÇÇ (not er‚ÇÇ) (list (element-retract p     ($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì p) :new es‚ÇÇ :name adjoin-retract‚ÇÇ)))))))

#+END_SRC

#+RESULTS:
: map-name

#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(ùí± intersect pf (adjoin-retract‚ÇÅ t) (adjoin-retract‚ÇÇ t) (renaming‚ÇÅ "") (renaming‚ÇÇ "")
 = "Intersect parent PackageFormer with given PF.

  ‚Äúpf‚ÇÅ intersect pf‚ÇÇ :renaming‚ÇÅ f :renaming‚ÇÇ g‚Äù  ‚âÖ  f(pf‚ÇÅ) ‚à© g(pf‚ÇÇ)

  This is essentially the pullback:
  { (x, y) ‚àà pf‚ÇÅ √ó pf‚ÇÇ ‚ùô f x = g y }.

  Intersect the elements of the parent PackageFormer with those of
  the provided PF symbolic name, then adorn the result with two views
  from the result PackageFormer to the input PackageFormers.

  ADJOIN-RETRACT·µ¢, for i : 1..2, are the optional names of the resulting morphisms.
  Provide nil if you do not want the morphisms adjoined.
  "
 :alter-elements (Œª es ‚Üí
   (let* ((p (symbol-name 'pf))
          (es‚ÇÅ (alter-elements es renaming renaming‚ÇÅ :adjoin-retract nil))
          (es‚ÇÇ (alter-elements ($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì p) renaming renaming‚ÇÇ :adjoin-retract nil))
          (es‚Ä≤      (reverse (intersection
                               (--reject (element-contains "View" it) es‚ÇÅ) es‚ÇÇ
                               :key #'element-name :test #'string-equal)))
          ;; names not mentioned in the intersection.
          (dangling (set-difference (-concat es‚ÇÅ es‚ÇÇ) es‚Ä≤
                      :key #'element-name :test #'string-equal)))

  ;; drop the dangling names
  (setq es‚Ä≤ (-reject (Œª e ‚Üí (-some (Œª d ‚Üí (element-contains (element-name d) e)) dangling)) es‚Ä≤))

  ;; Get old names so as to adjoin the co-retracts; i.e., the projections with renaming.
  (setq es‚ÇÅ (alter-elements es‚Ä≤ rename (reify-to-list renaming‚ÇÅ :inverse t) :adjoin-retract nil))
  (setq es‚ÇÇ (alter-elements es‚Ä≤ rename (reify-to-list renaming‚ÇÇ :inverse t) :adjoin-retract nil))

   (-concat
       es‚Ä≤
       (when adjoin-retract‚ÇÅ (list (element-retract $ùëùùëéùëüùëíùëõùë° es‚Ä≤ :new es‚ÇÅ :name adjoin-retract‚ÇÅ :contravariant t)))
       (when adjoin-retract‚ÇÇ (list (element-retract p     es‚Ä≤ :new es‚ÇÇ :name adjoin-retract‚ÇÇ :contravariant t)))))))
#+END_SRC

{{{end-fold}}}

The pushout of $f : X ‚Üí A$ and $g : X ‚Üí B$ is, essentially, the disjoint sum of $A$ and $B$ where embedded elements
are considered ‚Äòindistinguishable‚Äô when the share the same origin in $X$ via the paths $f$ and $g$.
Unfortunately, the resulting ‚Äòindistinguishable‚Äô elements are actually distinguishable: They may be the /A/-name or the /B/-name
and a choice must be made as to which name is preferred since users actually want to refer to them later on.
Hence, to be useful for library construction, the pushout construction actually requires at least another input function
that provides canonical names to the supposedly ‚Äòindistinguishable‚Äô elements.

Since a ~PackageFormer~ is essentially just a /signature/ ---a collection of typed names---, we can make a ‚Äòpartial choice of
pushout‚Äô to reduce the number of arguments from 6 to 4 by letting the typed-names object $X$ be ‚Äòinferred‚Äô and encoding
the canonical names function into the operations $f$ and $g$.
The inputs functions $f, g$ are necessarily /signature morphisms/ ---mappings of names that preserve types--- and
so are simply lists associating names of $X$ to names of $A$ and $B$. If we instead consider $f‚Ä≤ : X‚Ä≤ ‚Üê A$ and
$g‚Ä≤ : X‚Ä≤ ‚Üê B$, in the /opposite direction/, then we may reconstruct a pushout by
setting $X$ to be common image of $f‚Ä≤, g‚Ä≤$, and set $f, g$ to be inclusions
In-particular, the full identity of $X‚Ä≤$ is not necessarily relevant for
the pushout reconstruction and so it may be omitted. Moreover, the issue of canonical names is resolved:
If $a ‚àà A$ is intended to be identified with $b ‚àà B$ such that the resulting element has $c$ as the chosen
canonical name, then we simply require $f‚Ä≤\, a = c = g‚Ä≤ \, b$.

At first, a pushout construction needs 5 inputs, to be practical it further needs a function for canonical names
for a total of 6 inputs. However, a pushout of $f : X ‚Üí A$ and $g : X ‚Üí B$ is intended to be the ‚Äòsmallest object $P$
that contains a copy of $A$ and of $B$ sharing the common substructure $X$‚Äô, and as such it outputs two functions
$inj‚ÇÅ : A ‚Üí P,\, inj‚ÇÇ : B ‚Üí P$ that inject the names of $A$ and $B$ into $P$.
If we realise $P$ as a record ---a type of models--- then the embedding functions are /reversed/, to obtain
projections $P ‚Üí A$ and $P ‚Üí B$: If we have a model of $P$, then we can forget some structure and rename
via $f$ and $g$ to obtain models of $A$ and $B$.
For the resulting construction to be useful, these names could be automated such as $toA : P ‚Üí A$ and $toB : P ‚Üí B$
but such a naming scheme does not scale ---but we shall use it for default names. As such, we need two more inputs
to the pushout construction so the names of the resulting output functions can be used later on.
/Hence, a practical choice of pushout needs 8 inputs!/

Using the above issue to reverse the directions of $f, g$ via $f‚Ä≤, g‚Ä≤$, we can infer the shared structure $X$
and the canonical name function. Likewise, by using $toChild : P ‚Üí Child$ default-naming scheme, we may omit
the names of the retract functions. If we wish to rename these retracts or simply omit them altogether,
we make the /optional/ arguments: Provide ~:adjoin-retract·µ¢ "new-function-name"~ to use a new name, or ~nil~ instead
of a string to omit the retract. Here are some examples of this construction of mine.

Here we provide all arguments, optional and otherwise.
#+BEGIN_SRC agda
{-700
TwoBinaryOps = Magma union Magma :renaming‚ÇÅ "op to _+_" :renaming‚ÇÇ "op to _√ó_"  :adjoin-retract‚ÇÅ "left" :adjoin-retract‚ÇÇ "right"
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record TwoBinaryOps : Set‚ÇÅ where
    field Carrier : Set
    field _+_     : Carrier ‚Üí Carrier ‚Üí Carrier

    toType : let View X = X in View Type
    toType = record {Carrier = Carrier}

    field _√ó_     : Carrier ‚Üí Carrier ‚Üí Carrier

    left : let View X = X in View Magma
    left = record {Carrier = Carrier;op = _+_}

    right : let View X = X in View Magma
    right = record {Carrier = Carrier;op = _√ó_}
#+END_SRC

Remember, /this particular user implementation/ realises ~X‚ÇÅ union X‚ÇÇ :renaming‚ÇÅ f‚Ä≤ :renaming‚ÇÇ g‚Ä≤~
as the pushout of the inclusions ~f‚Ä≤ X‚ÇÅ ‚à© g‚Ä≤ X‚ÇÇ ‚ü∂ X·µ¢~ where the source is the set-wise intersection of names.
Moreover, when either ~renaming·µ¢~ is omitted, it defaults to the identity function.

The next example is one of the reasons the construction is named ‚Äòunion‚Äô instead of ‚Äòpushout‚Äô:
It's idempotent, if we ignore the addition of the retract.
#+BEGIN_SRC agda
{-700
MagmaAgain   = Magma union Magma
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record MagmaAgain : Set‚ÇÅ where
    field Carrier : Set
    field op      : Carrier ‚Üí Carrier ‚Üí Carrier

    toType : let View X = X in View Type
    toType = record {Carrier = Carrier}

    toMagma : let View X = X in View Magma
    toMagma = record {Carrier = Carrier;op = op}
#+END_SRC

We may perform disjoint sums ---simply distinguish all the names of one of the input objects.
#+BEGIN_SRC agda
{-700
-- Magma‚Ä≤    = Magma primed  ‚ü¥ record
-- SumMagmas = Magma union Magma‚Ä≤ :adjoin-retract‚ÇÅ nil ‚ü¥ record
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record SumMagmas : Set‚ÇÅ where
    field Carrier  : Set
    field op       : Carrier ‚Üí Carrier ‚Üí Carrier

    toType         : let View X = X in View Type
    toType = record {Carrier = Carrier}

    field Carrier‚Ä≤ : Set
    field op‚Ä≤      : Carrier‚Ä≤ ‚Üí Carrier‚Ä≤ ‚Üí Carrier‚Ä≤

    toType‚Ä≤ : let View X = X in View Type
    toType‚Ä≤ = record {Carrier = Carrier‚Ä≤}

    toMagma : let View X = X in View Magma
    toMagma = record {Carrier = Carrier‚Ä≤;op = op‚Ä≤}

    toMagma‚Ä≤ : let View X = X in View Magma‚Ä≤
    toMagma‚Ä≤ = record {Carrier‚Ä≤ = Carrier‚Ä≤;op‚Ä≤ = op‚Ä≤}
#+END_SRC

A common scenario is extending a structure, say ~Magma~, into orthogonal directions, such as by making
it operation associative or idempotent, then closing the resulting diamond by combining them, to obtain
a semilattice. However, the orthogonal extensions may involve different names and so the resulting
semilattice presentation can only be formed via pushout; below are three ways to form it.
#+BEGIN_SRC agda
{-700
Semigroup          = Magma postulating "_¬∑_" "associative" ‚ü¥ record
-- IdempotentMagma = Magma renaming "_¬∑_ to _‚äî_" ‚ü¥ postulating "_‚äî_" "idempotent"  :adjoin-retract nil ‚ü¥ record

‚äî-SemiLattice     = Semigroup union IdempotentMagma :renaming‚ÇÅ "_¬∑_ to _‚äî_" ‚ü¥ record
¬∑-SemiLattice     = Semigroup union IdempotentMagma :renaming‚ÇÇ "_‚äî_ to _¬∑_" ‚ü¥ record
‚Üë-SemiLattice     = Semigroup union IdempotentMagma :renaming‚ÇÅ "_¬∑_ to _‚Üë_" :renaming‚ÇÇ "_‚äî_ to _‚Üë_" ‚ü¥ record
-}
#+END_SRC

Let's close with the classic example of forming a ring structure by combining two monoidal structures.
This example also serves to further showcasing how using ~ùí±-postulating~ can make for more granular, modular, developments.
#+BEGIN_SRC agda
{-700
Additive           = Magma renaming "_¬∑_ to _+_" ‚ü¥ postulating "_+_" "commutative"  :adjoin-retract nil ‚ü¥ record
Multiplicative     = Magma renaming "_¬∑_ to _√ó_" :adjoin-retract nil ‚ü¥ record
AddMult            = Additive union Multiplicative ‚ü¥ record
AlmostNearSemiRing = AddMult ‚ü¥ postulating "_√ó_" "distributiveÀ°" :using "_+_" ‚ü¥ record
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record AlmostNearSemiRing : Set‚ÇÅ where
    field Carrier : Set
    field _+_     : Carrier ‚Üí Carrier ‚Üí Carrier

    toType : let View X = X in View Type
    toType = record {Carrier = Carrier}

    toMagma : let View X = X in View Magma
    toMagma = record {Carrier = Carrier;op = _+_}

    field comm       : ‚àÄ x y   ‚Üí _+_ x y ‚â° _+_ y x
    field _√ó_        : Carrier ‚Üí Carrier ‚Üí Carrier

    toAdditive : let View X = X in View Additive
    toAdditive = record {Carrier = Carrier;_+_ = _+_;comm = comm}

    toMultiplicative : let View X = X in View Multiplicative
    toMultiplicative = record {Carrier = Carrier;_√ó_ = _√ó_}

    field distÀ°      : ‚àÄ x y z ‚Üí _√ó_ x (_+_ y z) ‚â° _+_ (_√ó_ x y) (_√ó_ x z)
#+END_SRC

Following the reasoning for pushouts, we implement pullbacks in the same way with the same optional arguments.
Here's an example use:
#+BEGIN_SRC agda
{-700
Just-Carrier    = Additive intersect Multiplicative
Magma-yet-again = Additive intersect Multiplicative :renaming‚ÇÅ "_+_ to op" :renaming‚ÇÇ "_√ó_ to op"
-}
#+END_SRC
Moreover the absorptive law $X ‚à© (X ‚à™ Z) = X$ also holds for these operations:
~Additive intersect AddMult~ is just ~Additive~, when we ignore all adjoined retracts.

** Duality
   :PROPERTIES:
   :CUSTOM_ID: Duality
   :END:
Maps between grouping mechanisms are sometimes called /views/, which are essentially an internalisation of
of the /variationals/ in our system. Let's demonstrate an example of how dual concepts are
captured concretely in the system.

For example, the dual, or opposite, of a binary operation $_¬∑_$ is the operation $_¬∑·µí·µñ_$
defined by $x ¬∑·µí·µñ y ‚âî y ¬∑ x$.
Classically in Agda, duality is utilised as follows:
1. Define a module ~R _¬∑_~ for the desired concepts.
2. Define a shallow module ~R·µí·µñ _¬∑_~ that opens ~R _¬∑·µí·µñ_~ and renames the concepts in ~R~
   by the dual names.

   The RATH-Agda library performs essentially this approach, for example for obtaining ~UpperBounds~
   from ~LowerBounds~ in the context of a poset.

Unfortunately, this means that any record definitions in ~R~ must have its field names be
sufficiently generic to play /both/ roles as the original and the dual concept.
Admittedly, RATH-Agda's names are well-chosen; e.g., ~value, bound·µ¢, universal~
to denote a value that is a lower/upper bound of two given elements, satisfying
a lub/glb universal property. However, well-chosen names come at an upfront cost:
One must take care to provide sufficiently generic names and account for duality
at the outset, irrespective of whether one /currently/ cares about the dual or not; otherwise
when the dual is later formalised, then the names of the original concept must be refactored
throughout a library and its users.

Consider the following heterogeneous algebra.
#+BEGIN_SRC agda
{-700
PackageFormer LeftUnitalAction : Set‚ÇÅ where
  Scalar : Set
  Vector : Set
  _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
  ùüô       : Scalar
  leftId  : {x : Vector} ‚Üí ùüô ¬∑ x ‚â° x

-- Let's reify this as a valid Agda record declaration
LeftUnitalActionR  = LeftUnitalAction ‚ü¥ record
-}
#+END_SRC
Informally, one now ‚Äòdefines‚Äô a right unital action by duality, flipping the binary operation
and renaming ~leftId~ to be ~rightId~. Such informal parlance is in-fact nearly formally, as the following:
#+BEGIN_SRC agda
{-700
RightUnitalActionR = LeftUnitalActionR flipping "_¬∑_" :renaming "leftId to rightId" ‚ü¥ record
-}
#+END_SRC
Of-course the resulting representation is semantically identical to the previous one, and so it is
furnished with a ~to‚ãØ~ mapping:
#+BEGIN_SRC agda
forget : RightUnitalActionR ‚Üí LeftUnitalActionR
forget = RightUnitalActionR.toLeftUnitalActionR
#+END_SRC

Likewise for the RATH-Agda library's example from above, to define semi-lattice structures by duality:
#+BEGIN_SRC agda
import Data.Product as P

{-700
PackageFormer JoinSemiLattice : Set‚ÇÅ where
  Carrier : Set
  _‚äë_     : Carrier ‚Üí Carrier ‚Üí Set
  refl    : ‚àÄ {x} ‚Üí x ‚äë x
  trans   : ‚àÄ {x y z} ‚Üí x ‚äë y ‚Üí y ‚äë z ‚Üí x ‚äë z
  antisym : ‚àÄ {x y} ‚Üí x ‚äë y ‚Üí y ‚äë x ‚Üí x ‚â° y
  _‚äî_     : Carrier ‚Üí Carrier ‚Üí Carrier
  ‚äî-lub   : ‚àÄ {x y z} ‚Üí x ‚äë z ‚Üí y ‚äë z ‚Üí (x ‚äî y) ‚äë z
  ‚äî-lubÀò  : ‚àÄ {x y z}  ‚Üí (x ‚äî y) ‚äë z  ‚Üí x ‚äë z P.√ó y ‚äë z

JoinSemiLatticeR = JoinSemiLattice record
MeetSemiLatticeR = JoinSemiLatticeR flipping "_‚äë_" :renaming "_‚äî_ to _‚äì_; ‚äî-lub to ‚äì-glb"
-}
#+END_SRC
In this example, besides the map from meet semi-lattices to join semi-lattices, the types of
the dualised names, such as ~‚äì-glb~, are what one would expect were the definition written out explicitly:
#+BEGIN_SRC agda
module woah (M : MeetSemiLatticeR) where
  open MeetSemiLatticeR M

  nifty : ‚àÄ {x y z} ‚Üí z ‚äë x ‚Üí z ‚äë y ‚Üí z ‚äë (x ‚äì y)
  nifty = ‚äì-glb

  _ : let _‚äí_ = Œª x y ‚Üí y ‚äë x
      in ‚àÄ {x y z} ‚Üí x ‚äí y ‚Üí y ‚äí z ‚Üí x ‚äí z
  _ = trans
#+END_SRC

{{{fold(Definition of flipping -- Feel free to ignore until later)}}}
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(defun flip-type (œÑ)
  "Given a binary operation's type, as a string, flip the first two types.

E.g., ‚ÄúA ‚Üí B ‚Üí C‚Äù becomes ‚ÄúB ‚Üí A ‚Üí C‚Äù.
  "
  (-let [ts (s-split "‚Üí" œÑ)]
   (s-join " ‚Üí " (list (nth 1 ts) (nth 0 ts) (nth 2 ts)))))
#+END_SRC

#+RESULTS:
: flip-type

:test:
(flip-type "A ‚Üí B ‚Üí C")
:end:

#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(defun flip (name op)
 "If element OP is named NAME, then flip its type; else leave it alone-ish.

If OP mentions NAME, then prefix its type with
‚Äúlet NAME = Œª x y ‚Üí NAME y x in‚Äù, which results in valid Agda
due to its identifier scoping rules.
"
 (cond ((equal name (element-name op))
               (map-type #'flip-type op))
       ((or (element-contains name op) (element-contains (s-replace "_" "" name) op))
               (-let [letin (format "let %s = Œª x y ‚Üí %s y x in " name name)]
                 (thread-last op
                   (map-type (Œª œÑ ‚Üí (concat letin œÑ)))
                   (map-equations (Œª eqs ‚Üí (--map (-let [ps (s-split "=" it)] (format "%s = %s %s" (car ps) letin (s-join "=" (cdr ps)))) eqs))))))
       (t op)))
#+END_SRC

#+RESULTS:
: flip

:tests:
(flip "_+_" (car (parse-elements '("_+_ : A ‚Üí B ‚Üí C"))))  ‚áí  _+_ : B ‚Üí A ‚Üí C
(flip "_+_" (car (parse-elements '("_‚äï_ : A ‚Üí B ‚Üí C"))))  ‚áí  _‚äï_ : A ‚Üí B ‚Üí C
(flip "_+_" (element-contains "_+_" (car (parse-elements '("val : C" "val = _+_ b c"))))
:end:

#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(ùí± flipping name (renaming "")
 = "Flip a single binary operation, or predicate, NAME.

    Dual constructs usual require some identifiers to be renamed,
    and these may be supplied as a ‚Äú;‚Äù-separated ‚Äúto‚Äù-separated string list, RENAMING.

    There is no support for underscores; mixfix names must be given properly.
  "
    renaming 'renaming :adjoin-retract nil
 ‚ü¥ :alter-elements (Œª es ‚Üí
                      (let ((es‚Ä≤ (--map (flip name it) es)))
                        (-concat es‚Ä≤ (list (flip name (element-retract $ùëùùëéùëüùëíùëõùë° ($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì $ùëùùëéùëüùëíùëõùë°) :new es‚Ä≤)))))))
#+END_SRC

#+RESULTS:
: ùí±-flipping

{{{end-fold}}}

** Extracting Little Theories
   :PROPERTIES:
   :CUSTOM_ID: Extracting-Little-Theories
   :END:

The ~extended-by~ variational allows Agda users to easily employ the /tiny theories/ [cite:little_theories][mathscheme]
approach to library design: New structures are built from old ones by augmenting one concept at a time,
then one uses mixins such as ~union~, below, to obtain a complex structure.
This approach lets us write a program, or proof, in a context that only
provides what is /necessary/ for that program-proof and nothing more.
In this way, we obtain /maximal generality/ for re-use!
This approach can be construed as /The Interface Segregation Principle [design-patterns-solid]:
/No client should be forced to depend on methods it does not use./

#+BEGIN_SRC agda :tangle no
{-700
PackageFormer Empty : Set‚ÇÅ where {- No elements -}
Type  = Empty extended-by "Carrier : Set"
Magma = Type  extended-by "_¬∑_ : Carrier ‚Üí Carrier ‚Üí Carrier"
CommutativeMagma = Magma extended-by "comm : {x y : Carrier} ‚Üí  x ¬∑ y  ‚â°  y ¬∑ x"
-}
#+END_SRC

The cool thing here is that ~CommutativeMagma~ comes with ~toMagma, toType,~ and ~toEmpty~.

However, life is messy and sometimes one may hurriedly create a structure,
then later realise that they are being forced to depend on unused methods.
Rather than throw an ‚Äònot implemented‚Äô exception or leave them undefined,
we may use the ~keeping~ variational to extract the smallest well-formed
sub-PackageFormer that mentions a given list of identifiers.

For example, suppose we quickly formed ~Monoid~, from earlier, but later wished
to utilise other substrata. This is easily achieved with the following declarations.
#+BEGIN_SRC agda
{-700
Empty‚Ä≥        = Monoid keeping ""
Type‚Ä≥         = Monoid keeping "Carrier"
Magma‚Ä≥        = Monoid keeping "_¬∑_"
Semigroup‚Ä≥    = Monoid keeping "assoc"
PointedMagma‚Ä≥ = Monoid keeping "ùïÄ; _¬∑_"
-- ‚Ü™ Carrier; _¬∑_; ùïÄ
-}
#+END_SRC
Even better, we may go about deriving results ---such as theorems or algorithms---
in familiar settings, such as ~Monoid~, only to realise that they are more expressive
than necessary. Such an observation no longer need to be found by inspection, instead
it may be derived mechanically.
#+BEGIN_SRC agda
{-700
LeftUnitalMagma = Monoid keeping "ùïÄ-unique" ‚ü¥ record
-}
#+END_SRC
This expands to the following theory, minimal enough to derive ~ùïÄ-unique~.
#+BEGIN_SRC agda-results :tangle no
record LeftUnitalMagma : Set‚ÇÅ where

   field
     Carrier : Set
     _¬∑_     : Carrier ‚Üí Carrier ‚Üí Carrier
     ùïÄ       : Carrier
     leftId  : {x : Carrier} ‚Üí ùïÄ ¬∑ x  ‚â° x

   ùïÄ-unique     : ‚àÄ {e} (lid : ‚àÄ {x} ‚Üí e ¬∑ x ‚â° x) (rid : ‚àÄ {x} ‚Üí x ¬∑ e ‚â° x) ‚Üí e ‚â° ùïÄ
   ùïÄ-unique lid rid = ‚â°.trans (‚â°.sym leftId) rid
#+END_SRC

Surprisingly, in some sense, ~keeping~ let's us apply the interface segregation principle,
or ‚Äòlittle theories‚Äô, after the fact ---this is also known as [[https://en.wikipedia.org/wiki/Reverse_mathematics][reverse mathematics]].

** 200+ theories -- one line for each
   :PROPERTIES:
   :CUSTOM_ID: hundreds-of-theories
   :END:

   People should enter terse, readable, specifications that expand into useful,
   typecheckable, code that may be dauntingly larger in textual size.

 The following listing of structures was adapted from the source of a
 MathScheme library cite:tpc,mathscheme, which in turn was inspired by
 the web lists of [[http://math.chapman.edu/~jipsen/structures/doku.php][Peter Jipsen]] and [[http://home.utah.edu/~nahaj/logic/structures/][John Halleck]], and many others from
 Wikipedia and nlab. Totalling over 200 theories which elaborate into
 nearly 1500 lines of typechecked Agda, this demonstrates that our systems works;
 the 750% efficiency savings speak for themselves.

 {{{fold(200+ One Line Specfications)}}}
 #+INCLUDE: "math-scheme.agda" src agda :lines "20-258"
 {{{end-fold}}}

 {{{fold(~1500 Lines of Typechecked Agda)}}}
 #+INCLUDE: "math-scheme-generated.agda" src agda
 {{{end-fold}}}

 If anything, this elaboration demonstrates our tool as useful engineering result.
 The main novelty being the ability for library users to extend the collection
 of operations on packages, modules, and then have it immediately applicable to
 Agda, an executable programming language.

 Since the resulting expanded code is typechecked by Agda, we encountered a number
 of places where non-trivial assumptions accidentally got-by the MathScheme team;
 for example, in a number of places, an arbitrary binary operation occurred multiple
 times leading to ambiguous terms, since no associativity was declared.
 Even if there was an implicit associativity criterion, one would then expect
 multiple copies of such structures, one for each parenthesisation.
 Moreover, there were also certain semantic concerns about the design
 hierarchy that we think are out-of-place, but we chose to leave them as is
 ---e.g., one would think that a ‚Äúpartially ordered magma‚Äù would consist of
 a set, an order relation, and a binary operation that is monotonic in both arguments
 wrt to the given relation; however, ~PartiallyOrderedMagma~ instead comes with
 a single monotonicity axiom which is only equivalent to the two monotonicity
 claims in the setting of a monoidal operation.
 Nonetheless, we are grateful for the source file provided by the MathScheme team.
 # Indeed, monotonicity in the second argument cannot be proven from the given
 # law for the operation ‚Äúx ‚ü™ y = x‚Äù when ‚â§ is taken to be ‚âà, and we have 2 points.

 + Unlike other systems, ours does not come with a static set of module operators
   ---it grows dynamically, possibly by you, the user.

 We implore the readers to build upon our code of theories above by, for example,
 define the notion of homomorphism for every single one of the theories.
 Besides being tiresome, such a manual process is also error-prone.
 Instead, one can automatically derive this concept!
 ( The construction of such a variational is delegated to the more involved
 second part of the user manual. )

 Likewise, for other concepts from universal algebra ---which is useful to computer
 science in the setting of specifications.

** Summary of Sample Variationals Provided With The System
   :PROPERTIES:
   :CUSTOM_ID: Summary-of-Sample-Variationals-Provided-With-The-System
   :END:

   Below are some variationals that can be used immediately by a user ---no Lisp knowledge required.
   If you simply mention one of them in a comment, then load the file with ~C-c C-l~, then you may hover
   over them to see their full documentation. You may also look at the second part of the user manual
   below to see accompanying examples.

   | _Name_                 | _Description_                                                               |
   | ~record~               | Reify a PackageFormer as a valid Agda record.                             |
   | ~extended-by~          | ‚äô Extend a PackageFormer by a string-‚Äú;‚Äù-list of declaration.             |
   | ~keeping~              | ‚òÖ Largest well-formed PackageFormer consisting of a given list of elements.  |
   | ~union~                | ‚äô Union two PackageFormers into a new one, maintaining relationships.     |
   | ~flipping~             | ‚äô Dualise a binary operation or predicate.                                |
   | ~unbundling~           | Consider the first /N/ elements, which may have definitions, as parameters. |
   | ~data~                 | Reify a PackageFormer as a valid Agda algebraic data type.                |
   | ~open~                 | Reify a given PackageFormer as a parameterised Agda ‚Äúmodule‚Äù declaration. |
   | ~opening~              | ‚òÖ Open a record as a module exposing only the given names.                |
   | ~open-with-decoration~ | Open a record, exposing all elements, with a given decoration.            |
   | ~sorts~                | Keep only the types declared in a grouping mechanism.                     |
   | ~signature~            | Keep only the elements that target a sort, drop all else.                 |
   | ~rename~               | ‚äô Apply a ~Name ‚Üí Name~ function to the elements of a PackageFormer.        |
   | ~renaming~             | ‚äô ‚òÖ Rename elements using a list of ‚Äúto‚Äù-separated pairs.                 |
   | ~decorated~            | ‚äô Append all element names by a given string.                             |
   | ~codecorated~          | ‚äô Prepend all element names by a given string.                            |
   | ~primed~               | ‚äô Prime all element names.                                                |
   | ~subscripted·µ¢~         | ‚äô Append all element names by subscript ~i : 0..9~.                         |
   | ~hom~                  | Formulate the notion of homomorphism of parent PackageFormer algebras.    |

  + ‚òÖ :: Argument is a string of ‚Äú;‚Äù-separated items consisting of ‚Äúto‚Äù-separated pairs.

         - ~keeping~ has input being ‚Äú;‚Äù-separated string of proper names only.

  + ‚äô :: The resulting PackageFormer is furnished with an element ~toP : P; to P = record {old·µ¢ = new·µ¢}~
         where ~P~ is the name of the parent, or source, PackageFormer. This element provides a way to
         view the resulting child presentation as an instance of the original presentation.

         - If we dislike the ~toP~ naming, we can simply invoke ~renaming~.

         - Sometimes these ‚Äòmaps‚Äô are invertible; we leave it as an exercise to the interested reader
           to formulate ~toP‚Åª¬π~ in the variationals, when possible.

         - Invoke a variational with ~:adjoin-retract nil~ if you do not want this map to be added;
           or use ~t~ in-place of ~nil~ if you insist on it being added.

 Below are the *five meta-primitives* from which all variationals are borne, followed by a few others
 that are useful for extending the system by making your own grouping mechanisms and operations on them.
 Using these requires a small amount of Lisp, which is tersely reviewed in the second part of the user
 manual, below.
 | _Name_            | _Description_                                                          |
 | ~:waist~          | Consider the first /N/ elements as, possibly ill-formed, parameters.   |
 | ~:kind~           | Valid Agda grouping mechanisms: ~record, data, module~.                |
 | ~:level~          | The Agda level of a PackageFormer.                                   |
 | ~:alter-elements~ | Apply a ~List Element ‚Üí List Element~ function over a PackageFormer.   |
 | ~‚ü¥~               | Compose two variational clauses in left-to-right sequence.           |
 | ~map~             | ‚äô Map a ~Element ‚Üí Element~ function over a PackageFormer.             |
 | ~generated~       | Keep the sub-PackageFormer whose elements satisfy a given predicate. |

* User Manual II: Extending the System
:PROPERTIES:
:header-args: :tangle "package-former.agda"
:CUSTOM_ID: User-Manual-II--Extending-the-System
:END:

:Hide:
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref std-ùí±-lib :noweb yes
(defvar ‚ôØstandard-variationals 10
  "The number of variationals exported with the PackageFormer system.")
#+END_SRC
:End:

Herein we demonstrate how with a little bit of Lisp, one may create any desired form of
grouping mechanism as well as operation between groupings.

We begin with a brief review of Lisp basics such as list operations then immediately dive into
creating an Agda module that contains our new user-defined constructs, within 700-comments.

** COMMENT Substructure
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-Substructure
   :END:
[ ] A substructure is one where a subset of the carrier set of a
structure itself carries the structure.

{-  lisp
;;   f : A ‚Üí A ‚Üí A
;; ‚áí f-closure : ‚àÄ {x‚ÇÅ x‚ÇÇ} ‚Üí ‚Ñ¨ x‚ÇÅ ‚Üí ‚Ñ¨ x‚ÇÇ ‚Üí ‚Ñ¨ (f x‚ÇÅ x‚ÇÇ)
;;
;; (predicate-closure (car (parse-elements '("f : A ‚Üí A ‚Üí A"))))
;;
(defun predicate-closure (e)
(let* ((indices (number-sequence 1 (1- (length (s-split "‚Üí" (element-type e))))))
       (args (s-join " " (--map (format "x%s" it) indices))))
  (concat (s-replace "_" "" (element-name e))
          "-closure : "
          (unless (s-blank-p args)
            (format "‚àÄ {%s} ‚Üí %s ‚Üí "
              args
              (s-join " ‚Üí " (--map (format "‚Ñ¨ x%s" it) indices))))
    (format "‚Ñ¨ (%s.%s ùíú %s)"
      $ùëùùëéùëüùëíùëõùë°
      (element-name e)
      args))))

(ùí± substructure carrier
= "C.f. ùí±-data ^_^"
 :alter-elements (Œª es ‚Üí
    (thread-last es
      (--filter (s-contains? carrier (target (element-type it))))
      (mapcar #'predicate-closure)
      (cons (format "‚Ñ¨ : %s.%s ùíú ‚Üí Set" $ùëùùëéùëüùëíùëõùë° carrier))
      (cons (format "ùíú : %s" $ùëùùëéùëüùëíùëõùë°))
      parse-elements)))
-}

{-700
SubMonoid = MonoidR substructure "Carrier" ‚ü¥ record
-}
** Lisp Interface
   :PROPERTIES:
   :CUSTOM_ID: Lisp-Interface
   :END:
{{{goal(Summary of useful functions for programming variationals.)}}}

   # Need to explain that a PackageFormer element is a structure consisting of a qualifier, name, type, and list of equational clauses.
   # Then, need to tersely summarise the operations, projections & maps, on these items.

   + A ~PackageFormer~ is nothing more than a list of elements.
   + An ~element~ is a record of 4 items: A qualifier, a name, a type, and
     a list of equational clauses for that name.

  Below are functions that will be used in subsequent subsections in order to form user-defined
  variationals. Consult these tables as necessary and look at an [[https://alhassy.github.io/ElispCheatSheet/][Elisp Cheat Sheet]], if need be.

  + *Elements*

    Let ‚Ñ∞ denote one of ~qualifier, name, type, equations~ in the following list of useful functions.

    | ~(make-element ùìÜ ùìÉ ùìâ ‚ÑØ)~      | An ~element~ value is formed.                                |
    | ~(element-‚Ñ∞ e)~               | Project component ‚Ñ∞ from element ~e~.                        |
    | ~(map-‚Ñ∞ f e)~                 | Return a copy of ~e~ with component ‚Ñ∞ updated by function ~f~. |
    | ~(element-replace old new e)~ | Replace all string occurances of ~old~ by ~new~ in element ~e~.  |

  + *Lists*

    | ~(list x‚ÇÄ ‚Ä¶ x‚Çô)~            | Form a list of elements ~x·µ¢~.                    |
    | ~(car xs)~                  | Obtain first element of list ~xs~.               |
    | ~(cdr xs)~                  | Obtain all but first element of ~xs~.            |
    | ~(cons x xs)~               | Form a new list with car ~x~ and cdr ~xs~.         |
    | ~(mapcar (Œª it ‚Üí ‚ãØit‚ãØ) xs)~ | Map the given function on ~xs.~                  |
    | ~(--map (‚ãØit‚ãØ) xs)~         | Map the /implicit/ function ~(Œª it ‚Üí ‚ãØit‚ãØ)~ on ~xs~. |
    | ~(-cons* x‚ÇÄ ‚Ä¶ x‚Çô xs)~       | ~(cons x‚ÇÄ (cons x‚ÇÅ (‚ãØ (cons x‚Çô xs))))~.          |
    |                           |                                                |

  + *Strings*

    | ~(concat s‚ÇÄ ‚Ä¶ s‚Çô)~      | Concatenate strings ~s·µ¢~.                                                 |
    | ~(s-replace old new s)~ | Replace all string occurrences of ~old~ by ~new~ in string ~e~.               |
    | ~(rename-mixfix f op)~  | Rename string ~op~ according to function ~f~ by ‚Äòleaping over‚Äô underscores. |
    |                       | E.g., ~f, op = (Œª x ‚Üí (concat x "‚Ä≤")), _‚äï_  ‚áí _‚äï‚Ä≤_~.                        |

  {{{goal(*You can always see the documentation of an item with ~C-h o~!*)}}}

** User Manual Header
   :PROPERTIES:
   :CUSTOM_ID: User-Manual-Header
   :END:
{{{goal(A literate programming approach to a user manual.)}}}

   In order for our manual's examples to be up-to-date, we will take a literate approach
   to producing them. Namely, the Agda code here is ‚Äòtangled‚Äô from this prose into an Agda
   file which can then be checked by an Agda process. Whence, this file is the de-facto source.

   Let's start-off with a usual Agda header:
#+BEGIN_SRC agda
{- This loads the PackageFormer metaprogram; press C-x C-e after the closing ‚Äú)‚Äù below.                 -}
{- (progn (load-file "~/.emacs.d/agda-next-700-module-systems.el") (agda-next-700-module-systems-mode)) -}

module package-former where

open import package-former-generated
open import Level
open import Data.Bool
open import Data.List using (List; _‚à∑_; []; foldr)
import Relation.Binary.PropositionalEquality as ‚â°; open ‚â° using (_‚â°_)

{- Let's ensure content of User Manual part I actually type checkes -}
{- Feel free to comment this line out. -}
import package-former-user-manual-i
#+END_SRC
#
# Strip away the 700 annotations with:
# (progn (700-bare-bones) (find-file "Testing_Bare.agda"))

To make the resulting Agda file somewhat self-contained, in case anyone wishes to read that
or load it into Agda and play with it, let's add a blurb.
#+BEGIN_SRC agda
{-
0. There are a number of common use-cases.
1. We can handle all of them & more, since we're extensible.
  - Mention the Lean & Coq, as well as the Agda, repeated fragments.
2. The resulting setup is pragmatic: It is unobtrusive in the
   traditional Agda coding style in that it happens in the background.
3. It fills a particular need; the desire to avoid repetitious code.
-}
#+END_SRC

Before getting to the meat of things, it is important to note that comments
begun with ~{-~ /and/ followed by a space are treated as usual Agda comments,
whereas those /without/ a following space such as ~{-700~ and ~{-lisp~ are picked-up
by our meta-program.

For example, having no space between ‚Äú{-‚Äù and ‚Äúlisp‚Äù would cause the following block to be executed
as a Lisp form.
#+BEGIN_SRC agda
{- lisp
(message-box "Hello")
(message-box "World")
-}
#+END_SRC

Alternatively, here is the PackageFormer for M-Sets from the introduction.
It is a useful example since it is multi-sorted.
#+BEGIN_SRC agda
{-700
PackageFormer M-Set : Set‚ÇÅ where
   Scalar  : Set
   Vector  : Set
   _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
   ùüô       : Scalar
   _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
-}
#+END_SRC
Let us also introduce a slightly more syntactically-involved example:
*A PackageFormer with equations.* The equations, /depending on our perspective,/
---i.e., the variational invoked--- may be thought of as:
+ Derived elements; e.g., in a record, they are a definitional extension
  and for an ADT, they are methods defined on the constructors.
+ Coherence constraints; e.g., in a record, we may interpret an equation ~ùìÅ = ùìá~
  as an additional axiom ~‚àÄ {‚ãØ} ‚Üí ‚Ñì ‚â° ùìá~ ---e.g., when a user may supply an efficient definition
  of ~ùìÅ~ but is constrained to have a particular behaviour ~ùìá~.
+ Rewrite rules; e.g., in an ADT, an equation may simply act as an alias and is to be used
  in rewriting the remainder of the ADT declaration.
+ Ignored components; e.g., in a record, we may ignore the equations altogether
  and lift the associated names into being fields ---e.g., ~_‚âà_~ would usually be lifted into
  a field and its stringent implementation via ~_‚â°_~ is used as a motivating or simplifying factor.

#+BEGIN_SRC agda
{-700
PackageFormer MonoidP : Set‚ÇÅ where

    -- A few declarations
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)

    -- We have a setoid-like structure; with a default implementation
    _‚âà_   : Carrier ‚Üí Carrier ‚Üí Set
    _‚âà_   = _‚â°_
    ‚®æ-cong : ‚àÄ {x y x‚Ä≤ y‚Ä≤} ‚Üí x ‚âà x‚Ä≤ ‚Üí  y ‚âà y‚Ä≤ ‚Üí (x ‚®æ y) ‚âà (x‚Ä≤ ‚®æ y‚Ä≤)
    ‚®æ-cong = Œª{ ‚â°.refl ‚â°.refl ‚Üí ‚â°.refl}

    -- For now only one item in a declaration;
    -- namely ‚ÄúLid‚Äù & ‚ÄúRid‚Äù cannot be declared in one line.
    Lid : Carrier ‚Üí Carrier
    Lid x = Id ‚®æ x
    Rid : Carrier ‚Üí Carrier
    Rid x = x ‚®æ Id

    -- Agda permits pure, non-pattern-matching, equations between ‚Äúfields‚Äù in a record.
    concat : List Carrier ‚Üí Carrier
    concat = foldr _‚®æ_ Id

    -- More declarations
    leftId  : ‚àÄ {x : Carrier} ‚Üí (Id ‚®æ x) ‚âà x
    rightId : ‚àÄ {x : Carrier} ‚Üí Rid x ‚âà x

    -- Since there are no more pure declarations, ‚Äúfields‚Äù, subsequent equations
    -- may use pattern matching.

    Id¬≤ : (Id ‚®æ Id) ‚âà Id
    Id¬≤ = rightId

    concat‚Çö : List Carrier ‚Üí Carrier
    concat‚Çö []       = Id
    concat‚Çö (x ‚à∑ xs) = x ‚®æ concat‚Çö xs
-}
#+END_SRC

Notice that there is no particular segregation of declarations and equations.
Simply: A declaration may /optionally/ have an associated equation; however
once an equation uses pattern matching then all subsequent declarations must also
have equations ---this is a constraint of the current Agda implementation---;
as such, the equation for ~‚®æ-cong~ uses Agda's pattern-matching-Œª.

:not_yet_implemented:
TODO: implement support for literate blocks

The ~{-700 ‚ãØ -}~ approach may be acceptable to those writing ~.agda~ files,
but those who write ~.lagda~ files may find themselves often having
~\begin{code} {-700 ‚ãØ -} \end{code}~ which is rather clunky.
Instead, they may simply write ~\begin{700} ‚ãØ \end{700}~ and similarly for ~lisp~.

| Henceforth, we omit the comment delimiters. |

For example, here is our earlier PackageFormer of ~M-Set~'s declared in full.
,#+BEGIN_SRC agda :tangle no
PackageFormer M-Set : Set‚ÇÅ where
   Scalar  : Set
   Vector  : Set
   _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
   ùüô       : Scalar
   _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
#+END_SRC
:end:

** Empty Variationals
   :PROPERTIES:
   :CUSTOM_ID: Empty-Variationals
   :END:
   :PROPERTIES:

   :END:
{{{goal(A summary of the key features of ùí±ariationals)}}}

   The simplest user definable variational is the empty one:
#+BEGIN_SRC agda
{-700
-- Variational with empty right hand side.
ùí±-identity =
-}
        #+END_SRC

   The prefix ~ùí±-~ signals to the Elisp meta-program that this particular equation is intended
   to be a variational and should be /loaded into Emacs/ as such. Indeed, you may view the documentation
   and /elaborated/ Lisp of this definition using ~C-h o RET ùí±-identity~.

   *Remember*: The prefix ~ùí±-~ only occurs at the definition site, the call site omits it.
   Why? We have augmented the Emacs system with a new functional definition, and the ùí±-
   serves as a namespace delimiter.

   Indeed, we may now perform the following invocation ---within 700-comments.

        #+BEGIN_SRC agda
{-700
MonoidP‚Å±·µà = MonoidP identity
-}
        #+END_SRC

 Loading the meta-program using Agda's usual ~C-c C-l~ lets us
 hover over ~MonoidP‚Å±·µà~ to see its elaboration is precisely that of ~MonoidP~.

 /Moreover/, to be useful, all variationals
 have tooltips showing their user-defined documentation.
 If we hover over ~identity~, we are informed that it is undocumented.
 User documentation is optional and may appear immediately following the ~=~, as follows.
#+BEGIN_SRC agda
{-700
ùí±-no-op = "This is the do-nothing variational"
-}
        #+END_SRC

We may substitute equals-for-equals:
        #+BEGIN_SRC agda
{-700
-- No variational clauses needed!
MonoidP‚Å∞  = MonoidP
-}
        #+END_SRC

Doing nothing is meaningful with respect to a composition operation.
Momentarily, ‚Äú‚ü¥‚Äù is forwards composition: We ‚Äòthread‚Äô the ~Pf~ through the variationals ~v·µ¢~ in order.

        #+BEGIN_SRC agda
{-700
-- Identity of composition ‚ü¥
MonoidP·∂ú = MonoidP ‚ü¥
-}
#+END_SRC

| Operationally: ~Pf ‚ü¥ v  ‚âà  Pf v ‚ü¥  ‚âà  Pf v~ |

We may also augment a variational with positional and (optional) keyword arguments that have default values.
The keyword arguments along with their default value, /if any/, are enclosed in parenthesis.
#+BEGIN_SRC agda
{-700
ùí±-test positional (keyword 3) another = "I have two mandatory arguments and one keyword argument"

Monoid-test = MonoidP ‚ü¥ test "positional arg‚ÇÅ" "positional arg‚ÇÇ" :keyword 25
-}
#+END_SRC

We are not doing anything with the arguments here; we shall return to this in later subsections.

** ‚á® Errors
   :PROPERTIES:
   :CUSTOM_ID: --Errors
   :END:
   :PROPERTIES:

   :END:
  Even though this is a prototype, we wish it to be useful to ourselves and to others
  ---especially those who take a quick glance, think they got it, and try things out only to not have them work
  immediately. As such, we have implemented a cute little error-reporting system.
  | If you try to load, ~C-c C-l~, but your 700-syntax is wrong, you get an immediate error explaining why ‚ô•‚Äø‚ô• |

  For example, suppose we accidentally wrote ~tester~ instead of ~test~, which we defined
  at the end of the previous section, as in the following.
  ( The space before ~700~ is so that this crashing block is not in effect. )
#+BEGIN_SRC agda
{-   700
ùí±-whoops  = tester 1 2 :keyword 3
-}
#+END_SRC
  When we try to load our Agda file the Agda process is interrupted and we are warned:
#+BEGIN_SRC text :tangle no
700: Did you mistype a variational‚Äôs name: ‚Äútester‚Äù is not defined.

    ‚á®	whoops = tester 1 2 :keyword 3
    ‚á®	Use the PackageFormer menu to see which variationals are defined.
#+END_SRC
  The 700 system informs us of our fault in ‚Äúquotes‚Äù, suggests a solution,
  and points to the offending declaration hierarchy. Neato (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

  The ‚Äúquotes‚Äù help, in this case, when there are multiple variationals being
  invoked in a clause.

  Of-course, we do not attempt to cover all possible errors ---e.g., wrong number
  of arguments or division by zero--- instead relying on Emacs Lisp's native
  error mechanism.

** Records and Meta-Primitives ~:kind~ & ~:alter-elements~
   :PROPERTIES:
   :CUSTOM_ID: Records-and-Meta-Primitives---kind------alter-elements-
   :END:
   Let's begin with the simplest thing: Realising these fictitious ‚ÄòPackageFormers‚Äô as records.

   An Agda ‚Äòrecord‚Äô is just a PackageFormer where the qualifier ~PackageFormer~ has been
   replaced with ~record~ and each element is qualified by Agda keyword ~field~.
   We may declare this particular configuration using the meta-primitives
   ~:kind~ and ~:alter-elements~, as follows.
#+BEGIN_SRC agda
{-700
ùí±-record‚ÇÄ = :kind record :alter-elements (Œª es ‚Üí (--map (map-qualifier (Œª _ ‚Üí "field") it) es))
-}
#+END_SRC

   *Huh?*
   The ~:kind~ part was already explained, the ~:alter-elements~ is the powerhouse of our system.
   It takes a function with argument being the list of PackageFormer elements, ~es~,
   then we perform a functorial list map where each element is implicitly referred to as ~it~.
   Then the map function is to alter the qualifier of an element by replacing it with the string ~"field"~.
   In Agda syntax this corresponds to: ~Œª es ‚Üí map (Œª it ‚Üí (map-qualifier (Œª _ ‚Üí "field") it)) es~.
   \\
   Notice that the Agda form and Lisp form are only one outer parenthesis off from each other ---Lisp is easy!

   | /The ~:key value~ syntax is inspired from Lisp/ |

   Unsurprisingly, we have elected to name this grouping mechanism configuration as ~ùí±-record~.
   Let's try it out.
#+BEGIN_src agda
{-700
M-Set-Record = M-Set record‚ÇÄ
-}
#+END_SRC

   The system picks this up, looks up ~M-Set~ which was defined in the first section earlier,
   looks up the variational ~record~, then runs that configuration to generate:
#+BEGIN_SRC results-agda :tangle no
{- M-Set-Record = M-Set record‚ÇÄ -}
record M-Set-Record : Set‚ÇÅ where
   field Scalar     : Set
   field Vector     : Set
   field _¬∑_        : Scalar ‚Üí Vector ‚Üí Vector
   field ùüô      : Scalar
   field _√ó_        : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId     : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc      : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
#+END_src

  Nothing too remarkable; the keyword ~field~ has been inserted and the rewrite ~PackageFormer ‚Ü¶ record~
  has been performed. The above is the /exact/ generated result of the system ---the comment indicates
  the source of this generated code.

** Equation Accommodating Record Variational
   :PROPERTIES:
   :CUSTOM_ID: Equation-Accommodating-Record-Variational
   :END:

  Since record formation is a variational that is likely to be used often, it is sensible to document it
  ---which in turn is attached to all occurences of the variational name via tooltips.
  Moreover, let's strengthen it to accomodate PackageFormers with equations.
#+BEGIN_SRC agda
{-lisp
(ùí± record‚ÇÅ (discard-equations nil)
 = "Reify a variational as an Agda ‚Äúrecord‚Äù.
    Elements with equations are construed as
    derivatives of fields  ---the elements
    without any equations--- by default, unless
    DISCARD-EQUATIONS is provided with a non-nil value.
   "
  :kind record
  :alter-elements
    (Œª es ‚Üí
      (thread-last es
      ;; Keep or drop eqns depending on ‚Äúdiscard-equations‚Äù
      (--map
        (if discard-equations
            (map-equations (Œª _ ‚Üí nil) it)
            it))
      ;; Unless there's equations, mark elements as fields.
      (--map (map-qualifier
        (Œª _ ‚Üí (unless (element-equations it)
               "field")) it)))))
-}
#+END_SRC

   Unlike ~ùí±-identity~ from a previous section, we have decided to split this definition into multiple
   lines by enclosing it in ~{-lisp ‚ãØ -~}~. Such blocks may contain arbitrary Lisp to be executed and so
   all contents must be Lisp forms ---notice the ~ùí±-‚ãØ~ from ~700~-blocks has been *exchanged* for
   a parenthesised (~ùí± ‚ãØ)~ within ~lisp~-blocks.

   Let's try this out.

   First, using only the default value ---which doesn't discard equations.
#+BEGIN_SRC agda
{-700
Monoid-Record-derived = MonoidP record‚ÇÅ
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record Monoid-Record-derived : Set‚ÇÅ where
    field Carrier       : Set
    field _‚®æ_       : Carrier ‚Üí Carrier ‚Üí Carrier
    field Id        : Carrier
    field assoc     : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    _‚âà_     : Carrier ‚Üí Carrier ‚Üí Set ; _‚âà_   = _‚â°_
    ‚®æ-cong      : ‚àÄ {x y x‚Ä≤ y‚Ä≤} ‚Üí x ‚âà x‚Ä≤ ‚Üí  y ‚âà y‚Ä≤ ‚Üí (x ‚®æ y) ‚âà (x‚Ä≤ ‚®æ y‚Ä≤) ;  ‚®æ-cong = Œª{ ‚â°.refl ‚â°.refl ‚Üí ‚â°.refl}
    Lid     : Carrier ‚Üí Carrier ;   Lid x = Id ‚®æ x
    Rid     : Carrier ‚Üí Carrier ;   Rid x = x ‚®æ Id
    concat      : List Carrier ‚Üí Carrier ;  concat = foldr _‚®æ_ Id
    field leftId        : ‚àÄ {x : Carrier} ‚Üí (Id ‚®æ x) ‚âà x
    field rightId       : ‚àÄ {x : Carrier} ‚Üí Rid x ‚âà x
    Id¬≤     : (Id ‚®æ Id) ‚âà Id ;  Id¬≤ = rightId
    concat‚Çö     : List Carrier ‚Üí Carrier ;  concat‚Çö []       = Id ; concat‚Çö (x ‚à∑ xs) = x ‚®æ concat‚Çö xs
#+END_SRC
   Second, discarding equations and lifting all elements into ~field~-s.
#+BEGIN_SRC agda
{-700
Monoid-Record-field = MonoidP record‚ÇÅ :discard-equations t
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record Monoid-Record-cons : Set‚ÇÅ where
    field Carrier       : Set
    field _‚®æ_       : Carrier ‚Üí Carrier ‚Üí Carrier
    field Id        : Carrier
    field assoc     : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    field _‚âà_       : Carrier ‚Üí Carrier ‚Üí Set
    field ‚®æ-cong        : ‚àÄ {x y x‚Ä≤ y‚Ä≤} ‚Üí x ‚âà x‚Ä≤ ‚Üí  y ‚âà y‚Ä≤ ‚Üí (x ‚®æ y) ‚âà (x‚Ä≤ ‚®æ y‚Ä≤)
    field Lid       : Carrier ‚Üí Carrier
    field Rid       : Carrier ‚Üí Carrier
    field concat        : List Carrier ‚Üí Carrier
    field leftId        : ‚àÄ {x : Carrier} ‚Üí (Id ‚®æ x) ‚âà x
    field rightId       : ‚àÄ {x : Carrier} ‚Üí Rid x ‚âà x
    field Id¬≤       : (Id ‚®æ Id) ‚âà Id
    field concat‚Çö       : List Carrier ‚Üí Carrier
#+END_SRC

Let's also codify the converse operation of marking a grouping mechanism abstract to avoid elaboration.
#+BEGIN_SRC emacs-lisp emacs-lisp :tangle "variationals.tmp" :noweb-ref std-ùí±-lib :noweb yes
(ùí± PackageFormer = "Mark a grouping mechanism as abstract, so that it is NOT elaborated into concrete Agda." :kind PackageFormer)
#+END_SRC

** A Coherent Equation Accommodating Record Variational
   :PROPERTIES:
   :CUSTOM_ID: A-Coherent-Equation-Accommodating-Record-Variational
   :END:

   Yet another option to handling equations is to drop the names that have
   equations associated with them. To tackle such a scenario
   requires the remaining elements to be well-defined and so requires ‚Äúthe largest sub-PackageFormer‚Äù.

   Coherent relationships are just graphs in disguise, so let's abstract away the details and solve
   a graph-theoretic problem. In ~{-lisp ‚ãØ -}~ blocks we may have arbitrary Emacs Lisp code and so include
   the following ---which has a large number of shortcomings, but the aim is a simple demonstration of Lisp
   code for the Agda user, not to be robust Lisp code. The name, <<<graph-map>>>, may not be ideal but it seems good enough, for now.
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref std-ùí±-lib :noweb yes
;; p ‚âà symptom; f ‚âà medicine; adj ‚âà neighbouring dependency
;;
(cl-defun graph-map (p f adj xs &optional keep-only-marked)
  "Map the nodes XS satisfying P by F along adjacency ADJ.
<<docs('graph-map)>>"
  (let* (;; Using -map instead of -filter since nodes may become
         ;; sickly later on, position matters.
         (sickly (-map p xs))
         ;; Obtain the items that are currently ‚Äòsickly‚Äô.
         (get-sickly (lambda ()
                       (--filter it (--zip-with (when it other) sickly xs))))
         ;; infected x  ‚â° x has a sickly neighbour
         (infected (Œª x ‚Üí (--any (funcall adj x it) (funcall get-sickly)))))

     ;; Propogate sickness.
     (loop for _ in xs
           do (loop for x in xs
                    for i from 0
                    do (when (funcall infected x) (setf (nth i sickly) t))))

     ;; Apply medication to sickly elements only.
     (--filter it (--map (if (-contains-p (funcall get-sickly) it)
                (funcall f it)
                (unless keep-only-marked it))
            xs))))
#+END_SRC

Here's how this works ---the following is what the incantation
above ~<<docs('graph-map)>>~ refers to, and the reader may ignore all ~<<‚Ä¶>>~
as they are a backend ‚Äòliterate programming‚Äô utility.

#+name: graph-map
- F is performed on nodes satisfying P,
  all neighbours are then considered to satisfy P
  and the process repeats recursively.

-  E.g., nodes exhibiting symptoms P are given medicine F,
  and their sickness spreads to their neighbours who in turn
  become ill thereby requiring medication, and the process continues.

- ADJ is a binary relation denoting adjacency.
  + (adj x y)  ‚âà  ‚Äúx depends on, or is a neighbour, of y.‚Äù

- For example, a graph of 10 nodes, with an edge between multiples;
  where nodes 3, 4, 5 are initally ill.

  #+BEGIN_SRC emacs-lisp :tangle no
   (graph-map (Œª x ‚Üí (-contains-p '(3 4 5) x))
              (Œª x ‚Üí (format "medicated-%s" x))
              (Œª x y ‚Üí (zerop (mod x y)))
              '(1 2 3 4 5 6 7 8 9 10))
  ‚áí
    (1 2 medicated-3 medicated-4 medicated-5 medicated-6 7
       medicated-8 medicated-9 medicated-10)
  #+END_SRC

Testing this graph-theoretic solution for our setting shows it to be a reasonable fit.
#+BEGIN_SRC emacs-lisp :tangle no
;; Example: Dropping the implementations of the first 2 items.
(setq i -1)
(graph-map (Œª _ ‚Üí (incf i) (< i 2))
           (Œª x ‚Üí (map-equations (Œª _ ‚Üí nil) x))
           ;; x depends on y  ‚â°  x mentions y in its type or equations.
           (Œª x y ‚Üí (s-contains? (s-replace "_" " " (element-name y)) (s-join " " (cons (element-type x) (element-equations x)))))
           (parse-elements '("A : Set" "_‚âà_ : A ‚Üí A ‚Üí Set" "_‚âà_ = _‚â°_" "easy : ‚àÄ {x} ‚Üí x ‚âà x" "easy = refl"
                             "another : ‚àÄ {x} ‚Üí Set" "another = easy" "by : Set‚ÇÅ" "by = Set"))))
‚áí
  A       : Set
  eq      : A ‚Üí A ‚Üí Set    ;; implementation dropped
  easy	  : ‚àÄ {x} ‚Üí x ‚âà x  ;; ditto, since it depends on ‚âà's implementation
  another : ‚àÄ {x} ‚Üí Set    ;; ditto, since it depends on easy's implementation
  by      : Set‚ÇÅ
  by      = Set‚ÇÅ
#+END_SRC

Let's introduce a dedicated form for ~element~ values:
#+name: --graph-map
- Mark elements in a given list, and recursively mark all those that depend on
  them.  Return the list of elements with the marked ones being altered.

- MARK and ALTER are expressions mentioning IT, a value of ELEMENTS,
  and so are implicit functional expressions.

- Only the MARKED elements are kept.
#+BEGIN_SRC emacs-lisp  :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(cl-defmacro --graph-map (mark alter elements &optional (keep-only-marked t))
  "Recursively ALTER and MARK elements and their dependents.
<<docs('--graph-map)>>"
  `(graph-map (Œª it ‚Üí ,mark)
              (Œª it ‚Üí ,alter)
              ;; x depends on y  ‚â°  x mentions y, with all or no undescores,
              ;;                    in its type or equations.
              (Œª x y ‚Üí
                 (or (s-contains? (s-replace "_" " " (element-name x))
                                  (s-join " " (cons (element-type y)
                                                    (element-equations y))))
                     (s-contains? (element-name x)
                                  (s-join " " (cons (element-type y)
                                                    (element-equations y))))))
              ,elements ,keep-only-marked))
#+END_SRC

Now the previous example may be invoked as:
#+BEGIN_SRC emacs-lisp :tangle no
(setq i -1)
(--graph-map (progn (incf i) (< i 3))
             (map-equations (Œª _ ‚Üí nil) it)
             (parse-elements '("A : Set" "_‚âà_ : A ‚Üí A ‚Üí Set" "_‚âà_ = _‚â°_"
                               "easy : ‚àÄ {x} ‚Üí x ‚âà x" "easy = refl"
                               "another : ‚àÄ {x} ‚Üí Set" "another = easy" "by : Set‚ÇÅ" "by = Set"))))
#+END_SRC

With these pieces in hand, let's form
#+BEGIN_SRC  emacs-lisp  :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± record (discard-equations nil) (and-names nil)
 = "Reify a variational as an Agda ‚Äúrecord‚Äù.

    By default, elements with equations are construed as
    derivatives of fields  ---the elements
    without any equations.

    ‚á® DISCARD-EQUATIONS is nil by default.
      If provided with a non-nil value, equations are dropped indiscriminately.

    ‚á® AND-NAMES is nil by default and only takes
      effect when DISCARD-EQUATIONS is active.
      If provided with a non-nil value, names with
      equations are dropped altogether; but some may be kept
      if they are needed for some fields to be well-defined.
   "
  :kind record
  :alter-elements
    (Œª es ‚Üí
      (thread-last es

      (funcall (Œª es‚Ä≤ ‚Üí (if (not discard-equations) es‚Ä≤
               (--map (map-equations (-const nil) (map-qualifier (-const (when (element-equations it) 'eqns)) it)) es‚Ä≤))))

      (funcall (Œª es‚Ä≤ ‚Üí (if (not and-names) es‚Ä≤
        (--graph-map (not (equal 'eqns (element-qualifier it))) it es‚Ä≤))))

      ;; Unless there's equations, mark elements as fields.
      (--map (map-qualifier
        (Œª _ ‚Üí (unless (element-equations it)
               "field")) it)))))
#+END_SRC
:old:
  :alter-elements
    (Œª es ‚Üí (thread-last es
              ;; Keep or drop eqns depending on ‚Äúdiscard-equationals‚Äù.
              (--filter (if and-names (not (element-equations it)) it))
              (--map (if discard-equations (map-equations (-const nil) it) it))
              ;; Unless there's equations, mark all remaining elements as fields.
              (--graph-map t (map-qualifier (-const (unless (element-equations it) "field")) it)))))
:end:
We can obtain the previous variationals ~rcord·µ¢~ as well as new presentations.
#+BEGIN_SRC agda
{-700
Monoid-Record-derived-again  = MonoidP record
Monoid-Record-derived-again2 = MonoidP record :and-names t
Monoid-Record-field-again    = MonoidP record :discard-equations t
Monoid-Record-no-equationals = MonoidP record :discard-equations t :and-names t
-}
#+END_SRC
The last form yields:
#+BEGIN_SRC results-agda :tangle no
record Monoid-Record-no-equationals : Set‚ÇÅ where
    field Carrier       : Set
    field _‚®æ_       : Carrier ‚Üí Carrier ‚Üí Carrier
    field Id        : Carrier
    field assoc     : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
#+END_SRC

** Typeclasses ---Parameterised Records--- and Meta-Primitives ~:waist~ & ~:level~
   :PROPERTIES:
   :CUSTOM_ID: Typeclasses----Parameterised-Records----and-Meta-Primitives---waist------level-
   :END:

    We mentioned the <<<‚Äúwaist‚Äù>>> before, but what is it exactly?
    I propose that the difference between ‚Äòfield‚Äô and ‚Äòparameter‚Äô
    is an illusion ---as is that of ‚Äòinput‚Äô and ‚Äòoutput‚Äô when one
    considers relations rather than deterministic functions.

    For example, let's alter the previous variation declaration to
    lift the waist up 2 positions.
#+BEGIN_src agda
{-700
ùí±-typeclass-attempt = record ‚ü¥ :waist 2
-}
        #+END_SRC

   Notice we have avoided repeating the definition of the ~record~ variational from
   earlier by making use of composition. More on it later, but it suffices to say
   that above we could replace ~record ‚ü¥~ with the exact text of ~ùí±-record = ‚ãØ~ right-hand-side
   and all would continue work.

   Trying this out, below, one notices that the first two elements of the PackageFormer have been lifted
   into being parameters, while the rest have been construed as fields.
       #+BEGIN_SRC agda
{-700
M-Set-TypeClass = M-Set typeclass-attempt
-}
                   #+END_SRC
                   #+BEGIN_SRC results-agda :tangle no
record M-Set-TypeClass (Scalar : Set) (Vector : Set) : Set‚ÇÅ where
   field _¬∑_        : Scalar ‚Üí Vector ‚Üí Vector
   field ùüô      : Scalar
   field _√ó_        : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId     : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc      : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
#+END_src

   While this typechecks according to Agda standards, it is not ideal to human
   standards since the level of the resulting package is larger than necessary.
   The meta-primitive ~:level~ allows us to ~inc~-rement or ~dec~-crement the
   current level of a PackageFormer, so we may instead define:
#+BEGIN_src agda
{-700
ùí±-typeclass‚ÇÇ = record ‚ü¥ :waist 2 :level dec
MonoidT‚ÇÇ      = MonoidP typeclass‚ÇÇ
-}
        #+END_SRC

        #+BEGIN_SRC results-agda :tangle no
record MonoidT‚ÇÇ (Carrier : Set) (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier) : Set where
    field Id        : Carrier
    field assoc     : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    field leftId        : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    field rightId       : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
        #+END_SRC

  # Unlike records, typeclasses scream to have an argument: The height of the waist.
  # Variationals may have arguments and we will cover this issue in a later subsection
  # in preference to continuing our purview of the meta-primitives.

  For fun, here are a few more to play with:
#+BEGIN_SRC agda
{-700
MonoidT‚ÇÉ         = MonoidP record ‚ü¥ :waist 3 :level dec
-- MonoidT‚ÇÉ-again   = MonoidP ‚ü¥ record ‚ü¥ unbundling 3
M-Set-Typeclass‚ÇÇ = M-Set record ‚ü¥ typeclass‚ÇÇ
-}
#+END_SRC

In particular, the last example suggest that our composition is idempotent, but this is clearly not the case.
Indeed, here's a pretty alternative to the meta-primitive ~:waist~ that is not ‚ü¥-idempotent
but is in-fact a homomorphism: ~unbundling n ‚ü¥ unbundling m ‚âà unbundling (n + m)~.
#+BEGIN_SRC lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± unbundling n
 = "Make the first N elements as parameters to the PackageFormer.

    Any elements in above the waist line have their equations dropped.
    As such, unbundling is not invertible.
   "
   :waist n
   :alter-elements (Œª es ‚Üí
     (-let [i 0]
       (--graph-map (progn (incf i) (<= i n))
                    (map-equations (-const nil) it)
                    es))))
#+END_SRC
( The graph-map operation was defined in the previous section. )

Incidentally, this solves the problem of lifting the waist to include elements with equations.
#+BEGIN_SRC agda
{-700
-- Ill-formed in Agda: A defintion is not a parameter!
MonoidP-Typeclass‚ÇÖ = MonoidP :waist 5
-}
    #+END_SRC

    #+BEGIN_SRC results-agda :tangle no
{- Kind ‚ÄúPackageFormer‚Äù does not correspond  to a concrete Agda type.
{- MonoidP-Typeclass‚ÇÖ = MonoidP :waist 5 -}
PackageFormer MonoidP-Typeclass‚ÇÖ (Carrier : Set) (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier) (Id : Carrier) (assoc : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)) (_‚âà_ : Carrier ‚Üí Carrier ‚Üí Set ; _‚âà_ = _‚â°_) : Set‚ÇÅ where
    ‚®æ-cong      : ‚àÄ {x y x‚Ä≤ y‚Ä≤} ‚Üí x ‚âà x‚Ä≤ ‚Üí  y ‚âà y‚Ä≤ ‚Üí (x ‚®æ y) ‚âà (x‚Ä≤ ‚®æ y‚Ä≤) ;  ‚®æ-cong = Œª{ ‚â°.refl ‚â°.refl ‚Üí ‚â°.refl}
    Lid     : Carrier ‚Üí Carrier ;   Lid x = Id ‚®æ x
    Rid     : Carrier ‚Üí Carrier ;   Rid x = x ‚®æ Id
    concat      : List Carrier ‚Üí Carrier ;  concat = foldr _‚®æ_ Id
    leftId      : ‚àÄ {x : Carrier} ‚Üí (Id ‚®æ x) ‚âà x
    rightId     : ‚àÄ {x : Carrier} ‚Üí Rid x ‚âà x
    Id¬≤     : (Id ‚®æ Id) ‚âà Id ;  Id¬≤ = rightId
    concat‚Çö     : List Carrier ‚Üí Carrier ;  concat‚Çö []       = Id ; concat‚Çö (x ‚à∑ xs) = x ‚®æ concat‚Çö xs -}
#+END_SRC

#+BEGIN_SRC agda
{-700
MonoidT‚ÇÖ = MonoidP ‚ü¥ unbundling 5 ‚ü¥ record
-}
    #+END_SRC
    #+BEGIN_SRC results-agda :tangle no
record MonoidT‚ÇÖ (Carrier : Set) (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier) (Id : Carrier) (assoc : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)) (_‚âà_ : Carrier ‚Üí Carrier ‚Üí Set) : Set‚ÇÅ where
    field ‚®æ-cong        : ‚àÄ {x y x‚Ä≤ y‚Ä≤} ‚Üí x ‚âà x‚Ä≤ ‚Üí  y ‚âà y‚Ä≤ ‚Üí (x ‚®æ y) ‚âà (x‚Ä≤ ‚®æ y‚Ä≤)
    field Lid       : Carrier ‚Üí Carrier
    field Rid       : Carrier ‚Üí Carrier
    field concat        : List Carrier ‚Üí Carrier
    field leftId        : ‚àÄ {x : Carrier} ‚Üí (Id ‚®æ x) ‚âà x
    field rightId       : ‚àÄ {x : Carrier} ‚Üí Rid x ‚âà x
    field Id¬≤       : (Id ‚®æ Id) ‚âà Id
    field concat‚Çö       : List Carrier ‚Üí Carrier
#+END_SRC

 :smile:

** Primed Decoration and ~rename-mixfix~
   :PROPERTIES:
   :CUSTOM_ID: Primed-Decoration-and--rename-mixfix-
   :END:

    When we have two occurrences of a structure, we may want one of them to be decorated
    say with a prime so as to disambiguate them easily rather than have to qualify all
    of their components.

#+BEGIN_src agda
{-700
-- Intentionally erroenous attempt.
ùí±-primed-attempt = :alter-elements (Œª es ‚Üí (--map (map-name (Œª n ‚Üí (rename-mixfix (Œª np ‚Üí (concat np "‚Ä≤")) n)) it) es))

-- M-Set‚Ä≤-attempt = M-Set record ‚ü¥ primed-attempt
-}
#+END_SRC

#+BEGIN_SRC results-agda :tangle no
record M-Set‚Ä≤-attempt : Set‚ÇÅ where
   field Scalar‚Ä≤        : Set
   field Vector‚Ä≤        : Set
   field _¬∑‚Ä≤_       : Scalar ‚Üí Vector ‚Üí Vector
   field ùüô‚Ä≤     : Scalar
   field _√ó‚Ä≤_       : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId‚Ä≤        : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc‚Ä≤     : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
{- This is crashing Agda code; as expected. Working improvements below. -}
#+END_src

   There are number of issues to address.

   1. The system comes with a Lisp methods ~map-name~ and ~map-type~ that yield the name and type part,
      respectively, of a PackageFormer element.

   2. The ~:key value~ pairs have legitimate Lisp for the ~value~ positions.

      The basics of list processing, such as maps/filters/folds, with Lisp suffice for a rich
      inventory of possible configurations. Moreover, the functional nature of such higher-order
      functions ought to be familiar to any Agda coder [[https://www.phrases.org.uk/meanings/worth-ones-salt.html][worth their salt]].

      Here's a terse tutorial rendered as an [[https://alhassy.github.io/ElispCheatSheet/][Elisp Cheat Sheet]].

   3. One would expect catenating a prime to the mixfix name ~_√ó_~ would yield ~_√ó_‚Ä≤~ but above
      it yielded ~_√ó‚Ä≤_~. Indeed, the former would yield confusing expressions of the form
      ~1 √ó 2 ‚Ä≤~ whereas the latter permits ~1 √ó‚Ä≤ 2~. It is with this pragmatic usage that
      ~rename-mixfix~ performs a rewrite to a name by jumping over the Agda mixfix marker, ~_~,
      if it occurs at the start or end of a name.

      As an additional example, the name
      ~_‚âà_‚à∂_~, under the above scheme, would have rewritten to ~_‚âà_‚à∂‚Ä≤_~ thereby
      allowing terms such as ~x ‚âà y ‚à∂ A  ‚Üí  f x ‚âà f y ‚à∂‚Ä≤ B~ ---a elegant way to
      express that, say, ~f~ is a setoid homomorphism.
      If the prime scheme were instead a prepend, we would have obtained the name
      ~_‚Ä≤‚âà_‚à∂_~.

   # Notice that the generated code is commented out: The current type of the package
   # is not an admissible construct in Agda.

   # Moreover, if we try to instantiate this package further, say as in    ~M‚Ä≤ = M-Set‚Ä≤-attempt record~

   Notice that
   we have fields such as ~ùüô‚Ä≤ : Scalar~
   whose type is a free variable: ~Scalar~ no longer refers to any field.
   As such, the above code is ill-typed.
   The solution then is to /propagate/ any changes a name has down to its siblings.
   We will return to this later in the form of a ~map~ variational.

*** COMMENT primer
    :PROPERTIES:
    :CUSTOM_ID: COMMENT-primer
    :END:
   Indeed, /propagating the name changes:/
#+BEGIN_SRC agda
{-lisp
(ùí± primer = :alter-elements (lambda (es)
   (let* ((esnew es)
         ;; Let's try to accomodate for names with underscores
         (names_ (--map (element-name it) es))
         (names  (--map (s-replace "_" "" it) names_))
         (oldies (append names names_)))

     (loop for old in oldies
           for new in (--map (rename-mixfix (Œª n ‚Üí (concat n "‚Ä≤")) it) oldies)
           do
           (setq esnew (--map (element-replace old new it) esnew)))

     ;; return value
     esnew)))
-}
#+END_SRC

Then, for example:
#+BEGIN_SRC agda
{-700
MR‚Ä≤ = M-Set record ‚ü¥ primer
-}
        #+END_SRC

        #+BEGIN_SRC results-agda :tangle no
record MR‚Ä≤ : Set‚ÇÅ where
   field Scalar‚Ä≤        : Set
   field Vector‚Ä≤        : Set
   field _¬∑‚Ä≤_       : Scalar‚Ä≤ ‚Üí Vector‚Ä≤ ‚Üí Vector‚Ä≤
   field ùüô‚Ä≤     : Scalar‚Ä≤
   field _√ó‚Ä≤_       : Scalar‚Ä≤ ‚Üí Scalar‚Ä≤ ‚Üí Scalar‚Ä≤
   field leftId‚Ä≤        : {ùìã : Vector‚Ä≤}  ‚Üí  ùüô‚Ä≤ ¬∑‚Ä≤ ùìã  ‚â°  ùìã
   field assoc‚Ä≤     : {a b : Scalar‚Ä≤} {ùìã : Vector‚Ä≤} ‚Üí (a √ó‚Ä≤ b) ¬∑‚Ä≤ ùìã  ‚â°  a ¬∑‚Ä≤ (b ¬∑‚Ä≤ ùìã)
#+END_SRC

:maybe_not:
   Since 700-declarations must be single lines, we are forced to have something like
   the following ---which you are not expected to understand, but it serves as a nice
   comparison and motivation for the alternative approach below.
#+BEGIN_SRC results-agda :tangle no
{-700

ùí±-primed‚Çó‚Çë‚Çú = :alter-elements (lambda (fs) (-as-> (-unzip (--zip-with `(,other  ,(format "let %s = %s in " (get-name it) (get-name other))) fs (--map (map-name (concat name "‚Ä≤") it) fs))) yup (--zip-with (map-type (concat (s-join "" it) type) other) (-inits (cadr yup)) (car yup))))

MonoidR‚Ä≤   =  MonoidP record ‚ü¥ primed‚Çó‚Çë‚Çú
-}

record MonoidR‚Ä≤ : Set‚ÇÅ where
  field
    Carrier‚Ä≤ : Set
    _‚®æ‚Ä≤_ : let Carrier = Carrier‚Ä≤ in Carrier ‚Üí Carrier ‚Üí Carrier
    Id‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in Carrier
    assoc‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in let Id = Id‚Ä≤ in ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in let Id = Id‚Ä≤ in let assoc = assoc‚Ä≤ in ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in let Id = Id‚Ä≤ in let assoc = assoc‚Ä≤ in let leftId = leftId‚Ä≤ in ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x

#+END_SRC
:End:

** First-class PackageFormers
   :PROPERTIES:
   :CUSTOM_ID: First-class-PackageFormers
   :END:

   The previous example caused an Agda typechecking error, however if we do not
   invoke the ~record~ variational then the result is a non-Agda syntactical item
   which can only be the subject of further alteration via PackageFormer combinators.
#+BEGIN_src agda
{-700
M-Set‚Ä≤-attempt-raw = M-Set primed-attempt
-}
        #+END_SRC

        #+BEGIN_SRC results-agda :tangle no
{- Kind ‚ÄúPackageFormer‚Äù does not correspond  to a concrete Agda type.
PackageFormer M-Set‚Ä≤-attempt-raw : Set‚ÇÅ where
   Scalar‚Ä≤      : Set
   Vector‚Ä≤      : Set
   _¬∑‚Ä≤_     : Scalar ‚Üí Vector ‚Üí Vector
   ùüô‚Ä≤       : Scalar
   _√ó‚Ä≤_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId‚Ä≤      : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc‚Ä≤       : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã) -}
#+END_src

    This is interesting: We have not generated a concrete ---legitimate Agda construct---
    but instead yielded a new abstract grouping mechanism which may be instantiated later on,
    whenever desired.

    Likewise, we have already declared ~M-Set-Record = M-Set record~ and now we may apply
    our priming variational.
    #+BEGIN_src results-agda :tangle no
{- M-Set-Record‚Ä≤ = M-Set-Record primed-attempt -}
record M-Set-Record‚Ä≤ : Set‚ÇÅ where
   field Scalar‚Ä≤        : Set
   field Vector‚Ä≤        : Set
   field _¬∑‚Ä≤_       : Scalar ‚Üí Vector ‚Üí Vector
   field ùüô‚Ä≤     : Scalar
   field _√ó‚Ä≤_       : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId‚Ä≤        : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc‚Ä≤     : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
#+END_src

    | /We may apply  variationals even to concrete Agda packaging constructs!/ |

    Of-course, we may simply want to obtain ~M-Set-Record‚Ä≤~ without having first
    to define ~M-Set-Record~, and so we may use the variational composition operator ~‚ü¥~.

#+BEGIN_src results-agda :tangle no
{- M-Set-Record‚Ä≤ = M-Set record ‚ü¥ primed-attempt -}
record M-Set-Record‚Ä≤ : Set‚ÇÅ where
   field Scalar‚Ä≤        : Set
   field Vector‚Ä≤        : Set
   field _¬∑‚Ä≤_       : Scalar ‚Üí Vector ‚Üí Vector
   field ùüô‚Ä≤     : Scalar
   field _√ó‚Ä≤_       : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId‚Ä≤        : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc‚Ä≤     : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
#+END_src

   Since the ~record~ and ~primed~ configurations are ‚Äòdisjoint‚Äô, they commute
   with respect to composition. The reader may want to confirm the following identifications:
#+BEGIN_SRC agda :tangle no
      M-Set-Record‚Ä≤
   ‚âà  M-Set record ‚ü¥ primed-attempt
   ‚âà  M-Set primed-attempt ‚ü¥ record
   ‚âà  M-Set‚Ä≤ record
   ‚âà  M-Set-Record primed-attempt
#+END_SRC

It is important to remember that these primed perspectives do /not/ typecheck in Agda due to the free-variable
issue mentioned earlier. We are only demonstrating composition, ~‚ü¥~, in this section; in a later section we
fix-up ~primed~.

** Variationals with Arguments ---~map, rename, [co]decorated, subscripted·µ¢, renaming~
   :PROPERTIES:
   :CUSTOM_ID: Variationals-with-Arguments-----map--rename---co-decorated--subscripted·µ¢--renaming-
   :END:

    Thus far our variationals have been nullary, let's consider otherwise.

    For example, let's add arguments to the typeclass variational from earlier.
    :Not_now:
    An issue with this is that it may decrement the level too much; e.g., try it with
    no args given to M-Set.
    #+BEGIN_SRC lisp :tangle no
(ùí± typeclass (height 1) (level 'dec)
  = "Expose the first element and decrese the package's level ---c.f. Haskell typeclass.

     The optional keywords HEIGHT and LEVEL may be used to expose any number of
     elements and possibly increment the level, respectively.
    "
    record ‚ü¥ :waist height :level level)
    #+END_SRC
    :End:
    #+BEGIN_src agda
{-700
ùí±-typeclass height (level 'dec) = record ‚ü¥ :waist height :level level
M-Set2-Typeclass‚ÇÉ = M-Set typeclass 3 :level 'inc
M-Set0-Typeclass‚ÇÉ = M-Set typeclass 3
-}
        #+END_SRC

        #+BEGIN_SRC results-agda :tangle no
record M-Set2-Typeclass‚ÇÉ (Scalar : Set) (Vector : Set) (_¬∑_ : Scalar ‚Üí Vector ‚Üí Vector) : Set‚ÇÇ where
   field ùüô      : Scalar
   field _√ó_        : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId     : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc      : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)

record M-Set0-Typeclass‚ÇÉ (Scalar : Set) (Vector : Set) (_¬∑_ : Scalar ‚Üí Vector ‚Üí Vector) : Set where
   field ùüô      : Scalar
   field _√ó_        : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId     : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc      : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
#+END_src

   + Argument come before the ~=~ in a variational's definition and
     the may be used as if they were constants on the right-hand side.
     0. Above we introduced the named arguments ~height~ and ~level~.
     1. The first is positional, and the second is a keyword argument
        with /default/ value being a decrement value.
     2. We then passed the /argument/ ~level~ to the /meta-primitive/ ~:level~.

   + Invocation of variationals has positional arguments first then named arguments afterwards.
     One supplies a named argument in the form ~:argument-name the-value~ ---this is Lisp-inspired syntax.

     Consequently, order is irrelevant for named arguments.

     - Supplying ~:key value~ pairs where the ~key~ is not a named argument of
       the variational yields a error message indicating the allowable keys.

   # ‚û± If an argument is not supplied or its value is unacceptable, the cute
   # error-reporting mechanism is activated ---as is the case with other
   # pertinent aspects of loading such declarations.

   Let's code up the priming operation as a reusable pattern ---call it ~map~.
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(eval-and-compile
(ùí± map elements (support-mixfix-names nil) (adjoin-retract nil) (adjoin-coretract nil)
   = "Apply function ELEMENTS that acts on PackageFormer elements,
      then propogate all new name changes to subsequent elements.

      There is minimal support for mixfix names, but it may be
      ignored by setting SUPPORT-MIXFIX-NAMES to be nil.

      When ADJOIN-RETRACT is non-nil, we adjoin a ‚Äúrecord {old·µ¢ = name·µ¢}‚Äù
      view morphism; i.e., record translation.

      Clauses ‚Äúf = f‚Äù are considered to occur only in views, record translations,
      and so only the RHS occurance is updated to a new name.
      C.f. the definition of element-retract.
      "
     :alter-elements (lambda (es)

    (let* ((es‚Ä≤    (mapcar elements es))
           (names  (mapcar #'element-name es))
           (names‚Ä≤ (mapcar #'element-name es‚Ä≤)))

      ;; Replace all occurances of old names with corresponding new ones.
      (loop for old in names
            for new in names‚Ä≤
            do (setq es‚Ä≤ (--map (element-replace old new it :support-mixfix-names support-mixfix-names :avoid-altering-names (equal new (element-name it))) es‚Ä≤)))
            ;; E.g., With ‚Äúelements = Œª x ‚Ü¶ x‚Ä≤‚Äù, a name ‚Äúop‚Äù goes to ‚Äúop‚Ä≤‚Äù, such a name-change should propogate everywhere including in old names ‚Äúop-some-property‚Äù,
            ;; to obtain ‚Äúop‚Ä≤-some-property‚Äù, but we should not propogate it to the newely named element ‚Äúop‚Ä≤‚Äù thereby accidentally obtaining ‚Äúop‚Ä≤‚Ä≤‚Äù.

     ;; return value
     (-concat es‚Ä≤ (when adjoin-retract (list (element-retract $ùëùùëéùëüùëíùëõùë° es :new es‚Ä≤ :name adjoin-retract)))
                  (when adjoin-coretract (list (element-retract $ùëùùëéùëüùëíùëõùë° es‚Ä≤ :new es :name adjoin-coretract :contravariant t)))))))
)
#+END_SRC

#+RESULTS:
: ùí±-map

  This is a prototype; ideally the variational definition would be rendered in
  Agda code. Rather than using functional combinators such as
  ~unzip, map, zip-with~, for diversity, we used imperative constructs.

Important observations include:

1. The Lisp code lives in a ~{-lisp ‚ãØ -}~ block.

2. 700-comments have single-line ~ùí±-name args = rhs~, whereas lisp-blocks
   have multi-line ~(ùí± name args = rhs)~ ---the dash after the ùí± is gone and outer-most
   parenthesis are added.

3. To provide minimal accommodation for mixfix names, we simply remove the
   Agda argument indicator ‚Äò_‚Äô when performing rewrites.

   E.g., Agda let's you
   declare a name such as ~_‚äï_~ and use it without mentioning the underscore
   as in ~x ‚äï y~ and so the rename ~_‚äï_ ‚Ü¶ _‚äï‚Ä≤_~ would have no effect since ~_‚äï_~
   does not occur as a substring in ~x ‚äï y~, whence the need to ignore the underscores.

Trying it out:
#+BEGIN_SRC agda
{-700
MRùïè    = M-Set record ‚ü¥ map (Œª e ‚Üí (map-name (Œª n ‚Üí (rename-mixfix (Œª x ‚Üí (concat x "ùïè")) n)) e))
-}
        #+END_SRC
#+BEGIN_SRC results-agda :tangle no
record MRùïè : Set‚ÇÅ where
   field Scalarùïè        : Set
   field Vectorùïè        : Set
   field _¬∑ùïè_       : Scalarùïè ‚Üí Vectorùïè ‚Üí Vectorùïè
   field ùüôùïè     : Scalarùïè
   field _√óùïè_       : Scalarùïè ‚Üí Scalarùïè ‚Üí Scalarùïè
   field leftIdùïè        : {ùìã : Vectorùïè}  ‚Üí  ùüôùïè ¬∑ùïè ùìã  ‚â°  ùìã
   field assocùïè     : {a b : Scalarùïè} {ùìã : Vectorùïè} ‚Üí (a √óùïè b) ¬∑ùïè ùìã  ‚â°  a ¬∑ùïè (b ¬∑ùïè ùìã)
#+END_SRC

Now for some useful corollaries.
# For diversity, we render these in lisp-blocks.
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± rename f (support-mixfix-names t) (adjoin-retract t)
  =  "Rename elements using a string-to-string function F acting on names.

      There is minimal support for mixfix names, which may be ignored
      by setting SUPPORT-MIXFIX-NAMES to be nil.

      When ADJOIN-RETRACT is non-nil, we adjoin a ‚Äúrecord {old·µ¢ = name·µ¢}‚Äù
      view morphism; i.e., record translation.
     "
     map (Œª e ‚Üí (map-name (Œª n ‚Üí (rename-mixfix f n (not 'support-mixfix-names))) e))
         :support-mixfix-names 'support-mixfix-names
         :adjoin-retract 'adjoin-retract)
#+END_SRC

Let's try this out.
#+BEGIN_SRC agda
{-700
MRùï™    = M-Set-Record rename (Œª n ‚Üí (concat n "ùï™"))
MR-oh  = M-Set-Record rename (Œª n ‚Üí (pcase n ("Scalar" "S") ("ùüô" "Œµ") (else else)))
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record MRùï™ : Set‚ÇÅ where
   field Scalarùï™        : Set
   field Vectorùï™        : Set
   field _¬∑ùï™_       : Scalarùï™ ‚Üí Vectorùï™ ‚Üí Vectorùï™
   field ùüôùï™     : Scalarùï™
   field _√óùï™_       : Scalarùï™ ‚Üí Scalarùï™ ‚Üí Scalarùï™
   field leftIdùï™        : {ùìã : Vectorùï™}  ‚Üí  ùüôùï™ ¬∑ùï™ ùìã  ‚â°  ùìã
   field assocùï™     : {a b : Scalarùï™} {ùìã : Vectorùï™} ‚Üí (a √óùï™ b) ¬∑ùï™ ùìã  ‚â°  a ¬∑ùï™ (b ¬∑ùï™ ùìã)


{- MR-oh  = M-Set record ‚ü¥ rename (Œª n ‚Üí (pcase n ("Scalar" "S") ("ùüô" "Œµ") (else else))) -}
record MR-oh : Set‚ÇÅ where
   field S      : Set
   field Vector     : Set
   field _¬∑_        : S ‚Üí Vector ‚Üí Vector
   field Œµ      : S
   field _√ó_        : S ‚Üí S ‚Üí S
   field leftId     : {ùìã : Vector}  ‚Üí  Œµ ¬∑ ùìã  ‚â°  ùìã
   field assoc      : {a b : S} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
                        #+END_SRC

We would expect it to be common to prefix and suffix symbols, so let's make
variationals for these patterns.
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± decorated by
  = "Rename all elements by suffixing string BY to them."
     rename (Œª name ‚Üí (concat name by)))

(ùí± co-decorated by
  = "Rename all elements by prefixing string BY to them."
     rename (Œª name ‚Üí (concat by name)))

(ùí± primed
  = "All elements are renamed with a postfix prime."
    decorated "‚Ä≤")
#+END_SRC

Likewise, for the casing approach, let's make a ‚Äúto list‚Äù.
For now, such lists are necessarily enclosed in double-quotes.

#+name: reify-to-list
- Given a string of ‚Äú;‚Äù-separated items consisting of ‚Äúto‚Äù-separated pairs,
  interpret it as a Lisp function where ‚Äúto‚Äù-pairs denote mapping clauses.

- E.g., ‚Äúx‚ÇÄ to y‚ÇÄ; ‚Ä¶; x‚Çô to y‚Çô‚Äù becomes the function sending value x·µ¢ to y·µ¢,
  and behaves as the identity function otherwise unless OTHERWISE is provided,
  in which case it acts as a fallback.

- Concretely:
  #+BEGIN_SRC emacs-lisp :tangle no
      (reify-to-list "1 to x; 2 to y; p to q")
    ‚âà (Œª arg ‚Üí (pcase arg ("1" "x") ("2" "y") ("p" "q") (otherwise otherwise)))
  #+END_SRC

#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
;; Neato: (reify-to-list "x‚ÇÄ; ‚ãØ; x‚Çô" nil) ‚áí (Œª x ‚Ü¶ If ‚àÉ i ‚Ä¢ x ‚âà x·µ¢ then "" else nil)
;; KEY is a function applied to the input argument /before/ casing on LHS ‚Ü¶ RHS names.
;; INVERSE means to interpret clauses ‚Äúx to y‚Äù as mappings ‚Äúy ‚Ü¶ x‚Äù.
   (cl-defun reify-to-list (str &key (otherwise 'otherwise) (key #'identity) inverse)
   "Transform ‚Äúto list‚Äù STR with default OTHERWISE into a Lisp function.
<<docs('reify-to-list)>>"
   (let (clauses)
     (thread-last str
       (s-split ";")
       (--map (s-split " to " it))
       (--map (list (s-trim (car it)) (s-trim (or (cadr it) "")))) ;; accomodate empty str.
       (funcall (Œª cs ‚Üí (if inverse (--map (-rotate 1 it) cs) cs)))
       (-cons* 'pcase `(,key arg))
       (setq clauses))
     `(lambda (arg) ,(append clauses `((otherwise ,otherwise))))))

;; (reify-to-list "a to b; c to d" :inverse t) ;; neato!

(ùí± renaming by  (adjoin-retract nil) (adjoin-coretract nil)
= "Rename elements using BY, a ‚Äú;‚Äù-separated string of ‚Äúto‚Äù-separated pairs.

      Unlike ‚Äòrename‚Äô, this variational permits simultaneous renaming.
      Moreover, when the to-list is 1-to-1, we have a constructible bijection
      via ADJOIN-CORETRACT.

      When ADJOIN-RETRACT is non-nil, we adjoin a ‚Äúrecord {old·µ¢ = name·µ¢}‚Äù
      view morphism; i.e., record translation.
      Likewise for ADJOIN-CORETRACT results in the inverse morphism,
      ‚Äúrecord {name·µ¢ = old·µ¢}‚Äù.
"

   :alter-elements (Œª es ‚Üí

   ;; Function factorisation lol
(when nil
a ‚Üí b‚Ä≤; b ‚Üí a; c ‚Üí c‚Ä≤
a ‚Üí b‚Ä≤; b ‚Üí NEW[a] ‚Üí a; c ‚Üí c‚Ä≤
)

   (let* ((tos   (s-split ";" by))
          (to-s (--map (s-split "to" it) tos))
          (trim (Œª x ‚Üí (if x (s-trim x) ""))) ;; Trim if non-nil, else empty string
          (srcs (mapcar trim (mapcar #'car to-s)))
          (tgts (mapcar trim (mapcar #'cadr to-s)))
          (eek (intersection srcs tgts :test #'string-equal))
          es‚Ä≤
          freshies
          (injective-naming (s-join " ; " (--map (s-join " to " it)
(loop for x in srcs
      for y in tgts
      for fresh = (if (member y eek) (caar (push (cons (rename-mixfix (-const (format "%s" (gensym))) y) y) freshies)) y)
      collect (list x fresh)))))

          (collision-naming (s-join " ; " (--map (s-join " to " it)
(loop for (fresh . y) in freshies
      collect (list fresh y))))))

  (setq es‚Ä≤ (alter-elements es  map (Œª e ‚Üí (map-name (-partial (reify-to-list injective-naming)) e))))
  (setq es‚Ä≤ (alter-elements es‚Ä≤ map (Œª e ‚Üí (map-name (-partial (reify-to-list collision-naming)) e))))

  ;; return value
  (-concat es‚Ä≤ (when adjoin-retract (list (element-retract $ùëùùëéùëüùëíùëõùë° es :new es‚Ä≤ :name adjoin-retract)))
               (when adjoin-coretract (list (element-retract $ùëùùëéùëüùëíùëõùë° es‚Ä≤ :new es :name adjoin-coretract :contravariant t)))))))
#+END_SRC

#+RESULTS:
: ùí±-renaming

:OLD_renaming:
#+BEGIN_SRC emacs-lisp :tangle no
(ùí± renaming by (adjoin-retract t) (adjoin-coretract nil)
  = "Rename elements using BY, a ‚Äú;‚Äù-separated string of ‚Äúto‚Äù-separated pairs.

      There is minimal support for mixfix names, which may be ignored
      by setting SUPPORT-MIXFIX-NAMES to be nil.

      When ADJOIN-RETRACT is non-nil, we adjoin a ‚Äúrecord {old·µ¢ = name·µ¢}‚Äù
      view morphism; i.e., record translation.
      Likewise for ADJOIN-CORETRACT results in the inverse morphism,
      ‚Äúrecord {name·µ¢ = old·µ¢}‚Äù.
"
  map (Œª e ‚Üí (map-name (Œª n ‚Üí (funcall (reify-to-list by) n)) e))
         :adjoin-retract adjoin-retract
         :adjoin-coretract adjoin-coretract
         )
#+END_SRC
:END:
#+RESULTS:
: ùí±-renaming

It is common in Agda to provide ‚Äúto‚Äù-lists, so we've provide a variant that supports those
instead of forcing users to produce functions explicitly.

We may also prefer writing ~subscripted·µ¢~ rather than ~decorated "·µ¢"~.
With a bit of Lisp meta-programming, we can generate these variationals.
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(defun to-subscript (n)
  "Associate digit N with its subscript.

If N ‚àà 0..9, then yield ‚Çô, else N."

  (or (nth n '("‚ÇÄ" "‚ÇÅ" "‚ÇÇ" "‚ÇÉ" "‚ÇÑ" "‚ÇÖ" "‚ÇÜ" "‚Çá" "‚Çà" "‚Çâ")) n))

;; Let's make a family of variationals.
(loop for i from 0 to 9
      for ·µ¢    = (to-subscript i)
      for docs = (format "Subscript all elementes by suffixing them with %s." i)
      do (eval `(ùí± ,(intern (format "subscripted%s" ·µ¢)) = ,docs decorated ,·µ¢)))
#+END_SRC

Here are some example uses.
#+BEGIN_SRC agda
{-700
-- MR‚ÇÅ‚ÇÇ   = M-Set-Record decorated "‚ÇÅ" ‚ü¥ decorated "‚ÇÇ" :adjoin-retract nil
the-MR = M-Set-Record co-decorated "the-"
-- MR‚ÇÉ‚ÇÑ   = M-Set-Record subscripted‚ÇÉ ‚ü¥ subscripted‚ÇÑ :adjoin-retract nil
MR‚Çú‚Çí   = M-Set-Record renaming "Scalar to S; Vector to V; ¬∑ to nice"
NearMonoid = M-Set-Record renaming "Scalar to Carrier; Vector to Carrier; ¬∑ to √ó"
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
{- MR‚ÇÅ‚ÇÇ   = M-Set record ‚ü¥ decorated "‚ÇÅ" ‚ü¥ decorated "‚ÇÇ" -}
record MR‚ÇÅ‚ÇÇ : Set‚ÇÅ where
   field Scalar‚ÇÅ‚ÇÇ       : Set
   field Vector‚ÇÅ‚ÇÇ       : Set
   field _¬∑‚ÇÅ‚ÇÇ_      : Scalar‚ÇÅ‚ÇÇ ‚Üí Vector‚ÇÅ‚ÇÇ ‚Üí Vector‚ÇÅ‚ÇÇ
   field ùüô‚ÇÅ‚ÇÇ        : Scalar‚ÇÅ‚ÇÇ
   field _√ó‚ÇÅ‚ÇÇ_      : Scalar‚ÇÅ‚ÇÇ ‚Üí Scalar‚ÇÅ‚ÇÇ ‚Üí Scalar‚ÇÅ‚ÇÇ
   field leftId‚ÇÅ‚ÇÇ       : {ùìã : Vector‚ÇÅ‚ÇÇ}  ‚Üí  ùüô‚ÇÅ‚ÇÇ ¬∑‚ÇÅ‚ÇÇ ùìã  ‚â°  ùìã
   field assoc‚ÇÅ‚ÇÇ        : {a b : Scalar‚ÇÅ‚ÇÇ} {ùìã : Vector‚ÇÅ‚ÇÇ} ‚Üí (a √ó‚ÇÅ‚ÇÇ b) ¬∑‚ÇÅ‚ÇÇ ùìã  ‚â°  a ¬∑‚ÇÅ‚ÇÇ (b ¬∑‚ÇÅ‚ÇÇ ùìã)

{- the-MR = M-Set record ‚ü¥ co-decorated "the-" -}
record the-MR : Set‚ÇÅ where
   field the-Scalar     : Set
   field the-Vector     : Set
   field _the-¬∑_        : the-Scalar ‚Üí the-Vector ‚Üí the-Vector
   field the-ùüô      : the-Scalar
   field _the-√ó_        : the-Scalar ‚Üí the-Scalar ‚Üí the-Scalar
   field the-leftId     : {ùìã : the-Vector}  ‚Üí  the-ùüô the-¬∑ ùìã  ‚â°  ùìã
   field the-assoc      : {a b : the-Scalar} {ùìã : the-Vector} ‚Üí (a the-√ó b) the-¬∑ ùìã  ‚â°  a the-¬∑ (b the-¬∑ ùìã)

{- MR‚ÇÉ‚ÇÑ   = M-Set record ‚ü¥ subscripted‚ÇÉ ‚ü¥ subscripted‚ÇÑ -}
record MR‚ÇÉ‚ÇÑ : Set‚ÇÅ where
   field Scalar‚ÇÉ‚ÇÑ       : Set
   field Vector‚ÇÉ‚ÇÑ       : Set
   field _¬∑‚ÇÉ‚ÇÑ_      : Scalar‚ÇÉ‚ÇÑ ‚Üí Vector‚ÇÉ‚ÇÑ ‚Üí Vector‚ÇÉ‚ÇÑ
   field ùüô‚ÇÉ‚ÇÑ        : Scalar‚ÇÉ‚ÇÑ
   field _√ó‚ÇÉ‚ÇÑ_      : Scalar‚ÇÉ‚ÇÑ ‚Üí Scalar‚ÇÉ‚ÇÑ ‚Üí Scalar‚ÇÉ‚ÇÑ
   field leftId‚ÇÉ‚ÇÑ       : {ùìã : Vector‚ÇÉ‚ÇÑ}  ‚Üí  ùüô‚ÇÉ‚ÇÑ ¬∑‚ÇÉ‚ÇÑ ùìã  ‚â°  ùìã
   field assoc‚ÇÉ‚ÇÑ        : {a b : Scalar‚ÇÉ‚ÇÑ} {ùìã : Vector‚ÇÉ‚ÇÑ} ‚Üí (a √ó‚ÇÉ‚ÇÑ b) ¬∑‚ÇÉ‚ÇÑ ùìã  ‚â°  a ¬∑‚ÇÉ‚ÇÑ (b ¬∑‚ÇÉ‚ÇÑ ùìã)

{- MR‚Çú‚Çí = M-Set record ‚ü¥ renaming "Scalar to S; Vector to V; ¬∑ to nice" -}
record MR‚Çú‚Çí : Set‚ÇÅ where
   field S      : Set
   field V      : Set
   field _nice_     : S ‚Üí V ‚Üí V
   field ùüô      : S
   field _√ó_        : S ‚Üí S ‚Üí S
   field leftId     : {ùìã : V}  ‚Üí  ùüô nice ùìã  ‚â°  ùìã
   field assoc      : {a b : S} {ùìã : V} ‚Üí (a √ó b) nice ùìã  ‚â°  a nice (b nice ùìã)

{- NearMonoid = M-Set record ‚ü¥ renaming "Scalar to Carrier; Vector to Carrier; ¬∑ to √ó" -}
record NearMonoid : Set‚ÇÅ where
   field Carrier        : Set
   field _√ó_        : Carrier ‚Üí Carrier ‚Üí Carrier
   field ùüô      : Carrier
   field leftId     : {ùìã : Carrier}  ‚Üí  ùüô √ó ùìã  ‚â°  ùìã
   field assoc      : {a b : Carrier} {ùìã : Carrier} ‚Üí (a √ó b) √ó ùìã  ‚â°  a √ó (b √ó ùìã)
#+END_SRC

Some observations are in order:

0. Example ~M‚ÇÅ‚ÇÇ~ demonstrates that composition, ‚ü¥, is sequential from left to right.
   That is, ‚Äú‚ü¥‚Äù is just forwards composition: We thread the given PackageFormer
   through the variationals ~v·µ¢~ in order. Operationally:

   | Pf v‚ÇÄ ‚ü¥ ‚ãØ ‚ü¥ v‚Çô ‚âà ((Pf v‚ÇÄ) v‚ÇÅ) ‚ãØ) v‚Çô |
   | Pf ‚ü¥ v  ‚âà  Pf v ‚ü¥  ‚âà  Pf v          |

   Note: In the concrete syntax, parenthesisation is not permitted.

1. Notice that the ~NearMonoid~ example demonstrates multiplicity of PackageFormer elements is irrelevant.
   That is, elements are algebraically a free monoid with the axiom ~xs ‚äï ys ‚äï xs ‚âà xs ‚äï ys~.

2. *Notice that we wanted  Agda-style renaming via ~to~-lists, so we simply code that up!*
   This is so cool: We can just extend the system with whatever pattern we prefer!
   No more bending to the will of language designers! More power to the user!

   For example, we can codify the previous ~NearMonoid~ scheme into a top-level pattern.
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(defun is-sort (element)
  "Check whether the target of ELEMENT‚Äôs type is ‚ÄòSet‚Äô."
  (s-contains? "Set" (target (element-type element))))
  ;; Method ‚Äòtarget‚Äô is defined in the next subsection, on ADTs.

(ùí± single-sorted with-sort
  = "Replace all nullary sorts with the provided WITH-SORT string
     as the name of the new single sort, the universe of discourse."
    map (Œª e ‚Üí (if (is-sort e) (map-name (Œª _ ‚Üí with-sort) e) e)))
#+END_SRC

   Then the previous PackageFormer can be obtained with:
   Note that the following differs from ~NearMonoid~ since it has two binary operations:
   Our new variational one alters the number and name of sorts, not other elements.
#+BEGIN_SRC agda
{-700
NearMonoid¬π = M-Set-Record single-sorted "Carrier"
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record NearMonoid¬π : Set‚ÇÅ where
   field Carrier        : Set
   field _¬∑_        : Carrier ‚Üí Carrier ‚Üí Carrier
   field ùüô      : Carrier
   field _√ó_        : Carrier ‚Üí Carrier ‚Üí Carrier
   field leftId     : {ùìã : Carrier}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc      : {a b : Carrier} {ùìã : Carrier} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
#+END_SRC

*Exercise:*
Write a variational ~remove-sorts~ that strips out all sorts from a PackageFormer.
If elements depend on sorts, as they normally do, then one must remove them as well;
ignore this for now, and we shall return to subgenerated PackageFormers later on.
** Forming Syntax and the Special ~$ùëõùëéùëöùëí~ Variable
   :PROPERTIES:
   :CUSTOM_ID: Forming-Syntax-and-the-Special---ùëõùëéùëöùëí--Variable
   :END:

  |  /Records provide a semantics, what if we want the syntax?/ |

Since ~data~ declarations consist of constructors, whose target type necessarily
begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.
To do so, we use the helper function ~target~ which takes a declaration ~name : type0 ‚Üí ‚ãØ ‚Üí typeN~ and yields ~typeN~.

#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(defun target (thing)
  "Return final type mentioned in THING, a string declaration.

Given a type-name ‚Äò[name :] œÑ‚ÇÄ ‚Üí ‚ãØ ‚Üí œÑ‚Çô‚Äô, yield ‚ÄòœÑ‚Çô‚Äô;
the ‚Äòname‚Äô porition is irrelevant."
  (car (-take-last 1 (s-split "‚Üí" thing))))
#+END_SRC

With this in hand, a ~data~ presentation requires a designated ~carrier~ which is used to
keep only those elements that target it. Finally, as data constructor must target the
type being defined, we alter the filtered elements by changing every instance of the
carrier name with the name of the newly defined PackageFormer ---which we may access
using the special identifier ~$ùëõùëéùëöùëí~. In a ~lisp~ block, we formalise this algorithm as follows.
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± data carrier
  = "Reify as an Agda ‚Äúdata‚Äù type.

     Only elements targeting CARRIER are kept.
    "
    :kind  data
    :level dec
    :alter-elements (lambda (es)
      (thread-last es
        (--filter (s-contains? carrier (target (element-type it))))
        (--map (map-type (Œª œÑ ‚Üí (s-replace carrier $ùëõùëéùëöùëí œÑ)) it)))))
#+END_SRC

For example:
#+BEGIN_SRC agda
{-   700
ScalarTerm = M-Set data "Scalar"
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
data ScalarTerm : Set where
   ùüô        : ScalarTerm
   _√ó_      : ScalarTerm ‚Üí ScalarTerm ‚Üí ScalarTerm
#+END_SRC

Again:
The meta-primitive ~:alter-elements~ is instructed to map over those
elements ~e~ that contain the ~carrier~ in their ~target~ type
by replacing the given ~carrier~ with the newly-minted ~$ùëõùëéùëöùëí~ of
the grouping mechanism being constructed. Those that do not
contain the given ~carrier~ in their target type are filtered out.

Notice that ~$ùëõùëéùëöùëí~ is a special variable that refers to the newly defined PackageFormer's name.
- It is written using ~\Mi~ with Agda input; e.g., ~\Min~ gives ~ùëõ~.
- The ‚Äò$‚Äô is intended to further mark the special nature of this variable.

** COMMENT TODO: another adt example
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-TODO--another-adt-example
   :END:
   :PROPERTIES:

   :END:
*Important*: Notice that, in the second example above,
#+BEGIN_SRC results-agda :tangle no
{- ScalarSyntax = M-Set primer ‚ü¥ data :carrier "Scalar‚Ä≤" -}
data ScalarSyntax : Set where
   ùüô‚Ä≤ : ScalarSyntax
   _√ó‚Ä≤_ : ScalarSyntax ‚Üí ScalarSyntax ‚Üí ScalarSyntax
#+END_src
the name of the carrier is ~Scalar‚Ä≤~ since we changed the
PackageFormer to prime all elements, including the ~Scalar~, element.
#+BEGIN_SRC results-agda  :tangle no
{- No = M-Set primer ‚ü¥ data :carrier "Scalar" -}
data No : Set where
   ùüô‚Ä≤ : No‚Ä≤
   _√ó‚Ä≤_ : No‚Ä≤ ‚Üí No‚Ä≤ ‚Üí No‚Ä≤

{- Crashes since type No‚Ä≤ is not defined! -}
#+END_SRC

mention these:

   + [ ] Interpretation functions from termtypes to recordtypes ---which give terms meaning.
         - [ ] With an environment argument for open termtypes.
   + [ ] Staged terms and partial evaluators

** Subpackages with ~generated, sorts, signature~
   :PROPERTIES:
   :CUSTOM_ID: Subpackages-with--generated--sorts--signature-
   :END:

    A common grouping operation is to zoom-in to the minimal well-formed
    package that contains only certain specified elements. For example,
    in our ~M-Set~ grouping, we may want to keep only ~ùüô~ but to be well-defined
    we are forced to also keep the elements on which it depends ---namely, ~Scalar~.

    In particular, the following naive approach only works if the elements are
    independent of one another ---which is rarely the case for Agda users.
#+BEGIN_SRC emacs-lisp  :tangle no
;; cute, but too brutish.
(ùí± generated by = :alter-elements (lambda (es) (-filter by es)))
#+END_SRC

    The coherent scheme is straightforward to implement.
    For clarity, rather than efficiency,
    the algorithm below forms a list ~yeses~ of the elements that should be kept
    then traverses the elements list, adding all elements needed to ensure that list
    is coherent. Moreover, for generality, we consider a predicate rather than an explicit
    listing of items to be retained.
#+BEGIN_SRC  emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± generated by
  = "Keep the largest well-formed PackageFormer whose elements satisfy BY.

     BY is a predicate on elements.
    "
    :alter-elements (Œª es ‚Üí (--graph-map (funcall by it) it es)))

#+END_SRC
:OLD:
#+BEGIN_SRC  emacs-lisp :tangle no
(ùí± generated by
  = "Keep the largest well-formed PackageFormer whose elements satisfy BY.

     BY is a predicate on elements.
    "
    :alter-elements  (lambda (fs)
      (let* ( (yeses (--map (funcall by it) fs))
              (get-yeses (lambda () (--filter it (--zip-with (if it other) yeses fs))))
              (in-yeses (lambda (e)
                          (--any
                           (s-contains? (s-replace "_" " " (element-name e)) (element-type it))
                           (funcall get-yeses)))))

        (loop for _ in fs do
              (loop for f in fs
                    for i from 0
                    do ;; when f in yess, set f to be yes.
                    (when (funcall in-yeses f) (setf (nth i yeses) t))))

        (funcall get-yeses))))
#+END_SRC
:END:

Here's an immediate application: Obtaining the types declared in a grouping mechanism.
#+BEGIN_SRC emacs-lisp  :tangle  "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± sorts
 = "Obtaining the types declared in a grouping mechanism.

   For now, only base types; i.e., items targeting ‚ÄúSet‚Äù.
   "
   generated (Œª e ‚Üí (s-contains? "Set" (target (element-type e)))))
#+END_SRC
#+BEGIN_SRC agda
{-700
M-Set-Sorts = M-Set record ‚ü¥ sorts
-}
    #+END_SRC
    #+BEGIN_SRC results-agda :tangle no
record M-Set-Sorts : Set‚ÇÅ where
   field Scalar     : Set
   field Vector     : Set
#+END_SRC

We can even obtain a sub-signature wholesale:
#+BEGIN_SRC agda
{-700
MonoidSignature = M-Set-Record generated (Œª e ‚Üí (and (s-contains? "Scalar" (element-type e)) (not (s-contains? "Vector" (element-type e)))))
-}
    #+END_SRC
    #+BEGIN_SRC results-agda :tangle no
record MonoidSignature : Set‚ÇÅ where
   field Scalar     : Set
   field ùüô      : Scalar
   field _√ó_        : Scalar ‚Üí Scalar ‚Üí Scalar
#+END_SRC

This pattern of having a lawless grouping seems sufficiently desirable that we may
codify it.
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(defun targets-a-sort (element)
  "Check whether the given ELEMENT targets a sort.

The sorts considered refer to those of the *current* PacakgeFormer."
  (--any (s-contains? it (target (element-type element)))
         (-map #'element-name (-filter #'is-sort $ùëíùëôùëíùëöùëíùëõùë°ùë†))))

(ùí± signature
  = "Keep only the elements that target a sort, drop all else."
    generated (Œª e ‚Üí (targets-a-sort e)))
#+END_SRC

Here's an example.
#+BEGIN_SRC agda
{-700
MonSig = M-Set-Record signature
-}
    #+END_SRC

    #+BEGIN_SRC results-agda :tangle no
record MonSig : Set‚ÇÅ where
   field Scalar     : Set
   field Vector     : Set
   field _¬∑_        : Scalar ‚Üí Vector ‚Üí Vector
   field ùüô      : Scalar
   field _√ó_        : Scalar ‚Üí Scalar ‚Üí Scalar
#+END_SRC

   Neato! Those were some nifty applications!

   For practicality, let's also introduce a more concrete syntax
   analogous to that of ~renaming~:
   # Magma = Monoid generated (Œª e ‚Üí (equal "__¬∑__" (element-name e)))
#+BEGIN_SRC emacs-lisp  :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± keeping those
  = "Keep THOSE elements, a ‚Äú;‚Äù-separated string of proper names,
    along with the elements that ensure THOSE is well-defined.
 "
    generated (reify-to-list those :otherwise nil :key #'element-name))
#+END_SRC

** Shallow Renaming with Agda's ~open ‚ãØ public ‚ãØ renaming ‚ãØ~
   :PROPERTIES:
   :CUSTOM_ID: Shallow-Renaming-with-Agda-s--open---public---renaming---
   :END:
    The previous approach to renaming altered field names literally which is not
    desirable when one only wants to refer to field names of multiple instances
    of the same record ---e.g., when forming homomorphisms.

    A common pattern in Agda is then to open the record and perform the desired
    shallow renames. This pattern is so common that the standard library is [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Structures.html#2757][littered]]
    with instances of it.
    We can codify the pattern as a method rather than as a
    manual technique.

    Let's go from zero to one-hundred ---again: There's a Lisp Cheat Sheet that should
    have been consulted at one point.

    Zero: A module where the elements are all parameters.
#+BEGIN_SRC agda
{-700
ùí±-empty-module = :kind module :level none :waist 999
Neato = M-Set empty-module
-}

{- A module where the elements are all parameters -}
open Neato using ()
#+END_SRC

#+BEGIN_SRC results-agda :tangle no
module Neato (Scalar : Set) (Vector : Set) (_¬∑_ : Scalar ‚Üí Vector ‚Üí Vector) (ùüô : Scalar) (_√ó_ : Scalar ‚Üí Scalar ‚Üí Scalar) (leftId : {ùìã : Vector} ‚Üí ùüô ¬∑ ùìã ‚â° ùìã) (assoc : ‚àÄ {a b ùìã} ‚Üí (a √ó b) ¬∑ ùìã ‚â° a ¬∑ (b ¬∑ ùìã)) where
#+END_SRC

   One-hundred: A one-parameter module where elements may be renamed.
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± open with (avoid-mixfix-renaming nil)
  =
    "Reify a given PackageFormer as a *parameterised* Agda ‚Äúmodule‚Äù declaration.

     WITH is a renaming, string to string, function that is applied to the parent record that will
     be opened and reexported as a module.

     AVOID-MIXFIX-RENAMING is optional; by default renaming ‚Äújumps over‚Äù underscores,
     but providing a non-nil value for this argument leaves underscores alone.
     It is a matter of having, say, default ‚Äú_‚äï‚Çô_‚Äù versus ‚Äú_‚äï_‚Çô‚Äù.

     The resulting module has a parameter, whose name is irrelevant but is
     of the form ‚ÄúArgùíπùíπùíπùíπ‚Äù for some digits ùíπ in order to minimise clash with
     any user-defined names.

     Besides the addition of a new parameter, all element qualifiers are discarded.
    "
    :kind module
    :level none
    :waist 1
    :alter-elements  (lambda (fs)
      (let ((kind "{! !}") (‚Ñõ (format "Ar%s" (gensym))))
        (cons (make-element :name ‚Ñõ :type $ùëùùëéùëüùëíùëõùë°)
          (--map (let ((name (if avoid-mixfix-renaming (with (element-name it)) (rename-mixfix with (element-name it)))))
            (make-element :name name
                          :type (format "let open %s %s in %s" $ùëùùëéùëüùëíùëõùë° ‚Ñõ (element-type it))
                          :equations (list (format "%s = %s.%s %s" name $ùëùùëéùëüùëíùëõùë° (element-name it) ‚Ñõ)))) fs)))))
#+END_SRC

  Notice that we do not need any ~open ‚ãØ public~ since all elements are top-level.
  We are not making using of Agda's renaming facility. An example may clarify this observation.
  #+BEGIN_SRC agda
{-700
M-Set-R = M-Set record
M-Set-R‚ÇÅ = M-Set-R ‚ü¥ open (Œª x ‚Üí (concat x "‚ÇÅ"))
-}
#+END_SRC

#+BEGIN_SRC results-agda :tangle no
module M-Set-R‚ÇÅ (Arg6926 : M-Set-R) where
   Scalar‚ÇÅ      : let open M-Set-R Arg6926 in Set ; Scalar‚ÇÅ = M-Set-R.Scalar Arg6926
   Vector‚ÇÅ      : let open M-Set-R Arg6926 in Set ; Vector‚ÇÅ = M-Set-R.Vector Arg6926
   _¬∑‚ÇÅ_     : let open M-Set-R Arg6926 in Scalar ‚Üí Vector ‚Üí Vector ;    _¬∑‚ÇÅ_ = M-Set-R._¬∑_ Arg6926
   ùüô‚ÇÅ       : let open M-Set-R Arg6926 in Scalar ;  ùüô‚ÇÅ = M-Set-R.ùüô Arg6926
   _√ó‚ÇÅ_     : let open M-Set-R Arg6926 in Scalar ‚Üí Scalar ‚Üí Scalar ;    _√ó‚ÇÅ_ = M-Set-R._√ó_ Arg6926
   leftId‚ÇÅ      : let open M-Set-R Arg6926 in {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã ;    leftId‚ÇÅ = M-Set-R.leftId Arg6926
   assoc‚ÇÅ       : let open M-Set-R Arg6926 in ‚àÄ {a b ùìã} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã) ; assoc‚ÇÅ = M-Set-R.assoc Arg6926
  #+END_SRC

  In-case you've skipped over the above source documentation for ~open~, it's time to read it.

  Notice that a module opening depends on a record, whence the first declaration of ~M-Set-R~.

  #+begin_center
   These kind of open-renamings are so common that the tedium
   is actually acceptable by most users ---it shouldn't be
   and now it no longer has to be that way.
  #+end_center

  It is common in Agda to provide ‚Äúto‚Äù-lists, so let's provide a variant that supports those
  instead of forcing users to produce functions explicitly.
  #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± opening with
  = "Open a record as a module exposing only the names mentioned in WITH.

    WITH is a string of ‚Äú;‚Äù-separated items consisting of ‚Äúto‚Äù-separated pairs.
    "
    open (Œª x ‚Üí (funcall (reify-to-list with :otherwise "_") x)) :avoid-mixfix-renaming t)

    ;; Alternatively, we could have used ‚Äòtrash‚Äô names,
    ;; something like (format "%s" (gensym)), instead of "_".
  #+END_SRC

    #+BEGIN_SRC agda
{-700
M-Set-R-SV = M-Set-R opening "Scalar to S; Vector to V"
-}
    #+END_SRC
This opens the ~M-Set-R~ record *exposing only* ~S~ and ~V~ ---the rest are ignored using Agda's ~_~ mechanism.
    #+BEGIN_SRC results-agda :tangle no
module M-Set-R-SV (Arg6933 : M-Set-R) where
   S        : let open M-Set-R Arg6933 in Set ; S = M-Set-R.Scalar Arg6933
   V        : let open M-Set-R Arg6933 in Set ; V = M-Set-R.Vector Arg6933
   _        : let open M-Set-R Arg6933 in Scalar ‚Üí Vector ‚Üí Vector ;    _ = M-Set-R._¬∑_ Arg6933
   _        : let open M-Set-R Arg6933 in Scalar ;  _ = M-Set-R.ùüô Arg6933
   _        : let open M-Set-R Arg6933 in Scalar ‚Üí Scalar ‚Üí Scalar ;    _ = M-Set-R._√ó_ Arg6933
   _        : let open M-Set-R Arg6933 in {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã ;    _ = M-Set-R.leftId Arg6933
   _        : let open M-Set-R Arg6933 in ‚àÄ {a b ùìã} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã) ; _ = M-Set-R.assoc Arg6933
#+END_SRC

After simplifying the ~let~-expressions, this module definition is equivalent to the following
---the types of which may be seen with Agda's ~C-c C-o~ call.
#+BEGIN_SRC agda :tangle no
module M-Set-R-SV (Arg : M-Set-R) where
  S : (Arg : M-Set-R) ‚Üí Set ; S = M-Set-R.Scalar Arg
  V : (Arg : M-Set-R) ‚Üí Set ; V = M-Set-R.Vector Arg
#+END_SRC

Let's provide an even more common feature: Opening records with a decoration.
For example, when we have two algebraic structures, we might want the first to be subscripted with ‚ÇÅ
and the second with ‚ÇÇ ---this is different than ~subscripted·µ¢~ from above, which produces a /new/ record
rather than opening it with renames.
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± open-with-decoration ddd
  = "Open a record, exposing all elements, with decoration DDD.

    DDD is a string.
   "
   open (Œª x ‚Üí (concat x ddd)))
#+END_SRC

Here's an example.
#+BEGIN_SRC results-agda
{-700
M-Set-R‚Ä≤ = M-Set-R open-with-decoration "‚Ä≤"
-}
                          #+END_SRC

                          #+BEGIN_SRC results-agda  :tangle no
module M-Set-R‚Ä≤ (Arg6938 : M-Set-R) where
   Scalar‚Ä≤      : let open M-Set-R Arg6938 in Set ; Scalar‚Ä≤ = M-Set-R.Scalar Arg6938
   Vector‚Ä≤      : let open M-Set-R Arg6938 in Set ; Vector‚Ä≤ = M-Set-R.Vector Arg6938
   _¬∑‚Ä≤_     : let open M-Set-R Arg6938 in Scalar ‚Üí Vector ‚Üí Vector ;    _¬∑‚Ä≤_ = M-Set-R._¬∑_ Arg6938
   ùüô‚Ä≤       : let open M-Set-R Arg6938 in Scalar ;  ùüô‚Ä≤ = M-Set-R.ùüô Arg6938
   _√ó‚Ä≤_     : let open M-Set-R Arg6938 in Scalar ‚Üí Scalar ‚Üí Scalar ;    _√ó‚Ä≤_ = M-Set-R._√ó_ Arg6938
   leftId‚Ä≤      : let open M-Set-R Arg6938 in {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã ;    leftId‚Ä≤ = M-Set-R.leftId Arg6938
   assoc‚Ä≤       : let open M-Set-R Arg6938 in ‚àÄ {a b ùìã} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã) ; assoc‚Ä≤ = M-Set-R.assoc Arg6938
#+END_SRC

  Neato petito :smile:

#+begin_center
It is important to observe that ‚Äòopenings‚Äô are lossy:
They lose the types of the declarations and so cannot be used further to construct
new pacaking mechanisms. They are a terminal construction.
#+end_center

  In the next section, we make use of such openings to actually produce
  homomorphism constructions.

#  For now, let's show how /functions are PackageFormers./

** Automatically deriving homomorphism definitions ‚ô•‚Äø‚ô•
   :PROPERTIES:
   :CUSTOM_ID: Automatically-deriving-homomorphism-definitions
   :END:

    The definition of ‚Äústructure preservation‚Äù is, nearly always, mechanical to
    formulate and that's just what we shall do to avoid having to write it out
    by hand ever again ---which the [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Morphism.html#586][current approach]] in the Agda standard library.

    :Illuminating_yet_overkill_to-subscript_defn:
#+BEGIN_SRC emacs-lisp  :tangle no
(defun to-subscript (n)
  "Subscript numbers ùìÉ have hex-codes #x208ùìÉ,
   we realise the codes as characters to obtain the subscripts.

   This is preferable to casing:
  (pcase i (0 ‚Äú‚ÇÄ‚Äù) (1 ‚Äú‚ÇÅ‚Äù) (2 ‚Äú‚ÇÇ‚Äù) ‚ãØ)

  When ‚Äòn‚Äô ‚àâ 0..9 an error message halts execution.
  "

  (when (or (< n 0) (> n 9))
    (error "to-subscript: n must be in 0..9"))

  (thread-last
    (format "#x208%s" n)
    (read-from-string)
    car
    (format "%c")))
#+END_SRC
    :End:

    The idea is not too complicated:
    1. Suppose you have an operation ~_¬∑_ : Scalar ‚Üí Vector ‚Üí Vector~.
    2. Suppose you have a numbering of the sorts; e.g., ~sort‚ÇÅ = Scalar, sort‚ÇÇ = Vector~.
    3. Form functions ~map·µ¢ : sort·µ¢ ‚Üí sort·µ¢‚Ä≤~
    4. Include implicit arguments in the type: ~{x‚ÇÅ : Scalar} ‚Üí {x‚ÇÇ : Vector} ‚Üí Vector~.
    5. The target type ~Vector = sort‚ÇÇ~ means we need to apply ~map‚ÇÇ~ to the expression
       formed from the operation's name along with the arguments.
       - The left hand side is thus ~map‚ÇÇ (_¬∑_ x‚ÇÅ x‚ÇÇ)~.
    6. For the right hand side, we use the target-space's name, say ~_¬∑‚Ä≤_~,
       along with ~map·µ¢~ applied to ~x·µ¢~ for each ~i~ mentioned in the type.

    7. The result:
       ~pres-¬∑ : {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÇ : Vector} ‚Üí   map‚ÇÇ (_¬∑_ x‚ÇÅ x‚ÇÇ)   ‚â°   _¬∑‚Ä≤_ (map‚ÇÅ x‚ÇÅ) (map‚ÇÇ x‚ÇÇ)~.
      :RoughIdea:
    ‚áí  _¬∑_ : sort‚ÇÅ ‚Üí sort‚ÇÇ ‚Üí sort‚ÇÇ
    ‚áí pres-¬∑ : {x‚ÇÅ : sort‚ÇÅ} {x‚ÇÇ : sort‚ÇÇ}
         ‚Üí   form source expression:  x‚ÇÅ ¬∑ x‚ÇÇ
           ‚áí form target expression: map‚ÇÅ x‚ÇÇ ¬∑‚Ä≤ map‚ÇÇ x‚ÇÇ
           ‚áí equate them using target sort's map:  map‚ÇÇ (x‚ÇÅ ¬∑ x‚ÇÇ) ‚â° map‚ÇÅ x‚ÇÇ ¬∑‚Ä≤ map‚ÇÇ x‚ÇÇ
    :End:

    First, we need a helper that forms the preservation formulae.
    For example:
#+BEGIN_SRC emacs-lisp  :tangle no
(show-element (homify (make-element :name "_¬∑_" :type "Scalar ‚Üí Vector ‚Üí Vector")
                      '( ("Scalar" . 4) ("Vector" . 1))))
‚áí
  pres-¬∑ : {x‚ÇÑ : Scalar} ‚Üí {x‚ÇÅ : Vector}
         ‚Üí map‚ÇÅ (_¬∑_ x‚ÇÑ x‚ÇÅ)   ‚â°   _¬∑‚Ä≤_ (map‚ÇÑ x‚ÇÑ) (map‚ÇÅ x‚ÇÅ)
#+END_SRC

    With this as a specification, in a ~lisp~ block:
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(defun homify (element sort)
  "Given a typed name, produce the associating ‚Äúpreservation‚Äù formula.

E.g.,
  _¬∑_    : Scalar ‚Üí Vector ‚Üí Vector
  pres-¬∑ : {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÇ : Vector} ‚Üí map‚ÇÇ (x‚ÇÅ ¬∑ x‚ÇÇ) = map‚ÇÅ x‚ÇÅ ¬∑‚Ä≤ map‚ÇÇ x‚ÇÇ


Type œÑ gets variable x·µ¢ provided (i, œÑ) ‚àà SORT;
likewise we think of map·µ¢ : œÑ ‚Üí œÑ‚Ä≤.
Notice that the target name is primed, ‚Äú¬∑‚Ä≤‚Äù

ELEMENT is the typed-name and SORT is the alist of numbered sorts."
  (letf* ((sorts     (mapcar #'car sort))
          (index     (Œª it ‚Üí (to-subscript (cdr (assoc it sort)))))

          (tn‚Üí       (s-split " ‚Üí " (element-type element)))
          (arg-count (1- (length tn‚Üí)))

          (all-indicies  (mapcar index
                                 (--filter (member (s-trim it) sorts) tn‚Üí)))
          (indicies  (-drop-last 1 all-indicies))
          (tgt-idx   (car (-take-last 1 all-indicies)))

          (op        (element-name element))
          (args      (--map (concat "x" it) indicies))
          (lhs       (format "map%s (%s %s)" tgt-idx op (s-join " " args)))

          (op‚Ä≤       (rename-mixfix (lambda (n) (concat n "‚Ä≤")) op))
          (map-args  (--map (format "(map%s x%s)" it it) indicies))
          (rhs       (format "%s %s" op‚Ä≤ (s-join " " map-args)))

          (target    (format "  %s   ‚â°   %s" lhs rhs)))

    ;; Change the target type.
    (setq tn‚Üí (--map (when (assoc it sort)
                       (format "{x%s : %s}" (funcall index it) it)) tn‚Üí))
    (setf (nth arg-count tn‚Üí) target)

    ;; Stick it all together, with an updated name.
    (make-element
     :name (format "pres-%s" (s-replace "_" "" (element-name element)))
     :type (s-join " ‚Üí " tn‚Üí))))
#+END_SRC

    Then, we form the variational as follows ---also in a ~lisp~ block.
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± hom
  = "Formulate the notion of homomorphism of $ùëùùëéùëüùëíùëõùë° algebras.

     ‚û© $ùëùùëéùëüùëíùëõùë° must be an existing record type used in the resulting formulation.
    "
    record ‚ü¥
    :waist 2
    :alter-elements (lambda (es)

      (let (maps eqns sorts (ùíÆùìáùí∏ "Src") (ùíØ‚Ñäùìâ "Tgt"))

        ;; Construct the map·µ¢ : sort·µ¢ ‚Üí sort·µ¢‚Ä≤; keeping track of (sort . i) pairs.
        (loop for e in es
              for i from 1
         do
           (when (is-sort e)
             (push (cons (element-name e) i) sorts)
             (push (make-element
                      :qualifier "field"
                      :name (format "map%s" (to-subscript i))
                      :type (format "%s ‚Üí %s‚Ä≤" (element-name e) (element-name e)))
                   maps))

            (when (and (targets-a-sort e) (not (is-sort e)))
              (push (homify e sorts) eqns)))

      ;; Ensure we have a source and target space as elements.
      (-cons*
       (make-element :qualifier "field" :name ùíÆùìáùí∏ :type $ùëùùëéùëüùëíùëõùë°)
       (make-element :qualifier "field" :name ùíØ‚Ñäùìâ :type $ùëùùëéùëüùëíùëõùë°)
       (--map
        (map-type (Œª œÑ ‚Üí (format "let open %s %s; open %s‚Ä≤ %s in %s"
                                 $ùëùùëéùëüùëíùëõùë° ùíÆùìáùí∏ $ùëùùëéùëüùëíùëõùë° ùíØ‚Ñäùìâ œÑ))
                  (map-qualifier (Œª _ ‚Üí "field") it))
        (reverse (-concat eqns maps)))))))
#+END_SRC

    Here are two examples. *Note* that the latter allows us to /rename/ the ~map·µ¢~ as we
    wish ---which may be preferable to extending the variational to accommodate for new
    names.

#+BEGIN_SRC agda
{-700
Algebra  = M-Set record
Algebra‚Ä≤ = Algebra open-with-decoration "‚Ä≤"
Hom  = Algebra hom
Hom¬≤ = Algebra hom ‚ü¥ renaming "map‚ÇÅ to scalar; pres-ùüô to unity" :adjoin-retract nil
-}

_ : {Src Tgt : Algebra} ‚Üí Hom¬≤ Src Tgt ‚Üí Algebra.Scalar Src ‚Üí Algebra.Scalar Tgt
_ = Hom¬≤.scalar
#+END_SRC

#+BEGIN_SRC results-agda :tangle no
{- Hom  = Algebra hom -}
record Hom (Src : Algebra) (Tgt : Algebra) : Set‚ÇÅ where
   field map‚ÇÅ       : let open Algebra Src; open Algebra‚Ä≤ Tgt in Scalar ‚Üí Scalar‚Ä≤
   field map‚ÇÇ       : let open Algebra Src; open Algebra‚Ä≤ Tgt in Vector ‚Üí Vector‚Ä≤
   field pres-¬∑     : let open Algebra Src; open Algebra‚Ä≤ Tgt in {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÇ : Vector} ‚Üí   map‚ÇÇ (_¬∑_ x‚ÇÅ x‚ÇÇ)   ‚â°   _¬∑‚Ä≤_ (map‚ÇÅ x‚ÇÅ) (map‚ÇÇ x‚ÇÇ)
   field pres-ùüô     : let open Algebra Src; open Algebra‚Ä≤ Tgt in   map‚ÇÅ (ùüô )   ‚â°   ùüô‚Ä≤
   field pres-√ó     : let open Algebra Src; open Algebra‚Ä≤ Tgt in {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÅ : Scalar} ‚Üí   map‚ÇÅ (_√ó_ x‚ÇÅ x‚ÇÅ)   ‚â°   _√ó‚Ä≤_ (map‚ÇÅ x‚ÇÅ) (map‚ÇÅ x‚ÇÅ)


{- Hom¬≤ = Algebra hom ‚ü¥ renaming "map‚ÇÅ to scalar; pres-ùüô to unity" -}
record Hom¬≤ (Src : Algebra) (Tgt : Algebra) : Set‚ÇÅ where
   field scalar     : let open Algebra Src; open Algebra‚Ä≤ Tgt in Scalar ‚Üí Scalar‚Ä≤
   field map‚ÇÇ       : let open Algebra Src; open Algebra‚Ä≤ Tgt in Vector ‚Üí Vector‚Ä≤
   field pres-¬∑     : let open Algebra Src; open Algebra‚Ä≤ Tgt in {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÇ : Vector} ‚Üí   map‚ÇÇ (_¬∑_ x‚ÇÅ x‚ÇÇ)   ‚â°   _¬∑‚Ä≤_ (scalar x‚ÇÅ) (map‚ÇÇ x‚ÇÇ)
   field unity      : let open Algebra Src; open Algebra‚Ä≤ Tgt in   scalar (ùüô )   ‚â°   ùüô‚Ä≤
   field pres-√ó     : let open Algebra Src; open Algebra‚Ä≤ Tgt in {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÅ : Scalar} ‚Üí   scalar (_√ó_ x‚ÇÅ x‚ÇÅ)   ‚â°   _√ó‚Ä≤_ (scalar x‚ÇÅ) (scalar x‚ÇÅ)
#+END_SRC

  This is so cool (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

  We leave it to the reader to derive other constructs from a theory presentation.
  Examples can be found in these [[https://alhassy.github.io/next-700-module-systems/papers/JC_Program_Generation_Talk_IFIP.pdf][Metaprogramming Agda]] slides:
  Homomorphism equality, application to carrier elements, isomorphisms,
  isomorphisms where only one direction needs to preserve the structure
  and an automatically derivable proof that the other direction is also
  structure preserving, endomorphism and automorphism types, kernels,
  product & sum & other categorical types.

  + Challenge ::
      Design a scheme to produce simple Cartesian products from a given theory.

    1. The only variable to this problem is an arbitrary record, say it is ~M~.

       For this exercise to be tractable, assume ~M~ consists of declarations
       of sort symbols, function symbols, and nullary (non-implication) equations
       which may have implicit arguments.

    2. Ensure you understood the definition of the homomorphism scheme above.
    3. Mimic the homomorphism scheme to produce a typed ~Prod~ where ~Prod A‚ÇÄ A‚ÇÅ~
       consists of a ~M~ value, say ~P~, and two homomorphisms ~Hom P A·µ¢~.
    4. Write a Lisp code that produces a function ~MakeProduct : (A‚ÇÄ A‚ÇÅ : M) ‚Üí Prod A‚ÇÄ A‚ÇÅ~.

       - The projection morphisms are straightforward.
       - Every /n/-ary function ~f~ could be defined by ~f‚Çö = zip‚Çô f‚ÇÄ f‚ÇÅ~.
       - Every equation ~e~ could be defined by ~e‚Çö = cong‚ÇÇ _,_ e‚ÇÄ e‚ÇÅ~.

    5. If you have actually attempted this, then go on to include the remaining
       artefacts to make the construction an actual categorical product.

** COMMENT Currying for Datatypes
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-Currying-for-Datatypes
   :END:
   :PROPERTIES:

   :END:

   :Lisp_code_that_generates_the_code_for_this_subsection:
#+BEGIN_SRC emacs-lisp :var monoid = monoid :exports both :results replace :wrap "src results-agda"
(let* ((variationals nil) (instantiations-remaining nil)
       (vs (pf--load-variationals (s-join "\n" '(
      "ùí±-identity = "
      "ùí±-record  = :kind record :waist-strings (\"field\")"
      "ùí±-whoops  = :kind recorder :waist-strings (\"field\")"
      "ùí±-typeclass-attempt  = :kind record :waist-strings (\"field\") :waist 2"
      "ùí±-typeclass‚ÇÇ  = :kind record :waist-strings (\"field\") :waist 2 :level dec"
      "ùí±-primed-record = :kind record :waist-strings (\"field\") :alter-elements (Œª f ‚Üí (map-name (concat name \"‚Ä≤\") f))"
      "ùí±-primed = :alter-elements (Œª f ‚Üí (map-name (concat name \"‚Ä≤\") f))"
      "ùí±-typeclass height level = :kind record :waist-strings (\"field\") :waist height :level level"
; TODO:	  ; "ùí±-renamed with = :alter-elements (Œª e ‚Üí (map-name (funcall with name) e))"
      "ùí±-data-with carrier = :kind data :level dec :alter-elements (Œª f ‚Üí (if (s-contains? carrier (target (get-type f))) (map-type (s-replace carrier $ùëõùëéùëöùëí type) f) \"\"))"
      ))))
       (pf (load-package-former (second (get-children "PackageFormer" monoid)))))

  (--map (load-instance-declaration it)
    '(

      ; TODO: "M-Set-PF = M-Set identity :waist 2" ;; nope.

      ; "Monoid-Record = Monoid record"
      ; "Monoid-Classical = Monoid typeclass :height (1) :level (dec)"
       "MonoidOp = Monoid typeclass :height (2) :level (dec)"
      ; "M-Set-Record = M-Set whoops"
      ; "M-Set-Typeclass = M-Set typeclass-attempt"
      ; "M-Set-Typeclass‚ÇÇ = M-Set typeclass‚ÇÇ"
      ; "M-Set-Record‚Ä≤ = M-Set primed-record"
      ; "M-Set‚Ä≤ = M-Set primed"
      ; "M-Set-Record‚Ä≤ = M-Set-Record primed"
      ; "M-Set-Record‚Ä≤ = M-Set-Record record ‚ü¥ primed"
      ; "M-Set-Typeclass‚ÇÉ = M-Set-Record typeclass :height (3) :level (dec) :comment (why hello there)"

      ; TODO: "M-Set‚ÇÅ = M-Set renamed :with ((Œª x ‚Üí x))"

      ; "ScalarSyntax = M-Set data-with :carrier (\"Scalar\")"
      ))

  (reify-instances)
)
#+END_SRC

#+RESULTS:

:End:

Suppose you're a Haskell programmer and want to have multiple monoid instances for the Booleans.
You may make isomorphic copies of the Booleans, say ~And~ and ~Any~, and implement the desired instance
for each. What about if you want a Monoid instance but insist only that the unit be ~false~, what do you do then?

With this prototype, you expose the carrier and the operation in the first case, and expose the identity in the second case.
Moreover, you only write the definition of monoid once, leading to our motto:
#+BEGIN_CENTER
/Write once, derive many!/
#+END_CENTER

Here's a formalisation of monoids:
#+NAME: monoid
#+BEGIN_SRC agda :results replace :wrap "src results-agda"
PackageFormer Monoid : Set‚ÇÅ where
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
#+END_SRC
:Hide:
#+RESULTS: monoid
#+BEGIN_src results-agda
PackageFormer Monoid : Set‚ÇÅ where
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
#+END_src
:End:

We regain the Haskell-style typeclass definition with the following declaration:
#+BEGIN_SRC agda
 Monoid-Classical = Monoid typeclass :height (1) :level (dec)
#+END_SRC
Loading the script, with ~C-c C-l~ as usual, produces a generated file that elaborate this definition as follows:
#+BEGIN_SRC results-agda
record Monoid-Classical (Carrier : Set) : Set where
  field
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
#+END_SRC
Notice that a name ~Carrier~ has been lifted to being a parameter instead of a field.
This is the result of the ~:height~ argument to the ~typeclass~ variational defined
in the previous subsection.

:TODO_FIXME:
We could use the letter ~m~ in-place of ~Carrier~, as is done in Haskell, as follows.
#+BEGIN_SRC agda
 Monoid-m = Monoid typeclass renaming (Carrier to m)
#+END_SRC
Which propagates ~Carrier = m~ into the fields. The propagation is necessary
if we were, for example, to rename ~_‚®æ_ to _‚äï_~ ---otherwise we would need to parse
mixfix applications of this operator, as in ~assoc~!
#+BEGIN_SRC agda
record Monoid-m (m : Set) : Set where
  field
    _‚®æ_     : let Carrier = m in m ‚Üí m ‚Üí m
    Id      : let Carrier = m in m
    assoc   : let Carrier = m in ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : let Carrier = m in ‚àÄ {x : let Carrier = m in m} ‚Üí Id ‚®æ x ‚â° x
    rightId : let Carrier = m in ‚àÄ {x : let Carrier = m in m} ‚Üí x ‚®æ Id ‚â° x
#+END_SRC
:END:

Since Agda supports ‚Äònamed instances‚Äô, the Haskeller's first problem is solved. However, we demonstrate
an alternative solution that will allow us to solve the second problem in a fashion that current Agda
can only awkwardly approximate.

For example, with the current setup, we may go about requesting multiple monoid instances for the Booleans:
#+BEGIN_SRC agda
open Monoid-Classical using () renaming (_‚®æ_ to Op)

yuck-one :  (X Y : Classical ùîπ)
     ‚Üí  Op X  ‚â° _‚àß_  ‚Üí  Op Y  ‚â° _‚à®_
     ‚Üí  Set
yuck-one = ???
#+END_SRC

The following declaration lets us ‚Äòuncurry‚Äô the first ~N = 2~ elements
from the field-position to the parameter-position.
#+BEGIN_SRC agda
MonoidOp = Monoid typeclass :height (2) :level (dec)
#+END_SRC

This then yields:
#+BEGIN_src results-agda
record MonoidOp (Carrier : Set) (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier) : Set where
  field
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
#+END_src

Which let's us solve the first problem elegantly as so:
#+BEGIN_SRC agda
first-problem : MonoidOp ùîπ _‚àß_  ‚Üí  MonoidOp ùîπ _‚à®_  ‚Üí Set
first-problem = ???
#+END_SRC

Neato ^_^ Short and sweet.

Now for the second problem. Rather than forming a new data-type,
we hoist up the ~Id~-entity field as a parameter.
| ~TODO: Write this section~ |

#+BEGIN_SRC agda
 MonoidId = Monoid record exposing (Carrier; Id)
#+END_SRC
Which results in:
#+BEGIN_SRC agda
record MonoidId (Carrier : Set) (Id : Carrier) : Set where
  field
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
#+END_SRC

Resulting in the solution type:
#+BEGIN_SRC agda
second-problem-okay : (X Y : MonoidId ùîπ false) ‚Üí Set
second-problem-okay = ???
#+END_SRC
However, this too can get tedious if we wish to only consider monoids
with unit ~false~. In that case, we /treat/ the fields as if they where
manifest fields and instantiate them to form a new type.
#+BEGIN_SRC agda
{-700 Monoid-false = Monoid record with (Carrier to ùîπ; Id to false) -}

record Monoid-false : Set where
  field
    _‚®æ_     : ùîπ ‚Üí ùîπ ‚Üí ùîπ
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftfalse  : ‚àÄ {x : ùîπ} ‚Üí false ‚®æ x ‚â° x
    rightfalse : ‚àÄ {x : ùîπ} ‚Üí x ‚®æ false ‚â° x

second-problem-better : (X Y : Monoid-false) ‚Üí Set
second-problem-better = ???
#+END_SRC

The full source of this discussion is as follows.
{{{fold(CaseStudy.agda)}}}
#+INCLUDE: "CaseStudy.agda" src agda
{{{end-fold}}}

** regular expression tests :ignore:
   :PROPERTIES:
   :CUSTOM_ID: regular-expression-tests
   :END:
   :Hide:
   Names may involve (Emacs) regular expression operators such as [],+,*,?, etc.
#+BEGIN_SRC agda
{-700
-- regular expression test --

crazy-name-[]-+-\-^-*-? = M-Set extended-by "_+_ : Scalar; _*_ : Vector; ^ : Set; [_] : Set" :adjoin-retract nil ‚ü¥ record

PackageFormer MagmaP : Set‚ÇÅ where
  Carrier : Set
  op      : Carrier ‚Üí Carrier ‚Üí Carrier

Magma = MagmaP ‚ü¥ record

Pointed   = Magma extended-by "e : let Carrier = Carrier in Carrier" ‚ü¥ record
Additive+ = Pointed renaming "op to _+_; e to O; Carrier to C" ‚ü¥ record
Additive√ó = Additive+ renaming "_+_ to _√ó_"

crazy-name-test  = Pointed map (Œª e ‚Üí (map-name (Œª n ‚Üí (concat n "/crazy-name-[]-+-\-^-*-?")) e)) ‚ü¥ record
crazy-name-test2 = crazy-name-test map (Œª e ‚Üí (map-name (Œª n ‚Üí (concat n "+2")) e)) ‚ü¥ record
-}
#+END_SRC
   :End:
* COMMENT User Manual III: Semantics
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-User-Manual-III--Semantics
  :END:

1. A <<<context>>> Œì is an association list, for us they consist of name-type pairs
   where later types may depend on the names of previous types:

         Œì = (x‚ÇÄ : œÑ‚ÇÄ; ‚Ä¶; x‚Çô : œÑ‚Çô) is well-formed
     iff (x‚ÇÄ : œÑ‚ÇÄ; ‚Ä¶; x‚Çñ‚Çã‚ÇÅ : œÑ‚Çñ‚Çã‚ÇÅ) ‚ä¢ œÑ‚Çñ Type

2. A <<<morphism>>> of contexts $œÉ : Œì ‚Üí Œî$ is an assignment $Œì-names ‚Üí Œî-terms$
   such that $Œî ‚ä¢ œÉ x·µ¢ : œÉ·µâ œÑ·µ¢$ where œÉ·µâ is the homomorphic extension to types.

   For example, Œì = (A : Type; B : Type; q : A √ó B)
                Œî = (C : Type; p : C √ó C)
                œÉ = {A ‚Ü¶ C; B ‚Üí C; q ‚Ü¶ p}

   Then, Œî ‚ä¢ œÉ q ‚à∂ œÉ·µâ (A √ó B)
       ‚áî Œî ‚ä¢ p ‚à∂ œÉ·µâ A √ó œÉ·µâ B
       ‚áî Œî ‚ä¢ p ‚à∂ C √ó C
       ‚áî true

3. We have a category of contexts ‚ÑÇ.

4. The subcategory of nominal assignments ùîπ has only those morphisms whose terms
   are names; i.e., morphisms that are name-to-name assignments.

   - An <<<extension>>> is a nominal assignment where every name occurs
     at most once; these encode subcontext embeddings.
   - A <<<rename>>> is a nominal isomorphism.
   - Since renames and extensions are both nominals, their composition is also a nominal.

   Interestingly, nominal morphisms are essentially renames followed by extensions.

   Since we allow named constants, usual, possibly non-nominal, morphisms are essentially
   renames that send symbols to fresh constant symbols whose definitions denote the term in
   the orginal view, then we follow that by a rewrite and drop of these constant names.

5. Let ùîº denote the category of extensions: Objects are extension morphisms
   and arrows are two ùîπ-arrows that make the resulting square commute.

** COMMENT PackageFormers *as* Agda Datatypes :Eventually::after_prototype_is_done:
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-PackageFormers--as--Agda-Datatypes
   :END:

 #+BEGIN_SRC agda
open import Function using (id)
open import Data.List using (List; map)
open import Data.String using () renaming (String to Name)
open import Data.String using () renaming (String to Type)
open import Data.Product using (_√ó_) renaming (map to bimap)

data VarExpr : Set where
  :kind : String ‚Üí VarExpr
  :alter-elements : String ‚Üí VarExpr


{- No lambda's allowed; all arguments must be to the left of the ‚Äò=‚Äô. -}
{- Definition must be one liner. -}
ùëΩ-adorn : List (Name √ó Type) ‚Üí (Name ‚Üí Name) ‚Üí List (Name √ó Type)
ùëΩ-adorn xs f = map (bimap f id) xs

import Data.Maybe as Maybe
open Maybe using (Maybe; just; nothing)
import Data.List as List
open import Data.List using (_++_ ; _‚à∑_)
data Kind : Set where
  ‚Äµdata ‚Äµrecord ‚Äµmodule ‚Äµfunction ‚Äµpackageformer : Kind
  --
  -- note that pf's are not necessary, we can work with records then
  -- reify them as other groupingmechanisms.
  -- BUT it's preferable to be as unbiased as possible
  -- hence we keep the generic package-former kind.

record PF : Set where
  field
    kind       : Kind
    name       : Name
    level      : Level
    {- The following four are the ‚Äúconstiutents‚Äù or ‚Äúelements‚Äù of a PackageFormer -}

    -- old, remove me
    variation  : Maybe Name
    carrier    : Maybe Name

    parameters : List (Name √ó Type)
    fields     : List (Name √ó Type)

{-
pf‚Ä≤ = pf variational (args; otherwise)

variational : (new-name : Name) (args : ‚ãØ) (otherwise : ? ‚Üí ?) ‚Üí PF
variational pf‚Ä≤ args otherwise = ???
-}

_Variational‚ÇÅ : {‚Ñì : Level} (X : Set ‚Ñì) ‚Üí Set ‚Ñì
X Variational‚ÇÅ = (new-name : Name) (to-list : List (Name √ó X)) (otherwise : Name ‚Üí X)
               ‚Üí PF ‚Üí PF

_Variational‚ÇÄ : {‚Ñì : Level} (X : Set ‚Ñì) ‚Üí Set ‚Ñì
X Variational‚ÇÄ = (new-name : Name) (to-list : List X) (otherwise : Name ‚Üí X)
               ‚Üí PF ‚Üí PF

open import Data.Product using (_,_)
open import Data.String using (String)
postulate string-replace : (old new : String) ‚Üí String ‚Üí String

ùëΩ-record : Name Variational‚ÇÅ
ùëΩ-record new-name to-list otherwise pf = let open PF pf in
  record
    { kind       = ‚Äµrecord
    ; name       = new-name
    ; variation  = nothing
    ; level      = Level.suc level
    ; carrier    = just "Carrier"
    ; parameters = List.[]
    ; fields     =    parameters
                   ++ ("Carrier" , "Set level")  -- HACK!
                   ‚à∑ List.map (bimap (string-replace "name variation" "Carrier") id) fields   -- HACK!
    }

{- This‚Äô a lot at once; let's instead focus on small combinators. -}

-- as-kind : Kind ‚Üí PF ‚Üí PF
-- as-kind k

{-
with-carrier : Name ‚Üí PF ‚Üí PF
with-carrier c pf = let open PF pf in
  record
    { kind       = kind
    ; name       = name
    ; level      = level
    ; variation  = variation
    ; carrier    = just c
    ; parameters = List.map (bimap f id) parameters
    ; fields     = List.map (bimap f id) fields
    }


alter-elements : (Name ‚Üí Name) ‚Üí PF ‚Üí PF
alter-elements f pf = let open PF pf in
  record
    { kind       = kind
    ; name       = name
    ; level      = level
    ; variation  = variation
    ; carrier    = Maybe.map f carrier
    ; parameters = List.map (bimap f id) parameters
    ; fields     = List.map (bimap f id) fields
    }

-}

{-00

Woah = Monoid record adorn (Œª x ‚Üí x ++ "‚Çê")

-}




-- Since seven-hundred comments generate code which is imported, we may use their results
-- seemingly before their definition

-- _ = MonoidR
-- open MonoidR‚Ä≤

{-00
MonoidR   = Monoid record
MonoidR‚Ä≤  = Monoid opening MonoidR (Œª x ‚Üí x ++ "‚Ä≤")
MonoidR‚ÇÅ  = Monoid opening MonoidR (Œª x ‚Üí x ++ "‚ÇÅ")
MonoidR‚ÇÇ  = Monoid opening MonoidR (Œª x ‚Üí x ++ "‚ÇÇ")


record Monoid-Hom (ùíÆ ùíØ : MonoidR) : Set where
  open MonoidR‚ÇÅ ùíÆ; open MonoidR‚ÇÇ ùíØ
  field
    mor     : Carrier‚ÇÅ ‚Üí Carrier‚ÇÇ
    id-pres : mor Id‚ÇÅ ‚â° Id‚ÇÇ
    op-pres : ‚àÄ {x y} ‚Üí mor (x ‚®æ‚ÇÅ y) ‚â° mor x ‚®æ‚ÇÇ mor y
-}

{- Below are other examples, from the past. -}

{-00
MonoidTypeclass = Monoid typeclass hiding (_‚®æ_)
MonoidT         = Monoid typeclass renaming (Carrier to C; _‚®æ_ to _‚äï_)
MonoidE         = Monoid record exposing (Carrier; Id)
MonoidB         = Monoid record with (Carrier to Bool; Id to false)
MonoidD         = Monoid data renaming (_‚®æ_ to _Œî_)


-- MonoidR         = Monoid record unbundling 2
-- MonoidD‚Ä≤        = Monoid data decorated (Œª it ‚Üí "‚ï≤" ++ it ++ "‚ï±")

-- Accidentally ‚Äúdatar‚Äù instead of ‚Äúdata‚Äù.
-- Whoops = Monoid datar

_ = MonoidTypeclass
{- record MonoidTypeclass (Carrier : Set) : Set where ‚Ä¶ -}

_ = MonoidT ; open MonoidT using (_‚äï_)
{- record MonoidT (C : Set) : Set where ‚Ä¶ -}

_ = MonoidR
{- record MonoidR (Carrier : Set) (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier) : Set where ‚Ä¶ -}

_ = MonoidD
{- data MonoidD : Set where ‚Ä¶ -}

_ = MonoidE
{- record MonoidE (Carrier : Set) (Id : Carrier) : Set where ‚Ä¶ -}

_ = MonoidB ; open MonoidB using (leftfalse)
{- record MonoidB : Set‚ÇÄ where ‚Ä¶ -}

-- _ = MonoidD‚Ä≤

-}
 #+END_SRC
* Strings and Things
  :PROPERTIES:
  :CUSTOM_ID: Strings-and-Things
  :END:

Since our prototype is intended to be as minimally obtrusive as possible, we will
need to extract our special 700-syntactical items between delimited tokens
and process them.

The following subsections introduce:
+ ~get-children~ :: Obtaining intended items from a hierarchical listing.
+ ~sub-string-delimited-here~ :: Finding the shortest substring between a prefix
      ~ùë≥~ and a postfix ~ùëπ~ by using the ‚Äòmetavariable‚Äô ~$here~; e.g., ~‚Äúùë≥ $here ùëπ‚Äù.~
+ ~buffer-substring-delimited-whole-buffer~ :: Yield all portions of the
     buffer enclosed in the given delimiters, as a list of strings.
+ ~rename-mixfix~ :: Renamaing Agda mixifix names where the rename operation
     ignores the outermost (Agda) argument position markers ‚Äò_‚Äô.
+ ~extract-imports~ :: Obtain all ‚Äòimport‚Äô clauses so that they can be
     ported over to the generated file.

First we include an Emacs Lisp [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers][library header]] which declares important meta-data
---with the aim of having the resulting software
be distributed with Emacs's largest package repository, MELPA.
Installing this package, from within Emacs, also automatically installs its dependencies,
recursively.
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
;;; agda-next-700-module-systems.el --- Making Modules with Meta-Programmed Meta-Primitives, for Agda

;; Author: Musa Al-hassy <alhassy@gmail.com>
;; Version: 1.0
;; Package-Requires: ((s "1.12.0") (dash "2.16.0") (origami "1.0")  (emacs "24.4"))
;; Keywords: agda, modules, packages, theories, languages, convenience, maint, tools
;; URL: https://alhassy.github.io/next-700-module-systems

;; Copyright (c) 2019 Musa Al-hassy

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; This program is intended to reduce the burden in selecting
;; the form of records and other kinds of packages in Agda.
;; For example, the decision of whether a record element should be
;; declared as a field or as a parameter no longer needs to be performed
;; prematurely but rather may be selected when necessary.

;; We cannot use lexical binding since the package provides a macro called ùí±
;; that acts as an interface for a DSL that generates Lisp functions
;; which requires EVAL to bind staged formal arguments to their runtime values.

;; This el file has been tangled from a literate, org-mode, file.
;; See the documentation on:
;; https://alhassy.github.io/next-700-module-systems/prototype/package-former.html

;;; Code:
#+END_SRC

First some useful libraries:
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
;; String and list manipulation libraries
;; https://github.com/magnars/dash.el
;; https://github.com/magnars/s.el
(require 's)               ;; ‚ÄúThe long lost Emacs string manipulation library‚Äù
(require 'dash)            ;; ‚ÄúA modern list library for Emacs‚Äù
(require 'dash-functional) ;; Function library; ‚Äò-const‚Äô, ‚Äò-compose‚Äô, ‚Äò-orfn‚Äô, ‚Äò-not‚Äô, ‚Äò-partial‚Äô, etc.
(require 'origami)         ;; Folding away regions of text
(require 'subr-x)          ;; Extra Lisp functions; e.g., ‚Äòwhen-let‚Äô.
(require 'ert)             ;; Testing framework; ‚Äòshould‚Äô for assertions
(require 'cl-lib)          ;; New Common Lisp library; ‚Äòcl-???‚Äô forms.
#+END_SRC

** COMMENT Typing mechanism :avoiding_this_for_now:
   :PROPERTIES:
   :CUSTOM_ID: Typing-mechanism
   :END:

#+NAME: declare-type
Attach the given list of types to the function ‚ÄòF‚Äô
by advising the function to check its arguments‚Äô types
are equal to the list of given types.

#+NAME: declare-type
We name the advice ‚Äò‚ü™f‚ü´-typing-advice‚Äô so that further
invocations to this macro overwrite the same advice function
rather than introducing additional, unintended, constraints.

#+NAME: declare-type
Using type specifiers we accommodate for unions of types
and subtypes, etc ‚ô•‚Äø‚ô•.

#+NAME: declare-type
‚Äòkey-types‚Äô should be of the shape (:x‚ÇÄ t‚ÇÄ ‚ãØ :x‚Çô t‚Çô);
when there are no optional types, use symbol ‚Äú:‚Äù.

#+NAME: declare-type
E.g., (pf--declare-type my-func (:z string :w integer) integer symbol string)

#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
;; Crashes if an argument is ":"
(cl-defmacro pf--declare-type (f key-types &rest types)
  "Attach run-time typechecking to a function.
<<docs('declare-type)>>"

  ;; Basic coherency checks. When there aren't optional types, key-types is the ‚Äú:‚Äù symbol.
  (should (and (listp types) (or (listp key-types) (symbolp key-types))))

  (letf* ((pairify (lambda (xs) (loop for i in xs by #'cddr         ;; Turn a list of flattenned pairs
                                      for j in (cdr xs) by #'cddr   ;; into a list of explicit pairs.
                                      collect (cons i j))))         ;; MA: No Lisp method for this!?
         (result-type  (car (-take-last 1 types)))
         (types        (-drop-last 1 types))
         (num-of-types (length types))
         (key-types-og (unless (symbolp key-types) key-types))
         (key-types    (funcall pairify key-types-og))
         (advice-name  (intern (format "%s-typing-advice" f)))
         (notify-user  (format "%s now typed %s ‚Üí %s ‚Üí %s."
                               `,f key-types-og types result-type)))

      `(progn
         (defun ,advice-name (orig-fun &rest args)

           ;; Split into positional and key args; optionals not yet considered.
           (letf* ((all-args
                     (-split-at
                       (or (--find-index (not (s-blank? (s-shared-start ":" (format "%s" it)))) args) ,num-of-types)
                        args)) ;; The ‚Äúor‚Äù is for when there are no keywords provided.
                  (pos-args  (car all-args))
                  (key-args  (funcall ,pairify (cadr all-args)))
                  (fun-result nil)
                  ((symbol-function 'shucks)
                     (lambda (eœÑ e g)
                       (unless (typep g eœÑ)
                         (error "%s: Type mismatch! Expected %s %s ‚â† Given %s %s."
                                (function ,f) eœÑ e (type-of g) (prin1-to-string g))))))

         ;; Check the types of positional arguments.
         (unless (equal ,num-of-types (length pos-args))
           (error "%s: Insufficient number of arguments; given %s, %s, but %s are needed."
                  (function ,f) (length pos-args) pos-args ,num-of-types))
         (loop for (ar ty pos) in (-zip pos-args (quote ,types) (number-sequence 0 ,num-of-types))
               do (funcall shucks ty (format "for argument %s" pos) ar))

         ;; Check the types of *present* keys.
         (loop for (k . v) in key-args
               do (funcall shucks (cdr (assoc k (quote ,key-types))) k v))

         ;; Actually execute the orginal function on the provided arguments.
         (setq fun-result (apply orig-fun args))
         (funcall shucks (quote ,result-type) "for the result type (!)" fun-result)

         ;; Return-value should be given to caller.
         fun-result))

      ;; Register the typing advice and notify user of what was added.
      (advice-add (function ,f) :around (function ,advice-name))
      ,notify-user )))
#+END_SRC
#
# E.g., (pf--declare-type f‚ÇÅ (:z string :w list) integer symbol string)

** Finding Children in the Wild
   :PROPERTIES:
   :CUSTOM_ID: Finding-Children-in-the-Wild
   :END:

Being a prototype, we are talking a mostly string-based approach to working
with hierarchical phrases.
For example, consider the following todo list,
#+NAME: children-example
#+BEGIN_SRC org :results replace
+ item 0
+ item 1
  - subitem 1.1
    ,* subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 2.2
+ item 3
#+END_SRC

#+RESULTS: children-example
+ item 0
+ item 1
  - subitem 1.1
    * subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 2.2
+ item 3

:Example:
#+BEGIN_SRC emacs-lisp :var it = children-example
(message it)
#+END_SRC

#+RESULTS:
: + item 1
:   - subitem 1.1
:     * subsubitem 1.1.1
:   - subitem 1.2
: + item 2
:   - subitem 1.2
: + item 3
:End:

We would think that ~item 1~ has two ‚Äòchildren‚Äô, and, moreover, one grand-child.
Whereas ~item 2~ has a single child and ~item 3~ is barren.

Here's my intuitive algorithm: We obtain the indentation of the first child,
then all subsequent lines with at least that much indentation have the same ancestor.

{{{fold(get-indentation Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
;; (pf--declare-type pf--get-indentation : string integer)
(defun pf--get-indentation (string)
  "How many spaces are there at the front of STRING?

Property: The resulting number is ‚â§ length STRING."
  (if string (length (s-shared-start string (s-repeat (length string) " "))) 0))
#+END_SRC
{{{end-fold}}}

{{{fold(get-children Implementation)}}}

#+NAME: get-children
Go into ‚Äòthe-wild‚Äô seeking out the first occurence of ‚Äòparent‚Äô,
who once found, ought to have a minimal indentation for its children.

#+NAME: get-children
‚ÄúMinimal‚Äù in that if there are items with a greater indentation,
then they are children of children and should be kept.

#+NAME: get-children
The first input argument is of type ‚Äòstring‚Äô,
the second argument may be of type ‚Äòstring‚Äô or ‚Äòlist‚Äô of strings
---if it's a string, we split along new lines---,
the optional ‚Äòthen‚Äô is a function acting on children strings.

#+NAME: get-children
Result is the parent followed by its children, as a list of lines,
where each child has been altered using the optional THEN function.
Moreover, we also return the rest of the unconsidered portion of THE-WILD:

#+NAME: get-children
Result list: (unconsidered-prefix-of-the-wild
              (cons parent-line children-lines)
              unconsidered-remaining-lines)

#+NAME: get-children
The first element is the porition that does not contain an occurence
of PARENT.  The second is the parent and its children, if possible.
The third is the remainder of THE-WILD.

#+NAME: get-children
Implementation: Look at the indentation of the
first child, then use that as a lower bound to find the indentation
of the remaining children.

# (pf--declare-type get-children (:then t) string (or string list) cons)
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(cl-defun pf--get-children (parent the-wild &key (then #'identity))
  "Returns indented text under a PARENT line.
<<docs('get-children)>>"
  (let ((lines (if (stringp the-wild) (s-lines the-wild) the-wild))
        (indentation -1)
        unconsidered
        prefix
        lines&more
        parent-line)

    ;; Ensure: lines ‚âà (cons (not-here-prefix) (cons parent-here more-lines) )
    (setq lines (--split-with (not (s-contains? parent it)) lines))

    ;; Discard prefix, for now.
    (setq prefix (car lines))
    (setq lines (cadr lines))

    ;; Discard parent, but remember its contextual line.
    (setq parent-line (car lines))
    (setq lines (cdr lines))

    ;; How far is the first child indented? At least 1 space; otherwise no children.
    (setq indentation (max 1 (pf--get-indentation (car lines))))

    ;; Keep only the children that have at least this level of indentation.
    (setq lines&more
          (--split-with (<= indentation (pf--get-indentation it)) lines))
    (setq lines (car lines&more))
    (setq unconsidered (cadr lines&more))

    ;; Alter the children according to the given function.
    (setq lines (mapcar then lines))

    ;; Yield the parent line along with the children lines;
    ;; and the unconsumed wild's prefix and suffix.
    `(,prefix ,(cons parent-line lines) ,unconsidered)))
#+END_SRC
{{{end-fold}}}

Let's try this out on our example hierarchy, ~eh~, from earlier.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(cadr (pf--get-children "+ item 1" eh))
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 |

(pf--load-package-former (cadr (pf--get-children "PackageFormer"
"PackageFormer Test : Set‚ÇÅ where
PackageFormer Another : Set‚ÇÅ where
")))

Excellent! Let's looks at the other parents.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(pf--get-children "+ item 2" eh)
#+END_SRC

#+RESULTS:
| + item 0 | + item 1      | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 |
| + item 2 | - subitem 2.2 |               |                    |               |
| + item 3 |               |               |                    |               |

Notice that we found the parent ~+ item 2~ and its only child ~- subitem 1.2~, and
we kept the prefix of ~eh~ that did not contain the parent as well as
the remaining unconsidered portion of ~eh~. ---Moreover, it looks like we obtained
the transpose of the example hierarchy üòõ

Finally, the barren parents.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(pf--get-children "+ item 0" eh)
#+END_SRC

#+RESULTS:
| + item 0 |               |                    |               |          |               |          |
| + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 | + item 2 | - subitem 2.2 | + item 3 |

As well as,
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(pf--get-children "+ item 3" eh)
#+END_SRC

#+RESULTS:
| + item 0 | + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 | + item 2 | - subitem 2.2 |
| + item 3 |          |               |                    |               |          |               |

Everything before it is considered the prefix. Yay :smile:

Before we move on, let's try altering a child clause; e.g., I'd like
~* subitem 1.1.1~ to be renamed to ~* subitem that is super deep~.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(cadr (pf--get-children "+ item 1" eh
 :then (lambda (x) (s-replace "1.1.1" "that is super deep" x))))
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem that is super deep | - subitem 1.2 |

Nice :grin:

Now the moment of truth, let's try this out on our example.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results table replace :wrap "src results-agda"
(cadr (pf--get-children "PackageFormer" test))
#+END_SRC

   #+RESULTS:
#+begin_src results-agda
| PackageFormer M-Set : Set‚ÇÅ where | Scalar  : Set | Vector  : Set | _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector | ùüô       : Scalar | _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar | leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã | assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã) |
#+end_src

Also, does the list variant work:
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace  :wrap "src results-agda"
(cadr (pf--get-children "PackageFormer" (s-lines test)))
#+END_SRC

#+RESULTS:
#+begin_src results-agda
| PackageFormer M-Set : Set‚ÇÅ where | Scalar  : Set | Vector  : Set | _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector | ùüô       : Scalar | _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar | leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã | assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã) |
#+end_src

Test-driven development doesn't seem bad üò≤

These pretty-coloured tests and results may be nice for exposition,
however for maintenance it is ideal to include unit tests that can
be checked without human intervention. ~M-x ert <RET> t <RET>~, after
executing the following block, will report which tests pass and tries to explain
why tests fail.

{{{fold(Tests)}}}
#+BEGIN_SRC emacs-lisp :tangle no
(ert-deftest get-ind ()
  (loop for s in '(nil "" "x" "  x" "  x ")
    do (should (<= (pf--get-indentation s) (length s))))
  )

(ert-deftest get-child ()
  (-let [eh
"+ item 1
  - subitem 1.1
    ,* subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 2.2
+ item 3"]

    ;; Consider each line above as a parent, with ‚Äòeh‚Äô as the wild.
    (loop for parent in (s-split "\n" eh) do
      (let* ((cs (pf--get-children parent eh))
         (children (cdadr cs)))

      ;; Result is a list of lists: Each is either nil or a cons.
      (loop for r in cs do (should (listp r)))

      ;; The parent line contains the parent.
      (should (equal parent (caadr cs)))

      ;; The children all have the same indentation.
      (loop for c in children for d in children
            do (should (equal (pf--get-indentation c) (pf--get-indentation d))))

      ;; Extensionality: Orginal input can be regained from resulting parts.
      (should (equal eh (s-trim (s-join "\n" (--map (s-join "\n" it) cs)))))))))
#+END_SRC
{{{end-fold}}}

** Substrings Delimited by Tokens
   :PROPERTIES:
   :CUSTOM_ID: Substrings-Delimited-by-Tokens
   :END:

#+begin_center
/How do we find a string delimited by two tokens?/
#+end_center

Before we can get to the real stuff, we need to produce a few low-level ---string manipulation---
utilities, so that we can work with higher-level abstract datatypes.

+ ~substring-delimited~: Given ~prefix~ and ~suffix~,
  this operation takes a string of the form  ~‚ãØ‚Äòprefix‚Äô‚ü™needle‚ü´‚Äòsuffix‚Äô‚ãØ~ and yields ~needle~.
+ ~substring-delimited-here~: Given ~"‚ü™prefix‚ü´ $here ‚ü™suffix‚ü´"~
  this operation takes a string of the form  ~‚ãØ‚Äòprefix‚Äô‚ü™needle‚ü´‚Äòsuffix‚Äô‚ãØ~ and yields ~needle~.

{{{fold(substring-delimited Implementation)}}}

#+NAME: substring-delimited
We convert all adjacent whitespace
characters to a single space in the input STRING and trim any surrounding
whitespace from the resulting output needle string.

 - NOTE: Delimiters PREFIX and SUFFIX may be empty.

# ;; This may accept argument ":", which ‚Äúpf--declare-type‚Äù cannot currently handle.
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(cl-defun pf--substring-delimited (prefix suffix string)
  "Assuming ‚ÄúSTRING ‚âà ‚ãØPREFIX‚ü™needle‚ü´SUFFIX‚ãØ‚Äù, return the first such needle.
<<docs('substring-delimited)>>"

  (unless (stringp string)
    (error "PF--SUBSTRING-DELIMITED: Argument STRING must be a string"))
  (let* ((new (s-collapse-whitespace string)))
    (when (not (s-blank? prefix))
      (setq new (car (-take-last
                      (if (equal prefix suffix) 2 1) (s-split prefix new)))))
    (when (not (s-blank? suffix))
      (setq new (car (s-split suffix new))))
    (s-trim new)))
#+END_SRC

# TODO: broken
#+BEGIN_SRC emacs-lisp :tangle no
(ert-deftest subst-delimit ()
  (-let [str "ùüò ùüô ùüö ùüõ ùüú ùüù ùüú ùüû"] ;; Intentionally repeated ‚Äòùüú‚Äô.
    ;; Pattern for loop: (prefix postfix expected-needle :comment))
    (loop for it in `( ( "" "" ,str            :Identity)
               ( "ùüò" "ùüû" "ùüô ùüö ùüõ ùüú ùüù ùüú"  :Boundaries)
               ( "" "ùüû" "ùüò ùüô ùüö ùüõ ùüú ùüù ùüú" :NoLeft)
               ( "ùüò" "" "ùüô ùüö ùüõ ùüú ùüù ùüú ùüû" :NoRight)
               ( "ùü†" ""  ,str          :BogusL)
               ( "" "‚àû"  ,str          :BogusR)
               ( "ùü†" "‚àû" ,str          :BogusLR)
             )
      do (should (equal (third it)
                        (pf--substring-delimited (first it) (second it) str))))

    (should (equal "ùüõ" (pf--substring-delimited "ùüö" "ùüú" str)))

    ;; Identical boundaries.
    (should (equal "ùüô" (pf--substring-delimited "ùë≥" "ùë≥" "ùë≥ ùüô ùë≥")))
    (should (equal ""  (pf--substring-delimited "ùë≥" "ùë≥" "ùë≥ ùë≥")))
    (should (equal ""  (pf--substring-delimited "ùë≥" "ùë≥" "ùë≥ùë≥")))

    ;; Multiple occurances of prefix or postfix
    (should (equal "y"  (pf--substring-delimited "ùë≥" "ùëπ" "ùë≥ x ùë≥ y ùëπ")))
    (should (equal "x"  (pf--substring-delimited "ùë≥" "ùëπ" "ùë≥ x ùëπ y ùëπ")))
#+END_SRC
{{{end-fold}}}

# (pf--substring-delimited "PackageFormer" ":") "PackageFormer ùí´ : Set")
# (pf--substring-delimited-here "PackageFormer $here :" "PackageFormer ùí´ : Set")

{{{fold(pf--substring-delimited-here Implementation)}}}

#+Name: substring-delimited-here
- That is, assuming ‚ÄúCONTEXT ‚âà PREFIX $here SUFFIX‚Äù
  and ‚ÄúSTRING ‚âà ‚ãØPREFIX ‚ü™needle‚ü´ SUFFIX‚ãØ‚Äù, return the /first/ such needle.

  That is, we place template CONTEXT ‚Äúon top of‚Äù provide STRING,
  then return whatever falls under position ‚Äò$here‚Äô.

- NOTE: PREFIX and SUFFIX cannot be empty strings!

- We convert all adjacent whitespace
  characters to a single space in the input ‚Äòstring‚Äô and trim any surrounding
  whitespace from the resulting output needle string.

#  ;; This may accept argument ":", which ‚Äúpf--declare-type‚Äù cannot currently handle.
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(cl-defun pf--substring-delimited-here (context string) "\
Assuming ‚ÄúCONTEXT ‚âà PREFIX $here SUFFIX‚Äù yield the value of needle ‚Äò$here‚Äô.
<<docs('substring-delimited-here)>>"

  (-let [pre-post (s-split "$here" context)]
    (pf--substring-delimited (s-trim (car pre-post))
                             (s-trim (cadr pre-post))
                             string)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(ert-deftest subst-delimit-here ()
  (-let [str "ùüò ùüô ùüö ùüõ ùüú ùüù ùüú ùüû"] ;; Intentionally repeated ‚Äòùüú‚Äô.
    ;; Pattern for loop: (prefix postfix expected-needle :comment)
    (loop for it in `( ( "$here" ,str              :Identity)
               ( "ùüò $here ùüû" "ùüô ùüö ùüõ ùüú ùüù ùüú"  :Boundaries)
               ( "$here ùüû" "ùüò ùüô ùüö ùüõ ùüú ùüù ùüú"  :NoLeft)
               ( "ùüò $here"  "ùüô ùüö ùüõ ùüú ùüù ùüú ùüû" :NoRight)
               ( "ùü† $here"   ,str          :BogusL)
               ( "$here ‚àû"   ,str          :BogusR)
               ( "ùü† $here ‚àû" ,str          :BogusLR)
             )
      do (should (equal (second it)
                        (pf--substring-delimited-here (first it) str))))

    ;; Longest substring
    (should (equal "ùüõ" (pf--substring-delimited-here "ùüö $here ùüú" str)))

    ;; Identical boundaries.
    (should (equal "ùüô" (pf--substring-delimited-here "ùüò $here ùüò" "ùüò ùüô ùüò")))
    (should (equal ""  (pf--substring-delimited-here "ùüò $here ùüò" "ùüò ùüò")))
    (should (equal ""  (pf--substring-delimited-here "ùüò $here ùüò" "ùüòùüò")))

    ;; Multiple occurances of prefix or postfix
    (should (equal "y"  (pf--substring-delimited-here "ùë≥ $here ùëπ" "ùë≥ x ùë≥ y ùëπ")))
    (should (equal "x"  (pf--substring-delimited-here "ùë≥ $here ùëπ" "ùë≥ x ùëπ y ùëπ")))

    ;; Space irrelevance for keyword ‚Äò$here‚Äô:
    (should (equal "ùüô" (pf--substring-delimited-here "ùë≥ $here ùëπ" "ùë≥ ùüô ùëπ")))
    (should (equal "ùüô" (pf--substring-delimited-here "ùë≥ $hereùëπ" "ùë≥ ùüô ùëπ")))
    (should (equal "ùüô" (pf--substring-delimited-here "ùë≥$here ùëπ" "ùë≥ ùüô ùëπ")))
    (should (equal "ùüô" (pf--substring-delimited-here "ùë≥$hereùëπ" "ùë≥ ùüô ùëπ")))
    (should (equal "ùüô" (pf--substring-delimited-here "ùë≥      $here  ùëπ" "ùë≥ ùüô ùëπ")))
    ))
#+END_SRC
{{{end-fold}}}

Suppose a user provides us with an awkwardly spaced PackageFormer header,
our string manipulation setup is robust enough to get at the constituents:
#+BEGIN_SRC emacs-lisp :results replace :exports both
(-let [header "PackageFormer  Semigroup   (  v : Variation) : Set (  ‚Ñìexpr)   where"]
  ;; Three kinds of invocations; the last is my preferred choice ‚ô•‚Äø‚ô•
  `( ,(pf--substring-delimited "PackageFormer " "(" header)
     ,(pf--substring-delimited-here "PackageFormer $here (" header)))
#+END_SRC

#+RESULTS:
| Semigroup | Semigroup |

The aim is to eventually have an interface that interacts with an buffer containing Agda code.
To that end, we propose that our fictitious syntax be directly embedded via special comments,
~{-700 ‚ãØ -}~, henceforth referred to as ‚Äú<<<700-comments>>>‚Äù.

+ ~(pf--buffer-substring-delimited starting-regexp ending-regexp)~ yields the /next/ portion of the buffer
  as a string, relative to the current position of the cursor, that is contained in the ‚Äòparenthesis‚Äô
  ~starting-regexp~ and ~ending-regexp~.

+ ~(pf--buffer-substring-delimited-whole-buffer starting-regexp ending-regexp)~ yields /all/ portions of the buffer,
  contained in the ‚Äòparenthesis‚Äô ~starting-regexp~ and ~ending-regexp~, as a list of strings.

  - Cursor position is saved.
  - This function let's us obtain the contents of /all/ 700-comments.

Where we have the following value:
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defvar pf-folding nil
  "Should 700 and Lisp blocks be folded away when ùë™-ùëê ùë™-ùëô.")
#+END_SRC

{{{fold(pf--buffer-substring-delimited Implementation)}}}
#+name: buffer-substring-delimited
- Get the current buffer's /next/ available substring that is delimited
  between the regexp tokens START up to END, exclusively.

- If no tokens are found, an error is thrown.

- MORE is a function that is called on the found instance:
  It is a function of the start and end positions of the occurance.

- REGEXP indicates whether we are using regular expression strings, or literals.
   It is nil by default.

#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
;; pf--declare-type has no support for optionals yet
(cl-defun pf--buffer-substring-delimited
    (start end &optional more &key (regexp t))
  "Return next delimited substring in the current buffer.
<<docs('buffer-substring-delimited)>>"
  (let (start-pos end-pos sp ep content)
    (if regexp (re-search-forward start) (search-forward start))
    (setq start-pos (point))
    (backward-word)
    (setq sp (point))

    (if regexp (re-search-forward end) (search-forward end))
    (setq ep (point))
    (backward-word)
    (setq end-pos (point))

    (setq content  (buffer-substring-no-properties start-pos end-pos))

    (when more (funcall more sp ep))
    (when pf-folding (origami-close-node-recursively (current-buffer) (point)))

    content))
#+END_SRC
{{{end-fold}}}

{{{fold(pf--buffer-substring-delimited-whole-buffer Implementation)}}}
#+name: buffer-substring-delimited-whole-buffer
- Return a list of all substrings in the current buffer that
  are delimited by regexp tokens START and END, exclusively.

- MORE is a function that is called on the found instance:
  It is a function of the start and end positions of the occurance.

#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
;; pf--declare-type has no support for optionals yet
(cl-defun pf--buffer-substring-delimited-whole-buffer (start end &optional more)
  "Return all delimited substrings in the current buffer.
<<docs('buffer-substring-delimited-whole-buffer)>>"
  ;; Colour 700 keywords red ‚Äú'error‚Äù
  (highlight-phrase start 'error)
  (highlight-phrase end 'error)
  (save-excursion
    (let ((l nil) (continue t))
     (goto-char (point-min))

     (while continue
       (condition-case nil
     ;; attemptClause
     (setq l (cons (pf--buffer-substring-delimited start end more) l))
     ;; recoveryBody
     (error (setq continue nil))))

     ;; We've collected items as we saw them, so ‚Äòl‚Äô is in reverse.
    (reverse l))))
#+END_SRC
{{{end-fold}}}

Here are some possible invocations, the last one being our use case.
#+BEGIN_SRC emacs-lisp
;; Get text delimited by quotes
(pf--buffer-substring-delimited "^\"" "^\"")

;; Get text delimited by usual Agda comments
(pf--buffer-substring-delimited "^\{-" "^-\}")

;; Execute the following in an Agda buffer to see this function in action.
(setq it (pf--buffer-substring-delimited-whole-buffer "^\{-700" "^-\}"))
#+END_SRC

** Agda Mixfix Renaming and Imports
   :PROPERTIES:
   :CUSTOM_ID: Agda-Mixfix-Renaming-and-Imports
   :END:
   Renamaing Agda mixifix names where the rename operation ignores the outermost
   position markers ‚Äò_‚Äô.

#+name: rename-mixfix
- Given an Agda mixfix operator OP, apply a function on strings F on
  the inner-most delimiting tokens of the operator, in-particular ignoring
  outer argument markers ‚Äò_‚Äô.

- For example, if you wish to decorate an operator with a prime or a subscript,
  we cannot simply catenate else we obtain ‚Äú_‚äï_‚ÇÅ‚Äù rather than ‚Äú_‚äï‚ÇÅ_‚Äù.

- Here are some sample results, assuming ‚Äúf ‚âà (Œª it ‚Üí (format ‚Äú‚ÇÄ%s¬π‚Äù it))‚Äù:
  +  _‚äï_     ‚Ü¶  _‚ÇÄ‚äï¬π_
  + _[_‚äó_]  ‚Ü¶  _‚ÇÄ[_‚äó_]¬π
  + he_lo   ‚Ü¶  ‚ÇÄhe_lo¬π
  + he-lo   ‚Ü¶  ‚ÇÄhe-lo¬π

- AVOID-MIXFIX-RENAMING is optional; by default renaming ‚Äújumps over‚Äù
  underscores, but providing a non-nil value for this argument leaves
  underscores alone.

  It is a matter of having, say, default ‚Äú_‚äï‚Çô_‚Äù versus ‚Äú_‚äï_‚Çô‚Äù.

#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defun rename-mixfix (f op &optional avoid-mixfix-renaming)
  "Rename an operation by ‚Äúleaping over‚Äù Agda positional markers.
<<docs('rename-mixfix)>>"
  (let* ((parts (s-split "_" op))
         (front (s-blank? (first parts)))
         (rear (s-blank? (car (last parts)))))

    (if avoid-mixfix-renaming
        (funcall f op)
      (--> (concat (when front "_") "$here" (when rear "_"))
           (pf--substring-delimited-here it op)
           (funcall f it)
           (concat (when front "_") it (when rear "_"))))))
#+END_SRC

# E.g.,
# (rename-mixfix (lambda (it) (concat it "‚Ä≤")) "_‚äï_")  ;; ‚áí _‚äï‚Ä≤_

We also want to prefix the generated file with the imports of the current file.
# ;; (pf--declare-type extract-imports : string)
{{{fold(extract-imports Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defvar pf-generated-suffix "-generated"
  "The suffix applied to a file's name to produce it's generated counterpart.")

;; Sometimes we may want the full name due to files being in a nested
;; directory hierarchy: (file-name-sans-extension buffer-file-name)
(defun pf--generated-file-name ()
  "Name of the generated file."
  (concat (file-name-sans-extension (buffer-name)) pf-generated-suffix))

(cl-defun pf--extract-imports ()
  "Return substring of buffer whose lines mention ‚Äúimport‚Äù.

Throw away any that mention the substring ‚Äú‚ü™FileName‚ü´-generated‚Äù."
  (thread-last (buffer-substring-no-properties (point-min) (point-max))
    (s-split "\n")
    (--filter (s-contains? "import " it))
    (--remove (s-contains? (pf--generated-file-name) it))
    (s-join "\n")))
#+END_SRC
{{{end-fold}}}

So much string meddling, hopefully no more üôà :hear_no_evil: :speak_no_evil:

** ‚ÄúŒª‚Äù for the Agda User
   :PROPERTIES:
   :CUSTOM_ID: -Œª--for-the-Agda-User
   :END:

   Let's make this prototype more accessible to the Agda user
   by providing an abbreviation of Lisp functions ~(lambda (x‚ÇÄ ‚Ä¶ x‚Çô) body)~
   into the Agda-like syntax ~(Œª x‚ÇÄ ‚ãØ x‚Çô ‚Üí body)~.

 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defmacro Œª (&rest body)
  "Implementing Agda style, interactive, lambdas; ideally for inline use:

‚ÄúŒª Œ± Œ≤ ‚Ä¶ œâ ‚Üí BODY‚Äù  becomes an interactive function with arguments Œ±, ‚Ä¶, œâ.

The args list may be empty, in which case the separator ‚Äú‚Üí‚Äù may be omitted
entirely, if desired.

A BODY must always be supplied, even if the literal nil."
  (let* ((parts (-split-on '‚Üí body)) args rest)

    (if (<= 2 (length parts))
        (progn (setq args (car parts)) (setq rest (cadr parts)))
         ;; Otherwise, only one part was found ---no arguments were provided.
         (setq args nil) (setq rest (car parts)))

   `(lambda ,args (interactive) ,@rest)))
 #+END_SRC

* The ~package-former~ Datatype
  :PROPERTIES:
  :CUSTOM_ID: The--package-former--Datatype
  :END:

For this prototype's constraints, a PackageFormer will generally declared as
#+BEGIN_SRC agda :tangle no
PackageFormer Name : Set level where
     ‚ãÆ
#+END_SRC

The body, ~‚ãÆ~, of such a declaration consists of a number of name-type declarations
and, equations ---*not yet supported*--- so let's form a type to work with these
components rather than meddle with strings all the time.

#+name: package-former
- ‚Äòdocstring‚Äô: Relevant documentation about this structure; e.g.,
   what is the instance declaration that generated this type, if any.

- ‚Äòkind‚Äô: PackageFormer, record, data, module, function, etc.

- ‚Äòname‚Äô: The name of the grouping mechanism schema.

- ‚Äòlevel‚Äô: The universe level that the instantiations will inhabit.
       The universe level of the PackageFormer.

- Finally, the children fields are the typed-names that constitute the body of the
  grouping mechanism. As long as consistent indentation is selected, it does not matter how much.
  As such, we keep track of these indentation numerics ourselves in case we need to tweak them.

- The first ‚Äòwaist‚Äô-many elements are considered parameters.

TODO: Eventually need to support variations?

#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defstruct pf--package-former
  "Record of components that form a PackageFormer.
<<docs('package-former)>>"
  docstring
  kind
  name
  level

  waist ;; Delimits elements into parameters and fields.

  ;; children
  indentation ;; useful for when new elements are added.
  elements
)
#+END_SRC

We will keep track of all such declarations in a global list, and provide a minimal user-interface to it.
#+BEGIN_SRC emacs-lisp  :tangle agda-next-700-module-systems.el
(defvar pf--package-formers nil
  "The list of PackageFormer schema declarations in the current Agda buffer.")

(defun $ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì (pf)
 "Return elements of a given PackageFormer's name, PF.

 This is provided to users; it is one of the few utilities that
 makes use of implementation specfic details.
"

;; (message-box (format "%s" (nth 1 (backtrace-frame 30))))
;; -let [here (progn (goto-char (point-min)) (search-forward pf) (thing-at-point 'line 'no-properties))]

 ;; Ensure the given PackageFormer is defined.
 (pf--ensure (assoc pf pf--package-formers)
             (format "Undefined PackageFormer ‚Äú%s‚Äù" pf)
             (list pf)
             "Ensure you spelled the name correctly."
             "Use the PackageFormer menu to see which PackageFormers are defined.")

 ;; Return its elements.
 (pf--package-former-elements (cdr (assoc pf pf--package-formers))))
#+END_SRC

Let's also declare a global variable for keeping track of whether 700-syntactical
should be coloured or not. Below we use a particular set of default colours.
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defvar pf-highlighting t
  "Should PackageFormer syntactical items be coloured?

‚û© Yellow for PackageFormer content.
‚û© Red for delimiters 700 and Lisp.
‚û© Green for names of variationals.")
#+END_SRC

** Locally Opening a PackageFormer
   :PROPERTIES:
   :CUSTOM_ID: Locally-Opening-a-PackageFormer
   :END:
   :PROPERTIES:

   :END:
It will get rather redundant to write ~(pf--package-former-X p)~ to project the constituents of a PackageFormer ~p~. As such, let's introduce
a useful macro to ‚Äúopen p‚Äù locally.
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
;; An anaphoric macro ^_^
(defmacro pf--open-pf (p &rest body)
  "Open a package-former P so no qualifiers are required in form BODY."
  `(let*
    ((docstring             (pf--package-former-docstring ,p))
     (kind                  (pf--package-former-kind ,p))
     (name                  (pf--package-former-name ,p))
     (level                 (pf--package-former-level ,p))
     (waist                 (pf--package-former-waist ,p))
     (indentation           (pf--package-former-indentation ,p))
     (elements              (pf--package-former-elements ,p))
     (parameters            (-take waist elements))
     (fields                (-drop waist elements)))
    ,@body))
#+END_SRC

( Lisp convention would advise this function to be named ~with-pf~, but I'm using the prefix ~open~,
as it is closer to the object language, Agda. )

  It is crucial to realise that we have just established a convention
  that partitions the elements of a PackageFormer:
  + <<<parameters>>> are the elements before the waist line.
  + <<<fields>>> are the elements after the waist line.

** Elements
   :PROPERTIES:
   :CUSTOM_ID: Elements
   :END:
A PackageFormer is a list of elements.
   #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defstruct element
  qualifier ;; E.g., ‚Äúprivate, field‚Äù
  name      ;; The lhs of an equation and a typed-name
  type      ;; The type of a typed-name
  equations ;; List of definitional clauses: ‚Äúsame-name-as-above args = term‚Äù
)
#+END_SRC

Let's produce the associated useful map functions.
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el :results replace
(loop for place in '(qualifier type equations)
      do
      (-let [loc (intern (format "element-%s" place))]
        (eval `(defun ,(intern (format "map-%s" place)) (f e)
           ,(format "Alter the ‚Äò%s‚Äô field of an ‚Äòelement‚Äô value." place)
           (-let [e‚Ä≤ (copy-element e)]
             (setf (,loc e‚Ä≤) (funcall f (,loc e‚Ä≤)))
             e‚Ä≤)))))

;; Improved definition; template above would not suffice.
(cl-defun map-name (f e)
"Alter the ‚Äòname‚Äô field of an ‚Äòelement‚Äô value.

Account for relationship between ‚Äòname‚Äô component
and ‚Äòequations‚Äô component."

  (let* ((e‚Ä≤ (copy-element e))
         (n‚Ä≤ (funcall f (element-name e‚Ä≤))))
    (setf (element-name e‚Ä≤) n‚Ä≤)
    (setf (element-equations e‚Ä≤) (--map (s-join " " (cons n‚Ä≤ (cdr (s-split " " it)))) (element-equations e‚Ä≤)))
    e‚Ä≤))
#+END_SRC

Now a method for replacing textual strings within an element structure.
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defun element-contains (needle e)
  "Check whether string NEEDLE occurs anywhere in element E."
    (--any it
           (-concat (loop for place in '(element-qualifier element-name element-type)
                         collect (eval `(when (,place e) (string-match-p (format "\\b%s\\b" (regexp-quote needle)) (,place e)))))
                   (loop for eq in (element-equations e)
                         collect (string-match-p (format "\\b%s\\b" (regexp-quote needle))
                                 (s-join "=" (cdr (s-split "=" eq)))))))) ;; Ensure we do not consider the LHS of an equation.
#+END_SRC
:Test:
  (element-contains "a" (car (parse-elements '("A : Set"))))
‚áí nil
:End:

# MA: TODO: Clean this up.
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(cl-defun map-element (f e &key excluding)
  "Apply string function F to every non-nil component of an element E.

Element name is untouched; as all all items mentioned in EXCLUDING
---which may be a sublist of '(type qualifier equations)."
  (-let [e‚Ä≤ (copy-element e)]

    (and (element-qualifier e‚Ä≤) (not (member 'qualifier excluding))
      (setf (element-qualifier e‚Ä≤) (funcall f (element-qualifier e‚Ä≤))))

    (and (element-type e‚Ä≤) (not (member 'type excluding))
      (setf (element-type e‚Ä≤) (funcall f (element-type e‚Ä≤))))

    (and (not (member 'equations excluding))
         (setf (element-equations e‚Ä≤) (mapcar f (element-equations e‚Ä≤))))

    ;; return value
    e‚Ä≤))

(cl-defun replace-in-name (old new name &key (is-regexp))
  "Given an identifier NAME, perform the rewrite OLD ‚Ü¶ NEW.

There is support for Agda positional markers: In a secondary phase,
underscores are ignored, replaced with the empty string; since
they are used to indicate argument positions in Agda syntax.

E.g., (equal \"*-comm\" (replace-in-name \"_+_\"  \"_*_\" \"+-comm\"))

Remove adjacent underscores -- which are ill-formed Agda syntax.

By default, we regexp-quote the given ‚Äòold‚Äô, enable IS-REGEXP to avoid this.
"
      (let ((old‚Ä≤ (funcall (if is-regexp #'identity #'regexp-quote) old))
            (old_ (funcall (if is-regexp #'identity #'regexp-quote) (s-replace "_" "" old)))
            (new_ (s-replace "_" "" new))
            (nom  name))

       (loop for (this . that) in (cons (cons old‚Ä≤ new) (if (s-contains? "_" old) (list (cons old_ new_))))
       do (setq nom
        (cond
         ;; If nom ‚âà old, then simply replace it with that.
         ((string-equal old nom) that)

         ;; Replace unicode symbol ‚Äòthis‚Äô with the provided ‚Äòthat‚Äô.
         ((not (string-match-p "[[:alnum:]]" this)) (replace-regexp-in-string this that nom t))

         ;; Else we have ‚Äòthis‚Äô is a letter[s] or number[s], so we make
         ;; the replacements provided it's NOT next to an alphanumeric
         ;; character, but instead near something like _,/,-,‚Ä¶  Two
         ;; cases to consider: Either non-alphanumeric neighbour is
         ;; after ‚Äòthis‚Äô or before it, within ‚Äònom‚Äô.
         ((string-match-p (format "%s\\([^[:alnum:]]\\)" this) nom)
          (replace-regexp-in-string (format "%s\\([^[:alnum:]]\\)" this) (format  "%s\\1" that) nom t))
         ((string-match-p (format "\\([^[:alnum:]]\\)%s" this) nom)
          (replace-regexp-in-string (format "\\([^[:alnum:]]\\)%s" this) (format  "\\1%s" that) nom t))
         ;; Else leave nom as is.
         (t nom))))

       ;; Remove adjacent underscores -- which are ill-formed Agda syntax.
       (while (s-contains? "__" nom) (setq nom (s-replace "__" "_" nom)))

      nom))

;; Tests for replace-in-name
;;
(loop for (test old new expected) in (-partition 4 '(;; Wholeshalre rename
                                                     "œÑ" "œÑ" "ŒΩ" "ŒΩ"

                                                     ;; Renaming part of an identifier
                                                     "+-comm" "_+_" "_*_" "*-comm"

                                                     ;; Avoiding adjacent underscores -- which are ill-formed Agda
                                                     "op_fix_point" "op" "‚óá_" "‚óá_fix_point"
                                               ))
      for actual = (replace-in-name old new test)
      unless (equal expected actual)
      do (message-box "\t%s\n‚â†\t%s\n\n%s" expected actual "replace-in-name"))

(cl-defun element-replace (old new e &key (support-mixfix-names nil) (avoid-altering-names nil))
  "Replace every occurance of word OLD by string NEW in element E.

By default, we do not AVOID-ALTERING-NAMES, thereby enhancing
‚ÄúOLD ‚Ü¶ NEW‚Äù rewrite so that if OLD occurs as a subexpression in
the name of the given element E. Example use: We have a name
‚Äú*-comm‚Äù and make the rewrite ‚Äú_*_ ‚Ü¶ _+_‚Äù, then we have the
desirable name ‚Äú+-comm‚Äù.

We account for ‚ÄúOLD = [qualifier.]OLD‚Äù translations, as in
function ELEMENT-RETRACT, by transforming them into ‚ÄúOLD =
[qualifier.]NEW‚Äù.

There is little support for mixfix names, where terms such as
‚Äúx + y ‚Ü¶ x * y‚Äù when the replacement of ‚Äú_+_‚Äù by ‚Äú_*_‚Äù is invoked."

  (let* ((e‚Ä≤    (copy-element e))
         (old‚Ä≤  (s-replace "_" " " old))
         ;; regexp word marker ;; Do we have a word, or something strange like _+_ ?
         (word (if (or (= (length old‚Ä≤) 1) (and (string-match-p "[[:alnum:]]+" old‚Ä≤) (not (s-contains? "_" old)))) "\\b" ""))
         (temp  (format "%s%s" new (gensym)))
         (new‚Ä≤  (s-replace "_" " " new))
         (offend  (format "%s = \\(.+\\)?%s" (regexp-quote temp) (regexp-quote temp))) ;; ‚Äúl = [qualifier.]l‚Äù
         (correct (format "%s = \\1%s" old new)))     ;; ‚Äú\\1‚Äù refers to the matched qualifier.

    ;; (setq e‚Ä≤ (map-equations (Œª eqs ‚Üí (--map (replace-in-name old new it :is-regexp nil) eqs)) e‚Ä≤))

    ;; Also account for ‚Äúl = l‚Äù translations; c.f., element-retract.
    ;; E.g., with ‚Äúold, new ‚âî y, x‚Äù we have ‚Äúlet x = y in f x ‚üø let x
    ;; = temp in f x ‚üø let x = x in f x‚Äù Without the ‚Äòtemp‚Äô switch, we
    ;; would have had: ‚Äúlet x = y in f x ‚üø let x = x in f x ‚üø let y =
    ;; x in f x‚Äù, which may be fine in a let-clause, but ruins a
    ;; record declaration having ‚Äúx‚Äù as a field.
    (loop for (this . that) in (-concat `((,(regexp-quote old)  . ,temp)  (,offend . ,correct) (,(regexp-quote temp) . ,new))
                                        (when (s-contains-p "_" old) (list (cons (regexp-quote old‚Ä≤) new‚Ä≤))))
        do

        ; (message-box "A :: %s" (show-element e‚Ä≤))

          (setq e‚Ä≤ (map-element (Œª plc ‚Üí (replace-regexp-in-string (concat word this word) that plc (not (s-blank? word)))) e‚Ä≤
                 ;; :excluding (and (= 1 (length (element-equations e‚Ä≤))) (s-contains? "record" (car (element-equations e‚Ä≤))) (list 'equations))
      :excluding (and (element-equations e‚Ä≤) (s-contains? "record" (car (element-equations e‚Ä≤))) (list 'equations)))))

        ; (message-box "B :: %s" (show-element e‚Ä≤))

    ;; Also account for when we want, say, ‚Äú_+_ ‚Ü¶ _*_‚Äù but an
          ;; equation mentions ‚Äú+-assoc‚Äù, which is NOT one of the
          ;; element names and so wont be propogated here, whence we
          ;; want to explicitly rewrite that to ‚Äú*-assoc‚Äù.
    (setq e‚Ä≤ (map-equations-rhs (Œª r ‚Üí (replace-in-name (concat word (regexp-quote old) word) new r :is-regexp t)) e‚Ä≤))

        ; (message-box "C :: %s" (show-element e‚Ä≤))

    (unless avoid-altering-names
      (setq e‚Ä≤ (map-name (Œª n ‚Üí (replace-in-name old new n)) e‚Ä≤)))

        ; (message-box "D :: %s" (show-element e‚Ä≤))

    ;; return value
    e‚Ä≤))

;; test
;; (length (element-equations (car (parse-elements '("toMagma-via-AdditiveMagma       : let View X = X in View Magma" "toMagma-via-AdditiveMagma = record {U = U;_Src_ = _Tgt_}")))))

(cl-defun map-equations-rhs (f e)
  "‚Äúlhs = record {l·µ¢ = r·µ¢}‚Äù   ‚Ü¶  ‚Äúlhs = record {l·µ¢ = f r·µ¢}‚Äù

If the element E's equations do not mention the word ‚Äúrecord‚Äù, return them as is.
"
  (-let [e‚Ä≤ (copy-element e)]
    (when (element-contains "record" e)
      (setf (element-equations e‚Ä≤)
            (loop for eq in (element-equations e‚Ä≤)
                  ;; eq in '("l = record {}") ;in (element-equations e‚Ä≤)
                  when (s-contains? "record" eq)
                  for ‚âà‚âà = (s-split "=" eq)
                ;; first two items are ‚Äúlhs record l‚ÇÅ‚Äù, so ignore them for
                  ;; now since rewriting there would be erroneous.
                  for ‚®æ‚®æ = (mapcar (Œª l-r ‚Üí (s-split ";" l-r)) (cddr ‚âà‚âà))
                  collect   (s-join "="
                                    (-concat (-take 2 ‚âà‚âà)
                                             (--map (s-join ";" (cons (funcall f (car it)) (cdr it))) ‚®æ‚®æ))))))

    ;; return value
    e‚Ä≤))
#+END_SRC
Tests:
#+BEGIN_SRC emacs-lisp :tangle no
;; (element-replace "R" "_‚â§_" (car (parse-elements '("R-reflexive : ‚àÄ (x : U)  ‚Üí  R x x" "R-reflexive = record {R = R}"))))
;;
;; (map-equations (Œª eqs ‚Üí (--map (replace-in-name (format "= %s.*" (regexp-quote "_^_")) "= ‚äï\\1" it :is-regexp t) eqs))
;;  (element-replace "_^_" "_‚äï_" (car (parse-elements '("go : That" "go = { ^ ; ^-assoc = ^-assoc}")))))

;; Tests for element-replace
;;
; Notice that the final braces are within F!
(loop for (test old new expected) in (-drop 1 (-partition 4 '("œÑ : Set" "œÑ" "ŒΩ" "ŒΩ : Set"

                                                     ;; Rewrites propogate into identifiers, when reasonable.
                                                     "*-comm : x * y ‚â° y * x"
                                                     "_*_" "_+_"
                                                     "+-comm : x + y ‚â° y + x"

                                                     "inv : InverseOp"
                                                     "inv" "neg"
                                                     "neg : InverseOp"

                                                     "leftAbsorb-g1234567        : ‚àÄ (x y : U) ‚Üí x g1234567 (x + y) ‚â° x"
                                                     "_g1234567_" "_‚Üì_"
                                                     "leftAbsorb-‚Üì : ‚àÄ (x y : U) ‚Üí x ‚Üì (x + y) ‚â° x"

                                                     ;; No rewriting on the RHS of record value clauses
                                                     "forget : Magma ‚Ä¢ forget = record {U = ‚Ñï; op = _+_}"
                                                     "op" "no!"
                                                     "forget : Magma ; forget = record {U = ‚Ñï; op = _+_}"

                                                     ;; Maintaining operands.
                                                     "forget : Magma ‚Ä¢ forget = record {U = ‚Ñï; op = op}"
                                                     "op" "_+_"
                                                     "forget : Magma ; forget = record {U = ‚Ñï; op = _+_}"

                                                     ;; Only RHS affected in toX translations.
                                                     "toX : let View X = X in View toX ‚Ä¢ toX = record {U = U;_*_ = _*_;e = e;S = S;_‚ü´_ = _‚ü´_;identity_‚ü´_e = identity_‚ü´_e}"
                                                     "e" "ùüô"
                                                     "toX : let View X = X in View toX ; toX = record {U = U;_*_ = _*_;e = ùüô;S = S;_‚ü´_ = _‚ü´_;identity_‚ü´_e = identity_‚ü´_ùüô}"

                                                     "id : X ‚Üí X ‚Ä¢ id = Œª x ‚Üí x"
                                                     "X" "U"
                                                     "id : U ‚Üí U ; id = Œª U ‚Üí U" ;; .... ekk!; also arguments must be on the RHS via Œª.
                                               )))
      for actual = (s-collapse-whitespace (show-element (element-replace old new (car (parse-elements (mapcar #'s-trim (s-split "‚Ä¢" test)))))))
      unless (equal expected actual)
      do (message-box "\t%s\n‚â†\t%s\n\n%s" expected actual "element-replace"))

;; Tests for map-equations-rhs
;;
; Notice that the final braces are within F!
(loop for (test . expected) in (-partition 2 '("l = record {}" "l = record {}"                    ;; zero assignments
                                               "l = record {a = a}" "l = record {a = F[ a}]"      ;; one assignment
                                               "l = record {a = a; b = b; c = c; d = d}"          ;; four assignments
                                               "l = record {a = F[ a]; b = F[ b]; c = F[ c]; d = F[ d}]"

                                               "l x = x" "l x = x" ;; Not even a record assignment
                                               ))
      for actual = (element-equations (map-equations-rhs (Œª x ‚Üí (format " F[%s]" x)) (car (parse-elements (list "l : œÑ" test)))))
      unless (equal expected actual)
      do (message-box "map-equations-rhs ‚à∑ %s ‚â† %s" expected actual))
#+END_SRC
:Test:
#+BEGIN_SRC emacs-lisp :tangle no
(element-replace "e" "ùüò" (car (parse-elements '("go : These" "go = {e = e ; e2 = e2}"))))

(equal "*-comm" (replace-in-name "_+_"  "_*_" "+-comm"))
(replace-in-name "e"  "ùüò" "e2")

;; Identity -- OH NO! ‚Äú+‚Äù is also considered a qualifier! This is due to parse elements!
(element-replace "_+_" "_+_" (car (parse-elements '("_+_ : U ‚Üí U ‚Üí U" "_+_ = let _^_ = ^-comm in ‚ãØ + ‚ãØ ^ ‚ãØ"))))

;; Another operation
(element-replace "_+_" "_*_" (car (parse-elements '("_+_ : U ‚Üí U ‚Üí U" "_+_ = let _^_ = ^-comm in ‚ãØ + ‚ãØ ^ ‚ãØ"))))

;; Rewrite to self, but with decoration.
(element-replace "_+_" "_+'_" (car (parse-elements '("_+_ : U ‚Üí U ‚Üí U" "_+_ = let _^_ = ^-comm in ‚ãØ + ‚ãØ ^ ‚ãØ"))))

;; Single letter
(element-replace "R" "_‚â§_" (car (parse-elements '("r-R-reflexive : ‚àÄ (x : U)  ‚Üí  R x x" "r-R-reflexive = record{l = r}"))))

;; In equations?
(element-replace "_^_" "_‚äï_" (car (parse-elements '("_+_ : U ‚Üí U ‚Üí U" "_+_ = let _^_ = ^-comm in ‚ãØ + ‚ãØ * ‚ãØ"))))

;; In a type?
(element-replace "_*_" "_+_" (car (parse-elements '("*-comm : ‚àÄ x y ‚Üí x * y ‚â° y * x"))))

;; In a type? Not altering part of names.
(element-replace "inv" "neg" (car (parse-elements '("inv : Id Involutionary"))))


(replace-regexp-in-string (format "%s\\([^[:alnum:]]\\)" "R") (format  "%s\\1" "‚â§") "R-reflexive : ‚àÄ (x : U)  ‚Üí  R x x")

(element-replace "_¬∑_" "_+_" (car (parse-elements '("toMonoidR       : let View X = X in View MonoidR" "toMonoidR = record {Carrier = Carrier;_¬∑_ = _¬∑_;assoc = assoc;ùïÄ = ùïÄ;leftId = leftId;rightId = rightId}"))))

(element-replace "_¬∑_" "_+_" (car (parse-elements '("here : Set" "here = let R = ;_¬∑_ = _¬∑_; in R._¬∑_ f"))))

(element-replace "_¬∑_" "new" (element-replace "_¬∑_" "_+_" (car (parse-elements '("here : let R = { _¬∑_ = _¬∑_ } in R._¬∑_ f")))))






(equal (element-replace "_G_" "H" (make-element :name "A" :type "G and Gish"))
  (make-element :name "A" :type "H and Gish"))

(-let [e (car (parse-elements '("toMonoidR : let View X = X in View MonoidR"
                                "toMonoidR = record {Carrier = Carrier;_+_ = _+_;assoc = assoc;ùïÄ = ùïÄ;leftId = leftId;rightId = rightId}")))]
  (element-contains "_+_ = _+_" e))


(-let [e (car (parse-elements '("toMonoidR : let View X = X in View MonoidR"
                                "toMonoidR = record {Carrier = Carrier;_+_ = _+_; +-assoc = +-assoc}")))]
  (element-replace "_+_"  "_*_" e))

(element-replace "_¬∑_ = _¬∑_" "_¬∑_ = _+_"

                 :support-mixfix-names nil)
#+END_SRC

:End:

Given a typed name, return the name.
# (pf--declare-type parse-name : string string)
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defun parse-name (element)
  "Given an string representation of an ELEMENT, yield the ‚Äòname‚Äô component.

The shape of the input may be ‚Äúqualifier lhs ~ rhs‚Äù where ‚Äò~‚Äô is either ‚Äò:‚Äô
or ‚Äò=‚Äô.  The qualifier is a ‚Äòspecial‚Äô word: field, private."
  (let ((lhs (s-split " " (car (s-split " = " (car (s-split " : " element)))))))
    (if (and (< 1 (length lhs)) (pf--special (nth 0 lhs)))
        (cadr lhs)
      (car lhs))))
#+END_SRC

:Example:
#+BEGIN_SRC emacs-lisp :tangle no :results replace
(mapcar #'parse-name '("A : Set" "private B : Set" "C : ‚Ñï ‚Üí Set" "B = A" "C zero = A" "C (suc n) = A" "D : Set" "E : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)))" "ùíÆ‚ÑØùìâ = Set"))
#+END_SRC

#+RESULTS:
| A | B | C | B | C | C | D | E | ùíÆ‚ÑØùìâ |
:End:

Parsing a list of interleaved elements in concrete syntax.

#+name: parse-elements
- Given a list of PackageFormer ELEMENTS, as strings, parse them into the
  ‚Äòelement‚Äô datatype.  Declarations and equations may be interspersed, as along
  as equations of names follow their declarations.

- The order is preserved in-case there are declarations that make use of
  definitions.

- Types must always be supplied ---in general, type inference is
  undecidable in DTLs.

# (pf--declare-type parse-elements : (list-of string) (list-of element))
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defun parse-elements (elements)
  "Parse string representation of elements into the ‚Äòelement‚Äô record type.
<<docs('parse-elements)>>"
  (-let [es (mapcar #'list elements)]
    ;; Maintain a list of related items.
    (loop for i from 0
          for e in es
          for name = (parse-name (car e))
          do (loop for j from 0 to (1- i)
                   do
                   ;; If the name of ‚Äòe‚Äô occurs in the prefix,
                   ;; then move ‚Äòe‚Äô to the location in the prefix,
                   ;; and zero-out the current location.
                   (when (equal name (parse-name (or (car (nth j es)) "")))
                     ;; Use an empty string in-case the location is nil.
                     (setf (nth j es) (append (nth j es) e))
                     (setf (nth i es) nil))))

    ;; Drop the nils.
    (setq es (--reject (not it) es))

    ;; We now have a list of related items,
    ;; with the car of each being a qualified typed-name
    ;; and the cdr of each being a list of equational clauses
    ;; associated with that name.
    (loop for e in es
          for œÑ    = (s-split " : " (car e))
          for nom  = (parse-name (car œÑ))
          ;; In case there is no qualifier; regexp-quote to avoid regexp ops in a name.
          for qual = (-let [pts (s-split (regexp-quote nom) (car œÑ))] (when (= 2 (length pts)) (car pts)))
          for qual = (car (s-split nom (car œÑ)))
          for _    = (pf--ensure (cdr œÑ)
                                 (format "Type not supplied for %s!" nom)
                                 (s-join "\n\t\t" (-take 5 elements))
                                 "‚ãØ Add a type!")
          for ty   = (s-join " : " (cdr œÑ))
          collect
          (make-element :qualifier (unless (s-blank? qual) qual)
                        :name nom
                        :type ty
                        :equations (cdr e)))))
#+END_SRC

Notice that the equations do not necessarily immediately follow their associated declarations.
:Example:
#+BEGIN_SRC emacs-lisp :tangle no :results replace
(mapcar #'list (parse-elements
'("A : Set" "private B : Set" "C : ‚Ñï ‚Üí Set" "B = A" "C zero = A" "C (suc n) = A" "D : Set" "E : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)))")))
#+END_SRC

#+RESULTS:
| #s(element nil A Set nil)                                                         |
| #s(element private  B Set (B = A))                                                |
| #s(element nil C ‚Ñï ‚Üí Set (C zero = A C (suc n) = A))                              |
| #s(element nil D Set nil)                                                         |
| #s(element nil E {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã))) nil) |
:End:

:Test:
#+BEGIN_SRC emacs-lisp :tangle no
(ert-deftest tn ()
  ;; Superflous space
  (should (equal "name" (get-name "name   : type")))
  ;; Multiple ‚Äú:‚Äù.
  (should (equal "‚àÄ {X : Obj ùíû} ‚Üí (X ‚ü∂ X)"
         (get-type"Id : ‚àÄ {X : Obj ùíû} ‚Üí (X ‚ü∂ X)") )))
#+END_SRC
:End:

** Well-formed checks ---Error reporting
   :PROPERTIES:
   :CUSTOM_ID: Well-formed-checks----Error-reporting
   :END:
What is the above ‚Äúfancy cons‚Äù we mentioned? Here it is.

#+name: ensure
- Ensure CONDITION is true and defined, otherwise emit MESSAGE
  and indicate the offending CONTEXT.
  If there are any SUGGESTIONS to the user, then we show those too.

- If CONDITION is defined and non-nil, whence true, we return it.

#+BEGIN_SRC emacs-lisp  :tangle agda-next-700-module-systems.el
(defmacro  -ensure (condition message context &rest suggestions)
  "Ensure provided CONDITION is true, otherwise report an error.
<<docs('ensure)>>"
  `(let* ((·Éö\(‡≤†Áõä‡≤†\)·Éö
           (format "700: %s\n\n\t‚á®\t%s%s%s" ,message ,context
                   (if (quote ,suggestions) "\n" "")
                   (s-join "\n" (--map (format "\t‚á®\t%s" it)
                                       (quote ,suggestions)))))
          ;; Try to evaluate the condition.
          (res (condition-case nil ,condition (error ·Éö\(‡≤†Áõä‡≤†\)·Éö))))

     ;; If we've made it here, then the condition is defined.
     ;; It remains to check that it's true.
     (or res (error ·Éö\(‡≤†Áõä‡≤†\)·Éö))))
#+END_SRC

#+name: wf
- This operation checks that the VALUE of KEY
  is well-formed according to 700-specifications ---which are stated
  explicitly within this method--- and if it is well-formed we
  return the VALUE /interpreted/ along with the KEY.

- When the value is not well-formed, we use the provided CONTEXT
  in an error message.  No error is reported if VALUE is an ARGument, ARGS,
  of a variational begin declared.

# ;;  -declare-type cannot yet accomodate optional arguments
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defun -wf (key value &optional context args)
  "Report an error unless provided key-value are well-formed.
<<docs('wf)>>"
  (let* ((case
            (pcase key
              (:kind `(,(-contains? '(record data module PackageFormer) value)
                       This kind ‚Äú ,value ‚Äù is not support by Agda!
                       Valid kinds: record‚®æ data‚®æ module‚®æ PackageFormer!))
              (:waist `(,(numberp value)
                        The waist should be a number‚®æ which ‚Äú ,value ‚Äù is not!))
              (:level `(,(-contains? '(inc dec none) value)
                        The ‚Äúlevel‚Äù must be ‚Äúinc‚Äù or ‚Äúdec‚Äù or ‚Äúnone‚Äù‚®æ
                        which ‚Äú ,value ‚Äù is not!))))
        (condition (car case))
        (message   (mapconcat #'prin1-to-string (cdr case) " ")))

    ;; TODO: Acount for alter-elements well-formedness?
    ;; (:alter-elements (functionp value)
    ;; (format "Componenet alter-elements should be a function;
    ;; which ‚Äú%s‚Äù is not." value))

    (when case
      ( -ensure (or condition (-contains? args value)) message context))

    ;; Return the key-value as a pair for further processing.
    ;; :kind and :level values are symbols and so cannot be evaluated furthur.
    (cons key
          (if (or (-contains? args value) (-contains? '(:kind :level) key))
              value
            (eval value)))))
#+END_SRC

** Package Former Parsing and Pretty Printing
   :PROPERTIES:
   :CUSTOM_ID: Package-Former-Parsing-and-Pretty-Printing
   :END:

With this in hand, let's produce a robust parser.

#+name: load-package-former
- The input LINES must be a list of lines forming a full
  PackageFormer declaration; e.g., obtained by calling ‚Äòpf--get-children‚Äô.

- It is parsed and a ‚Äòpackage-former‚Äô value is returned.

- Whitespace is stripped off of items.

- Docstrings are ignored.

# ; (pf--declare-type pf--load-package-former : (list-of string) package-former)
# (pf--declare-type pf--load-package-former : t t)
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defun pf--load-package-former (lines)
  "Load a string representation of a ‚Äòpackage-former‚Äô into our global list.
<<docs('load-package-former)>>"
  (when (not lines)
      (error "PF--LOAD-PACKAGE-FORMER: Error: Input must be non-empty list"))

  (let* (pf
         (header (or (car lines) ""))
         (name (pf--substring-delimited-here "PackageFormer $here :" header))
         (level (pf--substring-delimited-here "Set $here where" header)))

    (when pf-highlighting
      (mapc (Œª it ‚Üí (highlight-phrase (s-trim it) 'hi-yellow)) (cdr lines)))

    (setq pf
          (make-pf--package-former
           :kind                     "PackageFormer"
           :name                     name
           ;; ‚Äòlevel‚Äô may be ‚Äú‚Äù, that's okay.
           ;; It may be a subscript or implicitly zero, so no space after ‚ÄòSet‚Äô.
           :level                    level
           :waist                    0
           ;; TODO: Currently no parameter support for arbitrary PackageFormers.
           :indentation              (max 4 (pf--get-indentation (cadr lines))) ;; 4 spaces is the minimum
           :elements  (parse-elements (--remove (s-starts-with? "-- " it)
                                                (--map (s-trim it)
                                                       (cdr lines))))))

      (push (cons name pf) pf--package-formers)

      ;; return value
      pf))
#+END_SRC

Let's try this out.
#+BEGIN_SRC emacs-lisp :exports both :results table replace :var test=test
;; (equal 4 (pf--package-former-indentation (pf--load-package-former (cadr (pf--get-children "PackageFormer" "PackageFormer Empty : Set where")))))

(pf--load-package-former (cadr (pf--get-children "PackageFormer" test)))
#+END_SRC

#+RESULTS:
| #s(package-former nil PackageFormer M-Set ‚ÇÅ 0 nil 3 (#s(element nil Scalar Set nil) #s(element nil Vector Set nil) #s(element nil _¬∑_ Scalar ‚Üí Vector ‚Üí Vector nil) #s(element nil ùüô Scalar nil) #s(element nil _√ó_ Scalar ‚Üí Scalar ‚Üí Scalar nil) #s(element nil leftId {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã nil) #s(element nil assoc {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã) nil))) |

# (pf--declare-type special : string t)
Conversely, let's have a pretty printer.

#+name: special
- Special elements F, for whatever reason are exceptional, and so
  are maked as singleton lists and their indentation is lessened.
  That is, these denote sibling fields rather than more children.

- Special elements include: field, private.

- See ‚Äòshow-package-former‚Äô for their use and how their printed.

#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defun pf--special (f)
  "Test whether an element F is special or not.
<<docs('special)>>"
  (--any? (s-contains? it f) '("field" "private" "open" "top-level" "sibling")))
#+END_SRC
A ‚Äúsibling‚Äù item has no indentation.

# (pf--declare-type show-element (:omit-qualifier t) element string)
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(cl-defun show-element (e &optional omit-qualifier)
  "Render an ‚Äòelement‚Äô value E in the form:

   qualifier name : type ; equational-clause‚ÇÄ ; ‚ãØ ; equational-clause‚Çô

Optional OMIT-QUALIFIER is useful for when
elements are in a parameter position."
  (s-join " ;\t"
          (cons
           (format "%s%s\t\t: %s"
                   (-let [it (element-qualifier e)]
                     (if (or (not it) omit-qualifier) "" (format "%s " it)))
                   (element-name e)
                   (element-type e))
           (element-equations e))))
#+END_SRC

# (pf--declare-type pf--show-package-former : pf--package-former string)
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(cl-defun pf--show-package-former (pf)
  "Pretty print a package-former PF record value."
  (pf--open-pf pf
    (s-join "\n"
      (-cons*

       ;; The documentation string
       (when docstring (format "{- %s -}" docstring))

       ;; The schema declaration
       (s-collapse-whitespace
        (s-join " "
                (list kind
                      name
                      (s-join " "
                              (--map (concat "("
                                             (show-element it :omit-qualifier)
                                             ")")
                                     parameters))
                      (unless (equal level 'none) (concat ": Set" level))
                      "where")))

       ;; The elements of a PackageFormer
       (thread-last fields
         (--map (format "%s%s"
                        (s-repeat indentation " ")
                        (show-element it))))))))
#+END_SRC

Let's test it out by /introducing/ a whole new local variable and trying
to include the ~field~ Agda keyword.
#+BEGIN_SRC emacs-lisp :exports both :results replace :wrap "src results-agda" :var test=test
(let* ((raw (cadr (pf--get-children "PackageFormer" test)))
       (pf (pf--load-package-former raw))
       (waist 2))
  (setf (pf--package-former-waist pf) waist)

  ;; mark all items as "fields"
  (--map (setf (element-qualifier it) "field") (pf--package-former-elements pf))

  ;; inject new items at the waist line
  (loop for new in (parse-elements '("private n : ‚Ñï" "n = 3" "ùíÆ‚ÑØùìâ : Set‚ÇÅ" "ùíÆ‚ÑØùìâ = Set"))
        do (push new
        (cdr (nthcdr (1- waist) (pf--package-former-elements pf)))))

   (pf--show-package-former pf))
#+END_SRC

#+RESULTS:
#+begin_src results-agda

PackageFormer M-Set (Scalar : Set) (Vector : Set) : Set‚ÇÅ where
   ùíÆ‚ÑØùìâ		: Set‚ÇÅ ;	ùíÆ‚ÑØùìâ = Set
   private  n		: ‚Ñï ;	n = 3
   field _¬∑_		: Scalar ‚Üí Vector ‚Üí Vector
   field ùüô		: Scalar
   field _√ó_		: Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId		: {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc		: {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
#+end_src

Notice that the $ùíÆ‚ÑØùìâ = Set$ alias is a top-level item, with respect to the current PackageFormer.

We can phrase an approximation of the opinion that parsing and showing
should be inverses.
#+BEGIN_SRC emacs-lisp :exports both :results table replace :var test=test
(-let [pf (cadr (pf--get-children "PackageFormer" test))]
  (should (equal (s-collapse-whitespace (concat "\n" (s-join "\n" pf)))
     (s-collapse-whitespace (pf--show-package-former (pf--load-package-former pf))))))
#+END_SRC

#+RESULTS:
| t |

#+begin_center
( /In Lisp, ~t~ denotes ‚Äútrue‚Äù!/ )
#+end_center

{{{fold(Unit Tests)}}}
#+BEGIN_SRC emacs-lisp :tangle no
(ert-deftest pf-parse ()

  ;; Error on empty list of lines.
   (should-error (pf--load-package-former nil))

   ;; No crash on empty line.
   (should (pf--load-package-former (list "")))

   ;; No crash on PackageFormer with no elements.
   (should (pf--load-package-former (list "PackageFormer PF : Set ‚Ñì where")))

   ;; Levels
   (should (equal "‚Ñì" (pf--package-former-level (pf--load-package-former (list "PackageFormer PF : Set ‚Ñì where")))))
   ;;
   (should (equal "" (pf--package-former-level (pf--load-package-former (list "PackageFormer PF : Set  where")))))
   ;;
   (should (equal "‚ÇÉ" (pf--package-former-level (pf--load-package-former (list "PackageFormer PF : Set‚ÇÉ where")))))
   ;;
   (should (equal "(Level.suc ‚Ñì)" (pf--package-former-level (pf--load-package-former (list "PackageFormer PF : Set (Level.suc ‚Ñì) where")))))

   ;; Full parsing.
   (-let [pf (pf--load-package-former (cadr (pf--get-children "PackageFormer" test)))]
     (equal (format "%s" pf)
            "#s(pf--package-former nil PackageFormer M-Set ‚ÇÅ 0 nil 3 (Scalar  : Set Vector  : Set _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector ùüô       : Scalar _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)))"))

  (-let [pf (cadr (pf--get-children "PackageFormer" test))]
    (should (equal (s-concat "\n" (s-join "\n" pf))
                   (pf--show-package-former (pf--load-package-former pf)))))

)
#+END_SRC
{{{end-fold}}}

* Variational Language
  :PROPERTIES:
  :CUSTOM_ID: Variational-Language
  :END:

  A variational has the syntactic form specfied by
#+BEGIN_SRC text
        ùìã   ::=  identifier (identifier)* = ùìãùí∏
        ùìãùí∏  ::= [identifier] (:key value)* (‚ü¥ ùìãùí∏)*

        identifier ‚âà key ‚âà value ‚âà string of text
#+END_SRC

  With the intention that ~l a = r~ is a list of key-value pairs
  determined from the right-hand side where the arguments ~a~
  are to be considered place-holders. Whenever one mentions free variables,
  or terms, one actually speaks of functions. Hence, let's reify these as functions.

  Let's keep track of the user defined variationals, so that we can display them to the
  user via menus, as well as highlight them, and attach tooltips to them.
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defvar pf--variationals nil
  "Association list of Agda-user defined variational operators.")
#+END_SRC

Let's be somewhat agonstic regardiing the variational composition operator;
users are welcome to use any other symbol.
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defvar pf-variational-composition-operator "‚ü¥"
  "The operator that composes varitionals.")
#+END_SRC

** Well-formed checks ---Error reporting
   :PROPERTIES:
   :CUSTOM_ID: Well-formed-checks----Error-reporting
   :END:
What is the above ‚Äúfancy cons‚Äù we mentioned? Here it is.

#+name: ensure
- Ensure CONDITION is true and defined, otherwise emit MESSAGE
  and indicate the offending CONTEXT.
  If there are any SUGGESTIONS to the user, then we show those too.

- If CONDITION is defined and non-nil, whence true, we return it.

#+BEGIN_SRC emacs-lisp  :tangle agda-next-700-module-systems.el
(defmacro pf--ensure (condition message context &rest suggestions)
  "Ensure provided CONDITION is true, otherwise report an error.
<<docs('ensure)>>"
  `(let* ((·Éö\(‡≤†Áõä‡≤†\)·Éö
           (format "700: %s\n\n\t‚á®\t%s%s%s" ,message ,context
                   (if (quote ,suggestions) "\n" "")
                   (s-join "\n" (--map (format "\t‚á®\t%s" it)
                                       (quote ,suggestions)))))
          ;; Try to evaluate the condition.
          (res (condition-case nil ,condition (error ·Éö\(‡≤†Áõä‡≤†\)·Éö))))

     ;; If we've made it here, then the condition is defined.
     ;; It remains to check that it's true.
     (or res (error ·Éö\(‡≤†Áõä‡≤†\)·Éö))))
#+END_SRC

#+name: wf
- This operation checks that the VALUE of KEY
  is well-formed according to 700-specifications ---which are stated
  explicitly within this method--- and if it is well-formed we
  return the VALUE /interpreted/ along with the KEY.

- When the value is not well-formed, we use the provided CONTEXT
  in an error message.  No error is reported if VALUE is an ARGument, ARGS,
  of a variational begin declared.

# ;; pf--declare-type cannot yet accomodate optional arguments
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(cl-defun pf--wf (key value &optional context args)
  "Report an error unless provided key-value are well-formed.
<<docs('wf)>>"
  (let* ((case
            (pcase key
              (:kind `(,(-contains? '(record data module PackageFormer) value)
                       This kind ‚Äú ,value ‚Äù is not support by Agda!
                       Valid kinds: record‚®æ data‚®æ module‚®æ PackageFormer!))
              (:waist `(,(numberp value)
                        The waist should be a number‚®æ which ‚Äú ,value ‚Äù is not!))
              (:level `(,(-contains? '(inc dec none) value)
                        The ‚Äúlevel‚Äù must be ‚Äúinc‚Äù or ‚Äúdec‚Äù or ‚Äúnone‚Äù‚®æ
                        which ‚Äú ,value ‚Äù is not!))))
        (condition (car case))
        (message   (mapconcat #'prin1-to-string (cdr case) " ")))

    ;; TODO: Acount for alter-elements well-formedness?
    ;; (:alter-elements (functionp value)
    ;; (format "Componenet alter-elements should be a function;
    ;; which ‚Äú%s‚Äù is not." value))

    (when case
      (pf--ensure (or condition (-contains? args value)) message context))

    ;; Return the key-value as a pair for further processing.
    ;; :kind and :level values are symbols and so cannot be evaluated furthur.
    (cons key
          (if (or (-contains? args value) (-contains? '(:kind :level) key))
              value
            (eval value)))))
#+END_SRC

** ùí±ùí∏,  ùí±-, and ùí±
   :PROPERTIES:
   :CUSTOM_ID: ùí±ùí∏---ùí±---and-ùí±
   :END:
   :PROPERTIES:

   :END:
  Variationals are refieid as functions with the prefix ùí±-;
  doing otherwise may override existing utilities in Emacs
  ---for example, ‚Äòrecord‚Äô is a useful name for a variational
  but is a super important utility function in Emacs.
  The apporach we take is to allow users to write ‚Äòrecord‚Äô
  but the implementation will refer to it with a prefix.

Parsing variational clauses is then straightforward:
#+BEGIN_SRC emacs-lisp :tangle no
(when nil *parent-context* nil
  "For error report; what is the current parent context of a child item.

   Should be set whenver a parent invokes a child.
   Since we have no grandchildren, we only need one level.
")
#+END_SRC

#+name: ùí±ùí∏
- If there is a ‚Äòlabel‚Äô, then yield ‚Äò(label :key value ‚ãØ)‚Äô
  since ‚Äòlabel‚Äô is assumed to exist as a variational having the given
  keys as arguments.  The result should be a list of pairs.

  BODY-LIST consists of elements of this shape.

- If there is no label, the parse the list of pairs.

- For example,

    (cl-defun ùí±-test (&key height kind) (list (format "%s & %s" height kind)))

    (ùí±ùí∏ '(test :height 3 :kind 'data)) ‚âà (test :height 3 :kind data) ‚âà (‚Äú3 & data‚Äù)

    (ùí±ùí∏ '(     :height 3 :kind data))  ‚âà ((:height . 3) (:kind . data))

- Newer items c‚ÇÄ ‚ü¥ ‚ãØ ‚ü¥ c‚Çô should be at the front of the list;
  access should then be using ‚Äòassoc‚Äô.

- CONTEXT is the parent context that contains an invocation of this method.

- ARGS is the list of names that are bound, and so are variational args.

#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defun ùí±ùí∏ (body-list &optional context args)
  "Parse a single ùí±ariational ùí∏lause, ‚Äú[label] (:key :value)*‚Äù, as a list.
<<docs('ùí±ùí∏)>>"
  (let (res)
    (loop for clause in (-split-on '‚ü¥ body-list)
          do (setq res (-concat
                        ;; Symbols starting with ‚Äú:‚Äù are keywords.
                        (if (not (keywordp (car clause)))
                            ;; Function invocation case
                            ;; We turn everything into a string so that we may
                            ;; prepend the function name with a ùí±-
                            ;; then turn that into Lisp with the first eval
                            ;; then invoke the resulting function call
                            ;; with the second eval.
                            (progn
                              ;; The variational being called is defined.
                              (pf--ensure (fboundp (ùí±- (car clause)))
                                          (format "%s %s ‚Äú%s‚Äù %s"
                                                  "Did you mistype a"
                                                  "variational's name:"
                                                  (car clause)
                                                  "is not defined.")
                                          context
                                          "Use the PackageFormer menu
                                                 to see which variationals
                                                 are defined.")
                              (eval `( ,(ùí±- (car clause)) ,@(--map (if (or (keywordp it) (ignore-errors (macrop (car it)))) it `(quote ,it)) (cdr clause)))))
                          ;; List of key-value pairs
                          `,(loop for key   in clause by #'cddr
                                  for value in (cdr clause) by #'cddr
                                  collect (pf--wf key value context args)))
                        ;; ‚Äúpf--wf‚Äù is just a fancy ‚Äúcons‚Äù.
                        ;; Newer items c‚ÇÄ ‚ü¥ ‚ãØ ‚ü¥ c‚Çô should be at the
                        ;; front of the list;
                        ;; access should then be using assoc.
                        res)))
    res))

;; (defmacro nope (&rest b) `(f ,@(--map (if (keywordp it) it `(quote ,it)) b)))
;; (equal '(f 'a :b 'c) (macroexpand '(nope a :b c)))
;;
;; (macrop (car '(lambda a))) ;; (ignore-errors (car '(a b)))
#+END_SRC
Where we have used the following helper to prefix Lisp code with ‚Äúùí±-‚Äù.
#+BEGIN_SRC emacs-lisp :results replace  :tangle agda-next-700-module-systems.el
(defun ùí±- (name)
  "Prefix the Lisp data NAME with a ‚Äúùí±-‚Äù then yield that as a Lisp datum."
  (should (symbolp name))
  (thread-last name
    (format "ùí±-%s")
    read-from-string
    car))
#+END_SRC

We now handle variational declarations by introducing a DSL; i.e., a macro that
expects the syntax outlined earlier.

#+name: ùí±
- The grammar:

        ùìã   ::= [docstring] identifier ([‚Äú(‚Äù]identifier[‚Äú)‚Äù])* = ùìãùí∏

        ùìãùí∏  ::= [identifier] (:key value)* (‚ü¥ ùìãùí∏)*

- The result is a function NAME prefixed by ùí±- whose BODY is an alist
  obtained from the aforementioned key-value pairs.

- E.g., (ùí± tes positional (keyword 3) = :kind data)
  This defines a variational with one positional and one keyword argument having
  3 as default.

- The resulting generated function has its code embeded as a docstring viewable
  with ‚Äúùë™-ùíâ ùíê‚Äù ---catented after any provided user documentation.

#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defmacro ùí± (name &rest body)
  "Reify as Lisp a variational declaration using the variational grammar.
<<docs('ùí±)>>"
  ;; Main code follows.
  (let* ((context (mapconcat (Œª x ‚Üí (prin1-to-string x t)) (cons name body) " "))
         (args-body (-split-on '= body))
         args pargs kargs argnames docs body res actual-code)
    (pcase (length args-body)
      (2 (setq args (car args-body)
               body (cadr args-body)))
      (_ (setq body (car args-body))))

    ;; Realise the arguments as either ùí´ositinal or ùí¶ey arguments.
    (loop for a in args
          do (if (consp a) (push a kargs) (push a pargs)))

    ;; The arguments are in reverse now, which doesn't matter for keywords
    ;; yet is crucial for positional arguments. So let's fix that.
    (setq pargs (reverse pargs))

    ;; Keep track of only the argument names, omitting any default values.
    (setq argnames (append pargs (mapcar #'car kargs)))

    ;; Set any documentation string and reify the body's variational clauses.
    (when (stringp (car body)) (setq docs (car body) body (cdr body)))
    (setq res (ùí±ùí∏ body context argnames))

    ;; I want to be able to actually, visually, see the resulting
    ;; generated definition of a function.
    ;; Hence, I embed its source code as a string in the code.
    ;;
    ;; I'm using strings so that they appear in the docstring via C-h o.
    ;;
    (setq actual-code
    `(cl-defun ,(ùí±- name) (,@pargs &key ,@kargs)

       ;; Stage the formal names *now*, then evaluate their values at run time.
       ;; Traverse the list of pairs and change the nested formal names with the
       ;; given values. Praise the Lord!
      (let* ((give-goal (quote ,res)) (give-goal‚ÇÄ give-goal))
        (when (quote ,argnames)

          "Stage the formal names *now*, then evaluate their values at run time."
          (loop for arg in (quote ,argnames)
                do (setq give-goal (cl-subst (eval arg) arg give-goal)))

          ;; TODO, maybe.
          ;; "Check that substituted values are well-typed"
          ;; (--map (pf--wf (car it) (or (cdr it)
          ;;                        ;; Mention which argument is not supplied.
          ;;                         (format "No Value for :%s Provided!"
          ;;                       (cdr (assoc (car it) (reverse give-goal‚ÇÄ))))
          )

         give-goal)))

    ;; Now set the code as a documentation string in it, after the fact.
    (setq docs (format "Arguments:\t%s %s\n%s" pargs (reverse kargs)
                       (if (not docs) "Undocumented user-defined variational."
                         ;; Keep paragraph structure, but ignore whitespace.
                         (thread-last docs
                           (s-split "\n\n")
                           (mapcar #'s-collapse-whitespace)
                           (mapcar #'s-trim)
                           (s-join "\n\n")
                           (s-word-wrap 70)
                           (format "\n%s\n\n\n")))))
              ;; When the user provides documentation, they may not want to see
             ;; the raw and expansions, so we pad extra whitespace before them.

    (put (ùí±- name) 'function-documentation
         (format "%s\n‚ü™User Definition‚ü´\n\n%s\n\n‚ü™Lisp Elaboration‚ü´\n\n%s"
                 docs context (pp-to-string actual-code)))
    ;; Register this new item in our list of variationals.
    (push (cons name docs) pf--variationals)
    ;; Return value:
    actual-code))
#+END_SRC

Consequently, any item declared with ùí± now has a docstring containing its user-facing
definition as well as its Lisp realisation ^_^ ---simply press ‚ÄúC-h o ENTER‚Äù on its name.

Here's an example.
#+BEGIN_SRC emacs-lisp
(ùí± test positional (keyword 3) another = "I have two mandatory arguments and one keyword argument")

(ùí±-test "positional arg‚ÇÅ" "positional arg‚ÇÇ" :keyword 25) ;; ‚áí nil ^_^
#+END_SRC

** Loading Variationals: Super Simple Conversion From String to Lisp
   :PROPERTIES:
   :CUSTOM_ID: Loading-Variationals--Super-Simple-Conversion-From-String-to-Lisp
   :END:

#+name: load-variational
- A VARIATION-STRING line is something like:

      ùí±-name x‚ÇÄ ‚Ä¶ x‚Çô  =  ([label‚ÇÄ] :key‚ÇÄ val‚ÇÅ ‚ãØ :key‚Çò val‚Çò ‚ü¥)*

- The result is a list of 3-tuples (name (x‚ÇÄ ‚ãØ x‚Çô) ((key‚ÇÄ val‚ÇÄ) ‚ãØ (key‚Çò val‚Çò))),
   containing the clause's name, argument list, and key-value pairs.

- For now, the RHS must be an expression of the form
  ‚Äú:key‚ÇÄ value‚ÇÄ ‚ãØ :key‚Çô value‚Çô‚Äù
  + where the value·µ¢ are legitmate Lisp expressions
  + and the LHS is an atomic name, possibly with argument names.

# - If the optional ‚Äòstring-list‚Äô is provided, then use
#   that instead of searching the buffer. This feature
#   has been added on to make the presentation of tests
#   and examples easier to digest ---without the mockup
#   of fletting ‚Äòbuffer-substring-no-properties‚Äô to return
#   what could instead be ‚Äòstring-list‚Äô. It was the addition
#    of a simple ‚Äòor‚Äô ---far less than this string explaning it.
#
#+begin_src emacs-lisp :tangle agda-next-700-module-systems.el
(cl-defun pf--load-variational (variation-string)
  "Obtain lines of the buffer that start with ‚Äúùí±-‚Äù as a Lisp alist.
<<docs('load-variational)>>"
  (thread-last variation-string
    (s-replace "ùí±-" "ùí± ")
    (format "(%s)")
    read-from-string
    car
    eval))
#+end_src

{{{fold(Unit Tests)}}}
# The extra quotes are okay; the front end supplies a single quote
# and here in the backend we need two.
# ?

#+BEGIN_SRC emacs-lisp :tangle no
(ert-deftest variationals-ùí±ùí∏ ()

  (should (equal (ùí±- 'nice)
                 'ùí±-nice))

  (should (equal (ùí±ùí∏ '(:height 3 :kind 'data))
                '((:height . 3) (:kind . data))))


  ;; Error along with ‚Äúnoice‚Äù.
  (should-error (ùí±ùí∏ '(:height 3 :kind datda) 'noice nil))

  ;; nice error.
  (should-error (ùí±ùí∏ '(:level 3)))

  ;;
  (cl-defun ùí±-test (&key height kind) `( (first . ,height) (second . ,kind)))
  ;;
  (should (equal (ùí±ùí∏ '(test :height 3 :kind 'three ‚ü¥ :kind 'module))
                 '((:kind . module) (first . 3) (second . three))))
  ;;
  ;; NOTE: ùí±-tests‚Ä≤ :kind is optional
  (should (equal (ùí±ùí∏ '(test :height 3 ‚ü¥ :kind 'module))
                 '((:kind . module) (first . 3) (second))))
  ;;
  (should (equal (ùí±ùí∏ '(:height 3 ‚ü¥ :kind 'module))
                 '((:kind . module) (:height . 3))))

  ;; Recursively place 3 (new) wherever 'it (old) occurs.
  ;; This' a standard Lisp utility.
  (should (equal
           (subst 3 'it '(1 2 it 4 (5 it) 7 (+ 8 it)))
           '(1 2 3 4 (5 3) 7 (+ 8 3))))
)
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no
(ert-deftest variationals-ùí± ()

  ;; Nullary
  (should (ùí± test‚ÇÄ  = :kind 'record :waist 3))
  (should (equal (ùí±-test‚ÇÄ)
               '((:kind . record) (:waist . 3))))

  ;; Unary
  (should (ùí± test‚ÇÅ heightish = :kind 'record :waist heightish))
  (should (equal (ùí±-test‚ÇÅ :heightish 6)
                 '((:kind . record) (:waist . 6))))

  ;; Invoking the previously defined variational
  (should (ùí± test‚ÇÇ  = :kind 'data ‚ü¥ test‚ÇÅ :heightish 2))
  (should (equal (ùí±-test‚ÇÇ)
                 '((:kind . record) (:waist . 2) (:kind . data))))

  ;; See a nice error message ^_^
  (should-error (ùí± test‚ÇÉ = :kind recordd))
)
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle no
(ert-deftest variationals-loading ()

  (should (pf--load-variational "ùí±-tc this height = :level this :waist height"))

  ;; NEATO! (Has desired error)
  ;; (-let [*parent-context* "woadh"]
  ;;   (ùí±-tc :height 'no :this 'inc))
  ;;
  ;; Does not pass: I've commented out the type checking in ùí± above, for now.

  (should (ùí±-tc :height 9 :this 'inc))

  (should (equal (ùí±ùí∏ '(:a 'b ‚ü¥ tc :height 1))
                 '((:level) (:waist . 1) (:a . b))))

;
)
#+END_SRC
{{{end-fold}}}

* Loading an Agda Buffer
  :PROPERTIES:
  :CUSTOM_ID: Loading-an-Agda-Buffer
  :END:

# Herein we define the datatype of ~instance-declaration~, describe how
# to parse such entities.

Before we can parse an Agda buffer, we need to be able to parse an instantiation declaration;
for which we would later generate code.

** Loading an Instance ---The Core Utility
   :PROPERTIES:
   :CUSTOM_ID: Loading-an-Instance----The-Core-Utility
   :END:
An instance declaration is of the form:
#+BEGIN_SRC results-agda
PF‚Ä≤ = PF variational‚ÇÅ args‚ÇÅ ‚ü¥  ‚ãØ ‚ü¥ variational‚Çô (args‚Çô)
#+END_SRC

This gives rise to a simple nice structure:
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defstruct pf-instance-declaration
  "Record of components for an PackageFormer instance declaration:
   ‚ü™name‚ü´ = ‚ü™package-former‚ü´ (‚ü¥ ‚ü™variation‚ü´ [‚ü™args‚ü´])*
  "

  docstring      ;; What the declaration looks like, useful for reference.
  name           ;; Left-hand side
  package-former ;; Parent grouping mechanism
  alterations    ;; List of variationals along with their arguments.
)
#+END_SRC

Loading an instantiation into our list is now trivial.

#+name:load-instance-declaration
- If the current LINE string is an instance declaration,
  then produce a new PackageFormer from it.  Else, do nothing.

- Whitespace is automatically collopased from LINE.

- Nil elements are discarded; e.g., due to a filter.

- Duplicates are discarded; e.g., due to a rename.

- Variational clauses may mention
  + $ùëõùëéùëöùëí: The name of the PackageFormer currently being declared;
            i.e., the LHS name.
  + $ùëíùëôùëíùëöùëíùëõùë°ùë†: Many variationals will act on individal elements, but may check a
           property relative to all elements and this name allows us to avoid
           having variationals that simply accomodate for binary functions
           that operate on an individual element while also needing to refer to
           all elements.  For example, a variational that keeps an element if
           it's related to another element somehow.

- SHOW-IT: For testing, and presentation, this optional value indicates whether
  the resulting PackageFormer should be pretty-printed or not.

#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defvar pf-consider-newly-named-declarations-only nil
  "Are we updating only new named declarations? If so, don't waste time doing work.")

(defun pf--load-instance-declaration (line &optional show-it)
  "Reify concrete instance declarations as ‚Äòpackage-former‚Äô values.
<<docs('load-instance-declaration)>>"
  (letf* (
     (pieces (s-split " " (s-collapse-whitespace line)))
     ($ùëõùëéùëöùëí      (nth 0 pieces))
     ($ùëíùëôùëíùëöùëíùëõùë°ùë†    nil)
     (eqSymb     (nth 1 pieces))
     ($ùëùùëéùëüùëíùëõùë°     (nth 2 pieces))
     (variations (nthcdr 3 pieces))
     (alterations nil)
     (self (copy-pf--package-former (cdr (assoc $ùëùùëéùëüùëíùëõùë° pf--package-formers))))
     (‚Åâ
      ;; If componenet ‚Äòc‚Äô is in the ‚Äòalterations‚Äô list of the
      ;; instance declaration, then evaluate any given ‚Äòmore‚Äô code,
      ;; get the value for ‚Äòc‚Äô and turn it
      ;; into a string, if ‚Äòstr‚Äô is true, then set the new PackageFormer's ‚Äòc‚Äô
      ;; componenet to be this value.
      ;; Well-formedness checks happen at the ùí± and ùí±ùí∏ stages, see below.
      (lambda (c &optional str more)
        (when-let ((it (cdr (assoc (intern (format ":%s" c)) alterations))))
          (eval `(progn ,@more))
          (when str (setq it (format "%s" it)))
          (eval `(setf (,(car (read-from-string
                               (format "pf--package-former-%s" c))) self)
                       it))))))

    ;; Ensure instance declaration is well-formed.
    (pf--ensure (and (not (s-blank? (s-trim $ùëõùëéùëöùëí))) (equal "=" eqSymb) $ùëùùëéùëüùëíùëõùë°)
                (concat "An instance declaration is of the form "
                        "‚Äúnew-name = parent-package-former "
                        "variational-clauses‚Äù.")
                line)

    (catch 'early-exit

    ;; Are we updating only new named declarations? If so, don't waste time doing work.
    (when pf-consider-newly-named-declarations-only
      (when (assoc $ùëõùëéùëöùëí pf--package-formers) (throw 'early-exit nil)))

    ;; Let's not overwrite existing PackageFormers.
    (pf--ensure (or (not (assoc $ùëõùëéùëöùëí pf--package-formers)) (equal $ùëõùëéùëöùëí "_"))
                (format "PackageFormer ‚Äú%s‚Äù is already defined; use a new name."
                        $ùëõùëéùëöùëí)
                line)
                ;; "Also, ‚Äú_‚Äù is the name of anonymous PackageFormers."

    ;; Ensure the PackageFormer to be instantiated is defined.
    (pf--ensure self
                (format "Parent ‚Äú%s‚Äù not defined." $ùëùùëéùëüùëíùëõùë°)
                line
                "Use the PackageFormer Emacs menu to see which PackageFormers are defined."
                "Perhaps you did not enclose the parent in 700-comments?")

    ;; Update the new PackageFormer with a docstring of its instantiation
    ;; as well as its name.
    (setf (pf--package-former-docstring self) line)
    (setf (pf--package-former-name self) $ùëõùëéùëöùëí)
    (setq $ùëíùëôùëíùëöùëíùëõùë°ùë† ; Copy so that user does not inadvertently
                  ; alter shared memory locations!
          (loop for e in (pf--package-former-elements self)
                collect (copy-element e)))

    ;; Parse the ‚Äúùìã‚ÇÄ ‚ü¥ ‚ãØ ‚ü¥ ùìã‚Çô‚Äù portion of an instance declaration.
     (thread-last  variations
       (s-join " ")     ;; Stick the rest back together.
       (format "'(%s)") ;; Construe as a lisp list
       read-from-string
       cadar
       (setq variations))
     ;;
     (setq alterations (ùí±ùí∏ variations line))

     ;; c.f. ‚Åâ above
     ;; Now that the aterations have been parsed, let's attach
     ;; the new components of the PackageFormer being made.

      ;; :kind ‚âà The vocabulary that replaces ‚ÄúPackageFormer‚Äù.
      (funcall ‚Åâ 'kind 'string-please)

      ;; :waist ‚âà The division between parameters and remaining elements.
      (funcall ‚Åâ 'waist)

      ;; :level ‚âà Either 'inc or 'dec, for increment or decrementing the level.
      (funcall ‚Åâ 'level nil ;; 'string-please
         '((let* ((lvl (pf--package-former-level self))
                  (toLevel (lambda (n)
                             (s-join "" (-concat (-repeat n "Level.suc (")
                                                 (list "Level.zero")
                                                 (-repeat n ")")))))
                 (subs `("" "‚ÇÅ" "‚ÇÇ" "‚ÇÉ" "‚ÇÑ" "‚ÇÖ" "‚ÇÜ" "‚Çá" "‚Çà" "‚Çâ"
                         ,(funcall toLevel 10)))
                 (here (-elem-index (s-trim lvl) subs)))
             (setq it
                   (if here

                       (pcase it
                         ('inc (nth (1+ here) subs))
                         ('dec (nth (1- here) subs)))

                     (pcase it
                       ('inc (format "Level.suc (%s)" lvl))
                       ('dec (s-join "suc"
                                     (cdr (s-split "suc" lvl :omit-nulls)))))))

             (unless it (setq it 'none)))))

      ;; :alter-elements ‚âà Access the typed name constituents list.
      ;; Perform *all* element alterations,
      ;; in the left-to-right ‚ü¥ order; if any at all.
      (loop for ae in (reverse (mapcar #'cdr (--filter
                                              (equal ':alter-elements (car it))
                                              alterations)))
            do
            (setq $ùëíùëôùëíùëöùëíùëõùë°ùë†
                  (cl-remove-duplicates (--filter it (funcall ae $ùëíùëôùëíùëöùëíùëõùë°ùë†))
                                     :test #'equal :from-end t)))
              ;; Filter in only the non-nil constituents & those not
              ;; starting with ‚Äú--‚Äù & remove duplicates.
              ;; We do this each time, rather than at the end, since
              ;; variationals may loop over all possible elements and we do not
              ;;  want to consider intermediary nils or duplicates.
      (setf (pf--package-former-elements self) $ùëíùëôùëíùëöùëíùëõùë°ùë†)

      ;; We've just formed a new PackageFormer, which can be modified,
      ;; specialised, later on.
      (add-to-list 'pf--package-formers (cons $ùëõùëéùëöùëí self))
      (if show-it (pf--show-package-former self) $ùëõùëéùëöùëí))))
#+END_SRC

** ~pf--load-700-comments~ and ~lisp~ blocks
   :PROPERTIES:
   :CUSTOM_ID: -pf--load-700-comments--and--lisp--blocks
   :END:

   We already two global lists ---for our loaded PackageFormers and varitionals
   declarared--- we need two additional globals: One for the contents of 700-comments,
   primarily for basic efficiency, and the other to port whatever is within
   700-comments but is not 700-syntax. The latter is for when we want definitions
   or generalised variables to be accessible in /both/ 700-comments and the
   surrounding script. Which is achieved since the matter is exported to
   the generated file in the Elisp stage, then imported at the Agda level.

   However, since content to be ported may occur between PackageFormer definitions
   and instance declarations, we need to remember the position of items that are ported.
   The simplest thing to do is simply place items for porting into the package-formers
   list ---then take care to check if an item is for porting or not when printing
   PackageFormers to a generated file.

#+BEGIN_SRC emacs-lisp  :tangle agda-next-700-module-systems.el
(defvar pf--annotations nil
  "The contents of the PackageFormer annotations.

If this variable does not change, we short-circut all processing.")
#+END_SRC

#+name: load-pf--annotations
- Parse comments of the form ‚Äú{-700 ‚ãØ -}‚Äù and add all PackageFormer declarations
  to the ‚Äòpackage-formers‚Äô list and load all instantations to the list as well.

- We also execute any valid Lisp code in ‚Äú{-lisp -}‚Äù comments;
  which may contain an arbitrary number of Lisp forms
  ---a ‚Äòprogn‚Äô is auto provided.

  Lisp is executed before any pf--annotations are; which is preferable
  due to Lisp's dynamic scope.

# ;; ("^\\\\begin{lisp}" . "^\\\\end{lisp}"))
#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(cl-defun pf--load-pf--annotations ()
  "Parse and load {-700‚ãØ-} syntax.
<<docs('load-pf--annotations)>>"
  (interactive)

  ;; First, let's run all the lisp. We enclose each in a progn in-case the user
  ;; has multiple forms in a single lisp-block.
  (loop for (lispstart . lispend) in '(("^\{-lisp" . "^-\}"))
        do (loop for lispstr in
                 (pf--buffer-substring-delimited-whole-buffer lispstart lispend)
                 do
                 (eval (car (read-from-string (format "(progn %s)" lispstr))))))

  ;; For now, ‚Äòitem‚Äô is a PackageFormer,
  ;; instantiation declaration, or other Agda code.
  (let (item lines 700-cmnts)

    ;; Catenate all pf--annotations into a single string.
    (setq 700-cmnts (s-join "\n"
                            (pf--buffer-substring-delimited-whole-buffer
                             "^\{-700"
                             "^-\}")))

    (if (equal pf--annotations 700-cmnts)

        (message "pf--annotations Unchanged.")

      ;; Update global.
      (setq pf--annotations 700-cmnts)

      ;; View comments as a sequence of lines, ignore empty lines
      ;; ---which are not in our grammar.
      (setq lines (--remove (s-blank? (s-collapse-whitespace it))
                            (s-lines pf--annotations)))

      ;; Traverse the pf--annotations:
      ;; ‚û© Skip comments; lines starting with ‚Äú-- ‚Äù.
      ;; ‚û© If we see a ‚Äúùí±-lhs = rhs‚Äù equation, then load it as a variational.
      ;; ‚û© If we view a ‚Äúlhs = rhs‚Äù equation, then load it as an
      ;;   instance delcaration.
      ;; ‚û© If we view a PackageFormer declaration, then load it into our
      ;;   package-formers list.
      (while lines
        (setq item (car lines))

        (if (not (s-blank? (s-shared-start "-- " (s-trim item))))
            (setq lines (cdr lines))

          (if (not (s-blank? (s-shared-start "ùí±-" item)))
              (progn (pf--load-variational item) (setq lines (cdr lines)))

            (if (s-contains? " = " item)
                (progn (pf--load-instance-declaration item)
                       (setq lines (cdr lines)))

              ;; Else we have a PackageFormer declaration
              ;; and other possiblly-non-700 items.
              (setq item (pf--get-children "PackageFormer" lines))

              ;; port non-700 items to generated file
              (push (cons 'porting (s-join "\n" (car item)))
                    pf--package-formers)

              ;; acknowledge PackageFormer declaration, if any
              (when (cadr item) (pf--load-package-former (cadr item)))

              ;; Update lines to be the unconsidered porition
              ;; of the wild comments.
              (setq lines (caddr item))))))

      (message "Finished parsing pf--annotations."))))
#+END_SRC

# Works, but hidden out from HTML output.
#
:Neato:
Let's test this out on our sample input file, ~Testing.agda~.

#+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
(let (pf--package-formers
      pf--annotations
      instantiations-remaining)

  (find-file "Testing.agda")
  (pf--load-pf--annotations)
  (switch-to-buffer "PackageFormer.org")

  (s-join "\n\n"
      (list (s-trim pf--annotations)
        (pp pf--package-formers) (pp instantiations-remaining)))
)
#+END_SRC

#+RESULTS:
#+begin_src results-agda
-- The next two lines are not 700-syntax and so are ported over to the generated file.
variable
   ‚Ñì : Level

PackageFormer MonoidP : Set‚ÇÅ where
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x

PackageFormer M-Set : Set‚ÇÅ where
   Scalar  : Set
   Vector  : Set
   _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
   ùüô       : Scalar
   _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)

-- Gives error that ùí±-doit is not defined (‡∏á‡≤†_‡≤†)‡∏á
-- Whoops   =  MonoidP doit


-- Variational with empty right hand side.
ùí±-identity =
MonoidP‚Å±·µà = MonoidP identity

-- No variational clauses needed!
MonoidP‚Å∞  = MonoidP

-- Identity of composition ‚ü¥
MonoidP·∂ú = MonoidP ‚ü¥

-- Operationally: Pf ‚ü¥ v  ‚âà  Pf v ‚ü¥  ‚âà  Pf v

-- ‚Äú‚ü¥‚Äù is just forwards composition: We ‚Äòthread‚Äô the Pf through the compositions v·µ¢ in order.



-- ùí±-whoops              = :kind recorder :waist-strings ("field")

ùí±-record                 = :kind record :waist-strings ("field")
ùí±-typeclass-attempt      = :kind record :waist-strings ("field") :waist 2
ùí±-typeclass‚ÇÇ             = :kind record :waist-strings ("field") :waist 2 :level dec
ùí±-typeclass height level = record ‚ü¥ :waist height :level level

MonoidT‚ÇÉ   =  MonoidP record ‚ü¥ :waist 3 :level dec
MonoidT‚ÇÇ   =  MonoidP typeclass‚ÇÇ ‚ü¥ :waist-strings ("private" "extra : Set‚ÇÅ" "extra = Set" "field")
MonoidT‚ÇÑ   =  MonoidP typeclass :height 4 :level 'dec


M-Set-Record = M-Set record
M-Set-Typeclass‚ÇÉ = M-Set-Record typeclass :height 3 :level 'dec



-- First one is intensionally erroenous attempt.
ùí±-primed-attempt = :alter-elements (lambda (fs) (mapcar (lambda (f) (map-name (concat name "‚Ä≤") f)) fs))

ùí±-primed‚Çó‚Çë‚Çú = :alter-elements (lambda (fs) (-as-> (-unzip (--zip-with `(,other  ,(format "let %s = %s in " (get-name it) (get-name other))) fs (--map (map-name (concat name "‚Ä≤") it) fs))) yup (--zip-with (map-type (concat (s-join "" it) type) other) (-inits (cadr yup)) (car yup))))

-- M-Set‚Ä≤-attempt = M-Set record ‚ü¥ primed-attempt

MonoidR    =  MonoidP record
MonoidR‚Ä≤   =  MonoidP record ‚ü¥ primed‚Çó‚Çë‚Çú
MonoidR‚Ä≥   =  MonoidR primed‚Çó‚Çë‚Çú

-- Operationally: Pf v‚ÇÄ ‚ü¥ ‚ãØ ‚ü¥ v‚Çô ‚âà ((Pf v‚ÇÄ) v‚ÇÅ) ‚ãØ) v‚Çô
-- Note: In the concrete syntax, such parenthisation is not permitted.



ùí±-map‚ÇÄ elements = :alter-elements (lambda (fs) (-as-> (-unzip (--zip-with `(,other  ,(format "let %s = %s in " (get-name it) (get-name other))) fs (mapcar elements fs))) yup (--zip-with (map-type (concat (s-join "" it) type) other) (-inits (cadr yup)) (car yup))))

Monoid‚Çò = MonoidR map‚ÇÄ :elements (lambda (f) (make-tn (concat (get-name f) "‚Çò") (get-type f)))

-- Note the prime on the rhs. MA: Maybe avoid this?
ùí±-rename‚ÇÄ elements = map‚ÇÄ :elements 'elements

ùí±-rename‚ÇÅ elements = map‚ÇÄ :elements (lambda (f) (make-tn (rename-mixfix elements (get-name f)) (get-type f)))

Monoid‚Çô = MonoidR rename‚ÇÅ :elements (lambda (name) (concat name "‚Çô"))


MR‚Ä≤ = M-Set record ‚ü¥ primer


MR‚ÇÅ‚Çã‚ÇÇ    = M-Set record ‚ü¥ decorated :by "‚ÇÅ" ‚ü¥ decorated :by "‚ÇÇ"
the-MR   = M-Set record ‚ü¥ co-decorated :by "the-"


MR-oh  = M-Set record ‚ü¥ rename :elements (lambda (name) (pcase name ("Scalar" "S") (x x)))


MR‚Çú‚Çí = M-Set record ‚ü¥ renaming :by "Scalar to S; Vector to V; ¬∑ to nice"
MR‚Çú‚Çí_ = M-Set record ‚ü¥ renaming_ :by "Scalar to S; Vector to V; _¬∑_ to _nice_"
NearMonoid = M-Set record ‚ü¥ renaming :by "Scalar to Carrier; Vector to Carrier; ¬∑ to √ó"


NearMonoid¬π = M-Set record ‚ü¥ single-sorted :with-sort "Carrier"


ùí±-empty-module = :kind module :level none :waist 999
Neato = M-Set empty-module


M-Set-R = M-Set record
M-Set-R‚ÇÅ = M-Set-R open :with (lambda (x) (concat x "‚ÇÅ"))
M-Set-R‚Ä≤ = M-Set-R open-with :decoration "‚Ä≤"


ùí±-sorts = generated :by (lambda (f) (s-contains? "Set" (target (get-type f))))

M-Set-Sorts = M-Set record ‚ü¥ sorts


MonoidSignature = M-Set record ‚ü¥ generated :by (lambda (f) (and (s-contains? "Scalar" f) (not (s-contains? "Vector" f))))


MonSig = M-Set record ‚ü¥ signature


Hom  = M-Set-R hom
Hom¬≤ = M-Set-R hom ‚ü¥ renaming :by "map‚ÇÅ to scalar; pres-ùüô to unity"

(("Hom¬≤" . #s(package-former "Hom¬≤ = M-Set-R hom ‚ü¥ renaming :by \"map‚ÇÅ to scalar; pres-ùüô to unity\"" "record" "Hom¬≤" "‚ÇÅ" 2
                             ("open M-Set-R  Src" "open M-Set-R‚Ä≤ Tgt" "field")
                             3
                             ("Src : M-Set-R" "Tgt : M-Set-R" "scalar : Scalar ‚Üí Scalar‚Ä≤" "map‚ÇÇ : Vector ‚Üí Vector‚Ä≤" "pres-¬∑ : {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÇ : Vector} ‚Üí   map‚ÇÇ (_¬∑_ x‚ÇÅ x‚ÇÇ)   ‚â°   _¬∑‚Ä≤_ (scalar x‚ÇÅ) (map‚ÇÇ x‚ÇÇ)" "unity : scalar (ùüô )   ‚â°   ùüô‚Ä≤" "pres-√ó : {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÅ : Scalar} ‚Üí   scalar (_√ó_ x‚ÇÅ x‚ÇÅ)   ‚â°   _√ó‚Ä≤_ (scalar x‚ÇÅ) (scalar x‚ÇÅ)")))
 ("Hom" . #s(package-former "Hom  = M-Set-R hom" "record" "Hom" "‚ÇÅ" 2
                            ("open M-Set-R  Src" "open M-Set-R‚Ä≤ Tgt" "field")
                            3
                            ("Src : M-Set-R" "Tgt : M-Set-R" "map‚ÇÅ : Scalar ‚Üí Scalar‚Ä≤" "map‚ÇÇ : Vector ‚Üí Vector‚Ä≤" "pres-¬∑ : {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÇ : Vector} ‚Üí   map‚ÇÇ (_¬∑_ x‚ÇÅ x‚ÇÇ)   ‚â°   _¬∑‚Ä≤_ (map‚ÇÅ x‚ÇÅ) (map‚ÇÇ x‚ÇÇ)" "pres-ùüô : map‚ÇÅ (ùüô )   ‚â°   ùüô‚Ä≤" "pres-√ó : {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÅ : Scalar} ‚Üí   map‚ÇÅ (_√ó_ x‚ÇÅ x‚ÇÅ)   ‚â°   _√ó‚Ä≤_ (map‚ÇÅ x‚ÇÅ) (map‚ÇÅ x‚ÇÅ)")))
 ("MonSig" . #s(package-former "MonSig = M-Set record ‚ü¥ signature" "record" "MonSig" "‚ÇÅ" 0
                               ("field")
                               3
                               ("Scalar  : Set" "Vector  : Set" "_¬∑_     : Scalar ‚Üí Vector ‚Üí Vector" "ùüô       : Scalar" "_√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar")))
 ("MonoidSignature" . #s(package-former "MonoidSignature = M-Set record ‚ü¥ generated :by (lambda (f) (and (s-contains? \"Scalar\" f) (not (s-contains? \"Vector\" f))))" "record" "MonoidSignature" "‚ÇÅ" 0
                                        ("field")
                                        3
                                        ("Scalar  : Set" "ùüô       : Scalar" "_√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar")))
 ("M-Set-Sorts" . #s(package-former "M-Set-Sorts = M-Set record ‚ü¥ sorts" "record" "M-Set-Sorts" "‚ÇÅ" 0
                                    ("field")
                                    3
                                    ("Scalar  : Set" "Vector  : Set")))
 ("M-Set-R‚Ä≤" . #s(package-former "M-Set-R‚Ä≤ = M-Set-R open-with :decoration \"‚Ä≤\"" "module" "M-Set-R‚Ä≤" none 1
                                 ("")
                                 3
                                 ("‚Ñõ : M-Set-R" "open M-Set-R ‚Ñõ public" "  renaming" "    ( Scalar to Scalar‚Ä≤\n       ; Vector to Vector‚Ä≤\n       ; _¬∑_ to _¬∑‚Ä≤_\n       ; ùüô to ùüô‚Ä≤\n       ; _√ó_ to _√ó‚Ä≤_\n       ; leftId to leftId‚Ä≤\n       ; assoc to assoc‚Ä≤\n       )")))
 ("M-Set-R‚ÇÅ" . #s(package-former "M-Set-R‚ÇÅ = M-Set-R open :with (lambda (x) (concat x \"‚ÇÅ\"))" "module" "M-Set-R‚ÇÅ" none 1
                                 ("")
                                 3
                                 ("‚Ñõ : M-Set-R" "open M-Set-R ‚Ñõ public" "  renaming" "    ( Scalar to Scalar‚ÇÅ\n       ; Vector to Vector‚ÇÅ\n       ; _¬∑_ to _¬∑‚ÇÅ_\n       ; ùüô to ùüô‚ÇÅ\n       ; _√ó_ to _√ó‚ÇÅ_\n       ; leftId to leftId‚ÇÅ\n       ; assoc to assoc‚ÇÅ\n       )")))
 ("M-Set-R" . #s(package-former "M-Set-R = M-Set record" "record" "M-Set-R" "‚ÇÅ" 0
                                ("field")
                                3
                                ("Scalar  : Set" "Vector  : Set" "_¬∑_     : Scalar ‚Üí Vector ‚Üí Vector" "ùüô       : Scalar" "_√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar" "leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã" "assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)")))
 ("Neato" . #s(package-former "Neato = M-Set empty-module" "module" "Neato" none 999 nil 3
                              ("Scalar  : Set" "Vector  : Set" "_¬∑_     : Scalar ‚Üí Vector ‚Üí Vector" "ùüô       : Scalar" "_√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar" "leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã" "assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)")))
 ("NearMonoid¬π" . #s(package-former "NearMonoid¬π = M-Set record ‚ü¥ single-sorted :with-sort \"Carrier\"" "record" "NearMonoid¬π" "‚ÇÅ" 0
                                    ("field")
                                    3
                                    ("Carrier : Set" "_¬∑_ : Carrier ‚Üí Carrier ‚Üí Carrier" "ùüô : Carrier" "_√ó_ : Carrier ‚Üí Carrier ‚Üí Carrier" "leftId : {ùìã : Carrier}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã" "assoc : {a b : Carrier} {ùìã : Carrier} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)")))
 ("NearMonoid" . #s(package-former "NearMonoid = M-Set record ‚ü¥ renaming :by \"Scalar to Carrier; Vector to Carrier; ¬∑ to √ó\"" "record" "NearMonoid" "‚ÇÅ" 0
                                   ("field")
                                   3
                                   ("Carrier : Set" "_√ó_ : Carrier ‚Üí Carrier ‚Üí Carrier" "ùüô : Carrier" "leftId : {ùìã : Carrier}  ‚Üí  ùüô √ó ùìã  ‚â°  ùìã" "assoc : {a b : Carrier} {ùìã : Carrier} ‚Üí (a √ó b) √ó ùìã  ‚â°  a √ó (b √ó ùìã)")))
 ("MR‚Çú‚Çí_" . #s(package-former "MR‚Çú‚Çí_ = M-Set record ‚ü¥ renaming_ :by \"Scalar to S; Vector to V; _¬∑_ to _nice_\"" "record" "MR‚Çú‚Çí_" "‚ÇÅ" 0
                              ("field")
                              3
                              ("S : Set" "V : Set" "_nice_ : S ‚Üí V ‚Üí V" "ùüô : S" "_√ó_ : S ‚Üí S ‚Üí S" "leftId : {ùìã : V}  ‚Üí  ùüô nice ùìã  ‚â°  ùìã" "assoc : {a b : S} {ùìã : V} ‚Üí (a √ó b) nice ùìã  ‚â°  a nice (b nice ùìã)")))
 ("MR‚Çú‚Çí" . #s(package-former "MR‚Çú‚Çí = M-Set record ‚ü¥ renaming :by \"Scalar to S; Vector to V; ¬∑ to nice\"" "record" "MR‚Çú‚Çí" "‚ÇÅ" 0
                             ("field")
                             3
                             ("S : Set" "V : Set" "_nice_ : S ‚Üí V ‚Üí V" "ùüô : S" "_√ó_ : S ‚Üí S ‚Üí S" "leftId : {ùìã : V}  ‚Üí  ùüô nice ùìã  ‚â°  ùìã" "assoc : {a b : S} {ùìã : V} ‚Üí (a √ó b) nice ùìã  ‚â°  a nice (b nice ùìã)")))
 ("MR-oh" . #s(package-former "MR-oh  = M-Set record ‚ü¥ rename :elements (lambda (name) (pcase name (\"Scalar\" \"S\") (x x)))" "record" "MR-oh" "‚ÇÅ" 0
                              ("field")
                              3
                              ("S : Set" "Vector : Set" "_¬∑_ : S ‚Üí Vector ‚Üí Vector" "ùüô : S" "_√ó_ : S ‚Üí S ‚Üí S" "leftId : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã" "assoc : {a b : S} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)")))
 ("the-MR" . #s(package-former "the-MR   = M-Set record ‚ü¥ co-decorated :by \"the-\"" "record" "the-MR" "‚ÇÅ" 0
                               ("field")
                               3
                               ("the-Scalar : Set" "the-Vector : Set" "_the-¬∑_ : the-Scalar ‚Üí the-Vector ‚Üí the-Vector" "the-ùüô : the-Scalar" "_the-√ó_ : the-Scalar ‚Üí the-Scalar ‚Üí the-Scalar" "the-leftId : {ùìã : the-Vector}  ‚Üí  the-ùüô the-¬∑ ùìã  ‚â°  ùìã" "the-assoc : {a b : the-Scalar} {ùìã : the-Vector} ‚Üí (a the-√ó b) the-¬∑ ùìã  ‚â°  a the-¬∑ (b the-¬∑ ùìã)")))
 ("MR‚ÇÅ‚Çã‚ÇÇ" . #s(package-former "MR‚ÇÅ‚Çã‚ÇÇ    = M-Set record ‚ü¥ decorated :by \"‚ÇÅ\" ‚ü¥ decorated :by \"‚ÇÇ\"" "record" "MR‚ÇÅ‚Çã‚ÇÇ" "‚ÇÅ" 0
                              ("field")
                              3
                              ("Scalar‚ÇÅ‚ÇÇ : Set" "Vector‚ÇÅ‚ÇÇ : Set" "_¬∑‚ÇÅ‚ÇÇ_ : Scalar‚ÇÅ‚ÇÇ ‚Üí Vector‚ÇÅ‚ÇÇ ‚Üí Vector‚ÇÅ‚ÇÇ" "ùüô‚ÇÅ‚ÇÇ : Scalar‚ÇÅ‚ÇÇ" "_√ó‚ÇÅ‚ÇÇ_ : Scalar‚ÇÅ‚ÇÇ ‚Üí Scalar‚ÇÅ‚ÇÇ ‚Üí Scalar‚ÇÅ‚ÇÇ" "leftId‚ÇÅ‚ÇÇ : {ùìã : Vector‚ÇÅ‚ÇÇ}  ‚Üí  ùüô‚ÇÅ‚ÇÇ ¬∑‚ÇÅ‚ÇÇ ùìã  ‚â°  ùìã" "assoc‚ÇÅ‚ÇÇ : {a b : Scalar‚ÇÅ‚ÇÇ} {ùìã : Vector‚ÇÅ‚ÇÇ} ‚Üí (a √ó‚ÇÅ‚ÇÇ b) ¬∑‚ÇÅ‚ÇÇ ùìã  ‚â°  a ¬∑‚ÇÅ‚ÇÇ (b ¬∑‚ÇÅ‚ÇÇ ùìã)")))
 ("MR‚Ä≤" . #s(package-former "MR‚Ä≤ = M-Set record ‚ü¥ primer" "record" "MR‚Ä≤" "‚ÇÅ" 0
                            ("field")
                            3
                            ("Scalar‚Ä≤  : Set" "Vector‚Ä≤  : Set" "_¬∑‚Ä≤_     : Scalar‚Ä≤ ‚Üí Vector‚Ä≤ ‚Üí Vector‚Ä≤" "ùüô‚Ä≤       : Scalar‚Ä≤" "_√ó‚Ä≤_     : Scalar‚Ä≤ ‚Üí Scalar‚Ä≤ ‚Üí Scalar‚Ä≤" "leftId‚Ä≤  : {ùìã : Vector‚Ä≤}  ‚Üí  ùüô‚Ä≤ ¬∑‚Ä≤ ùìã  ‚â°  ùìã" "assoc‚Ä≤   : {a b : Scalar‚Ä≤} {ùìã : Vector‚Ä≤} ‚Üí (a √ó‚Ä≤ b) ¬∑‚Ä≤ ùìã  ‚â°  a ¬∑‚Ä≤ (b ¬∑‚Ä≤ ùìã)")))
 ("Monoid‚Çô" . #s(package-former "Monoid‚Çô = MonoidR rename‚ÇÅ :elements (lambda (name) (concat name \"‚Çô\"))" "record" "Monoid‚Çô" "‚ÇÅ" 0
                                ("field")
                                4
                                ("Carrier‚Çô : Set" "_‚®æ‚Çô_ : let Carrier = Carrier‚Çô in Carrier ‚Üí Carrier ‚Üí Carrier" "Id‚Çô : let Carrier = Carrier‚Çô in let _‚®æ_ = _‚®æ‚Çô_ in Carrier" "assoc‚Çô : let Carrier = Carrier‚Çô in let _‚®æ_ = _‚®æ‚Çô_ in let Id = Id‚Çô in ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)" "leftId‚Çô : let Carrier = Carrier‚Çô in let _‚®æ_ = _‚®æ‚Çô_ in let Id = Id‚Çô in let assoc = assoc‚Çô in ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x" "rightId‚Çô : let Carrier = Carrier‚Çô in let _‚®æ_ = _‚®æ‚Çô_ in let Id = Id‚Çô in let assoc = assoc‚Çô in let leftId = leftId‚Çô in ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x")))
 ("Monoid‚Çò" . #s(package-former "Monoid‚Çò = MonoidR map‚ÇÄ :elements (lambda (f) (make-tn (concat (get-name f) \"‚Çò\") (get-type f)))" "record" "Monoid‚Çò" "‚ÇÅ" 0
                                ("field")
                                4
                                ("Carrier‚Çò : Set" "_‚®æ_‚Çò : let Carrier = Carrier‚Çò in Carrier ‚Üí Carrier ‚Üí Carrier" "Id‚Çò : let Carrier = Carrier‚Çò in let _‚®æ_ = _‚®æ_‚Çò in Carrier" "assoc‚Çò : let Carrier = Carrier‚Çò in let _‚®æ_ = _‚®æ_‚Çò in let Id = Id‚Çò in ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)" "leftId‚Çò : let Carrier = Carrier‚Çò in let _‚®æ_ = _‚®æ_‚Çò in let Id = Id‚Çò in let assoc = assoc‚Çò in ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x" "rightId‚Çò : let Carrier = Carrier‚Çò in let _‚®æ_ = _‚®æ_‚Çò in let Id = Id‚Çò in let assoc = assoc‚Çò in let leftId = leftId‚Çò in ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x")))
 ("MonoidR‚Ä≥" . #s(package-former "MonoidR‚Ä≥   =  MonoidR primed‚Çó‚Çë‚Çú" "record" "MonoidR‚Ä≥" "‚ÇÅ" 0
                                 ("field")
                                 4
                                 ("Carrier‚Ä≤ : Set" "_‚®æ‚Ä≤_ : let Carrier = Carrier‚Ä≤ in Carrier ‚Üí Carrier ‚Üí Carrier" "Id‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in Carrier" "assoc‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in let Id = Id‚Ä≤ in ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)" "leftId‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in let Id = Id‚Ä≤ in let assoc = assoc‚Ä≤ in ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x" "rightId‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in let Id = Id‚Ä≤ in let assoc = assoc‚Ä≤ in let leftId = leftId‚Ä≤ in ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x")))
 ("MonoidR‚Ä≤" . #s(package-former "MonoidR‚Ä≤   =  MonoidP record ‚ü¥ primed‚Çó‚Çë‚Çú" "record" "MonoidR‚Ä≤" "‚ÇÅ" 0
                                 ("field")
                                 4
                                 ("Carrier‚Ä≤ : Set" "_‚®æ‚Ä≤_ : let Carrier = Carrier‚Ä≤ in Carrier ‚Üí Carrier ‚Üí Carrier" "Id‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in Carrier" "assoc‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in let Id = Id‚Ä≤ in ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)" "leftId‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in let Id = Id‚Ä≤ in let assoc = assoc‚Ä≤ in ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x" "rightId‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in let Id = Id‚Ä≤ in let assoc = assoc‚Ä≤ in let leftId = leftId‚Ä≤ in ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x")))
 ("MonoidR" . #s(package-former "MonoidR    =  MonoidP record" "record" "MonoidR" "‚ÇÅ" 0
                                ("field")
                                4
                                ("Carrier : Set" "_‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier" "Id      : Carrier" "assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)" "leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x" "rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x")))
 ("M-Set-Typeclass‚ÇÉ" . #s(package-former "M-Set-Typeclass‚ÇÉ = M-Set-Record typeclass :height 3 :level 'dec" "record" "M-Set-Typeclass‚ÇÉ" "" 3
                                         ("field")
                                         3
                                         ("Scalar  : Set" "Vector  : Set" "_¬∑_     : Scalar ‚Üí Vector ‚Üí Vector" "ùüô       : Scalar" "_√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar" "leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã" "assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)")))
 ("M-Set-Record" . #s(package-former "M-Set-Record = M-Set record" "record" "M-Set-Record" "‚ÇÅ" 0
                                     ("field")
                                     3
                                     ("Scalar  : Set" "Vector  : Set" "_¬∑_     : Scalar ‚Üí Vector ‚Üí Vector" "ùüô       : Scalar" "_√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar" "leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã" "assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)")))
 ("MonoidT‚ÇÑ" . #s(package-former "MonoidT‚ÇÑ   =  MonoidP typeclass :height 4 :level 'dec" "record" "MonoidT‚ÇÑ" "" 4
                                 ("field")
                                 4
                                 ("Carrier : Set" "_‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier" "Id      : Carrier" "assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)" "leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x" "rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x")))
 ("MonoidT‚ÇÇ" . #s(package-former "MonoidT‚ÇÇ   =  MonoidP typeclass‚ÇÇ ‚ü¥ :waist-strings (\"private\" \"extra : Set‚ÇÅ\" \"extra = Set\" \"field\")" "record" "MonoidT‚ÇÇ" "" 2
                                 ("private" "extra : Set‚ÇÅ" "extra = Set" "field")
                                 4
                                 ("Carrier : Set" "_‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier" "Id      : Carrier" "assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)" "leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x" "rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x")))
 ("MonoidT‚ÇÉ" . #s(package-former "MonoidT‚ÇÉ   =  MonoidP record ‚ü¥ :waist 3 :level dec" "record" "MonoidT‚ÇÉ" "" 3
                                 ("field")
                                 4
                                 ("Carrier : Set" "_‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier" "Id      : Carrier" "assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)" "leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x" "rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x")))
 ("MonoidP·∂ú" . #s(package-former "MonoidP·∂ú = MonoidP ‚ü¥" "PackageFormer" "MonoidP·∂ú" "‚ÇÅ" 0 nil 4
                                 ("Carrier : Set" "_‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier" "Id      : Carrier" "assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)" "leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x" "rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x")))
 ("MonoidP‚Å∞" . #s(package-former "MonoidP‚Å∞  = MonoidP" "PackageFormer" "MonoidP‚Å∞" "‚ÇÅ" 0 nil 4
                                 ("Carrier : Set" "_‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier" "Id      : Carrier" "assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)" "leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x" "rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x")))
 ("MonoidP‚Å±·µà" . #s(package-former "MonoidP‚Å±·µà = MonoidP identity" "PackageFormer" "MonoidP‚Å±·µà" "‚ÇÅ" 0 nil 4
                                  ("Carrier : Set" "_‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier" "Id      : Carrier" "assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)" "leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x" "rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x")))
 ("M-Set" . #s(package-former nil "PackageFormer" "M-Set" "‚ÇÅ" 0 nil 3
                              ("Scalar  : Set" "Vector  : Set" "_¬∑_     : Scalar ‚Üí Vector ‚Üí Vector" "ùüô       : Scalar" "_√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar" "leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã" "assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)")))
 (porting . "")
 ("MonoidP" . #s(package-former nil "PackageFormer" "MonoidP" "‚ÇÅ" 0 nil 4
                                ("Carrier : Set" "_‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier" "Id      : Carrier" "assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)" "leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x" "rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x")))
 (porting . "variable\n   ‚Ñì : Level"))


nil
#+end_src
:End:

* Emacs Interface
  :PROPERTIES:
  :CUSTOM_ID: Emacs-Interface
  :END:

** Tooltips
   :PROPERTIES:
   :CUSTOM_ID: Tooltips
   :END:

   It gets rather tedious to jump to the generated files to see the elaborations
   of 700-syntactical items. As such, let's tie existing occurrences of a PackageFormer's
   name to its elaboration.

   #+name: tooltipify
   We only add tooltips to PHRASE as a standalone word, not as a subword.

   The PHRASE is taken literally; no regexp operators are recognised.

   Useful info on tooltips:
    + http://kitchingroup.cheme.cmu.edu/blog/2013/04/12/Tool-tips-on-text-in-Emacs/
    + https://www.gnu.org/software/emacs/manual/html_node/elisp/Changing-Properties.html
    + http://kitchingroup.cheme.cmu.edu/blog/2016/03/16/Getting-graphical-feedback-as-tooltips-in-Emacs/
    + https://stackoverflow.com/questions/293853/defining-new-tooltips-in-emacs

  The second resource above shows how to alter the phrase's font to indicate that it has
  a tooltip. It is not desirable for us, since we want to add onto Agda's colouring.

 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
;; Nearly instantaneous display of tooltips.
(setq tooltip-delay 0)

;; Give user 30 seconds before tooltip automatically disappears.
(setq tooltip-hide-delay 30)

(defun pf--tooltipify (phrase notification)
  "Add a tooltip to every instance of PHRASE to show NOTIFICATION.
<<docs('tooltipify)>>"
  (should (stringp phrase))
  (should (stringp notification))
  (save-excursion  ;; Return cursour to current-point afterwards.
    (goto-char 1)
    ;; The \b are for empty-string at the start or end of a word.
    (while (search-forward-regexp (format "\\b%s\\b" (regexp-quote phrase)) (point-max) t)
      (put-text-property (match-beginning 0)
                         (match-end 0)
                         'help-echo
                         (s-trim notification)))))
 #+END_SRC

 New textual occurrences of a name obtain tooltips when ~C-c C-l~ is invoked.
** Advising our Beloved ~C-c C-l~
   :PROPERTIES:
   :CUSTOM_ID: Advising-our-Beloved--C-c-C-l-
   :END:
   :PROPERTIES:

   :END:

 Let's give the current buffer access to the location of the generated file.
 #+BEGIN_SRC emacs-lisp  :tangle agda-next-700-module-systems.el
(defun pf--insert-generated-import (name-of-generated-file)
  "Insert an import pointing to the generated file.

In the current file, find the top-most module declaration
then insert an import to NAME-OF-GENERATED-FILE."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (condition-case _
        ;; attemptClause:
        (re-search-forward (concat "open import " name-of-generated-file))
      ;; recoveryBody:
      (error ;; (message-box (format "%s" the-err))
       (re-search-forward "\\(module.*\\)")
       (replace-match (concat "\\1\nopen import " name-of-generated-file))))))
 #+END_SRC

 The aim is to process test enclosed in ~{-700 ‚ãØ -}~ comments,
 produce legitimate Agda from that, and ensure the generated Agda is accessible to the
 current buffer automatically.

 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defvar pf-waiting-for-agda-threshhold 14 "\
How long we should wait for Agda before giving up on colouring and tooltips.

Default is to wait 4 √ó 0.5 milliseconds.
Why? An inital ‚Äòagda2-load‚Äô of a ~300 line file may take some time.")

(defvar pf-multiple-files nil
  "Whether the list of PackageFormers should be reset with each ‚ÄúC- c C-l‚Äù, or
   should be left persistant as in when we are loading over multiple files.")

(defun pf--reify-package-formers (orig-fun &rest args)
  "Parse package-former syntax and produce Agda when possible.

ORIG-FUN is intended to be the Agda loading process with arguments ARGS."
  (interactive)
  (let* (printed-pfs
        (parent-dir (s-join "/"
                            (-drop-last 1 (s-split "/" buffer-file-truename))))
        (generatedmodule  (pf--generated-file-name))
        (newfile (concat parent-dir "/" generatedmodule ".agda"))
        (parent-imports (pf--extract-imports)))

    ;; Load variationals, PackageFormers, instantiations, and porting list.
    ;; Setting the following to nil each time is not ideal.
    (setq	pf--variationals
             (-take-last ‚ôØstandard-variationals pf--variationals)
             ;; take last n items, those being exported into the .el.
             pf--package-formers       (when (or pf-consider-newly-named-declarations-only pf-multiple-files) pf--package-formers)
             pf--annotations           nil)

    (pf--load-pf--annotations)

    (with-temp-buffer
      (goto-char (point-min))

      ;; Copy/paste imports from parent file.
      (insert (s-join "\n" `(
         "{- This file is generated ;; do not alter. -}\n"
         ,parent-imports
         "open import Level as Level using (Level)"
         ,(format "module %s where " generatedmodule))))

     ;; Print the package-formers
      (setq printed-pfs
            (--map (cond
               ((equal 'porting (car it)) (format "%s" (cdr it)))
               ((equal "_" (car it))      "") ;; Anonymous PackageFormers
               (t (format
                (if (equal "PackageFormer" (pf--package-former-kind (cdr it)))
                    (concat "{- Kind ‚ÄúPackageFormer‚Äù does not correspond "
                            " to a concrete Agda type. \n%s\n -}")
                       "%s") (pf--show-package-former (cdr it)))))
             (reverse pf--package-formers)))
      ;;
      (insert (s-join "\n\n\n" printed-pfs))
      ;; (setq package-formers nil) ;; So no accidental

      ;; Replace tabs with spaces
      (untabify (point-min) (point-max))

      (write-region (goto-char (point-min)) (goto-char (point-max)) newfile))

    (pf--insert-generated-import generatedmodule)

    ;; Need to revert buffer to discard old colours.
    ;; (save-buffer) (revert-buffer t t t)

    ;; call agda2-load
    (apply orig-fun args)

  ;; Agda attaches ‚Äújump to definition‚Äù tooltips; we add to those.
  ;; For some reason we need a slight delay between when Agda is done checking
  ;; and when we can add on our tooltips.
  ;; Attach tooltips only for existing occurrences; update happens with C-c C-l.
  ;; Wait until Agda is finished highlighting, then do ours (‡∏á‡≤†_‡≤†)‡∏á
  (-let [counter 0] ; agda2-in-progress
    (while agda2-highlight-in-progress
      (when (> counter pf-waiting-for-agda-threshhold)
        (error (concat "PackageFormer ‚à∑ "
                       "Items generated, but not coloured; "
                       "Agda seems busy...")))
        (incf counter)
        (sleep-for 0.5))) ;; In case Agda errors on a term, no more waiting.
    (loop for (name . pf) in pf--package-formers
          do (unless (equal 'porting name)
               (pf--tooltipify name (pf--show-package-former pf))))
    ;; Special anonymous names.
    (pf--tooltipify "_" "‚Äú_‚Äù is the name of anonymous PackageFormers, which cannot be elaborated.")

    ;; Let's also add tooltips for the variationals & colour them.
    (loop for (v . docs) in pf--variationals
          do (pf--tooltipify (format "%s" v) docs)
          ;; For beauty, let's colour variational names green.
          ;; Only colour occurances that have a space before or after.
          (when pf-highlighting
            (highlight-phrase (format "[- \\| ]%s " v) 'hi-green)))

    (message "PackageFormer ‚à∑ All the best coding! (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà")))
 #+END_SRC

 Personal note:
 Using ~(write-file "Generated.agda")~ means we make a file
 then the temporary buffer /visits/ the Agda file, which loads the
 Agda process therein, which is undesirable since it could leave
 Agda working on the buffer even after it has been killed!
 + This would necessiate calling ~(agda2-restart)~ afterwards.
 + Instead we write the whole region, without visiting the resuting file.

** Menu matter
   :PROPERTIES:
   :CUSTOM_ID: Menu-matter
   :END:
 Let's quickly add a menu bar that allows users to enable or disable using PackageFormer's;
 along with a brief help menu.

  Names with a double dash are intended to be private, not to be touched by users.

 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(defvar pf--menu-bar (make-sparse-keymap "PackageFormer"))
 #+END_SRC

 {{{fold( Enabling the feature )}}}
 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(define-key pf--menu-bar [pf-enable-package-formers]
  '(menu-item "Enable PackageFormer Generation" pf-enable-package-formers))

(defun pf-enable-package-formers ()
 "Add a menubar, and make Agda's ùë™-ùëê ùë™-ùíç consider package-former syntax."
 (interactive)
 (define-key global-map [menu-bar pf--menu] (cons "PackageFormer" pf--menu-bar))
 (advice-add 'agda2-load :around #'pf--reify-package-formers)
 (message-box (concat "C-c C-l now reifies PackageFormer annotations"
                      "into legitimate Agda.")))
 #+END_SRC
 {{{end-fold}}}

 {{{fold( Disabling the feature )}}}
 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(define-key pf--menu-bar [pf-disable-package-formers]
  '(menu-item "Disable PackageFormer Generation" pf-disable-package-formers))

(defun pf-disable-package-formers ()
  "Remove menubar, and make Agda's ùë™-ùëê ùë™-ùíç act as normal."
 (interactive)
 (define-key global-map [menu-bar pf--menu] nil)
 (advice-remove 'agda2-load #'pf--reify-package-formers)
 (setq global-mode-string (remove "PackageFormer (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà " global-mode-string))
  (message-box "C-c C-l now behaves as it always has."))
 #+END_SRC
 {{{end-fold}}}

 {{{fold( About menu )}}}
 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(define-key pf--menu-bar [pf-package-formers-about]
  '(menu-item "About PackageFormers" pf-package-formers-about))

(defun pf-package-formers-about ()
  "Show help about the PackageFormer system."
 (interactive)
 (switch-to-buffer "*PackageFormer-About*") (insert "\
This is an editor extension prototyping ‚Äúthe next 700 module systems‚Äù
proposed research.

An informal documentation, with examples, page can be found at
https://alhassy.github.io/next-700-module-systems/prototype/package-former.html

The technical matter can be found at
https://alhassy.github.io/next-700-module-systems/

If you experience anything ‚Äúgoing wrong‚Äù or have any ideas for improvement,
please contact Musa Al-hassy at alhassy@gmail.com; thank-you ‚ô•‚Äø‚ô•"))
 #+END_SRC
 {{{end-fold}}}

 {{{fold( Bare Bones Agda )}}}
 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(define-key pf--menu-bar [pf--bare-bones]
  '(menu-item "Copy file with PackageFormer annotations stripped away"
              pf--bare-bones))

(defun pf-bare-bones ()
  "Duplicate the current buffer with PackageFormer annotations stripped away."
 (interactive)
 (let* ((src (file-name-sans-extension (buffer-name)))
        (src-agda (format "%s.agda" src))
        (bare-agda (format "%s-bare.agda" src)))
   (with-temp-buffer
     (insert-file-contents src-agda)
     (goto-char (point-min))
       (re-search-forward (format "module %s" src))
       (replace-match (format "module %s-bare" src))
     (loop for pre in '("^\{-lisp" "^\{-700")
      do
      (goto-char (point-min))
      (pf--buffer-substring-delimited-whole-buffer pre "^-\}"
           (lambda (sp ep)
             (save-excursion
             (goto-char (- sp 2))
             (push-mark ep)
             (setq mark-active t)
             (delete-region (- sp 2) ep)))))
     (write-file bare-agda))
     (message "%s_Bare.agda has been written." src)))
 #+END_SRC
 {{{end-fold}}}

 {{{fold( Menu of Defined PackageFormer Contents )}}}
 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(define-key pf--menu-bar [pf-show-variationals]
  '(menu-item "Show all registered variationals" pf-show-variationals))

(defun pf-show-variationals ()
  "Show all user declared ùí±ariationals in another buffer."
 (interactive)
 (occur "ùí±[ \\|-]"))

(define-key pf--menu-bar [pf-show-pfs]
  '(menu-item "Show all concrete PackageFormers" pf-show-pfs))

(defun pf-show-pfs ()
  "Show all user declared PackageFormer's in another buffer."
 (interactive)
 (occur "PackageFormer .* where"))
 #+END_SRC
 {{{end-fold}}}

 {{{fold( Folding Away PackageFormer Annotations )}}}
 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(define-key pf--menu-bar [pf-fold-annotations]
  '(menu-item "Toggle folding away ‚Äú700‚Äù and ‚Äúlisp‚Äù blocks"
              pf-fold-annotations))

(defun pf-fold-annotations ()
  "Fold all items enclosed in Agda comments ‚Äú{- ‚ãØ -}‚Äù."
  (interactive)
  (setq pf-folding (not pf-folding))
  (if pf-folding
      (message "Use ‚ÄúC-c f t‚Äù to toggle folding blocks")
    (origami-open-all-nodes (current-buffer))
    (message "Blocks ‚Äú700‚Äù and ‚Äúlisp‚Äù have been unfolded.")))

;; Basic origami support for Agda.
(push (cons 'agda2-mode (origami-markers-parser "{-" "-}"))
      origami-parser-alist)

;; Along with a hydra for super quick navigation
;; and easily folding, unfolding blocks!
(defhydra folding-with-origami-mode (global-map "C-c f")
  ("h" origami-close-node-recursively "Hide")
  ("o" origami-open-node-recursively  "Open")
  ("t" origami-toggle-all-nodes  "Toggle buffer")
  ("n" origami-next-fold "Next")
  ("p" origami-previous-fold "Previous"))
 #+END_SRC
 {{{end-fold}}}

 Let's pack these together into a minor mode.
 {{{fold( Minor mode )}}}

 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
;;;###autoload
(define-minor-mode agda-next-700-module-systems-mode "\
An editor extension prototyping ‚Äúthe next 700 module systems‚Äù proposed research.

An informal documentation, with examples, page can be found at
https://alhassy.github.io/next-700-module-systems-proposal/PackageFormer.html

The technical matter can be found at
https://alhassy.github.io/next-700-module-systems-proposal/

If you experience anything ‚Äúgoing wrong‚Äù or have any ideas for improvement,
please contact Musa Al-hassy at alhassy@gmail.com; thank-you ‚ô•‚Äø‚ô•"
  ;; Icon to display indicating the mode is enabled.
  :lighter " PackageFormer (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà"
  :require 'foo

  ;; Toggle the menu bar
  (define-key global-map [menu-bar pf--menu]
    (and agda-next-700-module-systems-mode (cons "PackageFormer" pf--menu-bar)))

  (letf (( (symbol-function 'message-box) #'message))
    (if agda-next-700-module-systems-mode
        ;; Initilisation
        (pf-enable-package-formers)

      ;; Closing
      (pf-disable-package-formers))))
 #+END_SRC

The file ought to also contain one or more autoload magic comments, as explained in
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging-Basics.html#Packaging-Basics][Packaging Basics]].

 {{{end-fold}}}

* Future & Related Work
  :PROPERTIES:
  :CUSTOM_ID: Work
  :END:

Well, that was a lot of Lisp I had to learn ~(‡∏á‡≤†_‡≤†)‡∏á~

Hopefully the resulting prototype will be useful to others;
drop me a line if you're interested in this effort or have
any feedback or pointers!

#+begin_center org
‚òÖ ‚òÖ ‚òÖ
#+end_center

** Features Wish-list
   :PROPERTIES:
   :CUSTOM_ID: Features-Wish-list
   :END:

We check them off, rather than deleting them,
to produce a ‚Äòtada‚Äô list of features ;-)

:Changelog:

‚û© NEW, Pushout construction!

  ùí±-union forms pushouts in the category of signatures ^_^

  My implementation solves some of TPC paper's issues regarding the number of inputs: I use optional inputs
  and defaults otherwise. I'm also using input function f,g in the reverse direction ---I haven't seen this
  before, but it works lol

‚û© NEW, Pullback construction ^_^

  This is much harder to do than pushout; but shares the same ideas for reducing the number of input arguments.

‚û© ‚Äúto‚Äù-lists can now be interpreted bijectively!

   ùí±-renaming now has an optional parameter ‚Äú:adjoin-coretract‚Äù to form
   the other half of the bijection. Unlike ‚Äú:adjoin-retract‚Äù, it's off by default.

‚û© Add remarks on commutativity of combinators in user manual section on renaming.

‚û© NEW variational, ‚Äúpostulating‚Äù.

    This was mentioned in an in-discussion exercise in the user manual.
    The solution to the exercise has been formalised and has a section in the user manual.

    It serves as an accessible example of extending the system by users.

‚û© Redirected extraction of ùí±ariationals defined in the first part of the user manual
  via reference ùí±-user-man-pt-1.

  Since they relied on the variationals defined in part 2, they caused an error during compilation.

‚û© Fixed indentation issue; using at least 4 spaces in elaborated code.

‚û© Support crazy names, like [],+,\,^,*,?

‚û© Experimented with having anonymous PackageFormers.

‚û© Made support-for-mixfix names off by default.

‚û© Added adjoin-retract option to ùí±-extended-by.

‚û© Fixed tooltip calculation to account for regular expression operators, such as [],+,\,^,*,?.

‚û© NEW, ùí±-PackageFormer

  variational to mark a grouping mechanism as abstract, so that it is NOT elaborated into concrete Agda.
:End:

+ [X] For now, arguments must be enclosed in parenthesis.
   - [X] This is likely to be dropped in a future edition of the system.

+ [X] Colouring for 700-syntactical items.

+ [X] Tooltips

+ [ ] Some menu items are a bit buggy ---this is low-priority.

+ [ ] MA: WK: hiding ‚Ü¶ dropping

+ [ ] Use pf--buffer-substring-delimited-whole-buffer to parse /multiple/
      pf--annotations!

+ [ ] Add a level component to an instance structure; reduce it if Carrier is a parameter and otherwise leave it alone.
      Instead, let the level of a PackageFormer denote the level of the typeclass instantiation, then with this in mind
      we increase the level component of an instance structure only for those variations that keep the carrier as a field.
      When we move to multi-sorted, as in Graphs, this issue will need to be revisited.

+ [X] Currently can only perform simple variational clauses; need to support complex clauses.

+ [X] Support for equations in PackageFormers: Easy, nothing new needed! Thank-you ~alter-elements~!

+ [X]   Examples from the user-manual
        should be exported into an Agda file which is then easily checked;
        or the resulting generated code should be generated when export happens.

+ [ ] We can only perform ‚ÄúLHS = PF ùìãùí∏‚Äù, do we also want stand-alone ‚ÄúPF ùìãùí∏‚Äù?
  - Maybe not? Maybe it suffices to use, say, ‚Äú_ = PF ùìãùí∏‚Äù?

  # TODO: Give an example making use of suffix-fields to ‚Äòextend‚Äô a packageformer with new fields. E.g., PackageFormer B = A extended-by cs ought to be valid but so should I = A vs extended-by cs which is amicable syntax for the instantation (A extended-by cs) vs. Should this automatically yield forgetful coercisions ‚ÄúI‚áíA‚Äù? For now, maybe yes by default and no if we use, say, fields instead of extended-by. There will be issues of coherency when we add items.

+ [X] Need to implement a *front-end* system to extend variational clauses.

+ [ ] The ~elements~ of a PackageFormer should be  an alist, ~'(name . type)~.
  - Maybe not, the front-end lets users treat them as strings, easily.
  - Maybe such a view is useful for the user? It is provided via ~get-name~ and ~get-type~.

+ [X] Refactor load-instantions function to make use of an ~alter~ field rather than overloading alter-fields in reify-instances.

+ [X] Refactor ~instantiate~ to make use of an ~instance~ structure, rather than 13 arguments.
  - In my defence, 13 arguments was because I was trying to find out what were the key ingredients
    necessary to form different variational presentations. It seems I only needed 5 ^_^

+ [ ] Why does ‚Äòpf--buffer-substring-delimited-whole-buffer‚Äô return a list of strings? Why not join its result to simply return a list?

+ [X] Generated.agda needs to inherit all open/import declarations from parent.

+ [ ] Give an example PackageFormer with some definitions or derived constructs, then hoist-up your waist so that the non-defined items are ~module~ parameters.

+ [X] PF's should account for equations. For simplicity they become components of a record & module, but derived operations on datatypes.

+ [ ] Demonstrate how generative modules can be emulated.

+ [ ] The global variables package-formers & instance-declaration should be /buffer/ specific?

+ [X] Assign to a local var, check equality against global pf--annotations,
      if identical, no more processing since everything already generated.

+ [ ] Make use of docstring so that when a user enters a key sequence or selects from a menu, we can show them a listing of all ‚Äòmajor‚Äô components of a program: An org-mode file is displayed with an enumeration of the items, each being a link to the source, and only their docstring is shown. This is a nice ‚Äòoverview‚Äô of the program source.

+ [X] Currently it looks like we are a minor mode, but this is not true. We only have a menu and the icon (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà is displayed when our feature is supported.
  - Now a minor mode.

+ [ ] Generate all instances of a PackageFormer schema.

+ ~MR = M-Set primed~ crashes!

+ [ ] Look into [[https://github.com/KestrelInstitute/Specware][*Specware*]].

  - Structures are created using colimits.
  - Are hierarchical considerations leaked by the resulting structures?

+ [X] PackageFormer.ext ‚Ü¶ package-former.ext

    ‚á® kebab-case is conventional of Lisp
+ [X] Arguments, in tooltip renditions, are in reverse order; c.f. ùí±-open.

       This is because ùí± lists them in the wrong order!
+ [X] colouring should be whole words only; see tooltipify
+ [X] Improved concept of PackageFormer constituents

  Element  ‚âà  [qualifier] [lhs] [:] [type] [list-of definitional clauses]

  Eqn      ‚âà  [same-lhs-as-before] [args] ‚âà [term]
+ [X] extensions of structures can be formed;
+ [X] Form sum of two PackageFormers!
+ [X] Form library of common or useful variations or combinators, using the meta-primitives.
  - renaming :: Given a function f, apply it to all names.
  - map-elements f :: Apply function f to each element.
  - prefix-elements :: Given a list of new elements, prepend them to the current list of elements.
  - postfix-elements :: Given a list of new elements, postpend them to the current list of elements.
  - drop-elements :: Given a predicate, drop the fields that satisfy it.
    - Moreover, drop additional fields if they depend on dropped fields? (maybe).
  - opening f :: Module renaming according to f.
  - manifest :: Mention one form; briefly mention others.

  Note that package formation has been liberated from the backend and brought to the user
  via our 5 meta-primitives: preamble, kind, waist, waist-strings, level, alter-elements.
+ [X] Allow ‚Äú:level‚Äù to be ‚Äòinc, dec, omit‚Äô where the last option omits the ‚Äú: Set ‚Ñì‚Äù declaration altogether.
  - Useful for module setups.
+ [X] Make a ‚Äúraw‚Äù variation that allows meta-primitives to be invoked whenever.
  - Maybe called ùìåùíæùìâùíΩ ?
    ‚û± Look at load variations, if there are any ùìåùíæùìâùíΩ clauses, then add them to the
       variation's pairs. assoc ensures only latest items are picked up and so
       these would overwrite whatever the variation wanted; neato.
       Perhaps check that ùìåùíæùìâùíΩ clauses only allow meta-primitives?

       - This is accomplished by a combination of a meta-primitive followed by ‚Äú‚ü¥‚Äù.
       - Unless needed otherwise, this is a non-issue.

** Equality: From ‚â° to ‚âà to ‚âà‚Ä≤
   :PROPERTIES:
   :CUSTOM_ID: Equality--From---to---to---
   :END:
   One may start from a basic ‚â°-equality, then *mechanically* move to a setoid one
   by including congruence laws.
   + Interestingly, sometimes such constructions are invariant under equivalent equalities.
     - http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Props.Lattice.html#2531

** PackageFormers with variational parameters
   :PROPERTIES:
   :CUSTOM_ID: PackageFormers-with-variational-parameters
   :END:

    + [ ] For now, PackageFormer's have no other parameters besides the variation symbol ---not even that atm.

 Allow package formers to have explicit ~Variation~ parameters; but
       how do we then deal with nested invocations? What are the uses of
       having differing invocations?

       For example,
       #+BEGIN_SRC agda
PackageFormer LawfullyPointed (v : Variation) : Set where
   point : LawfullyPointed v
   law   : LawfullyPointed FOL {- Concrete variation -}

                          #+END_SRC
       Would elaborate to something like:
       #+BEGIN_SRC agda
       data LP-Term (Vars : Set) : Set where
        {- Abstract fields from constituents of packageformer -}
        Point    : LP-Term
        {- Fragment of first order logic term formation -}
        _‚Ä≤       : Vars ‚Üí LP-Term {- Injection of vars as terms -}
        _‚âà_      : LP-Term ‚Üí LP-Term ‚Üí LP-Term
        ‚àÄ‚Ä≤ ‚àÉ‚Ä≤    : (Vars ‚Üí LP-Term) ‚Üí LP-Term

       record LP : Set‚ÇÅ where
     constructor _,_,_
     field
        Carrier : Set
        point   : Carrier
        law     : LP-Term Carrier
 #+END_SRC

       With the following example uses.
       #+BEGIN_SRC agda
      Contractable : (A : Set) (a : A) ‚Üí LP
      Contractable A a =  A , a , ‚àÄ‚Ä≤ (Œª x ‚Üí x ‚âà a ‚Ä≤)

      Indistinguishable : (A : Set)  ‚Üí  LP hiding point
      Indistinguishable A a =  A , ‚àÄ‚Ä≤ (Œª x ‚Üí ‚àÄ‚Ä≤ (Œª y ‚Üí x ‚âà y))
       #+END_SRC
       Where ~PF hiding c~ is the largest sub-PackageFormer of ~PF~ with constituent ~c~
       removed ---in particular, constituents that depend on ~c~ would also be dropped.

       :Hide:
     #+BEGIN_SRC emacs-lisp
(defun generate-all-instances () ;; TODO
  "For each PackageFormer ‚Äòpf‚Äô, produce the default instances:
   ‚Äòpf-record‚Äô, ‚Äòpf-typeclass‚Äô, ‚Äòpf-data‚Äô.

   Use: You want a particular instance in rapid developement and don't want
   to be bothered to give it a name.  Or experimenting and unsure which instance
   is most desirable, so have access to all of them.

   Possible extensions:
   0. Introduce concrete syntax ‚ÄúGenerateDefaultInstances pf‚Äù to invoke this command.
   1. Have a global list of default instances.
  "

  (interactive)

    ;; Keep this around since we may want to produce variations wholesale with
  ;; names: packageformer-variation; e.g., Magma-typeclass.
  ;;
  ;;
  ;; the variations
;;  (setq the-vars-shush (--map (car it) (--map (-take-last 1 it) (--map (s-split " " it) decls-vars-shush))))
  ;;
  ;; (dolist (variation the-vars-shush ll)
  ;;  (setq ll (cons (make-typeclass decls (concat pf-name "-" variation)) ll)))

  )
 #+END_SRC
       :End:

** COMMENT DONE Flip Combinator
   :PROPERTIES:
   :CUSTOM_ID: Flip-Combinator
   :END:

   Some properties are merely the syntactic mirror of other
   ---it would make sense to have this relationship explicit.
   For example:
   + Left units/zeros/distributively are mirrors of the right ones.
     - http://www.cse.chalmers.se/~nad/listings/lib/Algebra.FunctionProperties.html#1
     - Additionally, in the presence of commutativity, such mirrored definitions are provably identically.

   With duality, we can even derive more structure!    For example,
   + Join semilattices are dual to meet semilattices.
   + As such, /position/ of the operators is symmetric wrt the definition of a join-&-meet lattice.
     - http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Props.Lattice.html#1029
     - See RATH for a fine-grained approach to lattices.

** COMMENT DONE Extensions
   :PROPERTIES:
   :CUSTOM_ID: Extensions
   :END:
   Mathematical structures naturally come in related hierarchies.
   Agda users' current solution is to manually declare such relationships
   by means of conversion functions. An extension *variational* could be formed
   to make this process mechanical ---using tiny theories.
   + Examples: http://www.cse.chalmers.se/~nad/listings/lib/Algebra.html#2533
     - C.f., every abelian group /is a/ group.

   *Theory graphs:*
   Incidentally, as it stands, the current prototype allows arbitrary Emacs Lisp to be
   used and so such a variational could potentially produce ~dot~ specifications
   in the current directory, which can be used to obtain *visually* the relationships
   between structures. Such ‚Äúmathematical knowledge management‚Äù is underway with the MMT setup.

   + [ ] ~B = cs ‚ü®+ A ‚ü®+ cs‚Ä≤~ where each cs is a single name-type declaration and the operation is left-associative, and A is an existing packageformer. This gives us a nice way to build a hierarchy. Note that since only A has a name, we may form a forgetful coercion B‚áíA automatically.
  E.g., ~Monoid = Type ‚ü®+ Pointed ‚ü®+ (Magma renaming (_‚äï_ to _‚®æ_)) ‚ü®+ LeftUnital ‚ü®+ RightUnital ‚ü®+ assoc : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)~ gives, automatically, ~Monoid‚áíType, Monoid‚áíPointed, Monoid‚áíMagma, Monoid‚áíLeftUnital, Magma‚áíRightUnital~ (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà MA: To begin with, ignore the rename and work up the sequence one ‚ü®+ at a time.

** Related Work
   :PROPERTIES:
   :CUSTOM_ID: Related-Work
   :END:

   + Theory Presentation Combinators [cite:tpc]

     This work aims to provide a sound categorical basis for most of the combinators
     in section 2 above, in-particular: Extensions, renames, and pushouts.
     The work emphasises the importance of these combinators at the PackageFormer
     level but also at the level of morphisms between them ---which is not something
     we are even considering.

   + [[https://github.com/ysharoda/PhD-Proposal/blob/master/proposal.pdf][Leveraging the information contained in theory presentations]] (PhD Proposal)

     This work focuses on /library combinators that give free common constructions/
     such as deriving the type of homomorphisms from a given PackageFormer.
     We have shown this particular example, in section 2 of the user manual, to
     demonstrate how our low-level setup can be used in the creation of such
     combinators.

     *We provide a low-level kernel which supports the creation of such combinators, but we are not studying such combinators, their use, their classifications, nor their theory.*

   + A Scalable Module System [link]
     # cite:mmt_main_paper

     An impressive work, the MMT language ---a module system for mathematical theories---
     may serve as a standardised representation format for a formal,
     web-scalable, digital
     library that supports mathematical knowledge management ‚Äòin the large‚Äô.
     The resulting system is not only logic-independent but also foundation-independent;
     unlike [cite:tpc], it shifts semantic concerns to concrete instances but
     allows more than first-class morphisms between contexts, going up to morphisms
     between logics.

     *Whereas one focus of this work is the developement of a standardised format and library of mathematical knowledge management, our aims are more humble: An extensible and mouldable module system for programmers via a kernel of meta-primitives.*
** COMMENT more
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-more
   :END:

  + TODO: [[cite:casl_user_manual][CASL (Common Algebraic Specfication Language)]] ; [[cite:maude][Maude]] ; Specware ; Hets

* Bibliography :ignore:
  :PROPERTIES:
  :CUSTOM_ID: Bibliography
  :END:
  # The style is only relevant for LaTeX export.
  bibliographystyle:unsrtnat
  bibliography:/Users/musa/thesis-proposal/papers/References.bib
** TODO Works to look into
   :PROPERTIES:
   :CUSTOM_ID: Works-to-look-into
   :END:

 + [ ] Bart Jacobs' book /Categorical Logic and Type Theory/.
   - *Display maps*
   - Chapter 10, section 10.4

 + [ ] Mei ‚Äî A Module System for Mechanized Mathematics Systems
       J. Xu
       In: J. Carette and F. Wiedijk, eds., Proceedings of Programming Languages for Mechanized Mathematics (PLMMS 2007), 17 pp., Hagenburg, Austria, June 29-30, 2007.

 + [ ] Formalizing mathematical knowledge as a biform theory graph: A case study Abstract PDF
       J. Carette and W. M. Farmer
       In: H. Geuvers, M. England, O. Hasan, F. Rabe, and O. Teschke, eds., Intelligent Computer Mathematics (CICM 2017), Lecture Notes in Computer Science (LNCS), 10383:9‚Äì24, 2017 (without appendices). Preprint with appendices: arXiv: 1704.02253 (43 pp.), 2017.

 + [ ]  J. Carette and W. M. Farmer. High-level theories. In A. Autexier et al., editor,
        Intelligent Computer Mathematics, volume 5144 of Lecture Notes in Computer
        Science, pages 232‚Äì245. Springer-Verlag, 2008.

 + [ ]  CoFI (The Common Framework Initiative). Casl Reference Manual. LNCS Vol.
        2960 (IFIP Series). Springer-Verlag, 2004.

 + [ ] W. M. Farmer. Biform theories in Chiron. In M. Kauers, M. Kerber, R. R.
       Miner, and W. Windsteiger, editors, Towards Mechanized Mathematical Assistants,
       volume 4573 of Lecture Notes in Computer Science, pages 66‚Äì79. Springer-Verlag,
       2007.

 + [ ] HetsCasl Online Tool: http://rest.hets.eu/

 + [ ] W. M. Farmer, J. D. Guttman, and F. J. Thayer. IMPS: An Interactive Mathematical Proof System. Journal of Automated Reasoning, 11:213‚Äì248, 1993.

 + [ ] Meaning formulas for syntax-based mathematical algorithms PDF
        W. M. Farmer
        In: T. Kutsia and A. Voronkov, eds., SCSS 2014 (6th International Symposium on Symbolic Computation in Software Science), EasyChair Proceedings in Computing (EPiC), 30:10‚Äì11, 2014.
        Extended Abstract.

 + [ ] Richard D. Jenks and Robert S. Sutor. AXIOM: The Scientific Computation
       System. Springer-Verlag, 1992.

 + [ ] Douglas R. Smith. Constructing specification morphisms. Journal of Symbolic
       Computation, 15:5‚Äì6, 1993.

 + [ ] Douglas R. Smith. Mechanizing the development of software. In M. Broy and
        R. Steinbrueggen, editors, Calculational System Design, Proceedings of the NATO
        Advanced Study Institute, pages 251‚Äì292. IOS Press, Amsterdam, 1999.

 + [ ] Wikipedia ‚ÄúList of algebraic structures‚Äù.
      [[http://en.wikipedia.org/wiki/List of algebraic structures]].
* Appending the *.el with the useful variationals AND el footer :ignore:
  :PROPERTIES:
  :CUSTOM_ID: Appending-PackageFormer-el-with-the-useful-variationals
  :END:

:Hide:
   We read in the temporary variationals file, then tangle the result into the PackageFormer.el file.

   This must come at the end since it uses things like ùí± which need to be defined first.

   #  :var it = (s-count-matches-all "(ùí±" (file-as-string "variationals.tmp"))
# (setq ‚ôØstandard-variationals 10)

#+BEGIN_SRC emacs-lisp :noweb yes :exports none :tangle agda-next-700-module-systems.el
  <<std-ùí±-lib>>
  <<ùí±-user-man-pt-1>>
#+END_SRC

The above is enclosed in a let-clause, which we need to leave to declare the following
top-level item.

#+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(provide 'agda-next-700-module-systems)
;;; agda-next-700-module-systems.el ends here
 #+END_SRC
 This is the footer line; it appears at the very end of the file.
 Its purpose is to enable people to detect truncated versions of the file from the lack of a footer line.
   :End:

* COMMENT Testing install in a clean emacs :Reference:
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-Testing-install-in-a-clean-emacs
  :END:

 0. ~emacs -Q~

 1. In the scratch buffer, paste and execute the following.
    #+BEGIN_SRC emacs-lisp

(progn
(require 'package)
(push '("melpa-stable" . "http://stable.melpa.org/packages/") package-archives)
(package-initialize)
(package-refresh-contents)

;; Obtain & setup installation interface.
(unless (package-installed-p 'use-package)
  (package-install 'use-package))
(require 'use-package)
(setq use-package-always-ensure t)

;; Necessary libraries for producing the prototype
(use-package names)              ;; Namespace utility
(use-package s)                  ;; ‚ÄúThe long lost Emacs string manipulation library‚Äù.
(use-package dash)               ;; ‚ÄúA modern list library for Emacs‚Äù.
(use-package dash-functional)    ;; -partial, -compose, -orfun, etc.
(use-package origami)            ;; Folding away regions of text.
(use-package hydra)              ;; Helpful menus.
(require 'subr-x)                ;; Extra Lisp functions; e.g., when-let.

(shell-command "cp ~/thesis-proposal/prototype/agda-next-700-module-systems.el ~/.emacs.d/agda-next-700-module-systems.el")
(add-hook 'agda2-mode-hook #'agda-next-700-module-systems-mode)

;; Uncomment out the last line above if you want package-former
;; to ALWAYS be active on .agda files.

;; You likely have this in your ~/.emacs file already
(load-file (let ((coding-system-for-read 'utf-8))
                (shell-command-to-string "/usr/local/bin/agda-mode locate")))
  )
#+END_SRC

 2. In a new ~test.agda~ file, load the meta-program and C-c C-l the following.
  #+BEGIN_SRC agda
{- Execute me: (agda-next-700-module-systems-mode) -}
open import test-generated
module test where

{-700
PackageFormer this : Set‚ÇÅ where
  A : Set
  a : A

ùí±-mid = "neato"

thisR = this record ‚ü¥ mid
-}

_ = thisR
#+END_SRC

 3. Now C-c C-l package-former.agda from the webpage.

* COMMENT Construction Sites
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-Construction-Sites
  :END:
** Cool stuffs, but now obsolete -e.g.,                       :itify:
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-Cool-stuffs--but-now-obsolete--e-g--
   :END:
*** recursively replacement; i.e., Lisps' subst
    :PROPERTIES:
    :CUSTOM_ID: recursively-replacement--i-e---Lisps--subst
    :END:
    :PROPERTIES:

    :END:

 Accidentally_reimplemented_Lisps_subst
 #+BEGIN_SRC emacs-lisp :results replace :tangle agda-next-700-module-systems.el
;; This is Lisp's ‚Äúsubst‚Äù, lol ^_^
(defun rec-replace (old new thing)
  "Traverse ‚Äòthing‚Äô and seek out all, possibly nested, instances
   of ‚Äòold‚Äô and replace them with ‚Äònew‚Äô."
  (cond
   ((equal thing old) new  )
   ((atom thing)      thing)
   ((consp thing)     (cons (rec-replace old new (car thing))
                            (rec-replace old new (cdr thing))))))

;; test
;; (rec-replace 'it 3
;;              '(1 2 it 4 (5 it) 7 (+ 8 it))
;;             )
;; Neato!
 #+END_SRC

***  ùí±  ---super simple                                           :posterity:
    :PROPERTIES:
    :CUSTOM_ID: ùí±
    :END:
    :PROPERTIES:

    :END:
 #+BEGIN_SRC emacs-lisp :results replace  :tangle agda-next-700-module-systems.el
;; Posterity
(defmacro ùí±‚ÇÄ (name &rest body)
  "lhs args = key-value pairs   ‚áí  a Lisp lambda taking args, yielding the pairs"
  (let* ((it body) (args-pairs (-split-on '= body)) args pairs pp)
    (pcase (length args-pairs)
      (2 (setq args  (car args-pairs)
               pairs (cadr args-pairs)))
      (t (setq pairs (car args-pairs))))

    `(lambda ,args
    ,(-let [res
        `,(loop for key   in pairs by #'cddr
                      for value in (cdr pairs) by #'cddr
                      collect (cons key value))]

       ;; Stage the formal names *now*, then evaluate their values at run time.
       ;; Traverse the list of pairs and change the nested formal names with the
       ;; given values. Praise the Lord!
      `(loop for a in (quote ,args)
            collect (subst (eval a) a (quote ,res)))

  ))))
 #+END_SRC

*** update-state
    :PROPERTIES:
    :CUSTOM_ID: update-state
    :END:

 #+begin_src emacs-lisp :tangle agda-next-700-module-systems.el :results replace
(cl-defun update-state (xs ys)
  "Given ys, a list of key-value pairs, where the keys appear free in list of pairs xs,
   update the values of xs making use of these new pairs.

   E.g., (setq xs '((a . (list b d)) (c . d)))
         (setq ys '((b . ùí∑) (d . ùíπ)))
         ‚áí    (update-state xs ys)
            ‚âà '((a . (list ‚Äúùí∑‚Äù ‚Äúùíπ‚Äù)) (c . ‚Äúùíπ‚Äù)))
  "
  (loop for (key . val) in xs
         collect (cons key
            (eval `(progn ,@(--map `(setq ,(car it) ,(format "%s" (cdr it))) ys)
              ,(car (read-from-string (format "%s" val)))))))
  )

;; (update-state xx yy)
 #+end_src

*** Methods to obtain PackageFormer name & variation sumbol
    :PROPERTIES:
    :CUSTOM_ID: Methods-to-obtain-PackageFormer-name---variation-sumbol
    :END:
    :PROPERTIES:

    :END:

  As such, we form a method for
  obtaining the name, the variation symbol, and a method to rewrite substrings of the
  children ---wait, we already have the last one: ~pf--get-children~ with optional ~:then~
  keyword.

  #+BEGIN_SRC emacs-lisp
;; The following two only work on headers of PackageFormer declarations.

(defun package-former-name (declaration)
  "Given a declaration of the form
   ‚ÄúPackageFormer Semigroup (v : Variation) : Set where‚Äù
   return the name ‚ÄúSemigroup‚Äù.
  "
  (s-chop-prefix "PackageFormer "
    (s-chop-suffix " ("
      (car (s-match "PackageFormer .* (" declaration))))
)


(defun variation-symbol (declaration)
  "Given a declaration of the form
   ‚ÄúPackageFormer Semigroup (v : Variation) : Set where‚Äù
   return the name ‚Äúv‚Äù.
  "
  (s-chop-prefix "("
    (s-chop-suffix " : Variation)"
      (car (s-match "(.*)" declaration))))
)
  #+END_SRC

  Let's test these two out.
  #+BEGIN_SRC emacs-lisp
(package-former-name "PackageFormer Semigroup (v : Variation) : Set where")
;; ‚áí "Semigroup"

(variation-symbol "PackageFormer Semigroup (v : Variation) : Set where")
;; ‚áí "v"
  #+END_SRC

*** Parameter Erasure & Insertion
    :PROPERTIES:
    :CUSTOM_ID: Parameter-Erasure---Insertion
    :END:
    :PROPERTIES:

    :END:
  MA: Just change the package-former-variation to package-former-parameter ---which is a pair, ‚Äúname : type‚Äù.
  This may make it easier later to transition to having multiple parameters.

  When a PackageFormer such as the following is instantiated, say, to a typeclass
  variation, we must erase the variation parameter and insert a new type parameter.
  #+BEGIN_SRC agda
   PackageFormer Semigroup (v : Variation) : Set where ‚Ä¶
‚Ü¶  record Semigroup (Carrier : Set) : Set  where ‚ãØ
  #+END_SRC

  #+RESULTS:
  : <interactive>:5:1: error: parse error on input ‚Äò‚Ü¶‚Äô

  #+BEGIN_SRC emacs-lisp
;; The following only work on headers of PackageFormer declarations.

(defun erase-parameters (declaration)
  "Given a declaration of the form
   ‚ÄúPackageFormer Semigroup (existing-params) : Set ‚Ñì where‚Äù
   return
   ‚ÄúPackageFormer Semigroup : Set ‚Ñì where‚Äù
  "
  (s-collapse-whitespace ;; Convert all adjacent whitespace chars to a single space.
   (s-replace
      (car (s-match "(.*) : Set" declaration))
      ": Set"
      declaration))
)

(defun insert-parameter (param declaration)
  "Given a declaration of the form
   ‚ÄúPackageFormer Semigroup (existing-params) : Set ‚Ñì where‚Äù
   return
   ‚ÄúPackageFormer Semigroup (existing-params) ‚Äòparam‚Äô : Set ‚Ñì where‚Äù

   Precondition: ‚Äòparam‚Äô is a string.
  "
  (let ((rest-of-line (car (s-match ": Set.*" declaration))))
  (s-replace
      rest-of-line
      (concat param " " rest-of-line)
      declaration)
  )
)
  #+END_SRC

  #+RESULTS:
  : insert-parameter

  Let's test these out:
  #+BEGIN_SRC emacs-lisp :exports both
(erase-parameters "PackageFormer Semigroup (v : Variation) (C : Set) : Set where")
  #+END_SRC

  #+RESULTS:
  : PackageFormer Semigroup : Set where

  # Notice the superfluous whitespace is /not/ collapsed for parameter insertion.
  #+BEGIN_SRC emacs-lisp :exports both
(insert-parameter "(Carrier : Set)"
  (erase-parameters "PackageFormer Semigroup (v : Variation) : Set where"))
  #+END_SRC

  #+RESULTS:
  : PackageFormer Semigroup (Carrier : Set) : Set where

  A naturally expected property is if we obtain the variation symbol of a package former,
  erase said parameter, then insert it; then we have essentially done nothing.
  #+BEGIN_SRC emacs-lisp :exports both :results replace
(let* ((ex "PackageFormer Semigroup (ww : Variation) : Set where")
       (vd "(%ww : Variation)"))

  (and (equal "PackageFormer Semigroup : Set where" (erase-parameters ex))
       (equal ex (insert-parameter vd (erase-parameters ex))))
)
  #+END_SRC

  #+RESULTS:
    | nil |

  Excellent üòé

** ‚Äúto lists‚Äù
   :PROPERTIES:
   :CUSTOM_ID: -to-lists-
   :END:
 For uniformity, the ~args~ will generally be a single function.
 We introduce ‚Äúto lists‚Äù as a nice concrete syntax for functions involving
 case analysis. These meta-lists occur in existing Agda notation and so
 we overload them for sake of familiarity ---in actuality, we are generalising the existing form.

 {{{fold(~parse-labelled-to-list~)}}}
 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
(cl-defun parse-labelled-to-list (label the-list &key (no-to nil))

     "Given a ‚Äúto-list‚Äù of the form ‚Äúlabel (x‚ÇÄ to y‚ÇÄ; ‚Ä¶; x‚Çô to y‚Çô; Œª x ‚Üí Bx)‚Äù
      yield the Lisp list of dotted pairs ‚Äú( ((x‚ÇÄ . y‚ÇÄ) ‚ãØ (x‚Çô . y‚Çô)) ‚Äú(lambda (x) Bx)‚Äù)‚Äù
      where the *optional* final clause of the to-list is considered a default or ‚Äòotherwise‚Äô
      case and is converted into a legitimate Lisp function.

      No label results in to-list becoming a dotted list.
      When the otherwise clause is absent, it defaults to the identity function.

      If ‚Äúno-to‚Äù is true, then we do not parse the to-clauses, yielding
      a list of strings.

      Errors on an empty list. Yields nil if the label is not found.
      Note that n = 0 is fine, provided the otherwise clause
      is present.
     "

     (when (or (equal (car (s-split " " (s-trim the-list))) label) (s-blank? (s-trim label)))

     (-let* ( ;; (label "var") (the-list "var ()") no-to
         (result (thread-last the-list

              ;; Discard identifying label
              (pf--substring-delimited-here (format "%s ($here)" label))

              ;; Split along semicolons.
              (s-split ";")

              ;; Removed superflous whitespace
              (--map (s-trim it))))

         otherwise var)

       ;; If there is a ‚Äúotherwise‚Äù function to apply,
       ;; then turn it into a Lisp function and drop it
       ;; from the prefix of the to-list. Else, set otherwise to identity.
       (if (not (s-contains? "Œª" (car (-take-last 1 result))))

       (setq otherwise #'identity)

     ;; Drop the Agda's Œª‚Üí in-favour of Lisp's (lambda ‚ãØ).
     ;; Replace Agda catenation's with Lisp concat.
     (setq otherwise (thread-last (car (-take-last 1 result))
           (s-replace "++" " ")
           (pf--substring-delimited-here "Œª $here")
           (s-split " ‚Üí ")
           (funcall-it (format "(lambda (%s) (concat %s))" (car it) (cadr it)))
           read-from-string
           car
           ))

     (setq result (-drop-last 1 result)))

       ;; Turn into dotted pairs, unless suggested otherwise.
       ;; Need to ensure ‚Äòresult‚Äô is non-empty; since it may
       ;; be a singleton that was dropped into the ‚Äòotherwise‚Äô.
       (when (and result (not no-to))
     (setq result (thread-last result
         (--map (s-split " to " it))
         ;; Need to ensure it's a list of pairs; otherwise something went wrong.
         ;; Suffices to ensure the head element has a second component.
         (funcall-it (if (cadar it)
         (--map (cons (s-trim (first it)) (s-trim (second it))) it)
         (message "parse-labelled-to-list: Is this ‚Äúto-list‚Äù well-formed: %s ‚Åá" (pp it)) it))))) ;; No desire to error since we may parse non 700-syntax.
       (list result otherwise)
)))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp :tangle no
(ert-deftest parse-tos ()

  ;; Expected use
  (should (equal '(("a" . "b") ("c" . "d")) (car(parse-labelled-to-list "map"  "map (a to b; c to d)"))))
  (should (equal '(("a" . "b")) (car(parse-labelled-to-list "map"  "map (a to b)"))))
  (should (equal '(("a" . "b")) (car(parse-labelled-to-list "map"  "map (a to b; Œª x ‚Üí x)"))))
  (should (equal (lambda (x) (concat x)) (cadr(parse-labelled-to-list "map"  "map (a to b; Œª x ‚Üí x)"))))
  (should (equal (lambda (x) (concat x "‚Ä≤")) (cadr(parse-labelled-to-list "map"  "map (a to b; Œª x ‚Üí x ++ \"‚Ä≤\")"))))
  (should (equal (lambda (x) (concat x "‚Ä≤")) (cadr(parse-labelled-to-list "map" "map (Œª x ‚Üí x ++ \"‚Ä≤\")"))))

  ;; Empty list is fine.
  (should (equal '((("")) identity)  (parse-labelled-to-list "map" "map ()")))

  ;; Singleton list
  (should (equal '(("a" . "b")) (car (parse-labelled-to-list "map"  "map (a to b)"))))
    (should (equal '(("one-arg")) (car (parse-labelled-to-list "map" "map (one-arg)"))))

  ;; No label results in to-list becoming a dotted list.
  (should (equal '(("a" . "b") ("c" . "d")) (car(parse-labelled-to-list ""  "(a to b; c to d)"))))

  ;; Unmatched label.
  (should (equal nil (car(parse-labelled-to-list "mapp"  "map (a to b)"))))

  ;; Not ill-formed list ---one arg list!
  (should (parse-labelled-to-list "map"  "map (a what b)"))
)
 #+END_SRC
 {{{end-fold}}}

** Namespacing                                        :experimenting:
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-Namespacing
   :END:

 # Warning: Many instances instance of ‚Äúdefun‚Äù are actually ‚Äúcl-defun‚Äù in disguise!
 # This is because the name-space hack currently used is wrapped in an ‚Äúeval‚Äù,
 # which consequently requires _all_ non-defun declarations to be quoted.

 #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
;; The ‚Äúeval‚Äù requires all non-defun declarations to be quoted;
;; we get around this by locally macroletting relevant declarations.
(eval (cl-macrolet ((defun (&rest more) `(cons 'cl-defun (quote ,more)))
                    (defmacro (&rest more) `(cons 'defmacro (quote ,more)))
                    ;; (defstruct (&rest more) `(cons 'defstruct (quote ,more)))
                    (defvar    (&rest more) `(cons 'defvar (quote ,more))))
        (cl-flet ((require (pkg) `(require (quote ,pkg))))

          (define-namespace woah-
(list 'progn
       #+END_SRC

       End Namespace Declaration :experimenting:

       #+BEGIN_SRC emacs-lisp :tangle agda-next-700-module-systems.el
      ))))) ;; End namespace
 #+END_SRC
