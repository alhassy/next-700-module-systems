#+title: Progressing on a type theory for =PackageFormer=
#+author: Musa Al-hassy
#+agda_version: 2.6.0.1

# Some blocks are marked â€œhaskellâ€ so that they are coloured and #not#
# interpreted as agda blocks. They're informal and do not typecheck.

* Table of Contents                                    :Github:TOC_4:
- [[#semantics-via-ma-sets][Semantics via â€œMA-Setsâ€]]
  - [[#syntactic-sugar--imports][Syntactic Sugar & imports]]
  - [[#type-of-declarations][Type of Declarations]]
  - [[#contexts-are-sets-contexts-over-contexts-are-indexed-contexts][Contexts are sets; â€œcontexts over contextsâ€ are indexed-contexts]]
  - [[#normal-forms][Normal Forms]]
    - [[#packageformers-and-derived-__][PackageFormers and derived =_âŠ_=]]
  - [[#meta-primitives-as-functions][Meta-Primitives as Functions]]
  - [[#algebraic-structure----ma-sets][Algebraic Structure ---â€œ<<<MA-Sets>>>â€]]
- [[#shallow-embedding-approach][Shallow Embedding Approach]]
  - [[#imports][Imports]]
  - [[#syntax-declarations][Syntax Declarations]]
  - [[#contexts-types-and-terms][Contexts, types, and terms]]
    - [[#types][types]]
    - [[#terms][terms]]
    - [[#context-constructors][context constructors]]
  - [[#coercisions-and-Ï€][Coercisions and Î ]]
  - [[#lam-and-app][=lam= and =app=]]
  - [[#example-terms][Example terms!]]
- [[#old-approach-using-deep-embedding][Old Approach using Deep Embedding]]
  - [[#imports-1][Imports]]
  - [[#fixity--syntax-declarations][Fixity & syntax declarations]]
  - [[#declarations-for-mutually-recursive-dtl-concepts][Declarations for mutually recursive DTL concepts]]
  - [[#packageformer-syntax][PackageFormer syntax]]
  - [[#declarations-in-context][â€œdeclarations in contextâ€]]
  - [[#decision-procedure-for-tedious-proofs][Decision procedure for tedious proofs]]
  - [[#types-in-context][â€œtypes in contextâ€]]
  - [[#type-names-of][=type-names-of=]]
  - [[#a-hierarchy-of-dependent-weakening-rules][A hierarchy of dependent weakening rules]]
  - [[#how-many-arguments-does-a-type-have][How many â€˜argumentsâ€™ does a type have?]]
  - [[#the-subparts-of-a-type-expression][The subparts of a type expression]]
  - [[#terms-in-context][â€œterms in contextâ€]]
  - [[#examples][Examples]]
  - [[#semantics][Semantics]]
  - [[#further-experiments][Further experiments]]

* Semantics via â€œMA-Setsâ€

#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
-- The .agda file is trangled from an org file.
module semantics-via-MA-Sets

  -- We need an ambient type theory:
  --
  -- An infinite set of variable names
  (ğ• : Set)
  -- A typing judgement for terms e of
  -- type Ï„ in a context Î“,
  -- which we write Î“ âŠ¢ e : Ï„
  (let Context = Set)
  (Expr    : Set)
  (_âŠ¢_âˆ¶_ : Context â†’ Expr â†’ Expr â†’ Set)
  (_âŠ¢_type : Context â†’ Expr â†’ Set)

  where
  -- TODO: Ignoring optional definitions for now.
#+END_SRC

** Syntactic Sugar & imports
#+BEGIN_SRC agda2  :tangle semantics-via-MA-Sets.agda
open import Data.Unit
open import Data.Product hiding (_,_)
open import Data.Nat
open import Data.Sum
open import Relation.Binary.PropositionalEquality
open â‰¡-Reasoning

Î£âˆ¶â€¢ : âˆ€ {a b} (A : Set a) (B : A â†’ Set b) â†’ Set _
Î£âˆ¶â€¢ = Î£

infix -666 Î£âˆ¶â€¢
syntax Î£âˆ¶â€¢ A (Î» x â†’ B) = Î£ x âˆ¶ A â€¢ B
       #+END_SRC

** Type of Declarations
  Given an ambient type theory ğ‘», we define the type =Declaration= to be the
  triples ~n âˆ¶ Ï„ â‰” Î´~ where =n= is a â€˜nameâ€™, =Ï„= is a type of the given type theory, and
  =Î´= is a term over that type theory, possibly adjoined with other declarations
  =náµ¢ : Ï„áµ¢ â‰” Î´áµ¢=; i.e., the context ~ğ‘», nâ‚€ : Ï„â‚€ â‰” Î´â‚€, â€¦, nâ‚˜ : Ï„â‚˜ â‰” Î´â‚˜~ ensures ~Ï„~ is
  a type and ~Î´~ is of that type, and ~n~ must be a fresh name.

#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
data Declaration (Î“ : Context) : Set where
  _âˆ¶_â‰”_ : (n : ğ•) {Ï„ Î´ : Expr} â†’ Î“ âŠ¢ Ï„ type â†’ Î“ âŠ¢ Î´ âˆ¶ Ï„ â†’ Declaration Î“
    #+END_SRC

** Contexts are sets; â€œcontexts over contextsâ€ are indexed-contexts

#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
âˆ… : Context
âˆ… = âŠ¤

type : Context â†’ Setâ‚
type Î“ = Î“ â†’ Set

_â¨¾_ : (Î“ : Context) (Ï„ : type Î“) â†’ Context
Î“ â¨¾ Ï„ = Î£ Î³ âˆ¶ Î“ â€¢ Ï„ Î³

-- We need to be able to speak about â€œcontexts over contextsâ€

Contextâ€² : Context â†’ Setâ‚
Contextâ€² Î = Î â†’ Set

âˆ…â€² : âˆ€ {Î} â†’ Contextâ€² Î
âˆ…â€² = Î» _ â†’ âŠ¤

typeâ€² : âˆ€ {Î} â†’ Contextâ€² Î â†’ Setâ‚
typeâ€² Î“ = âˆ€ {Î¾} â†’ Î“ Î¾ â†’ Set

_â¨¾â€²_ : âˆ€ {Î} â†’ (Î“ : Contextâ€² Î) (Ï„ : typeâ€² Î“) â†’ Contextâ€² Î
Î“ â¨¾â€² Ï„ = Î» Î¾ â†’ Î£ Î³ âˆ¶ Î“ Î¾ â€¢ Ï„ Î³
#+END_SRC

** Normal Forms
  Ignoring the concrete syntax, every PackageFormer has a canonical flattened form:
#+begin_example haskell
LHS = âˆ… â¨¾ nâ‚€ âˆ¶ Ï„â‚€ â‰” dâ‚€ â¨¾ â‹¯ â¨¾ nâ‚˜ âˆ¶ Ï„â‚˜ â‰” dâ‚˜ âŸ´ :waist ğ“Œ âŸ´ :kind ğ“€
#+end_example

The â€œâ¨¾â€ is read â€œextended-byâ€ and the definitional clauses $dâ‚–$ may involve any
of the names $náµ¢$ for $i < k$.  It is an a *right* action:
#+begin_example haskell
_â¨¾_ : PackageFormer â†’ Declaration â†’ PackageFormer
#+end_example

# Where the semigroup structure on declarations is determined
# by sequential composition: If ~eáµ¢~ are declarations, then ~eâ‚€â¨¾â‹¯â¨¾eâ‚™~
# is a â€˜singleâ€™ declaration.

The canonical form suggests that /PackageFormers are triples/
consisting of a context, a number, and a tag.

Instead of $âˆ… â¨¾ nâ‚€ âˆ¶ Ï„â‚€ â‰” dâ‚€ â¨¾ â‹¯ â¨¾ nâ‚˜ âˆ¶ Ï„â‚˜ â‰” dâ‚˜ âŸ´ :waist ğ“Œ âŸ´ :kind ğ“€$ let us
write $eâ‚€ â¨¾ â€¦ â¨¾ e_ğ“Œ â™_{ğ“€} e_{ğ“Œ+1}â¨¾ â€¦ eâ‚˜$.
- When the kind ğ“€ is uninteresting, or may be arbitrary, we shall omit it from
  the notation altogether. Likewise for the separator â€˜â™â€™.

We may now define a composition operation on PackageFormers, via
pushout or disjoint union; e.g., $(Î“â‚ â™ Î“â‚‚) âŠ (Î“â‚â€² â™ Î“â‚‚â€²) = Î“â‚â€³ â™ Î“â‚‚â€³$ where Î“áµ¢â€³
is catenation of Î“áµ¢ and Î“áµ¢â€², in some fixed chosen order.

We may also define a dual form of extension, known as â€œsnocâ€ when â¨¾ is read
â€œconsâ€.
#+begin_src haskell
_â¸µ_ : Declaration â†’ PackageFormer â†’ PackageFormer
e â¸µ (Î“â‚ â™ Î“â‚‚) = ((âˆ… â¨¾ e) âŠ Î“â‚) â™ Î“â‚‚
#+end_src

In the informal notation of contexts of type theory, the three operations â¸µ, â¨¾,
âŠ are denoted â€œ,â€.

*** PackageFormers and derived =_âŠ_=
 #+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
record PackageFormer : Setâ‚ where
  constructor _â™_
  field
    parameters : Context
    body       : Contextâ€² parameters

_âŠâ‚š_ : PackageFormer â†’ PackageFormer â†’ PackageFormer
(Î“â‚ â™ Î“â‚‚) âŠâ‚š (Î“â‚â€² â™ Î“â‚‚â€²) = (Î“â‚ âŠ Î“â‚â€²) â™ [ Î“â‚‚ , Î“â‚‚â€² ]
 #+END_SRC

** Meta-Primitives as Functions

With a notation and understanding of what a PackageFormer
consists of, we are in a position to provide a semantics
for the meta-primitives.

# :waist, :kind, â–·, and âŸ´ are syntactic constructors.

First, ~waist~ is lifted from a syntactic construct to a function operation on
PackageFormers as follows.
#+begin_src haskell
_waist_ : PackageFormer â†’ â„• â†’ PackageFormer
(Î“â‚ â™ Î“â‚‚) waist 0       = âˆ… â™ (Î“â‚ âŠ Î“â‚‚)
(Î“â‚ â™ Î“â‚‚) waist (n + 1) = (head Î“â‚) â— (tail Î“â‚ â™ Î“â‚‚) waist n

where head : PackageFormer â†’ Maybe Declaration
      head âˆ… = Nothing
      head (eâ‚, â€¦, eâ‚™ â™ Î“â‚‚) = Just eâ‚

      tail : PackageFormer â†’ PackageFormer
      tail âˆ… = âˆ…
      tail (eâ‚ â— Î“) = Î“
#+end_src

That is, if $Î“ = eâ‚€â¨¾ â‹¯â¨¾ eâ‚˜$, ignoring the separator, then
$Î“ waist n â‰ˆ eâ‚€â¨¾ â‹¯â¨¾ eâ‚™ â™ eâ‚™â‚Šâ‚â¨¾ â‹¯â¨¾ eâ‚˜$. That is, =waist= introduces
a partition in a context. Operationally, only the associated number
component of a PackageFormer has been altered.

** Algebraic Structure ---â€œ<<<MA-Sets>>>â€

Contexts have a monoidal structure determined by pushouts; i.e., disjoint unions
âŠ and the empty PackageFormer âˆ….  Indeed, we have a mutual-associativity law
$(Î“â‚ âŠ Î“â‚‚) â¨¾ e = Î“â‚ âŠ (Î“â‚‚ â¨¾ e)$ ---which may serve to define âŠ.

# ---in the concrete syntax this becomes:
# =Î“ extended-by "eâ‚" âŸ´ extended-by "eâ‚‚" â‰ˆ Î“ extended-by "eâ‚; eâ‚‚".=
# With this approach, the structure of declarations mimics the notion of a context from type theory.
# Indeed, we also have the â€˜emptyâ€™ declaration, denoted =""=
# in concrete syntax and as Îµ abstractly.

Note that we do not have a monoidal action since â¨¾ and âŠ do not satisfiy the
necessary coherence laws ---even worse, the right law $(Î“ â¨¾ eâ‚) â¨¾ eâ‚‚ = Î“ â¨¾ (eâ‚ âŠ
eâ‚‚)$ and the left law $Î“â‚ â¨¾ (Î“â‚‚ â¨¾ e) = (Î“â‚ âŠ Î“â‚‚) â¨¾ e$ are both ill-typed. Hence,
we have no hope of using âŠ/â¨¾ to trivially obtain a left/right monoidal action.

In order to define a semantics, we need a notion of models in which to interpret
the syntactic PackageFormer entities.  Since left and right monoid-sets have
been ruled out, we shall formulate another species to fit the structure embedded
in PackageFormer.

Define a â€œMA-Setâ€, or a â€˜Mâ€™utually â€˜Aâ€™ssocitive structure to be a triple (â„³, ğ’®,
Â·) where â„³ is a monoid, ğ’® is a set, and $_Â·_ : â„³ â†’ ğ’® â†’ â„³$ is an action that is
mutually associative with the monoidal operation, $(mâ‚ âŠ• mâ‚‚) Â· y = mâ‚ âŠ• (mâ‚‚ Â·
y)$.

 #+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
record MA-Set : Setâ‚ where
  field
    â„³  : Set
    _âŠ•_ : â„³ â†’ â„³ â†’ â„³
    Id  : â„³
    ğ’œ :  Set
    _Â·_ : â„³ â†’ ğ’œ â†’ â„³
    -- TODO: Ommiting axioms for now.

open MA-Set
 #+END_SRC

- This is nearly an M-Set, but the functoriality law has been replaced by the
   an associtivity law.

- Unlike M-Sets in which a monoids â€œactsâ€ on a set, in a MA-Set we have the set
  acting on the monoid.

As discussed earlier, PackageFormers form a MA-Set ---and are the motivation of
introducing MA-Sets.

Given two MA-Sets (â„³, ğ’œ, Â·) and (â„³â€², ğ’œâ€², Â·â€²), define a /MA-Set homomorphism/ to be
a pair of functions /hâ‚ : â„³ â†’ â„³â€², hâ‚‚ : ğ’œ â†’ ğ’œâ€²/ that preserve the structure on each
set and respect the action; i.e.,
1. $hâ‚$ is a monoid homomorphism
2. $hâ‚ (m Â· a) â‰ˆ hâ‚ m Â·â€² hâ‚‚ a$, a reasonable coherence condition.

 #+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
record Hom (Src Tgt : MA-Set) : Setâ‚ where
  field
    morâ‚ : â„³ Src â†’ â„³ Tgt
    morâ‚‚ : ğ’œ Src â†’ ğ’œ Tgt
    pres-Id : morâ‚ (Id Src) â‰¡ Id Tgt
    pres-âŠ•  : âˆ€ {x y} â†’ morâ‚ (_âŠ•_ Src x y) â‰¡ _âŠ•_ Tgt (morâ‚ x) (morâ‚ y)
    coherence : âˆ€ {m a} â†’ morâ‚ (_Â·_ Src m a) â‰¡ _Â·_ Tgt (morâ‚ m) (morâ‚‚ a)

open Hom
 #+END_SRC

Theorems:
1. (Id, Id) is a MA-Set homomorphism for any (â„³, ğ’œ)-set.
   - Sketch: Id is a monoid homomorphism, and the coherence
     condition is true by â‰ˆ-reflexivity.

   - Formally:
      #+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
id : âˆ€ {MA : MA-Set} â†’ Hom MA MA
id = record
  { morâ‚      = Î» x â†’ x
  ; morâ‚‚      = Î» x â†’ x
  ; pres-Id   = refl
  ; pres-âŠ•    = refl
  ; coherence = refl
  }
 #+END_SRC

2. MA-Set homomorphisms are closed under composition.
   - Sketch: The composition of monoid homomorphisms is again
     a homomorphism; it remains to check coherence:
    #+BEGIN_SRC haskell
     (fâ‚ âˆ˜ gâ‚) (m Â· a)
    = fâ‚ (gâ‚ (m Â· a))
    = fâ‚ (gâ‚ m Â· gâ‚‚ a)
    = fâ‚ (gâ‚ m) Â· fâ‚‚ (gâ‚‚ a)
    = (fâ‚ âˆ˜ gâ‚) m Â· (fâ‚‚ âˆ˜ gâ‚‚) a
#+END_SRC
    Whence, the coherence condition is true.

   - Formally:
    #+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
_âˆ˜_ : âˆ€ {MA MB MC : MA-Set}
    â†’ Hom MB MC
    â†’ Hom MA MB
    â†’ Hom MA MC
_âˆ˜_ {MA} {MB} {MC} F G = record
  { morâ‚ = Î» x â†’ morâ‚ F (morâ‚ G x)
  ; morâ‚‚ = Î» x â†’ morâ‚‚ F (morâ‚‚ G x)
  ; pres-Id = trans (cong (morâ‚ F) (pres-Id G)) (pres-Id F)
  ; pres-âŠ• = Î» {x y} â†’ begin
      morâ‚ F (morâ‚ G (_âŠ•_ MA x y))          â‰¡âŸ¨ cong (morâ‚ F) (pres-âŠ• G) âŸ©
      morâ‚ F (_âŠ•_ MB (morâ‚ G x) (morâ‚ G y)) â‰¡âŸ¨ pres-âŠ• F âŸ©
      _âŠ•_ MC (morâ‚ F (morâ‚ G x)) (morâ‚ F (morâ‚ G y)) âˆ
  ; coherence = Î» {m a} â†’ begin
      morâ‚ F (morâ‚ G (_Â·_ MA m a)) â‰¡âŸ¨ cong (morâ‚ F) (coherence G) âŸ©
      morâ‚ F (_Â·_ MB (morâ‚ G m) (morâ‚‚ G a)) â‰¡âŸ¨ coherence F âŸ©
      _Â·_ MC (morâ‚ F (morâ‚ G m)) (morâ‚‚ F (morâ‚‚ G a)) âˆ }
 #+END_SRC

3. MA-Sets form a category.

The goal is then to show that MA-Sets have PackageFormer as an initial object!
---Initial semantics!

* Shallow Embedding Approach :typechecks:

In the setup below, it seems using the context approach can sometimes be easier
than using the Î» approach, even though they are essentially the same.
Intuitively:
| What doing? | Easier to use |
|-------------+---------------|
| Reasoning   | Context       |
| Programming | Functions     |

** Imports
 #+BEGIN_SRC agda2
module pf where

open import Level renaming (zero to â„“zero; suc to â„“suc; _âŠ”_ to _âŠ_)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl)
open import Data.Nat
open import Data.Unit
open import Data.Empty
open import Data.Bool
open import Data.List
open import Data.List.Membership.Propositional
open import Data.List.Relation.Unary.Any using (here; there)
open import Relation.Nullary using (yes; no)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.String using (String) renaming (_==_ to _==â‚›_; _â‰Ÿ_ to _â‰Ÿâ‚›_; _++_ to _++â‚›_)
open import Data.Product using (Î£ ; projâ‚ ; projâ‚‚ ; _Ã—_ ; _,_)

 #+END_SRC

** Syntax Declarations
 #+BEGIN_SRC agda2

Name = String

Î£âˆ¶â€¢ : âˆ€ {a b} (A : Set a) (B : A â†’ Set b) â†’ Set _
Î£âˆ¶â€¢ = Î£

infix -666 Î£âˆ¶â€¢
syntax Î£âˆ¶â€¢ A (Î» x â†’ B) = Î£ x âˆ¶ A â€¢ B

infixr 10 Î 
syntax Î  A (Î» x â†’ B) = Î  x âˆ¶ A â€¢ B

infix 9 _âŠ¢Term_

 #+END_SRC
** Contexts, types, and terms

   Contexts are types, level-indexed types are functions, Ï„-terms are functions taking
   the context and yielding a value.

  #+BEGIN_SRC agda2
PackageFormer : (i : Level) â†’ Set (â„“suc i)
PackageFormer i = Set i
 #+END_SRC

*** types
  Next, object-level universes are implemented using meta-level universes.
  - Note: =Î“ âŠ¢Type ğ’¾  â‰¡  Î“ âŠ¢Term (ğ’° ğ’¾)=.

  #+BEGIN_SRC agda2
_âŠ¢Type_ :  âˆ€ {i} â†’ PackageFormer i â†’ (j : Level) â†’ Set (i âŠ â„“suc j)
Î“ âŠ¢Type ğ’¾ = Î“ â†’ Set ğ’¾

ğ’° : âˆ€ {i} {Î“ : PackageFormer i} (j : Level) â†’ Î“ âŠ¢Type (â„“suc j)
ğ’° j = Î» Î³ â†’ Set j
  #+END_SRC
*** terms
  #+BEGIN_SRC agda2
_âŠ¢Term_ : âˆ€ {i j} â†’ (Î“ : PackageFormer i) â†’ Î“ âŠ¢Type j â†’ Set (i âŠ j)
Î“ âŠ¢Term Ï„ = (Î³ : Î“) â†’ Ï„ Î³
  #+END_SRC

  After all, a classical context ~xâ‚ : Ï„â‚, â€¦, xâ‚™ : Ï„â‚™ âŠ¢ e : Ï„~ only /asserts/ =e : Ï„=
  /provided/ =xáµ¢ : Ï„áµ¢=, and so the latter is a function of the former! Indeed, as the
  Î»-introduction rule shows, *all contexts are the humble function*
  ---e.g., with church encodings, we have that algebraic data-types are also
  functions, the eliminators.
  + MA: Perhaps with this neato observation, I should simply focus on functions?

*** context constructors

  The empty context is the unit type and context extension is interpreted using Î£-types.
  The identity of dependent products is the unit type, whence it denotes the empty PackageFormer.

 #+BEGIN_SRC agda2
Îµ : PackageFormer â„“zero
Îµ = âŠ¤

_â–·_ : âˆ€ {i j} (Î“ : PackageFormer i) â†’ Î“ âŠ¢Type j â†’ PackageFormer (i âŠ j)
Î“ â–· A = Î£ Î³ âˆ¶ Î“ â€¢ A Î³

  #+END_SRC
** Coercisions and Î 

 #+BEGIN_SRC agda2
weaken : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type k}
       â†’ Î“ âŠ¢Type j â†’ (Î“ â–· A) âŠ¢Type j
weaken Ï„ (Î³ , a) = Ï„ Î³

pf-refl : âˆ€ {i j} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j}
        â†’ (Î“ â–· A) âŠ¢Term weaken A
pf-refl = projâ‚‚

Î  : âˆ€ {i j k} {Î“ : PackageFormer i} (A : Î“ âŠ¢Type j) (B : (Î“ â–· A) âŠ¢Type k)
  â†’ Î“ âŠ¢Type (j âŠ k)
Î  A B = Î» Î³ â†’ âˆ€ (a : A Î³) â†’ B (Î³ , a)

_â‡’_ : âˆ€ {i j k} {Î“ : PackageFormer i} (A : Î“ âŠ¢Type j) (B : Î“ âŠ¢Type k)
    â†’ Î“ âŠ¢Type (j âŠ k)
A â‡’ B = Î  A (weaken B)

 #+END_SRC
** =lam= and =app=
 Abstraction and application are just Currying & Uncurrying
 #+BEGIN_SRC agda2
lam : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j} {B : (Î“ â–· A) âŠ¢Type k}
    â†’ (Î“ â–· A) âŠ¢Term B  â†’  Î“ âŠ¢Term (Î  A B)
lam g = Î» Î³ â†’ Î» a â†’ g (Î³ , a)

app : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j} {B : (Î“ â–· A) âŠ¢Type k}
      â†’  Î“ âŠ¢Term (Î  A B)  â†’ (Î“ â–· A) âŠ¢Term B
app g = Î»{(Î³ , a) â†’ g Î³ a}
 #+END_SRC

 Here are other forms of function application.
 #+BEGIN_SRC agda2
cutâ€² : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j} {B : Î“ âŠ¢Type k}
      â†’  (Î“ â–· A) âŠ¢Term weaken B
      â†’  Î“       âŠ¢Term A
      â†’  Î“       âŠ¢Term B
cutâ€² f a = Î» Î³ â†’ f (Î³ , a Î³)

_on_ : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j}
      â†’ (Î“ â–· A) âŠ¢Type k
      â†’  Î“ âŠ¢Term A
      â†’  Î“ âŠ¢Type k
f on a = Î» Î³ â†’ f (Î³ , a Î³)

cut : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j} {B : (Î“ â–· A) âŠ¢Type k}
      â†’  (Î“ â–· A) âŠ¢Term B
      â†’  (a : Î“  âŠ¢Term A)
      â†’  Î“       âŠ¢Term (B on a)
cut f a = Î» Î³ â†’ f (Î³ , a Î³)

_$_ : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j} {B : (Î“ â–· A) âŠ¢Type k}
      â†’ Î“ âŠ¢Term (Î  A B)
      â†’ (a : Î“ âŠ¢Term A)
      â†’ Î“ âŠ¢Term (B on a)
_$_ g = Î» a Î³ â†’ g Î³ (a Î³)
 #+END_SRC

** Example terms!

 #+BEGIN_SRC agda2
â€µid : Îµ âŠ¢Term Î  A âˆ¶ ğ’° â„“zero â€¢ let Aâ€² = Î» _ â†’ projâ‚‚ A -- weakening.
                              in (Aâ€² â‡’ Aâ€²) Îµ
â€µid = lam (lam projâ‚‚)
 #+END_SRC

 Let's try to show that =pf-refl= really is the identity function, up to isomorphism.
 #+BEGIN_SRC agda2
â€µidâ‚‚ : âˆ€ {i j} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j}
     â†’ Î“ âŠ¢Term A â‡’ A
â€µidâ‚‚ = lam pf-refl
 #+END_SRC

 Neato! Progress, finally (à¸‡à² _à² )à¸‡
* Old Approach using Deep Embedding :incomplete:holes:

  #+begin_example agda2
module pf where
#+end_example
** Imports
#+begin_example agda2
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl)
open import Data.Nat
open import Data.Unit
open import Data.Empty
open import Data.Bool
open import Data.List
open import Data.List.Membership.Propositional
open import Data.List.Relation.Unary.Any using (here; there)
open import Relation.Nullary using (yes; no)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.String using (String) renaming (_==_ to _==â‚›_; _â‰Ÿ_ to _â‰Ÿâ‚›_; _++_ to _++â‚›_)
open import Data.Product using (Î£ ; projâ‚ ; projâ‚‚ ; _Ã—_ ; _,_)
Name = String
#+end_example
** Fixity & syntax declarations
#+begin_example agda2
infix 11 eq
syntax eq Ï„ l r  =  l â€µâ‰¡ r âˆ¶ Ï„

infixr 10 _â€µâ†’_ â€µâˆ€
syntax â€µâˆ€ Ï„ (Î» Î· â†’ Î³) = Î  Î· âˆ¶ Ï„ â€¢ Î³ -- â€œZ-notationâ€

-- infixl 9 _âˆ¶_ _âˆ¶_â‰”_
infixl 9 _âˆ¶_

infixl 5 _extended-by_

Î£âˆ¶â€¢ : âˆ€ {a b} (A : Set a) (B : A â†’ Set b) â†’ Set _
Î£âˆ¶â€¢ = Î£

infix -666 Î£âˆ¶â€¢
syntax Î£âˆ¶â€¢ A (Î» x â†’ B) = Î£ x âˆ¶ A â€¢ B
#+end_example
** Declarations for mutually recursive DTL concepts
#+begin_example agda2
data PF : Set                          -- Syntax of PackageFormers; i.e., contexts
data _âŠ¢Type (Î“ : PF) : Set             -- Types in context
type-names-of : PF â†’ List Name
-- types-of : (Î“ : PF) â†’ List (Î“ âŠ¢Type)   -- The collection of types mentioned in a context
record _âŠ¢constituent (Î“ : PF) : Set    -- The type of terms
data _âŠ¢Term:_ (Î“ : PF) : Î“ âŠ¢Type â†’ Set -- Terms in context
#+end_example
** PackageFormer syntax
#+begin_example agda2
data PF where
  empty : PF
  _extended-by_ : (Î“ : PF) â†’ Î“ âŠ¢constituent â†’ PF
#+end_example
** â€œdeclarations in contextâ€
#+begin_example agda2
record _âŠ¢constituent Î“ where
  -- constructor _âˆ¶_â‰”_
  constructor _âˆ¶_
  inductive
  field
    name     : Name
    type     : Î“ âŠ¢Type
    -- equation : Maybe (Î“ âŠ¢Term: type)
    -- Ommitted for brevity

open _âŠ¢constituent

{-
_âˆ¶_ : âˆ€ {Î“} â†’ Name â†’ Î“ âŠ¢Type â†’ Î“ âŠ¢constituent
x âˆ¶ Ï„ = x âˆ¶ Ï„ â‰” nothing
-}
#+end_example
** Decision procedure for tedious proofs
#+begin_example agda2
-- Soundness: Let's construct a decision procedure that actually provides tedious proofs.
-- This is used in the ADT â€œ_âŠ¢Typeâ€.

data Error : String â†’ Set where

present? : Name â†’ List Name â†’ Set
present? Î· []       = Error ("The type â€œ" ++â‚› Î· ++â‚› "â€ is not in the parent context!")
present? Î· (n âˆ· ns) with Î· ==â‚› n
...| true  = âŠ¤
...| false = present? Î· ns

soundness : âˆ€ {Î· ns} â†’ present? Î· ns â†’ Î· âˆˆ ns
soundness {Î·} {n âˆ· ns} p with Î· â‰Ÿâ‚› n
...| yes q = here q
...| no Â¬q = there (soundness p)

tedious-example : "C" âˆˆ ("A" âˆ· "B" âˆ· "C" âˆ· "D" âˆ· [])
tedious-example = there (there (here refl))

improved-example : "C" âˆˆ ("A" âˆ· "B" âˆ· "C" âˆ· "D" âˆ· [])
improved-example = soundness tt

-- Uncomment to see an error since c is not in the list.
-- useful-error-msg : "c" âˆˆ ("A" âˆ· "B" âˆ· "C" âˆ· "D" âˆ· [])
-- useful-error-msg = soundness tt
#+end_example
** â€œtypes in contextâ€
#+begin_example agda2
{-
  Ï„ âˆ·= Set       â€œuniverse of typesâ€
     | Ï„ â†’ Ï„     â€œfunction typesâ€
     | Î±         â€œatomic types mentioned in the contextâ€
     | e â‰¡ d     â€œterm equality in contextâ€
-}

data _âŠ¢Type Î“ where

  â€µSet  : Î“ âŠ¢Type                                        -- type of small types

  -- â€µâˆ€ : (Ï„ : Î“ âŠ¢Type) (body : Î“ âŠ¢Term: Ï„ â†’ Î“ âŠ¢Type) â†’ Î“ âŠ¢Type -- Pi types, we fail the positivity checker.
  -- In the spirit of gradual typing, we use a weaker form: The assumed term losses any possible definiens, equations.
  â€µâˆ€ : (Ï„ : Î“ âŠ¢Type) (body : (Î· : Name) â†’ (Î“ extended-by Î· âˆ¶ Ï„) âŠ¢Type) â†’ Î“ âŠ¢Type

  _â€µâ†’_ : Î“ âŠ¢Type â†’ Î“ âŠ¢Type â†’ Î“ âŠ¢Type -- function type; making this derived requires a weak form of commuatvity at the context level

  -- variable case; the name must be mentioned in Î“
  â€µ_   : (Î· : Name) {{_ : present? Î· (type-names-of Î“)}} â†’ Î“ âŠ¢Type

  eq : (Ï„ : Î“ âŠ¢Type) (l r : Î“ âŠ¢Term: Ï„) â†’ Î“ âŠ¢Type

{-
_â€µâ†’_ : {Î“ : PF} â†’ Î“ âŠ¢Type â†’ Î“ âŠ¢Type â†’ Î“ âŠ¢Type -- function type
Ï„ â€µâ†’ Î³ = Î  _ âˆ¶ Ï„ â€¢ weaken Î³
-}
#+end_example
** =type-names-of=
#+begin_example agda2
type-names-of empty = []
type-names-of (pf extended-by nameâ‚ âˆ¶ â€µSet) = nameâ‚ âˆ· type-names-of pf
type-names-of (pf extended-by _) = type-names-of pf
#+end_example
** A hierarchy of dependent weakening rules
#+begin_example agda2
{-
weaken1 : âˆ€ {Î“ e} â†’ Î“ âŠ¢Type â†’ (Î“ extended-by e) âŠ¢Type

insert-before-last : âˆ€ {Î“ Î· e Ï„} â†’ (Î“ extended-by Î· âˆ¶ Ï„) âŠ¢Type
                                 â†’ (Î“ extended-by e extended-by Î· âˆ¶ weaken1 Ï„) âŠ¢Type

insert-before-second-last : âˆ€ {Î“ Î·â‚ Î·â‚‚ Ï„â‚ Ï„â‚‚ e}
 â†’ (Î“ extended-by               Î·â‚ âˆ¶         Ï„â‚ extended-by Î·â‚‚ âˆ¶  Ï„â‚‚) âŠ¢Type
 â†’ (Î“ extended-by e extended-by Î·â‚ âˆ¶ weaken1 Ï„â‚ extended-by Î·â‚‚ âˆ¶ insert-before-last Ï„â‚‚) âŠ¢Type
insert-before-second-last Ï„ = {!!}

insert-before-last â€µSet = â€µSet
insert-before-last (â€µâˆ€ Ï„ body) = Î  Î· âˆ¶ insert-before-last Ï„ â€¢  insert-before-second-last (body Î·)
insert-before-last (Ï„ â€µâ†’ Ï„â‚) = {!!}
insert-before-last (â€µ Î·) = {!!}
insert-before-last (eq Ï„ l r) = {!!}

weaken1 â€µSet        = â€µSet
weaken1 (â€µâˆ€ Ï„ body) = Î  Î· âˆ¶ weaken1 Ï„ â€¢ insert-before-last (body Î·)
weaken1 (Ï„ â€µâ†’ Ï„â‚)   = {!!}
weaken1 (â€µ Î·)       = {!!}
weaken1 (eq Ï„ l r)  = {!!}
-}

{- Other weakening rules
weaken-cons : âˆ€ {Î“ e} â†’ Î“ âŠ¢constituent â†’ (Î“ extended-by e) âŠ¢constituent

weaken-mid : âˆ€ {Î“ pre post new} â†’ (Î“ extended-by pre extended-by post) âŠ¢Type
                                â†’ (Î“ extended-by pre extended-by new extended-by weaken-cons post) âŠ¢Type
-}
#+end_example
** How many â€˜argumentsâ€™ does a type have?
#+begin_example agda2
{-

arity : âˆ€ {Î“} â†’ Î“ âŠ¢Type â†’ â„•
arity â€µSet        = 0
arity (â€µâˆ€ Ï„ body) = 1 + arity (body "_") -- Hack; possible since names are strings.
arity (Ï„ â€µâ†’ Ï„â‚)   = 1 + arity Î³  -- E.g., Î± â€µâ†’ (Î² â€µâ†’ Î³) has 2 arguments.
arity (â€µ Î·)       = {!!} -- Need to consider its type in Î“
arity (eq Ï„ l r)  = 0
-}
#+end_example
** The subparts of a type expression
#+begin_example agda2
{--

-- An alias for _â‰¡_; a singleton type
data JustThis {A : Set} : A â†’ Set where
  this : (a : A) â†’ JustThis a

-- If arity Ï„ = 0 then âŠ¤ else the type of the first argument.
type-head : âˆ€ {Î“} â†’ Î“ âŠ¢Type â†’ Set
type-head â€µSet      = âŠ¤
type-head (Ï„ â€µâ†’ _)  = JustThis Ï„
type-head _  = âŠ¤

-- If arity Ï„ = 0 then âŠ¤ else the type of the first argument.
type-tail : âˆ€ {Î“} â†’ Î“ âŠ¢Type â†’ Î“ âŠ¢Type
type-tail Ï„ = {!!}
-}
#+end_example
** â€œterms in contextâ€
#+begin_example agda2
data _âŠ¢Term:_ Î“ where

  -- TODO: â€œx must be fresh for Î“â€; variable case
  â€µ_  : {Ï„ : Î“ âŠ¢Type} (x : Name) â†’ Î“ âŠ¢Term: Ï„

  -- curried function application
  -- _$_ : (f : Î“ âŠ¢constituent) â†’ type-head (type f) â†’ Î“ âŠ¢Term: type-tail (type f) -- Omitted for brevity
#+end_example
** Examples
#+begin_example agda2
Type : PF
Type = empty extended-by "Carrier" âˆ¶ â€µSet

Indistinguishable : PF
Indistinguishable = Type extended-by
                         "blind" âˆ¶ Î  ğ“ âˆ¶ â€µ "Carrier" â€¢ Î  ğ“‡ âˆ¶ â€µ "Carrier" â€¢ â€µ ğ“ â€µâ‰¡ â€µ ğ“‡ âˆ¶ â€µ "Carrier"

Pointed : PF
Pointed = Type extended-by "ğŸ™" âˆ¶ â€µ "Carrier"
-- Typos such as forgetting the final letter produce type-checking errors:
-- The type â€œCarrieâ€ is not in the parent context!
-- Pointed = Type extended-by "ğŸ™" âˆ¶ â€µ "Carrie"

Magma : PF
Magma = Type extended-by "_Â·_" âˆ¶ â€µ "Carrier" â€µâ†’ â€µ "Carrier" â€µâ†’ â€µ "Carrier"
#+end_example
** Semantics
#+begin_example agda2
terms : PF â†’ List (Î£ Î“ âˆ¶ PF â€¢ Î“ âŠ¢constituent)
terms empty = []
terms (p extended-by x) = terms p ++ [ p , x ]

Type-names-of : PF â†’ Set
Type-names-of Î“ = Î£ Î· âˆ¶ Name â€¢ present? Î· (type-names-of Î“)

semâ‚œ : âˆ€ {Î“} â†’ (Type-names-of Î“ â†’ Setâ‚) â†’ Î“ âŠ¢Type â†’ Setâ‚‚
semâ‚‘ : âˆ€ {Î“} {Ï„ : Î“ âŠ¢Type} (Ïƒ : Type-names-of Î“ â†’ Setâ‚) â†’ Î“ âŠ¢Term: Ï„ â†’ Setâ‚ -- semâ‚œ Ïƒ Ï„  â‡  free variables are just placeholders for the types they represent

semâ‚‘ {Î“} {Ï„} Ïƒ (â€µ x) = {!semâ‚œ Ïƒ Ï„!}

open import Level using (Lift)

semâ‚œ Ïƒ â€µSet          = Setâ‚
semâ‚œ Ïƒ (â€µâˆ€ Ï„ body)   = âˆ€ (x : semâ‚œ Ïƒ Ï„) â†’ âŠ¥ -- TODO
semâ‚œ Ïƒ (Ï„ â€µâ†’ Î³)      = semâ‚œ Ïƒ Ï„ â†’ semâ‚œ Ïƒ Î³
semâ‚œ Ïƒ (â€µ_ Î· {{p}})  = Lift _ (Ïƒ (Î· , p))
semâ‚œ Ïƒ (eq Ï„ l r)    = semâ‚‘ Ïƒ l â‰¡ semâ‚‘ Ïƒ r  -- ARGH: semâ‚‘ must yield Setâ‚ so it can be used in semâ‚œ !!!!!!  -- JC, what do?

{-
present?-tn : âˆ€ {Î· Î“ e} â†’   present? Î· (type-names-of (Î“ extended-by e))
                          â‰¡ (if   (Î· ==â‚› name e)
                             then âŠ¤
                             else present? Î· (type-names-of Î“))
present?-tn {Î·} {Î“} {e} with type-names-of (Î“ extended-by e) | Î· ==â‚› name e
present?-tn {Î·} {Î“} {e} | [] | false = {!!}
present?-tn {Î·} {Î“} {e} | [] | true = {!!}
present?-tn {Î·} {Î“} {e} | x âˆ· xs | t = {!!}


weaken-present? : âˆ€ {Î· Î“ e} â†’ present? Î· (type-names-of Î“)
                            â†’ present? Î· (type-names-of (Î“ extended-by e))
weaken-present? {Î·} {Î“ = Î“} p with type-names-of Î“ | p
weaken-present? {Î·} {Î“ = Î“} p | x âˆ· xs | q with Î· ==â‚› x
weaken-present? {Î·} {Î“} p | x âˆ· xs | q | false = {!!}
weaken-present? {Î·} {Î“} p | x âˆ· xs | q | true = {!!}
-}

weaken : âˆ€ {Î“ e}  â†’ Î“ âŠ¢Type â†’ (Î“ extended-by e) âŠ¢Type
weaken â€µSet        = â€µSet
weaken (â€µâˆ€ Ï„ body) = {!!}
weaken (Ï„ â€µâ†’ Î³)   = weaken Ï„ â€µâ†’ weaken Î³
weaken (â€µ_ Î· {{p}})       = â€µ_ Î· {{{!!}}}
weaken (eq Ï„ l r)  = {!!}

termsâ€² : (Î“ : PF) (Ïƒ : Î“ âŠ¢Type â†’ Set) â†’ List (Î£ Î“â€² âˆ¶ PF â€¢ Set Ã— Î“â€² âŠ¢constituent)
termsâ€² empty Ïƒ = []
termsâ€² (p extended-by e@(Î· âˆ¶ Ï„)) Ïƒ = termsâ€² p (Î» x â†’ Ïƒ (weaken x)) ++ [ p , Ïƒ (weaken Ï„) , e ] -- termsâ€² p {!!} ++ [ p , {!!} , {!x!} ]
-- terms p ++ [ p , x ]


{-
sem : (Î“ : PF) (Ïƒ : Î“ âŠ¢Type â†’ Set) (Î± : (Î· : Name) â†’ Î£ T âˆ¶ Set â€¢ T) â†’ Set
sem p Ïƒ Î± with terms p
...| [] = âŠ¥
...| (_ , Î· âˆ¶ Ï„) âˆ· xs = {!!}
  where -- function patching
        Î±â€² : Name â†’ Î£ T âˆ¶ Set â€¢ T
        Î±â€² n = if n ==â‚› Î· then (Ïƒ {!!}) , {!!} else Î± n
-}

#+end_example
** Further experiments
#+begin_example agda2
{-
-- TODO: Add support for catenating PFs.
--
-- _âŒ¢_ : PF â†’ PF â†’ PF
-- l âŒ¢ empty = l
-- l âŒ¢ (r extended-by x) = (l âŒ¢ r) extended-by {! need a weakening rule!}
--

monoid : PF
monoid = empty extended-by "Carrier" âˆ¶ â€µSet
               extended-by "_Â·_" âˆ¶ â€µ "Carrier" â€µâ†’ â€µ "Carrier" â€µâ†’ â€µ "Carrier"
               extended-by "ğŸ™" âˆ¶ â€µ "Carrier"
               extended-by "assoc" âˆ¶ {!!}
-}
  #+end_example
