# TODO User Manual :Incomplete:
# TODO: The ~package-former~ Datatype                         :missing_documentation:
#
:Attach_a_purpose_to_each_heading:

#+begin_center
/purpose of item/
#+end_center

:End:
#+MACRO: goal @@html:<center><em>@@ $1 @@html:</center></em>@@

* COMMENT Issues to fix
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-Issues-to-fix
  :END:
# -- Crashes for some reason, why !? Somethingto do with the printing of pfs?
# -- This won't work, why? Something to do with printing?
# -- MR = M-Set primed
#
# -- MSâ‚ƒâ‚„   = M-Set âŸ´ subscriptedâ‚ƒ
#
#
# Remove *parent-context*!
#        * There is an implementation key, ~*parent-context*~, which is used to
#         capture the current context for error-reporting purposes and should
#         not be altered by the user ---otherwise they may obtain less than helpful
#         error messages.
#
# \begin{lisp} & \begin{700}
#
# HACK: TODO: MA: URGENT: FIXME:
# Element  â‰ˆ  [qualifier] [lhs] [:] [type] [list-of definitional clauses]
# Eqn      â‰ˆ  [same-lhs-as-before] [args] â‰ˆ [term]
#
# One of the allowable â€œtypesâ€ should be any PackageFormer kind?
# That way we have a basic form of nested modules?
#
# extensions,
#     and the flattening of hierarchical structures can be formed;
#
#
# (org-babel-load-file "PackageFormer.org")
# Export all Lisp blocks into a file then load it.
#
# (setq test outsidetest)

# MA: Switch to spacemacs theme before export.

:Fix_porting_issue:
{- (Ideally, does not yet work)

-- The next two lines are not 700-syntax and so are ported over to the generated file.
variable
   the-â„“ : Level
-}
:End:
# TODO: Form sum of two PackageFormers! How?
:after_monoid_signature:
-- Compare this with â€œrenamingâ€ from above.
--
{-lisp
;; â€œthoseâ€ should be a â€œ;â€-seperated string of names
(ğ’± keeping those
  = generated :by '(lambda (element)
      (let (clauses)
        (thread-last by
          (s-split ";")
          (--map (cons (s-trim it) t)) ;; t â‰ˆ true
          (-cons* 'pcase '(get-name element))
          (setq clauses)
        )
      (eval (append clauses '((otherwise nil)))) ;; nil â‰ˆ false
      )
))
-}

-- TODO: FIXME: !!!!!!
{- 00
ğŸ™-et-al = M-Set record âŸ´ keeping :those "ğŸ™; _Ã—_"
-}

-- _ = ğŸ™-et-al
:End:
:Hide:
#+begin_quote
â‡‹ For now, in this document, I will demonstrate how the provided meta-primitives
may be used to form the above excluded the following, which the reader may
form their self, or await the next edition of this document. â‡‹

âŸ± Not demonstrated: Syntax, UntypedSyntax, Stream, VectorSyntax.

âŸ° I doubt the outermost two would be any difficulty for the reader;
the inner two may require some familiarity with the code-base or Lisp.
#+end_quote
:End:
:More_tasks_to_tackle:
# Add :precondition key so that variational users can perform a check
# on the coherency of a variational. E.g., the homomorphism construction
# needs to be invoked on a record.
#
# Maybe not; something to consider.

# To do:
# + Form library of common or useful variations or combinators, using the meta-primitives.
#   - renaming :: Given a function f, apply it to all names.
#   - map-elements f :: Apply function f to each element.
#   - prefix-elements :: Given a list of new elements, prepend them to the current list of elements.
#   - postfix-elements :: Given a list of new elements, postpend them to the current list of elements.
#   - drop-elements :: Given a predicate, drop the fields that satisfy it.
#     - Moreover, drop additional fields if they depend on dropped fields? (maybe).
#   - opening f :: Module renaming according to f.
#   - manifest :: Mention one form; briefly mention others.

#   Note that package formation has been liberated from the backend and brought to the user
#   via our 5 meta-primitives: preamble, kind, waist, waist-strings, level, alter-elements.

# + Allow â€œ:levelâ€ to be â€˜inc, dec, omitâ€™ where the last option omits the â€œ: Set â„“â€ declaration altogether.
#   - Useful for module setups.

# + Make a â€œrawâ€ variation that allows meta-primitives to be invoked whenever.
#   - Maybe called ğ“Œğ’¾ğ“‰ğ’½ ?
#     â± Look at load variations, if there are any ğ“Œğ’¾ğ“‰ğ’½ clauses, then add them to the
#        variation's pairs. assoc ensures only latest items are picked up and so
#        these would overwrite whatever the variation wanted; neato.
#        Perhaps check that ğ“Œğ’¾ğ“‰ğ’½ clauses only allow meta-primitives?
:End:

:more_for_testing_agda:

-- Here's some cuteness. ;; need to fix porting to happen in-place rather than at the top.

-- Desired:
{- 00
variable
  Src Tgt : M-Set-R

-- this comment should be ignored; why is it being ported!?
-}

{-
-- PackageFormer place-holder-so-next-line-doesnt-get-ported : Set where

Remember that â€˜openingâ€™ is a lossy operation; it is terminal and so
something like
â€œHom-D = Hom opening :with "mapâ‚ to _Dâ‚€_" âŸ´ :waist 3â€
has no meaning. We cannot lift â€˜fieldsâ€™ to â€˜parametersâ€™ since an â€œopeningâ€
has lost the necessary type information for the elements.

If we want something to be parametersied; we will use Agda's generalised variables mechanism. (For now).
-}

-- _ = Hom-$

{- works

variable
  A B : M-Set-R

module Hom-D (â„› : Hom A B) where
  â‹¯
-}

-----------------------------------------------------------------------------------------
--- Â§9. Algebraic Data Types

{-lisp
(ğ’± data carrier
  = :kind data
    :level dec
    :alter-elements (lambda (fs)
      (thread-last fs
        (--filter (s-contains? carrier (target (get-type it))))
        (--map (map-type (s-replace carrier $ğ‘›ğ‘ğ‘šğ‘’ type) it))))
)
-}

{-00
ScalarSyntax  = M-Set primer âŸ´ data :carrier "Scalarâ€²"
ScalarTerm    = M-Set data :carrier "Scalar" âŸ´ primer

-- Example of erroenous invocations.
-- Crashes since type Noâ€² is not defined!
-- No = M-Set primer âŸ´ data :carrier "Scalar"

-}
-- _ = ScalarSyntax
-- _ = ScalarTerm

-- TODO:
-- What about syntax of vectors? Well that depends on scalars!

{-lisp
(ğ’± data-with-params carrier
  = :kind data
    :level dec
    :alter-elements (lambda (fs)
      (thread-last fs
        (--filter (s-contains? carrier (target (get-type it))))
        (--map (map-type (s-replace carrier $ğ‘›ğ‘ğ‘šğ‘’ type) it))))
)
-}

-- â€œdata with paramsâ€
-- VectorSyntax  = M-Set data :carrier "Vector" âŸ´ primer

------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
-- Experiments follow --

{-
-- ğ’±-data-with-identified carrier = :kind data :level dec :alter-elements (lambda (fs) (thread-last fs (--filter (-any? (lambda (c) (s-contains? c (target (get-type it)))) carrier)) (loop for c in carrier do (--map (map-type (s-replace c $ğ‘›ğ‘ğ‘šğ‘’ type) it)) )))

ğ’±-data-with-identified carrier = :alter-functions (lambda (f) (message-box "HELLO"))

M-Setâ€² = M-Set record âŸ´ primed

M-Set-Syntax = M-Setâ€² data-with-identified :carrier (list '(list "Scalar"))
-}


{-00

ğ’±-data-with carrier      = map :elements (lambda (f) (when (s-contains? carrier (target (get-type f))) (map-type (s-replace carrier $ğ‘›ğ‘ğ‘šğ‘’ type) f)))

MonoidD   =  MonoidP data-with :carrier "Carrier"

-}

{- TODO
PackageFormer MonoidP : Setâ‚ where
    Carrier : Set
    _â¨¾_     : Carrier â†’ Carrier â†’ Carrier
    Id      : Carrier

    left-â¨¾  : Carrier â†’ Carrier â†’ Carrier â†’ Carrier
    left-â¨¾ x y z = (x â¨¾ y) â¨¾ z

    assoc   : âˆ€ {x y z} â†’ left-â¨¾ x y z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x

- record â‡’ local intersped with fields
- data  â‡’ rewrite [syntax sugar] and possibly global operation afterwards as an additional new method, and possibly adding it in as a constructor to the data-type, eg. See Isabelle's distinctions of definition vs abbrevation where the former rewuires an explicit tactic to apply as in coq's intro and the latter is definitional.
- module â‡’ local let, or possibly rewrite with local declaration inside module

-- MonoidR   =  MonoidP :kind record :waist 2 :level dec âŸ´ :waist-strings ("private" "n : Setâ‚" "n = Set" "field")
-- MonoidD = data-with :carrier Carrier
-}

{-
ğ’±-recordâ·             = :kind record :waist-strings (when (package-former-elements self) '("field"))

ğ’±-data-with carrier      = :kind data :level dec :alter-elements (lambda (f) (if (s-contains? carrier (target (get-type f))) (map-type (s-replace carrier $ğ‘›ğ‘ğ‘šğ‘’ type) f) ""))

ğ’±-filter-attempt by = map :elements (lambda (f) (if (funcall by f) f ""))
MonoidF   = MonoidP filter :by (lambda (f) nil)

-- TODO: 7 crashes things --yikes! This is because agda keyword field cannot occur barren --c.f. ğ“¥-recordâ·.
-- MonoidTâ· = MonoidP record âŸ´ :waist 4
-}

------------------------------------------------------------------------------------------
-- Observations

{-00
-- MA: TODO: Useful example to know how to do. Maybe fix this whole quotation issue!
ğ’±-try this = decorated :by '(car this)
Ni = M-Set record âŸ´ try :this '(list "áµ¢" "â±¼" "â‚–")

-}
-- _ = Ni

-- Passed functions need the quote.
-- E.g.,
-- ğ’±-keeping those = generated :by 'those
:End:

# [â€¼] Nesting of PackageFormers; e.g., data declarations delimited by module declarations.
#
# Maybe an element may be an item that begins with PackageFormer/record/data/module?

:more:
(ğ’± record (discard-equations nil)
  = "Reify a variational as an Agda â€œrecordâ€.

     Elements with equations are construed as
     derivatives of fields  ---the elements
     without any equations.

     Or do we want to treat them as fields, some
     or all?
    "
  :kind record
  :alter-elements
     (Î» es â†’
       (thread-last
       (if discard-equations
           (--map (map-equations (Î» _ â†’ nil) it) es)
          es)
       (--map (map-qualifier
         (Î» _ â†’ (unless (element-equations it) "field")) it) es))))

-- ripped out of Paper0.agda
--
-- may have useful content
--
{-  lisp
(ğ’± maybemap elements = :alter-elements (lambda (fs)
   (let* ((fsnew (mapcar elements fs))
          sep
          itâ€²
          (names  (--map (s-replace "_" "" (get-name it)) fs))
          (namesâ€² (--map (s-replace "_" "" (get-name it)) fsnew)))
     (loop for old in names
           for new in namesâ€²
           for i from 0 to (length fs)
           do
           (setq fsnew
                 (--map
                   (progn
                     (setq sep (if (s-contains? "=" it) "=" ":"))
                     (setq itâ€² (s-split sep it))
                     (setf (cdr itâ€²) (s-join sep (cdr itâ€²)))
                     ;; If old has _ in it, then account for forms with all _ in them or none in them (which is handled by the previous clause.)
                     (setf (cdr itâ€²) (replace-regexp-in-string (format "\\b%s\\b" (regexp-quote old)) new (cdr itâ€²) t))
                     (when (s-contains? "_" (nth i fs))
                          (setf (cdr itâ€²) (s-replace (get-name (nth i fs)) (get-name (funcall elements (nth i fs))) (cdr itâ€²))))
                     (format "%s%s%s" (car itâ€²) sep (cdr itâ€²))) fsnew)))
     ;; return value
     fsnew
     )))
-}
--
-- â€œ\\bâ€ matches the empty string, but only at the beginning or end of a word.
-- Thus, â€œ\\bfoo\\bâ€ matches any occurence of â€œfooâ€ as a seperate word, without any
-- prefix or suffix.
-- E.g., (replace-regexp-in-string "\\bT\\b" "NEW" "T and Tâ‚€ âˆ€ {and : T} but not â€µT End." t)
:end:

** COMMENT Changelog
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-Changelog
   :END:

 ### Backend ###

 + [X] Added â€œÎ» x â†’ â‹¯â€ macro to reduce burden for Agda users in using Lisp.
 + [X] Typed-name string pairs have been replaced with the â€œelementâ€ datatype.
       Which comes with projections â€œelement-Xâ€ and map operations â€œmap-Xâ€,
       as well as a number of other useful functions I needed: replace, parse, etc.
       â© Updated prototype to make use of this type instead of string typed-name pairs.
 + [X] Awkward â€œwaist-stringsâ€ replaced by natural â€œelementâ€ datatype.
 + [X] The â€œ:key valueâ€ syntax is no longer forced onto the user.
       Instead, all arguments are positional unless enclosed in parenthesis
       possibly along with a default value, then they are accessed as key-value pairs.
       â© The telescope style to arguments was suggested by Wolfram.
 + [X] Have begun using â€œdeclare-typeâ€ as a typing mechanism; unsure about this
       since it cannot yet handle arguments mentioning â€œ:â€, and also no convenient
       way to temporarily rid a function of a fixed type. Things to consider improving.
 + [X] Switched to /copying/ $ğ’†ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘  rather than exposing them directly, so that
       shared memory locations are not altered accidentally.
 + [ ] Tried to add support for lagda files ---still does not work as desired; not exposed.
 + [X] Tooltips do not affect subwords, only whole words.

 ### User manual ###
 + [X] Switched to a literate approach for examples: All examples tangle to legitimate
       Agda files, which can easily be checked with C-c C-l.
       As such, it's easy to ensure all examples are up-to-date ^_^
 + [X] New section on empty variationals that aims to document all possible things
       with variationals ---including user documentation and optional arguments ^_^
 + [X] Updated nearly all of user manual to reflect the new structure of the
       prototype.
 + [X] Keeping track of a â€œstandard libraryâ€ of useful variationals to export with
       the prototype (â€¢Ì€á´—â€¢Ì)Ùˆ
       â© They all come with useful documentation as well as some optional arguments
         for exceptional circumstances.
 + [X] New variationals:
   - [co-]decorated :: Renaming by simple provided decorations.
   - subscriptedáµ¢ :: Renaming by a subscript ğ’¾.
   - primed :: Renaming by a prime.
   - single-sorted :: Collapse a multisorted structure by identifying all sorts.
   - data :: What the gpce19 paper calls termtype; perhaps ought to provide it as an alias.
   - exposing :: Which is misnamed, it should be unbundling, as in the gpce19 paper.

 ## Webpage ###
 + [X] New and stylish webpage style ^_^
 + [X] All headings now have reasonable HTML anchors.


 TODO:
 + [ ] Noticed ~M-Set âŸ´ subscriptedâ‚ƒ~ crashes for some reason, possibly due to a printing
       error.

 + [ ] Remove global ~*parent-context*~; it's unsued.

 + [ ] Incorporate record-with-discard-equations into user manual.
       â© What about all the existing variationals.
       â© Revise main example to include equations, as in the gpce19 paper.
         â© Perhaps some derived properties of M-Sets?

 + [ ] Add the necessary â€œquoteâ€ in the definition of ğ’±ğ’¸ so that arguments passed to
       other variationals need not be quoted. This is a bug that exposes how ğ“¥ works!

 + [ ] Add support for \begin{lisp}   and \begin{700}
  -----------------------------------------------------------------------------------------

 [X] Formed variationals ~termtype~ and ~termtype-with-variables~ for syntactic types.
 [X] Variationals may now have optional documentation, viewable with â€œC-h oâ€ ^_^
     [X] Even better, such docs are displayed as tooltips (â€¢Ì€á´—â€¢Ì)Ùˆ
 [X] Elaborated code is attached to its named declaration via tooltips.
 [X] Formed variationals ~recordâ‚‘~ and ~termtypeâ‚‘~ that extend the non-â‚‘ counterparts by accounting for equations.
 [X] Paper0.agda now contains real working code for all the examples mentioned in Paper0, and then some ;-)
   - E.g., the â€œconcatáµ¢â€ are now generated from a *single* definition (à¸‡à² _à² )à¸‡
   - Added an appendix in response to editorial remarks.
 [X] Extended the â€œmapâ€ variational to accomodate PackageFormers with equations. â™¥â€¿â™¥

 -----------------------------------------------------------------------------------------

   All issues have been addressed.

   [X] Added a top-level link to this document from 700 github.io website.

   [X] Added new menu item: A bare-bones presentation of a file, with 700-annotations
       stripped out, is now provided.

   [X] Moved prototype material into its own directory ---tackling issue #5.

   [X] Included a comment in Â§2.9 addressing issue #10 to reduce ambiguity.

   [X] Trying a different colour scheme for the exported HTML
       ---exporting in spacemacs-light theme.

   [X] The meta-primitive is â€œ:kindâ€, not  â€œ:typeâ€ which is an overloaded word.
       The codebase and examples now refer to the former exclusively;
       addersing issue #7.

   [X] Added further docs to Â§2.5/2.6 to clarify that the main difference between
       the two is that the former does things directly, whereas the latter uses
       composition instead. This addresses issue #9.

   [X] Issue #8 has been addressed. A new todo has been added:
       â†’ Examples from the user-manual
         should be exported into an Agda file which is then easily checked;
         or the resulting generated code should be generated when export happens.

 -----------------------------------------------------------------------------------------

   [X] Lots of cleaning at the backend.
       â†’ *Sequential* porting currently broken.

   [X] Added two new menu items for locating variationals and PackageFormers.

   [X] Added menu item for folding away â€œ700â€ and â€œlispâ€ blocks.

   [X] Begun updating Paper0

   [X] NEW, Paper0.agda for implementations of the code in Paper0.agda (â€¢Ì€á´—â€¢Ì)Ùˆ

   [X] Colouring in PackageFormer syntax is now enabled.

 -----------------------------------------------------------------------------------------

   [X] Updated user manual; new derived constructs include ~open, open-with~.
       These required we expose a new reference: $ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡.

   [X] Demonstrated how homomorphism constructions may be automated; as well
       as how /easily/ alter automted names with user-provided names!

   [X] Introduced ~rename_~ and ~renaming_~ for rewrites that provide no special attention to underscores.

   [X] ~waist-strings~ expressions now needen't be quoted /and/ may have
       arbitrary Lisp expressions as elements (â€¢Ì€á´—â€¢Ì)Ùˆ

       This was necessary for the homomorphism construction to be
       sufficiently generic.

 -----------------------------------------------------------------------------------------

   [X] Now parsing {-lisp -} comments; which must contain a single Lisp form
       ---or multiple if enclosed in a progn.

   [X] Updated user manual; improved definition of /derived/ construct ~map~.
       New derived constructs include: ~renaming, rename, [co]decorated~;
       as well as ~single-sorted, generated~.

   [X] Composition, âŸ´, now actually composes variationals!
       Non-functional primitives are overwritten,
       alteration primitive is composed sequentially.

   [X] Introduced reference $ğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘ . Used this to derive primitive ~signature~.

 -----------------------------------------------------------------------------------------

 1. Dropped the *builtin* variation tags, â€˜vâ€™,
    in-favour of *extensible* â€œvariationalsâ€
    ---which may even have arguments! â™¥â€¿â™¥

    â†’ Â§2.3 demonstrates how to use meta-primitives to
      form common built-in operations.
    â†’ Â§2.4 uses the variationals from Â§2.3 to solve
      a common problem.

    The monster functions â€œinstantiateâ€ and â€œreify-package-formersâ€
    are now much much more manageable: All the built-in logic to
    cater to particular operations on grouping mechanisms has been
    thrown away in favour of a general template.

 2. Solve the single-sorted problem.
    â†’ Motivating example in Â§1 is now two sorted!
    â†’ Â§2.3 shows how it can be used and even reduced to a single sort.

 3. Massive re-organisation:
    â†’ At the document level
    â†’ At the code level
    â†’ At the design level
      â± The presentation of PackageFormers has changed from that in
        the thesis proposal and in Paper0.

** TODO COMMENT Feedback
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-Feedback
   :END:

 [X] Could I get an option to generate a more 'bare' agda, i.e. stripping
 out the 700-commands? [I agree with the default of keeping them in]

 [X] I really like the care in the error reporting (section 2.3)

 [X] the very 90s-web colour choices do get quite tiring...  The colour
 differences of the 3 lines of text at the end of 2.3 is almost
 imperceptible.

    â± MA: Switch to spacemacs theme before export.

 [ ] the "level dec" (and "level inc") feature is nice and also too
 low-level. This one is definitely worth thinking about more.

 [ ] I still heavily disagree with your naming of this as 'typeclass'. It
 is as much an illusion as input/output in relations.

 [ ] :alter-elements is some serious syntactic meta-programming! That one's
 going to be hard to generalize. But it is also worth thinking about.

 [ ] 2.7 "Records provide a semantics, what if we want the syntax?" While I
 100% agree with you, this is kind of a short-hand means of communication
 that works within a small group of people at McMaster, and that might be
 it. For external understandability, you're going to greatly expand on
 what you mean here.

 [ ] The reasoning in "Forming syntax" is sound - but how to go from that
 into something that makes sense at a higher level is tricky. You might
 want to read a textbook or two on Universal Algebra, and see how they
 deal with Term Algebras.

 [ ] 2.8 Nice. And many of the comments above apply.

 [ ] 2.9 ":level none" seems to be a serious hack to deal with modules vs
 records!  But the feature is very cool.

 [ ] 2.10 does clearly points to the need of dealing with "dependency
 graphs" when you move beyond syntactic meta-programming. But the reward
 is definitely non-trivial.

 [ ] 2.11 nice. You should compare with the same idea in Universal Algebra.
 And think of how to do this without so much syntax munging.
    But I agree, quite cool.

    Here's a very (very!) hard test: From Category, apply homomorphism
 once to get Functor, again to get NaturalTransformation, again to get
 Modification, again to get perturbation (Functor is a 0-transfor,
 pertubations are 3-transfors; there's a nice periodic table at
 https://ncatlab.org/nlab/show/transfor).

 [X] Won't comment on sections 3,4,5,6,7 in detail as these are
 implementation details of the prototype. They are excellent to see all
 spelled out like this. The important part is to really understand the
 meaning of the stuff in section 2.

 [ ] It's going to be worth prioritizing that Future Work section.

 [ ] Last meta-comment: this is a very operational description of the work,
 which is great for a tutorial. You need to also start thinking about
 bringing in stronger motivation for the usefulness of the various
 pieces. All your examples might be self-evident to you, but never assume
 that of your reader.

 [X] Summary: very cool. Solid progress in the right direction. Continue!

** COMMENT Random content to inspect
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-Orphan-content
   :END:

  # Breaks since I'm not allowing â€œ:â€ in variationals since it acts as an invocation to the meta-primitives.
  #
  # :alter-elements (Î» f â†’ (s-contains? pf-name (target (cadr (s-split \":\" f))))) "

  # Old tests
 :all_argument_test:
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"ğ’±-test argâ‚€ argâ‚ argâ‚‚ aâ‚ƒ aâ‚„ = :kind argâ‚€ :waist argâ‚ :waist-strings argâ‚‚ :level aâ‚ƒ :alter-elements aâ‚„ "))
  (setq variationals nil)
  (load-variationals)

(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "NewName = M-Set test :aâ‚„ ((lambda (x) (concat \"â‚‚\" x))) :aâ‚ƒ (inc) :argâ‚€ (record) :argâ‚ (1) :argâ‚‚ ((\"field BdRO\"))")))

  ; (instance-declaration-alterations mid)
  (instantiate mid)
))
 #+END_SRC

 #+RESULTS:
 #+BEGIN_src results-agda
{- NewName = M-Set test :aâ‚„ ((lambda (x) (concat "â‚‚" x))) :aâ‚ƒ (inc) :argâ‚€ (record) :argâ‚ (1) :argâ‚‚ (("field BdRO")) -}
record NewName (â‚‚Scalar : Set) : Setâ‚‚ where
 field BdRO
   â‚‚Vector  : Set
   â‚‚_Â·_     : Scalar â†’ Vector â†’ Vector
   â‚‚ğŸ™       : Scalar
   â‚‚_Ã—_     : Scalar â†’ Scalar â†’ Scalar
   â‚‚leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   â‚‚assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
 #+END_src
 :End:
 :using_âŸ´_:
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"ğ’±-test kind  = :kind kind
ğ’±-testâ€² height = :waist height
"))
  (setq variationals nil)
  (load-variationals)

(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "NewName = M-Set test :kind 'module âŸ´ testâ€² :height (3)")))

  ; (instance-declaration-alterations mid)
  (instantiate mid)
))
 #+END_SRC

 #+RESULTS:
 #+BEGIN_src results-agda
{- NewName = M-Set test :kind (module) âŸ´ testâ€² :height (3) -}
module NewName (Scalar : Set) (Vector : Set) (_Â·_ : Scalar â†’ Vector â†’ Vector) : Setâ‚ where
   ğŸ™       : Scalar
   _Ã—_     : Scalar â†’ Scalar â†’ Scalar
   leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
 #+END_src
 :End:
 :more_anonymous_testing:
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"ğ’±-test        = :kind record âŸ´ testâ€² :height 2
ğ’±-testâ€² height = :waist height
"))
  (setq variationals nil)
  (load-variationals)
)
(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "LHS = M-Set test âŸ´ :level dec")))

  ; (instance-declaration-alterations mid)
  (instantiate mid)
))
 #+END_SRC

 #+RESULTS:
 #+begin_src results-agda
{- LHS = M-Set test âŸ´ :level dec -}
record LHS : Set where
   Scalar  : Set
   Vector  : Set
   _Â·_     : Scalar â†’ Vector â†’ Vector
   ğŸ™       : Scalar
   _Ã—_     : Scalar â†’ Scalar â†’ Scalar
   leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
 #+end_src
 :End:

 TODO: Put with user manual.
 Re: renames/maps
 #+BEGIN_SRC emacs-lisp
;; Could ty this into renaming, but avoiding such entaglement for now.
;; Stick all renames â€œso farâ€ in front of each declaration.

;; (setq x a y b) â‡’ b

; (setq _xs nil)
;; (push x xs)  â‡’  updated xs

(insert (format "%s"
(funcall
(lambda (fs)
    (-as-> (-unzip (--zip-with `(,other  ,(format "let %s = %s in " (get-name it) (get-name other))) fs (--map (map-name (concat name "â€²") it) fs))) yup
           (--zip-with (map-type (concat (s-join "" it) type) other) (-inits (cadr yup)) (car yup))))

'( "a : Set" "b : Set" "c : Set"))))


(aâ€² : Set
 bâ€² : let a = aâ€² in Set
 câ€² : let a = aâ€² in let b = bâ€² in Set)
 #+END_SRC

 TODO: Dropping after a map wont work well since the map would have created a local let; so need to remove from the lets!
 To accomodate for let-clauses we need to get the type, then drop all clauses of the form â€œlet l = r inâ€
 where â€œlâ€ is not in the yeses list.

 #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
;   "ğ’±-primed-record = :kind record :waist-strings (\"field\")
(load-variational "ğ’±-primed-record = :kind 'module âŸ´ :level 'inc :alter-elements (lambda (f) (map-name (concat name \"â€²\") f))")
(setq package-formers nil)
(load-package-former (second (get-children "PackageFormer" test)))
(load-instance-declaration "NewNamfe = M-Set primed-record âŸ´ :kind 'record :waist 2 :waist-strings (\"field\")")
 #+END_SRC

 HERE TODO: testing data HERE
    #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(setq package-formers nil)
(load-package-former (second (get-children "PackageFormer" test)))

;; TODO: UHOH: Write now I'm overwriting things rather than composing!
;; The following are exepcted to be equal but are only the last variational!
; (load-instance-declaration "Mâ‚  =  M-Set âŸ´ primed âŸ´ data :carrier \"Scalar\"" 'show-me)
(load-instance-declaration "Mâ‚‚  =  M-Set âŸ´ data :carrier \"Vector\" âŸ´ primed" 'show-me)

(load-instance-declaration "Mâ‚â‚‚  =  M-Set decorated :by \"â‚\" âŸ´ decorated :by \"â‚‚\"" 'show-me)
 #+END_SRC

 #+RESULTS:
 #+begin_src results-agda
{- Mâ‚â‚‚  =  M-Set decorated :by "â‚" âŸ´ decorated :by "â‚‚" -}
PackageFormer Mâ‚â‚‚ : Setâ‚ where
   Scalarâ‚â‚‚ : Set
   Vectorâ‚â‚‚ : Set
   _Â·â‚â‚‚_ : Scalarâ‚â‚‚ â†’ Vectorâ‚â‚‚ â†’ Vectorâ‚â‚‚
   ğŸ™â‚â‚‚ : Scalarâ‚â‚‚
   _Ã—â‚â‚‚_ : Scalarâ‚â‚‚ â†’ Scalarâ‚â‚‚ â†’ Scalarâ‚â‚‚
   leftIdâ‚â‚‚ : {ğ“‹ : Vectorâ‚â‚‚}  â†’  ğŸ™â‚â‚‚ Â·â‚â‚‚ ğ“‹  â‰¡  ğ“‹
   assocâ‚â‚‚ : {a b : Scalarâ‚â‚‚} {ğ“‹ : Vectorâ‚â‚‚} â†’ (a Ã—â‚â‚‚ b) Â·â‚â‚‚ ğ“‹  â‰¡  a Â·â‚â‚‚ (b Â·â‚â‚‚ ğ“‹)
 #+end_src

 TODO: testing renames
 #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(load-variational "ğ’±-rename expr = :alter-elements '(lambda (fs) (-as-> (-unzip (--zip-with `(,other  ,(format \"let %s = %s in \" (get-name it) (get-name other))) fs (mapcar (eval expr) fs))) yup (--zip-with (map-type (concat (s-join "" it) type) other) (-inits (cadr yup)) (car yup))))")
(setq package-formers nil)
(load-package-former (second (get-children "PackageFormer" test)))
(load-instance-declaration "NewNamfe = M-Set :waist 2")
 #+END_SRC

 TODO:
 #+BEGIN_SRC emacs-lisp :tangle yes
;; (load-instance-declaration "LHS = PF :argâ‚€ valâ‚€ âŸ´ testâ‚ :heightish 23")

     ;; PackageFormer names are in yellow; instances are are bolded.
     ;; (highlight-phrase (format "%s " (nth 2 pieces)) 'hi-yellow)
     ;; (highlight-phrase (nth 0 pieces) 'bold) ;; 'warning) ;; i.e., orange
     ;;
     ;; MA: Replace with a hook.
 #+END_SRC

 TODO: load instance declaratin tests.
 {{{fold(Tests)}}}
 #+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest lid ()

  (let (id)

  ;; Anonymous variational
  (setq id (load-instance-declaration "LHS = PF :argâ‚€ valâ‚€ âŸ´ varâ‚ :argâ‚ valâ‚"))

  ;; Basic invocation shape
  ;; â€œtoâ€! (setq id (load-instance-declaration "NewName = PF varâ‚ :arg (Î» xâ‚ â†’ Bâ‚) âŸ´ varâ‚‚ :arg (a to b; Î» xâ‚‚ â†’ Bâ‚‚)"))
  (setq id (load-instance-declaration "NewName = PF varâ‚ :argâ‚€ (Î» xâ‚ â†’ Bâ‚) :valâ‚€ nice âŸ´ varâ‚‚ :arg (Î» xâ‚‚ â†’ Bâ‚‚)"))
  (cdr (instance-declaration-alterations id))
  (should (equal "NewName" (instance-declaration-name id)))
  (should (equal "PF" (instance-declaration-package-former id)))
  (should (equal "((varâ‚‚ ((a . b)) (lambda (xâ‚‚) (concat Bâ‚‚))) (varâ‚ nil (lambda (xâ‚) (concat Bâ‚))))"
         (format "%s" (instance-declaration-alterations id))))

  ;; Ill-formed: LHS name is empty string.
  (should (not (load-instance-declaration " = PF var")))

  ;; Ill-formed: Not even a declaration.
  (should (not (load-instance-declaration "private n : â„•")))

  ;; Variation has no args.
  (should (load-instance-declaration "LHS = PF var ()"))

  ;; Arbitrary variational
  ;; There are parens around each arg since each should be a pair.
  (should (equal "((some-variational ((argâ‚€) (â€¦) (argâ‚™)) identity))" (format "%s" (instance-declaration-alterations (load-instance-declaration
   "LHS = Magma some-variational (argâ‚€; â€¦; argâ‚™)")))))
  (should (equal "((some-variational nil (lambda (x) (concat x â€²))))" (format "%s" (instance-declaration-alterations (load-instance-declaration
  "LHS = Magma some-variational (Î» x â†’ x ++ \"â€²\")")))))
))
 #+END_SRC
 {{{end-fold}}}

*** COMMENT Let's put the pieces together.      :deprecated:_useful_examples:
    :PROPERTIES:
    :CUSTOM_ID: COMMENT-Let's-put-the-pieces-together.
    :END:

  OLD:
  #+BEGIN_SRC emacs-lisp  :tangle yes
(cl-defun instantiate (id)

  "Given an instance-declaration â€˜idâ€™, produce a new PackageFormer.

   Donâ€™t bother generating non-working Agda code: Better see the error now rather than at Agda typechecking.
  "

  (should (instance-declaration-p id))
  (letf ((self (copy-package-former (cdr (assoc (instance-declaration-package-former id) package-formers))))
        (variation nil) (op nil) ($ğ‘›ğ‘ğ‘šğ‘’ nil)
        ((symbol-function 'âŸ°)
         ;; Check to see if â€œcâ€ has a value, if it does then assert it satisfies the property â€œpâ€ otherwise error with
         ;; message â€œmâ€. If all good, then update the PackageFormer at that component.
         ;; Property â€œpâ€ and message â€œmâ€ are quoted expressions mentioning â€œitâ€.
         ;; â€œmoreâ€ is any auxialry code that ought to be run; it is a quoted list.
         (lambda (c p m &optional str more) (when-let ((it (cdr (assoc (intern (format ":%s" c)) (instance-declaration-alterations id)))))
                           (unless (eval p) (error (format "700: %s\n\n\tâ‡¨\t%s\n\tâ‡¨\t%s â‰ˆ %s" (eval m) (instance-declaration-docstring id) variation op)))
                           (eval `(progn ,@more))
                           (when str (setq it (format "%s" it)))
                           (eval `(setf (,(car (read-from-string (format "package-former-%s" c))) self) it))))

        ))

    (unless self (error (format "700: %s\n\n\tâ‡¨\t%s\n\tâ‡¨\t%s â‰ˆ %s"
                                (format "Parent â€œ%sâ€ not defined." (instance-declaration-package-former id))
                                (instance-declaration-docstring id) variation op)))

      (setf (package-former-docstring self) (instance-declaration-docstring id))
      (setq $ğ‘›ğ‘ğ‘šğ‘’ (instance-declaration-name id))
      (setf (package-former-name self) $ğ‘›ğ‘ğ‘šğ‘’)

      ;; :kind â‰ˆ The vocabulary that replaces â€œPackageFormerâ€.
      (âŸ° 'kind '(-contains? '(record data module PackageFormer) it)
         '(format "This kind â€œ%sâ€ is not supported by Agda!\n     Valid kinds: record, data, module, PackageFormer." it)
         'string-please
         )

      ;; :waist â‰ˆ The division between parameters and remaining elements.
      (âŸ° 'waist '(numberp it) '(format "The waist should be a number; which â€œ%sâ€ is not." it))

      ;; :waist-strings â‰ˆ Extra strings to insert at the waist position.
      (âŸ° 'waist-strings '(listp it) '(format "The waist-strings should be a Lisp list of strings; which â€œ%sâ€ is not." it))

      ;; :level â‰ˆ Either 'inc or 'dec, for increment or decrementing the level.
      (âŸ° 'level '(-contains? '(inc dec) it) '(format "The â€œlevelâ€ must be â€œincâ€ or â€œdecâ€; which â€œ%sâ€ is not." it) 'string-please
         '((let* ((lvl (package-former-level self))
                  (toLevel (lambda (n) (s-join "" (-concat
                        (-repeat n "Level.suc (") (list "Level.zero") (-repeat n ")")))))
                 (subs `("" "â‚" "â‚‚" "â‚ƒ" "â‚„" "â‚…" "â‚†" "â‚‡" "â‚ˆ" "â‚‰" ,(funcall toLevel 10)))
                 (here (-elem-index (s-trim lvl) subs)))

             (setq it
                   (if here

                       (pcase it
                         ('inc (nth (1+ here) subs))
                         ('dec (nth (1- here) subs)))

                     (pcase it
                       ('inc (format "Level.suc (%s)" lvl))
                       ('dec (s-join "suc" (cdr (s-split "suc" lvl :omit-nulls))))))))))

      ;; TODO: FIXME: Propogate map to remaining elements.
      ;; :alter-elements â‰ˆ Map over the typed name constituents.
      (when-let ((ae (cdr (assoc ':alter-elements (instance-declaration-alterations id)))))
        (setf (package-former-elements self)
              (-map ae (package-former-elements self))))
      ;; (setq fsnew (funcall op otherwise fs)) ;; MA: TODO: Incorporate â€˜argsâ€™!

      ;; We've just formed a new PackageFormer, which can be modified, specialised, later on.
      (add-to-list 'package-formers (cons (instance-declaration-name id) self))

      (show-package-former self)
))
  #+END_SRC

  # DONE:
  Let's instantiate our test example from earlier to produce a super simple record;
  i.e., legitimate Agda. Moreover, let's decorate each field name with a prime
  and lift-up the first two items to be parameters.

  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
;   "ğ’±-primed-record = :kind record :waist-strings (\"field\")
(load-variational "ğ’±-primed-record = :kind record âŸ´ :level nice :alter-elements (lambda (f) (map-name (concat name \"â€²\") f))")
(setq package-formers nil)
(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "NewName = M-Set primed-record âŸ´ :waist 2 :waist-strings (\"field\")")))
  (instantiate mid)
)
  #+END_SRC

  #+RESULTS:
  #+begin_src results-agda
{- NewName = M-Set primed-record âŸ´ :waist 2 :waist-strings ("field") -}
PackageFormer NewName : Setâ‚ where
   Scalar  : Set
   Vector  : Set
   _Â·_     : Scalar â†’ Vector â†’ Vector
   ğŸ™       : Scalar
   _Ã—_     : Scalar â†’ Scalar â†’ Scalar
   leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
  #+end_src

  #RESULTS:
  #+begin_src results-agda
{- NewName = M-Set primed-record âŸ´ :waist 2 :waist-strings ("field") -}
record NewName (Scalarâ€² : Set) (Vectorâ€² : Set) : Setâ‚‚ where
 field
   _Â·â€²_ : Scalar â†’ Vector â†’ Vector
   ğŸ™â€² : Scalar
   _Ã—â€²_ : Scalar â†’ Scalar â†’ Scalar
   leftIdâ€² : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   assocâ€² : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
  #+end_src

  # RESULTS:
  #+begin_src results-agda
{- NewNasme = M-Set primed-record âŸ´ :waist 2 -}
record NewNasme (Scalarâ€² : Set) (Vectorâ€² : Set) : Setâ‚ where
 field
   _Â·â€²_ : Scalar â†’ Vector â†’ Vector
   ğŸ™â€² : Scalar
   _Ã—â€²_ : Scalar â†’ Scalar â†’ Scalar
   leftIdâ€² : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   assocâ€² : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
  #+end_src

  :asserts:
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"

(assert (equal "NewNasme = {! Undefined Parent: M-Sset !}"
        (instantiate (load-instance-declaration "NewNasme = M-Sset var"))))

(assert (equal "NewNasme = {! Undefined Variational: do-the-thing !}"
        (instantiate (load-instance-declaration "NewNasme = M-Set do-the-thing"))))
  #+END_SRC
  :End:

  # DONE:
  Let's form a Haskell-like typeclass; more precisely, a record where the first two
  fields are exposed as parameters.
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
  "ğ’±-typeclassâ‚‚ = :kind record :level dec :waist-strings (\"field\") :waist 2"))
  (setq variationals nil)
  (load-variationals)

(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "NewName = M-Set typeclassâ‚‚")))

  (instantiate mid)
))
  #+END_SRC

  #+RESULTS:
  #+BEGIN_src results-agda
{- NewName = M-Set typeclassâ‚‚ -}
record NewName (Scalar : Set) (Vector : Set) : Set where
 field
   _Â·_     : Scalar â†’ Vector â†’ Vector
   ğŸ™       : Scalar
   _Ã—_     : Scalar â†’ Scalar â†’ Scalar
   leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
  #+END_src

  The Vector & Scalar sorts are exposed!
  Moreover, the level of the resulting record is as minimal as possible ^_^ Neato! ğŸº

  # What about a bundled up record declaration? Simple, we leave the waist with default value zero.

  Records provide a semantics, what if we want the syntax?
  Since ~data~ declarations consist of constructors, whose target type necessarily
  begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.

  First, a helper function.
  #+BEGIN_SRC emacs-lisp :tangle yes
(defun target (field)
  "Given a declaration â€œname : type0 â†’ â‹¯ â†’ typeNâ€, yield â€œtypeNâ€. "
  (ignore-errors (car (-take-last 1 (s-split "â†’" field))))
  ;; Ignore errors since field may be nil.
)
  #+END_SRC

  Let's test it out:
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace
(-let [pf-name "Semigroup-syntax"]

  (list (s-contains? pf-name (target "Id    :  Semigroup-syntax"))
    (s-contains? pf-name (target "_â¨¾_   :  Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax"))
    (s-contains? pf-name (target "assoc :  âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)"))
    (s-contains? pf-name (target "Semigroup-syntax : Set")))
)
  #+END_SRC

  #+RESULTS:
  | t | t | nil | t |

  As the last test case shows, the name position of a declaration could have
  a data-type name --which is not allowed in Agda since constructors share the
  same namespace as types, yet this property is not ensured in our generation;
  so let's sanitise for it.

  Now a real use case.

  # DONE:
   #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(flet ((buffer-substring-no-properties (x y)
"ğ’±-data-with carrier = :kind data :level dec :alter-elements (Î» f â†’ (if (s-contains? carrier (target (get-type f))) (map-type (s-replace carrier $ğ‘›ğ‘ğ‘šğ‘’ type) f) \"\"))"))
  (setq variationals nil)
  (load-variationals)
  (setq package-formers nil)

(load-package-former (second (get-children "PackageFormer" test)))
(let ((mid (load-instance-declaration "ScalarSyntax = M-Set data-with :carrier (\"Scalar\")")))

  ; (instance-declaration-alterations mid)
  (instantiate mid)
  ))
  #+END_SRC

  #+RESULTS:
  #+BEGIN_src results-agda
{- ScalarSyntax = M-Set data-with :carrier ("Scalar") -}
data ScalarSyntax : Set where



   ğŸ™ : ScalarSyntax
   _Ã—_ : ScalarSyntax â†’ ScalarSyntax â†’ ScalarSyntax


  #+END_src

  Notice that $ğ‘›ğ‘ğ‘šğ‘’ is a special variable that refers to the newly defined PackageFormer's name.
  - It is written using ~\Mi~ with Agda input; e.g., ~\Min~ gives ~ğ‘›~.
  - The â€˜$â€™ is intended to further mark the special nature of this variable.

  Yeehaw! We've got three variations and possibly much more from a small core interface
  ğŸ¤  We can emulate generative modules this way too! ğŸ˜»

  Let's package these particular toggle configurations into their own functions.

  :TODO:
  That's a lot of mumbo jumbo, let's have a sanity check.
  #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(s-join "\n\n" (list
 (instantiate-as-unbundled 1 test :name-suffix "On") ;; typeclass
 (instantiate-as-unbundled 0 test :name-suffix "semantics") ;; record
 (instantiate-as-data test)
))
  #+END_SRC

  #+RESULTS:
  #+begin_src results-agda
{- This was generated from the PackageFormer Semigroup . -}
record Semigroup-On (Carrier : Set) : Set where
  field
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup . -}
record Semigroup-semantics : Set (Level.suc Level.zero) where
  field
    Carrier : Set
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup . -}
data Semigroup-syntax : Set where
    _â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax
    Id  : Semigroup-syntax
  #+end_src

  Notice that the results contained generated names since no names were provided.

  Woah, look at that: This' reminiscent of that 200% increase from earlier ;-)
  *Moreover*, with ~unbundled~ we may expose any or all constituents of a package
  at will.

  {{{fold(Unit Tests)}}}
  #+BEGIN_SRC emacs-lisp :var test = test
(ert-deftest inst ()

  ;; Parameterised record
  (should (equal (instantiate test :carrier "Carrier" :docstring "" :waist-strings (list "field") :waist 2)
         "{-  -}
record Semigroup- (Carrier : Set) (_â¨¾_ : Carrier â†’ Carrier â†’ Carrier) : Set where
  field
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)"))

  (should (equal  (instantiate-as-unbundled 1 test :name-suffix "On")
          "{- This was generated from the PackageFormer Semigroup . -}
record Semigroup-On (Carrier : Set) : Set where
  field
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)"))

  ;; ADT, data declaration
  (should (equal  (instantiate test :kind "data" :new-name "ğ’®" :docstring "" :inc-level nil
                   :keep-fields (lambda (f) (s-contains? "ğ’®" (target (cadr (s-split ":" f))))))
          "{-  -}
data ğ’® : Set where
    _â¨¾_ : ğ’® â†’ ğ’® â†’ ğ’®
    Id  : ğ’®"))

   (should (equal (instantiate-as-data test)
          "{- This was generated from the PackageFormer Semigroup . -}
data Semigroup-syntax : Set where
    _â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax
    Id  : Semigroup-syntax")))

  #+END_SRC
  {{{end-fold}}}
  :END:
  ** COMMENT Module instantions

 We can emit module declarations as follows; which may be useful for ADT instantions
 of PackageFormers that contain derived operations.
 #+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(instantiate test   :new-name "Semanticsâ‚"
            :kind "module"
            :carrier "Carrier"
            :omit-level-decl t
            :waist 4
            )
 #+END_SRC

 #+RESULTS:
 #+begin_src results-agda
{- This was generated from the PackageFormer Semigroup . -}
module Semanticsâ‚ (Carrier : Set) (_â¨¾_ : Carrier â†’ Carrier â†’ Carrier) (Id : Carrier) (assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)) where
 #+end_src

 For now, a common scenario is forming modules that re-export a type under a new superficial disguise;
 e.g., in the setting where we want to have multiple references to a structure, as in when defining homomorphisms.
 #  :tangle yes
 #+BEGIN_SRC emacs-lisp exports both :results replace :wrap "src results-agda"
(cl-defun instantiate-as-opening (decls inst)

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - â€˜declsâ€™ is immediately provided to â€˜get-childrenâ€™, so it may be a string,
      a list, or a value of type â€˜package-formerâ€™.

   - â€˜instâ€™ is an instance declaration value whose â€˜openingsâ€™ componenet is non-nil.
  "

  (let* ((openings (instance-declaration-openings inst))
     (new-name (instance-declaration-name inst))
     (kind (car openings))
     (renames (cadr openings))
     (otherwise (caddr openings)))

    (s-replace "\t" "    " ;; replace rabs with spaces
    (instantiate decls    :new-name new-name
            :kind "module"
            :docstring (instance-declaration-docstring inst)
            :omit-level-decl t
            :waist 1
            :alter-fields (lambda (fs)
             (let (fsnew)


               (loop for (old . new) in renames
                 do (push (format "%s to %s" old new) fsnew))

               ;; TODO: MA: To consider default â€˜otherwiseâ€™ via opening Î» x â†’ x ++ "â€²"
               ;; (read-from-string "(lambda (x) xt)")
               ;;

               ;; HACK: Terrible.
               (setq fs (cons (map-name "Carrier" (car fs)) (cdr fs)))

               (loop for f in fs
                 do (unless (assoc (get-name f) renames)
                  (push (format "%s to %s" (get-name f)
                        (rename-mixfix otherwise (get-name f)))
                    fsnew)))

               (thread-last
            ;; Resulting elements must be a list, so we make a singleton list.
            (format "\t\t( %s\n\t\t\t)" (s-join "\n\t\t\t; " (reverse fsnew)))
            list

            ;; Stick on the renaming, which in turn requires an opening clause;
            ;; which in turn requires a module parameter.
            (cons "\t renaming")
            (cons (format "open %s â„› public" kind))
            (cons (format "â„› : %s" kind))
               )

    ))))))
 #+END_SRC

 #+RESULTS:
 #+begin_src results-agda
instantiate-as-opening
 #+end_src

 Let's test it out.
 #+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
(-let [inst (load-instance-declaration "Monoidâ€² = MonoidPF opening Monoid (Carrier to ğ’®; _â¨¾_ to _âŠ•_; Î» x â†’ x ++ \"â€²\")")]
  (instantiate-as-opening test inst))
 #+END_SRC

 #+RESULTS:
 #+begin_src results-agda
{- Monoidâ€² = MonoidPF opening Monoid (Carrier to ğ’®; _â¨¾_ to _âŠ•_; Î» x â†’ x ++ "â€²") -}
module Monoidâ€² (â„› : Monoid) where
    open Monoid â„› public
     renaming
        ( Carrier to ğ’®
        ; _â¨¾_ to _âŠ•_
        ; Id to Idâ€²
        ; assoc to assocâ€²
        )
 #+end_src

 This utility shines when we use it wholesale; as follows.
 #+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
(let ((instâ‚ (load-instance-declaration "Monoidâ‚ = MonoidPF opening Monoid (Î» x â†’ x ++ \"â‚\")"))
      (instâ‚‚ (load-instance-declaration "Monoidâ‚‚ = MonoidPF opening Monoid (Î» x â†’ x ++ \"â‚‚\")")))
  (s-join "\n\n" (list (instantiate-as-opening test instâ‚) (instantiate-as-opening test instâ‚‚))))
 #+END_SRC

 #+RESULTS:
 #+begin_src results-agda
{- Monoidâ‚ = MonoidPF opening Monoid (Î» x â†’ x ++ "â‚") -}
module Monoidâ‚ (â„› : Monoid) where
    open Monoid â„› public
     renaming
        ( Carrier to Carrierâ‚
        ; _â¨¾_ to _â¨¾â‚_
        ; Id to Idâ‚
        ; assoc to assocâ‚
        )

{- Monoidâ‚‚ = MonoidPF opening Monoid (Î» x â†’ x ++ "â‚‚") -}
module Monoidâ‚‚ (â„› : Monoid) where
    open Monoid â„› public
     renaming
        ( Carrier to Carrierâ‚‚
        ; _â¨¾_ to _â¨¾â‚‚_
        ; Id to Idâ‚‚
        ; assoc to assocâ‚‚
        )
 #+end_src

 We have written this kind of boilerplate so often that we welcome the
 sweet relief provided by the editor tactic being developed herein.

* Preamble :ignore:
  :PROPERTIES:
  :CUSTOM_ID: Preamble
  :END:
:Idea:
TODO: Maintain a list of instantations-loaded, then use that to obtain
the elements of an instance to determine how an â€˜openingâ€™ should be
performed. For example, given âŸªparams â™ fieldsâŸ« we know that the
opening module must have âŸªparams, â„› : instanceâŸ« as parameters,
and the remaining list of fields will then avilable for renaming.
This scheme will work for arbitrary typeclasses ^_^
:End:

#+TITLE: Making Modules with Meta-Programmed Meta-Primitives
#+SUBTITLE: @@html: <h2> <center> Liberating Package Formation from the Backend </center> </h2> @@
# Prototyping PackageFormers with Elisp
#+DESCRIPTION: Generalising ADTS, records, typeclasses to â€œpackage formersâ€.
#+AUTHOR: Musa Al-hassy
#+EMAIL: alhassy@gmail.com
#+PROPERTY: header-args :results none :tangle no :comments nil :noweb yes

#+CATEGORIES: Agda MetaProgramming Lisp
#+OPTIONS: html-postamble:nil toc:nil d:nil tag:nil

# IMAGE: ../assets/img/org_logo.png
# SOURCE: https://raw.githubusercontent.com/alhassy/org-agda-mode/master/literate.lagda

#+TODO: TODO | Future
:Threading_Remarks:

;; The â€œthread-first x formsâ€ syntax feeds initial value â€˜xâ€™ as the first argument into the
;; next form, which in-turn is then fed as the first argument to the form following it, and so on.
;; It provides a nice way to avoid lots of parenthesising on a particular argument; thereby being clearer.
;;
;; (insert (format "\nâ‡’ %s" (macroexpand '(thread-first xâ‚€ (fâ‚ xâ‚Â¹ â€¦ xÂ¹â‚˜) â‹¯ (fâ‚™ xâ‚™Â¹ â€¦ xâ¿â‚–)))))
;; â‡’ (fâ‚™ (â‹¯ (fâ‚ xâ‚€ xâ‚Â¹ â€¦ xÂ¹â‚˜)) xâ‚™Â¹ â€¦ xâ¿â‚–)
;;
;; A simple implementation can be found [[https://www.emacswiki.org/emacs/ThreadMacroFromClojure][here]].
;;
;; Dually, thread-last behaves the same but being at the final-most
;; form position;
;; that is, it is essentially â€œforwards function applicationâ€.
;; More generally, the dash library provides â€˜-as->â€™ which allows us to bind a name
;; such as â€˜resâ€™, which is then an alias for all intermediate results.
;;
;; (insert (format "\nâ‡’ %s" (macroexpand '(-as-> xâ‚€ res (fâ‚ xâ‚Â¹ â€¦ res â‹¯ xÂ¹â‚˜) â‹¯resâ‹¯))))
;; â‡’ (let ((res xâ‚€)) (-as-> (fâ‚ xâ‚Â¹ â€¦ res â‹¯ xÂ¹â‚˜) res â‹¯resâ‹¯))
;;
;; It is defined recursively to make use of the same name.
;;
;; The operator â€˜-->â€™ uses the name â€˜itâ€™ by default.
:End:
:Testing_Remarks:
#+BEGIN_SRC emacs-lisp
 ;; â‡’ crashes since equality is nil.
 ; (assert (= (+ 1 2) 4))

;; M-x ert RET t â‡’ crashes explaining that (3 = 4) â‰¡ nil; much better!
;; â€˜shouldâ€™ shows intermediate values.
(ert-deftest addition-test ()
  ;; â€œI know it fails, tell me but don't provide report.â€
  ;; :expected-result :failed
    (should (equal (+ 2 2) 4)))

;; There are also â€˜should-notâ€™ and â€˜should-errorâ€™.

;; â€˜Mockingâ€™: We can elimitate side-effects from functions we wish to test by using Lisp's dynamic
;; binding to locally redefine the side-effects to, say, do nothing and yield true.
(defun go () (if (file-exists-p "nice.txt") 'yay 'boom))
(ert-deftest eg-mock ()
  (flet ((file-exists-p (file) t))
    (should (equal (go) 'yay))))

;; Run all tests; run tests táµ¢ with: (ert (or 't0 ... 'tN))
;; (ert t)

;; Execute all blocks, then run all tests.
;; (progn (org-babel-execute-buffer) (ert t))

;; Shortcut
(local-set-key (kbd "C-x e")
  (lambda () (interactive) (ert t)))
#+END_SRC

In the ~*ert*~ buffer, press ~r~ on a test to re-run it.
+ Re-run failed tests to ensure that they are deterministic before trying to find
  the cause for the failure.
  - ~m~ to see the messages that the test may have emitted, and ~b~ to see the backtrace.
+ The logical error may be in the test, rather than the code.
+ See [[https://www.gnu.org/software/emacs/manual/html_node/ert/Interactive-Debugging.html#Interactive-Debugging][here]] for more tips.
  + [ ] See [[http://www.gigamonkeys.com/book/][Practical Common Lisp]]'s Chapter 9 on [[http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html][Practical: Building a Unit Test Framework]].
:End:

#+EXCLUDE_TAGS: :noexport:

** COMMENT org/ob-agda setup                                        :load_me:
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-org/ob-agda-setup
   :END:

 Just C-c C-c this block (â€¢Ì€á´—â€¢Ì)Ùˆ
 #+begin_src emacs-lisp
(add-to-list 'org-src-lang-modes '("results-agda" . org-agda))

;; No code execution on export
;; âŸª For a particular block, we use â€œ:eval never-exportâ€ âŸ«
;;
(setq org-export-use-babel nil)

(progn "Set up some colours *before* loading org-agda-mode"

  (setq org-agda-extra-word-colours nil)
(add-to-list 'org-agda-extra-word-colours '("typeclass" 0 'agda2-highlight-keyword-face))
(add-to-list 'org-agda-extra-word-colours '("PackageFormer" 0 'font-lock-type-face))
(add-to-list 'org-agda-extra-word-colours '("_â¨¾_" 0 'font-lock-type-face))
(add-to-list 'org-agda-extra-word-colours '("assoc" 0 'font-lock-type-face))

;; Treat the following words as if they were â€˜typesâ€™; i.e., bold red.
(dolist (word (s-split " " "PackageFormer _â¨¾_ assoc rightId leftId Semigroup-semantics Semigroup-syntax SemigroupOn M.*") org-agda-extra-word-colours)
  (add-to-list 'org-agda-extra-word-colours `(,word 0 'font-lock-type-face))
  )

  ; (load-file "~/org-agda-mode/org-agda-mode.el")
  (load-file "~/org-agda-mode/literate.el")
)

;; org-agda-mode.el has now deviated as follows:
;;
; (defvar org-agda-extra-word-colours nil "other words that user of org-mode wants coloured, along with their specified font-lock-type-face")
;
; (define-generic-mode
;     'org-agda-mode                      ;; name of the mode
;     (list '("{-" . "-}"))               ;; comments delimiter
;     org-agda-keywords
;     ;; font lock list: Order of colouring matters;
;     ;; the numbers refer to the subpart, or the whole(0), that should be coloured.
;     (-concat  ;; â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜… org-agda-extra-word-colours is a free variable, user should define it /before/ loading org-agda-mode â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
           (if (boundp (quote org-agda-extra-word-colours)) org-agda-extra-word-colours nil)
;     (list â‹¯) â‹¯))

;; Also this so people use â€œagdaâ€ instead of being forced to use â€œorg-agdaâ€
;;
;;  If an Emacs major-mode named <lang>-mode exists, where <lang> is the language identifier from code blockâ€™s header line, then the edit buffer uses that major-mode. Use this variable to arbitrarily map language identifiers to major modes.
;;
(add-to-list 'org-src-lang-modes '("agda" . ob-agda))

;; The following allows me to do â€œC-c C-câ€ on agda org-src blocks.
;; The result is just the src body parroted to us, no â€œevaluationâ€ performed.
;;
;;
;; (async-shell-command "cp  ~/.emacs.d/elpa/org-9.2.3/ob-C.el ~/org-agda-mode/ob-agda.el")

; (async-shell-command "ln -s ~/org-agda-mode/ob-agda.el ~/.emacs.d/elpa/org-plus-contrib-20190408/ob-agda.el")
(load-file "~/org-agda-mode/ob-agda.el")

;; Execute this for alias:
(add-to-list 'org-src-lang-modes '("results-agda" . ob-agda))
;; (defalias 'results-agda 'org-agda)

;;
;; (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((agda . t)))
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Tangleing happens for each language, one at a time, but I want to tangle
;; lisp blocks into an agda file AND in an org-file I want them to be coloured like lisp.
;; Here's my workaround.
(when nil  ; does not work

(add-to-list 'org-src-lang-modes '("agda-lisp" . emacs-lisp))

(defalias 'agda-lisp nil)

(defun momentarily-pretend-lisp-is-agda (orig-fun &rest args)
  ; (setq org-src-lang-modes (delete '("agda-lisp" . emacs-lisp) org-src-lang-modes))
  ; (add-to-list 'org-src-lang-modes '("agda-lisp" . ob-agda))
  (-let [result (apply orig-fun args)]
  ; (pop org-src-lang-modes)
  ; (add-to-list 'org-src-lang-modes '("agda-lisp" . emacs-lisp))
  result))

(advice-add #'org-babel-tangle :around #'momentarily-pretend-lisp-is-agda)

)
 #+end_src

 #+RESULTS:

** HTML Stuffs                                                       :ignore:
   :PROPERTIES:
   :CUSTOM_ID: HTML-Stuffs
   :END:
 # super brief intro to tables: https://www.w3schools.com/html/html_tables.asp
 # See here for a nice intro to tables: https://www.w3.org/TR/CSS2/tables.html
 # Here for borders: https://www.w3schools.com/css/css_border.asp
 #
 #
 #+begin_export html
 <style>

 /* wrap lengthy lines for code blocks */
 pre{white-space:pre-wrap}

 /* inline code; see here for other colours: https://www.w3schools.com/colors/colors_names.asp */
 code { background: Cyan;
        border-radius: 5px; /* How curvy the borders should be. */
 }

 table {
     background: pink;
     border-radius: 10px; /* How curvy the borders should be. */
     /* width:90% */

     border-bottom: hidden;
     border-top: hidden;

     /* Put table in the center of the page, horizontally. */
     margin-left:auto;margin-right:auto;

     font-family:"Courier New";
     font-size:90%;
 }

 /* table â€˜dâ€™ata elements

   no padding
 */
 td {
     border: 0px solid red; padding: 1em;
     /* border: none;
     border-left: 1px solid transparent;
     border-right: 1px solid transparent; */
 }

 /* Alter visible labels of source blocks */
 pre.src-agda:before { content: 'Agda'; }
 pre.src-haskell:before { content: 'Agda'; }
 pre.src-org:before { content: 'Text'; }

 /* Using source blocks â€œagda-resultsâ€ as pink-background coloured blocks in HTML. */
 /* pre.src-results-agda:before { content: 'Results: Agda'; } */
 pre.src-results-agda { background: pink;}
 /* Execute this for alias: (add-to-list 'org-src-lang-modes '("results-agda" . org-agda)) */

 </style>
 #+end_export

*** Macro: fold                                                      :ignore:
    :PROPERTIES:
    :CUSTOM_ID: Macro:-fold
    :END:
 # Folding up some code blocks in the resulting html.
 #
 # Usage: {{{fold(title here)}}} contents {{{end-fold}}}
 #
 #+MACRO: end-fold  #+HTML: </details>
 #+MACRO: fold      #+HTML: <details class="code-details"> <summary> <strong> <font face="Courier" size="3" color="green"> $1 </font> </strong> </summary>

*** org-notes-style setup                                            :ignore:
    :PROPERTIES:
    :CUSTOM_ID: org-notes-style-setup
    :END:

  # Turn off default internal styles
  #+OPTIONS: html-style:nil html5-fancy:t

  # Exporting to HTML5
  #+HTML_DOCTYPE: html5
  #+HTML_HEAD: <meta http-equiv="X-UA-Compatible" content="IE=edge">
  #+HTML_HEAD: <meta name="viewport" content="width=device-width, initial-scale=1">

  # Add notes.css here
  #+HTML_HEAD: <link href="./org-notes-style.css" rel="stylesheet" type="text/css" />
* Abstract                                                           :ignore:
  :PROPERTIES:
  :CUSTOM_ID: Abstract
  :END:
#+BEGIN_CENTER org
*Abstract*
#+END_CENTER
#+begin_quote org
This article is about implementing a prototype supporting [[https://alhassy.github.io/next-700-module-systems/][â€œthe next 700 module systemsâ€ proposal]]
as an editor extension. In particular, we show how intimately related presentations of a type
can be /derived automatically/ from a single generic declaration which we call a ~PackageFormer~.

Think of a language that does not support currying and you need to have a function of
10 arguments that needs to support accepting any number of arguments less than 10, say
for partial application. In such languages, one must utilise the builder design pattern,
or quickly copy-paste the function 10 times, altering it slightly each time.
In general, if such a function definition requires /N/ lines and /M/ forms of the function
are needed, then nearly /N Ã— M/ lines of code are written manually.

Our prototype deals with this problem, among others, for functions on /types/
---i.e., type constructors--- and reduces this quadratic count to a linear
count /N + M/: One declaration of /N/ lines, then /M/ lines, each being an instantiation
of the desired form. These ideas are discussed in the pre-print
[[../papers/gpce19_a_language_feature_to_unbundle_data_at_will.pdf][A Language Feature to Unbundle Data at Will]].

*Design patterns for theories become library methods!*
An interesting side-effect of having meta-primitives for packages
is that traditional patterns for theories
---e.g., homomorphisms, syntax, interpretation functions---
can now be codified as general re-usable methods.

The ideas are targeted to the dependently-typed language Agda.
However, with little alterations they could easily be made to target
other languages, such as Haskell and Coq. The ideas transcend the presentation
language, Agda. Ideally, variational definitions would also be in the host
language rather than in Lisp but that would require alteration to the host
language itself, and Lisp with Emacs hooks is much easier to do; for now.
/This is an Emacs centric language extension./

The [[Aim: /Scrap the Repetition/][first section]] below quickly elaborates on our goal,
after that is a â€˜[[User Manual][user manual]]â€™, then the remainder of
the article serves as literate documentation of the prototype;
as well as an opportunity for me to explore emojis.
To follow along, it may be useful to look at an [[https://alhassy.github.io/ElispCheatSheet/][Elisp Cheat Sheet]].
#+end_quote

# In some sense, we are â€œcontinuingâ€ the story of Z's schemas.

#+BEGIN_CENTER org
/Everything here works with Agda version 2.6.0./
#+END_CENTER

| Results of tests and [[file:PackageFormer.agda][examples]] will be in pink, like this. |

#+TOC: headlines 3

* Aim: /Scrap the Repetition/
  :PROPERTIES:
  :CUSTOM_ID: Aim:-/Scrap-the-Repetition/
  :END:

We're going to write a code generator in Lisp that is going to interpret
fictitious Agda code ---henceforth referred to as â€œ700 codeâ€---
into currently legitimate Agda code.

For example, something like the following, henceforth referred to as ~test~:
#+NAME: test
#+BEGIN_Src agda :results replace :exports code
PackageFormer M-Set : Setâ‚ where
   Scalar  : Set
   Vector  : Set
   _Â·_     : Scalar â†’ Vector â†’ Vector
   ğŸ™       : Scalar
   _Ã—_     : Scalar â†’ Scalar â†’ Scalar
   leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)

Semantics     = M-Set record
Syntax        = M-Set data with tags (Scalar; Vector)
UntypedSyntax = M-Set data with identified carrier (Scalar; Vector)
ScalarSyntax  = M-Set data with identified carrier (Scalar)
Stream        = M-Set parameterised codata with identified carrier (Vector) renaming (_Â·_â‚ to head; _Â·_â‚‚ to tail)
VectorSyntax  = M-Set data with identified carrier (Vector) and variables (embed) from (Scalar)
NearMonoid    = M-Set record renaming (Scalar to Carrier; Vector to Carrier; _Â·_ to _â¨¾_; _Ã—_ to _â¨¾_)
#+END_Src

:Hide:
#+RESULTS: test
#+begin_example
PackageFormer M-Set : Setâ‚ where
   Scalar  : Set
   Vector  : Set
   _Â·_     : Scalar â†’ Vector â†’ Vector
   ğŸ™       : Scalar
   _Ã—_     : Scalar â†’ Scalar â†’ Scalar
   leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)

Semantics     = M-Set record
Syntax        = M-Set data with tags (Scalar; Vector)
UntypedSyntax = M-Set data with identified carrier (Scalar; Vector)
ScalarSyntax  = M-Set data with identified carrier (Scalar)
Stream        = M-Set parameterised codata with identified carrier (Vector) renaming (_Â·_â‚ to head; _Â·_â‚‚ to tail)
VectorSyntax  = M-Set data with identified carrier (Vector) and variables (embed) from (Scalar)
NearMonoid    = M-Set record renaming (Scalar to Carrier; Vector to Carrier; _Â·_ to _â¨¾_; _Ã—_ to _â¨¾_)
#+end_example

#
# The â€œ:results replaceâ€ is since we actually want the results of this
# block later on when using â€œtestâ€ as a org-provided variable to org-src blocks.
:End:

:Hide_Needs_CcCvCb:
# Someplaces I want to use â€˜testâ€™ without having it in the header, whence:
#+BEGIN_SRC emacs-lisp :var outsidetest = test :exports both :results none
(setq test outsidetest)
#+END_SRC
:End:

Will behave as if it were written:
#+BEGIN_Src agda
record Semantics : Setâ‚ where
  field
    Scalar  : Set
    Vector  : Set
    _Â·_     : Scalar â†’ Vector â†’ Vector
    ğŸ™       : Scalar
    _Ã—_     : Scalar â†’ Scalar â†’ Scalar
    leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
    assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)

data SyntaxTag : Set where Scalar Vector : SyntaxTag
data Syntax : SyntaxTag â†’ Setâ‚ where
    _Â·_     : Syntax Scalar â†’ Syntax Vector â†’ Syntax Vector
    ğŸ™       : Syntax Scalar
    _Ã—_     : Syntax Scalar â†’ Syntax Scalar â†’ Syntax Scalar

data UntypedSyntax : Setâ‚ where
    _Â·_     : UntypedSyntax â†’ UntypedSyntax â†’ UntypedSyntax
    ğŸ™       : UntypedSyntax
    _Ã—_     : UntypedSyntax â†’ UntypedSyntax â†’ UntypedSyntax

data ScalarSyntax : Setâ‚ where
    ğŸ™       : ScalarSyntax
    _Ã—_     : ScalarSyntax â†’ ScalarSyntax â†’ ScalarSyntax

{- Nutshell: Keep items ending in â€œStream Carrierâ€, then discard that ending,
         then form a subscripted version for each argument.
-}
record Stream (Carrier : Set) : Setâ‚ where
  coinductive
  field
    head : Carrier
    tail : Stream Carrier

data VectorSyntax (Scalar : Set) : Setâ‚ where
    embed   : Scalar â†’ VectorSyntax
    _Â·_     : Scalar â†’ VectorSyntax â†’ VectorSyntax

record NearMonoid : Setâ‚ where
  field
    Carrier : Set
    _â¨¾_     : Carrier â†’ Carrier â†’ Carrier
    ğŸ™       : Carrier
    leftId  : {ğ“‹ : Carrier}  â†’  ğŸ™ â¨¾ ğ“‹  â‰¡  ğ“‹
    assoc   : {a b : Carrier} {ğ“‹ : Carrier} â†’ (a â¨¾ b) â¨¾ ğ“‹  â‰¡  a â¨¾ (b â¨¾ ğ“‹)
#+END_Src
This is a more than a <<<200% increase>>> in size; that is, our fictitious code will
save us a lot of repetition.

The above is ideal syntax: In Lisp fashion, we are not limiting our vision to what
we can currently be done. The actual syntax that is currently supported by this
program is surprisingly close to the above, with an occasional ~-~ or ~:~ inserted.
Just look at the following source file and resulting generated code!

{{{fold(PackageFormer.agda)}}}
#+INCLUDE: "PackageFormer.agda" src agda
{{{end-fold}}}

{{{fold(PackageFormer_Generated.agda)}}}
#+INCLUDE: "PackageFormer_Generated.agda" src agda
{{{end-fold}}}

Above is a sample source file which contains special comments that are picked up
by the prototype which then copy-paste-cuts to produce a generated file.
The above code is discussed below, in the user manual
---in fact, it's generated from the user-manual below.

 For this prototype, we have the following <<<constraints>>>:

1. The type of a PackageFormer is ~Set â„“~ where ~â„“~ is the empty string
   or a parenthesised expression of type ~Level~.
   - In-particular, subscript types are not yet supported.

2. The ~where~ keyword appears on the same line as the ~PackageFormer~ key-phrase.

3. The name of the PackageFormer should not contain ~PackageFormer~ as a sub-identifier.

4. Each element of a PackageFormer spans only /one/ physical line.

There are many useful features outlined in the proposal, such as default implementations, that we
hope to include in the future. For now, we just want something that works, is decently documented, and
can be useful.
* User Manual
:PROPERTIES:
:CUSTOM_ID: user-manual
:header-args: :tangle "PackageFormer.agda"
:END:

If the previous section is unclear regarding the aims and uses of this prototype,
please consult the pre-print [[../papers/gpce19_a_language_feature_to_unbundle_data_at_will.pdf][A Language Feature to Unbundle Data at Will]]
or [[https://alhassy.github.io/next-700-module-systems/][the next 700 module systems proposal]].

** Installation
   :PROPERTIES:
   :CUSTOM_ID: Installation
   :END:

{{{goal(Obtaining the system!)}}}

Click here to obtain [[https://raw.githubusercontent.com/alhassy/next-700-module-systems-proposal/master/prototype/PackageFormer.el][PackageFormer.el]], place it somewhere, open an Agda file, execute
~M-x your/location/PackageFormer.el~, then enable the mode by executing ~M-x 700-mode~.

*Alternatively*, add the following to your Emacs configuration file:
#+BEGIN_SRC emacs-lisp :tangle no
;; Ensure you have the pre-requsite libraries ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                                       ;;
;; String and list manipulation libraries                                                ;;
;; https://github.com/magnars/dash.el                                                    ;;
;; https://github.com/magnars/s.el                                                       ;;
(package-install 's)                ;; â€œThe long lost Emacs string manipulation libraryâ€ ;;
(package-install 'dash)             ;; â€œA modern list library for Emacsâ€                 ;;
(package-install 'fold-this)        ;; Folding away regions of text                      ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Next, obtain the Elisp file, load it, and attach it to Agda.

(shell-command (concat "curl "
  "https://raw.githubusercontent.com/alhassy/next-700-module-systems-proposal/master/PackageFormer.el "
  ">> ~/.emacs.d/PackageFormer.el"))

(load-file "~/.emacs.d/PackageFormer.el")

(add-hook 'agda2-mode-hook #'700-mode)
#+END_SRC

When you enable ~700-mode~:

0. A menu-bar ~700PackageFormers~ will be added.

1. It will allow you to temporarily disable and enable this new feature,
   as well as providing a help menu. Invoke ~M-x 700-mode~ to toggle turning off this feature
   completely.

2. The string icon ~700 (â€¢Ì€á´—â€¢Ì)Ùˆ~ is displayed in the mode line ---near the bottom of Emacs.

3. You may use ~C-c c-l~ as usual, but it will now recognise 700-comments and generate
   legitimate Agda code from them ---more on this later.

   - PackageFormer syntactical items are coloured green, PackageFormer names are
     coloured yellow, and their instantiation are simply bolded.
     # To update a coloured
     # item, simply save then ~revert-buffer~ (F5), then reload with ~C-c C-l~.

If you need any assistance, please contact me!

** Syntax
   :PROPERTIES:
   :CUSTOM_ID: Syntax
   :END:
{{{goal(Superficial glance at the system's syntax.)}}}

The prototype works by translating fictitious 700-syntax into legitimate Agda;
as follows:
#+BEGIN_SRC agda :tangle no
...agda code here...
{-700
       ...700-syntactical items here...
-}
...more agda code...
#+END_SRC
Since the first section provides an example source fragment with both 700-comments as well
as instantiations, we shall only enclose 700-syntax in 700-comments when it is surrounded
by other Agda code, and otherwise leave it free standing.

/We will provide full source listings at the end of discussions that only display fragments!/

 <<<700-syntax>>> is defined informally as follows:
#+BEGIN_EXAMPLE text
âŸª700-syntaxâŸ«    ::=  âŸªPackageFormerâŸ« | âŸªInstantiationâŸ« | âŸªAgdaâŸ«

âŸªPackageFormerâŸ« ::= PackageFormer âŸªIdentifierâŸ« : Set (âŸªlevelâŸ«) where
               âŸªnewline-with-indentationâŸ« âŸªElementâŸ«*

âŸªElementâŸ«       ::=  âŸªIdentifierâŸ« : âŸªAny-Agda-TypeâŸ«

âŸªInstantiationâŸ« ::= âŸªIdentifierâŸ« = âŸªIdentifierâŸ« âŸªVariationalClauseâŸ«

âŸªVariationalClauseâŸ« ::= [âŸªIdentifierâŸ«] (:key (value))* (âŸ´ âŸªVariationalClauseâŸ«)*
#+END_EXAMPLE

:Old:
#+BEGIN_EXAMPLE text
{- Only listing the currently implemented -}
âŸªVariationâŸ«     ::= typeclass | data | record
âŸªVOpâŸ«           ::=   renaming âŸªToListâŸ«
            | unbundling âŸªâ„•âŸ«
            | exposing (âŸªSemicolon-seperated-list-of-IdentifiersâŸ«)
            | with     âŸªToListâŸ«

âŸªToListâŸ« ::= (âŸªIdentifierâ‚€âŸ« to âŸªIdentifierâ‚€âŸ«; â‹¯; âŸªIdentifierâ‚™âŸ« to âŸªIdentifierâ‚™âŸ«) {- for any n : â„• -}
#+END_EXAMPLE
:End:

+ One derives many presentations of a grouping mechanism by what we call â€˜variational clausesâ€™.
  - In a 700-comment, one declares â€˜variationalâ€™ such as
     | ~ğ’±-typeclass height = :kind record :level dec :waist-strings ("field") :waist height~   |

     These are functions whose names begin with ~ğ’±-~, they may have arguments on the left-hand-side,
     and their right hand side may invoke any of the 5 meta-primitives
     ~kind, waist, waist-strings, level, alter-elements~ with any mixture of
     arguments and concrete values.

     # - These is limited Agda syntax support; in doubt, Lisp syntax is used.

     - To invoke a variational in an instantiation clause, arguments are not positional
       but instead are passed by name ---e.g., ~:key value~.

#   Note that package formation has been liberated from the backend and brought to the user
#   via our 5 meta-primitives: preamble, kind, waist, waist-strings, level, alter-elements.

+ Example uses of the variational clauses could be seen in the ~Testing.agda~ listing in the first section above.

** Lisp Interface                                                      :TODO:
   :PROPERTIES:
   :CUSTOM_ID: Lisp-Interface
   :END:
{{{goal(Summary of useful functions for programming variationals.)}}}

   Need to explain that a PackageFormer element is a structure consisting of a qualifier, name, type, and list of equational clauses.

   Then, need to tersely summarise the operations, projections & maps, on these items.

** User Manual Header
   :PROPERTIES:
   :CUSTOM_ID: User-Manual-Header
   :END:
{{{goal(A literate programming approach to a user manual.)}}}

   In order for our manual's examples to be up-to-date, we will take a literate approach
   to producing them. Namely, the Agda code here is â€˜tangledâ€™ from this prose into an Agda
   file which can then be checked by an Agda process. Whence, this file is the de-facto source.

   Let's start-off with a usual Agda header:
#+BEGIN_SRC agda
{- This loads the PackageFormer metaprogram          -}
{- (progn (load-file "PackageFormer.el") (700-mode)) -}

module PackageFormer where

open import PackageFormer_Generated
open import Level
open import Data.Bool
open import Relation.Binary.PropositionalEquality using (_â‰¡_)
open import Data.String hiding (_++_)
#+END_SRC
#
# Strip away the 700 annotations with:
# (progn (700-bare-bones) (find-file "Testing_Bare.agda"))

To make the resulting Agda file somewhat self-contained, in case anyone wishes to read that
or load it into Agda and play with it, let's add a blurb.
#+BEGIN_SRC agda
{-
0. There are a number of common use-cases.
1. We can handle all of them & more, since we're extensible.
  - Mention the Lean & Coq, as well as the Agda, repeated fragments.
2. The resulting setup is pragmatic: It is unobtrusive in the
   traditional Agda coding style in that it happens in the background.
3. It fills a particular need; the desire to avoid repetitious code.
-}
#+END_SRC

Before getting to the meat of things, it is important to note that comments
begun with ~{-~ /and/ followed by a space are treated as usual Agda comments,
whereas those /without/ a following space such as ~{-700~ and ~{-lisp~ are picked-up
by our meta-program.

For example, having no space between â€œ{-â€ and â€œlispâ€ would cause the following block to be executed
as a Lisp form.
#+BEGIN_SRC agda
{- lisp
(message-box "Hello")
(message-box "World")
-}
#+END_SRC

Alternatively, here is a example PackageFormer for monoids as well as that of M-Sets from earlier.
#+BEGIN_SRC agda
{-700
PackageFormer MonoidP : Setâ‚ where
    Carrier : Set
    _â¨¾_     : Carrier â†’ Carrier â†’ Carrier
    Id      : Carrier
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x

PackageFormer M-Set : Setâ‚ where
   Scalar  : Set
   Vector  : Set
   _Â·_     : Scalar â†’ Vector â†’ Vector
   ğŸ™       : Scalar
   _Ã—_     : Scalar â†’ Scalar â†’ Scalar
   leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)

-}
#+END_SRC

:not_yet_implemented:
TODO: implement support for literate blocks

The ~{-700 â‹¯ -}~ approach may be acceptable to those writing ~.agda~ files,
but those who write ~.lagda~ files may find themselves often having
~\begin{code} {-700 â‹¯ -} \end{code}~ which is rather clunky.
Instead, they may simply write ~\begin{700} â‹¯ \end{700}~ and similarly for ~lisp~.

| Henceforth, we omit the comment delimiters. |

For example, here is our earlier PackageFormer of ~M-Set~'s declared in full.
#+BEGIN_SRC agda :tangle no
PackageFormer M-Set : Setâ‚ where
   Scalar  : Set
   Vector  : Set
   _Â·_     : Scalar â†’ Vector â†’ Vector
   ğŸ™       : Scalar
   _Ã—_     : Scalar â†’ Scalar â†’ Scalar
   leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
#+END_SRC
:end:

** Empty Variationals
   :PROPERTIES:
   :CUSTOM_ID: Empty-Variationals
   :END:
{{{goal(A summary of the key features of ğ’±ariationals/)}}}

   The simplest user definable variational is the empty one:
#+BEGIN_SRC agda
{-700
-- Variational with empty right hand side.
ğ’±-identity =
-}
        #+END_SRC

   The prefix ~ğ’±-~ signals to the Elisp meta-program that this particular equation is intended
   to be a variational and should be /loaded into Emacs/ as such. Indeed, you may view the documentation
   and /elaborated/ Lisp of this definition using ~C-h o RET ğ’±-identity~.

   *Remember*: The prefix ~ğ’±-~ only occurs at the definition site, the call site omits it.
   Why? We have augmented the Emacs system with a new functional definition, and the ğ’±-
   serves as a namespace delimiter.

   Indeed, we may now perform the following invocation ---within 700-comments.

        #+BEGIN_SRC agda
{-700
MonoidPâ±áµˆ = MonoidP identity
-}
        #+END_SRC

 Loading the meta-program using Agda's usual ~C-c C-l~ lets us
 hover over ~MonoidPâ±áµˆ~ to see its elaboration is precisely that of ~MonoidP~.

 /Moreover/, to be useful, all variationals
 have tooltips showing their user-defined documentation.
 If we hover over ~identity~, we are informed that it is undocumented.
 User documentation is optional and may appear immediately following the ~=~, as follows.
#+BEGIN_SRC agda
{-700
ğ’±-no-op = "This is the do-nothing variational"
-}
        #+END_SRC

We may substitute equals-for-equals:
        #+BEGIN_SRC agda
{-700
-- No variational clauses needed!
MonoidPâ°  = MonoidP
-}
        #+END_SRC

Doing nothing is meaningful with respect to a composition operation.
Momentarily, â€œâŸ´â€ is forwards composition: We â€˜threadâ€™ the ~Pf~ through the variationals ~váµ¢~ in order.

        #+BEGIN_SRC agda
{-700
-- Identity of composition âŸ´
MonoidPá¶œ = MonoidP âŸ´
-}
#+END_SRC

| Operationally: ~Pf âŸ´ v  â‰ˆ  Pf v âŸ´  â‰ˆ  Pf v~ |

We may also augment a variational with positional and (optional) keyword arguments that have default values.
The keyword arguments along with their default value, /if any/, are enclosed in parenthesis.
#+BEGIN_SRC agda
{-700
ğ’±-test positional (keyword 3) another = "I have two mandatory arguments and one keyword argument"

Monoid-test = MonoidP âŸ´ test "positional argâ‚" "positional argâ‚‚" :keyword 25
-}
#+END_SRC

We are not doing anything with the arguments here; we shall return to this in later subsections.

** Records and Meta-Primitives ~:kind~ & ~:alter-elements~
   :PROPERTIES:
   :CUSTOM_ID: Records-and-Meta-Primitives-~:kind~-&-~:waist-strings~
   :END:
   Let's begin with the simplest thing: Realising these fictitious â€˜PackageFormersâ€™ as records.

   An Agda â€˜recordâ€™ is just a PackageFormer where the qualifier ~PackageFormer~ has been
   replaced with ~record~ and each element is qualified by Agda keyword ~field~.
   We may declare this particular configuration using the meta-primitives
   ~:kind~ and ~:alter-elements~, as follows.
#+BEGIN_SRC agda
{-700
ğ’±-record = :kind record :alter-elements (Î» es â†’ (--map (map-qualifier (Î» _ â†’ "field") it) es))
-}
#+END_SRC

   *Huh?*
   The ~:kind~ part was already explained, the ~:alter-elements~ is the powerhouse of our system.
   It takes a function with argument being the list of PackageFormer elements, ~es~,
   then we perform a functorial list map where each element is implicitly referred to as ~it~.
   Then the map function is to alter the qualifier of an element by replacing it with the string ~"field"~.
   In Agda syntax this corresponds to: ~Î» es â†’ map (Î» it â†’ (map-qualifier (Î» _ â†’ "field") it)) es~.
   \\
   Notice that the Agda form and Lisp form are only one outer parenthesis off from each other ---Lisp is easy!

   | /The ~:key value~ syntax is inspired from Lisp/ |

   Unsurprisingly, we have elected to name this grouping mechanism configuration as ~ğ’±-record~.
   Let's try it out.
#+BEGIN_src agda
{-700
M-Set-Record = M-Set record
-}
#+END_SRC

   The system picks this up, looks up ~M-Set~ which was defined in the first section earlier,
   looks up the variational ~record~, then runs that configuration to generate:
#+BEGIN_SRC results-agda :tangle no
{- M-Set-Record = M-Set record -}
record M-Set-Record : Setâ‚ where
   field Scalar     : Set
   field Vector     : Set
   field _Â·_        : Scalar â†’ Vector â†’ Vector
   field ğŸ™      : Scalar
   field _Ã—_        : Scalar â†’ Scalar â†’ Scalar
   field leftId     : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   field assoc      : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
#+END_src

  Nothing too remarkable; the keyword ~field~ has been inserted and the rewrite ~PackageFormer â†¦ record~
  has been performed. The above is the /exact/ generated result of the system ---the comment indicates
  the source of this generated code.

  Since this is a variational that is likely to be used often, it is sensible to document it
  ---which in turn is attached to all occurences of the variational name via tooltips.
#+BEGIN_SRC agda
{-lisp
(ğ’± record = "Reify a variational as an Agda â€œrecordâ€."
            :kind record
            :alter-elements (Î» es â†’ (--map (map-qualifier (Î» _ â†’ "field") it) es)))
-}
#+END_SRC

   Unlike ~ğ’±-identity~ from the previous section, we have decided to split this definition into multiple
   lines by enclosing it in ~{-lisp â‹¯ -~}~. Such blocks may contain arbitrary Lisp to be executed and so
   all contents must be Lisp forms ---notice the ~ğ’±-â‹¯~ from ~700~-blocks has been *exchanged* for
   a parenthesised (~ğ’± â‹¯)~ within ~lisp~-blocks.

   :Hide_export_to_el:
   #+BEGIN_SRC lisp :tangle "variationals.tmp"
(ğ’± record = "Reify a variational as an Agda â€œrecordâ€."
            :kind record
            :alter-elements (Î» es â†’ (--map (map-qualifier (Î» _ â†’ "field") it) es)))
#+END_SRC
:End:

** â‡¨ Errors
   :PROPERTIES:
   :CUSTOM_ID: â‡¨-Errors
   :END:
  Even though this is a prototype, we wish it to be useful to ourselves and to others
  ---especially those who take a quick glance, think they got it, and try things out only to not have them work
  immediately. As such, we have implemented a cute little error-reporting system.
  | If you try to load, ~C-c C-l~, but your 700-syntax is wrong, you get an immediate error explaining why â™¥â€¿â™¥ |

  For example, suppose we accidentally wrote ~recorder~ instead of ~record~ for the ~:kind~ as in the following.
  ( The space before ~700~ is so that this crashing block is not in effect. )
#+BEGIN_SRC agda
{-   700
ğ’±-whoops  = :kind recorder
-}
#+END_SRC
  Even thought we have the correct invocation, say ~M-Set-Record = M-Set whoops~,
  when we try to load our Agda file the Agda process is interrupted and we are warned:
#+BEGIN_SRC text :tangle no
 700: This kind â€œrecorderâ€ is not supported by Agda!
      Valid kinds: record, data, module, PackageFormer.

    â‡¨	whoops  = :kind recorder
#+END_SRC
  The 700 system informs us of our fault in â€œquotesâ€, suggests a solution,
  and points to the offending declaration hierarchy. Neato (â€¢Ì€á´—â€¢Ì)Ùˆ

** Typeclasses ---Parameterised Records--- and Meta-Primitives ~:waist~ & ~:level~
   :PROPERTIES:
   :CUSTOM_ID: Typeclasses----Parameterised-Records----and-Meta-Primitives-~:waist~-&-~:level~
   :END:

    We mentioned the <<<â€œwaistâ€>>> before, but what is it exactly?
    I propose that the difference between â€˜fieldâ€™ and â€˜parameterâ€™
    is an illusion ---as is that of â€˜inputâ€™ and â€˜outputâ€™ when one
    considers relations rather than deterministic functions.

    For example, let's alter the previous variation declaration to
    lift the waist up 2 positions.
#+BEGIN_src agda
{-700
ğ’±-typeclass-attempt = record âŸ´ :waist 2
-}
        #+END_SRC

   Notice we have avoided repeating the definition of the ~record~ variational from
   earlier by making use of composition. More on it later, but it suffices to say
   that above we could replace ~record âŸ´~ with the exact text of ~ğ’±-record = â‹¯~ right-hand-side
   and all would continue work.

   Trying this out, below, one notices that the first two elements of the PackageFormer have been lifted
   into being parameters, while the rest have been construed as fields.
       #+BEGIN_SRC agda
{-700
M-Set-TypeClass = M-Set typeclass-attempt
-}
                   #+END_SRC
                   #+BEGIN_SRC results-agda :tangle no
record M-Set-TypeClass (Scalar : Set) (Vector : Set) : Setâ‚ where
   field _Â·_        : Scalar â†’ Vector â†’ Vector
   field ğŸ™      : Scalar
   field _Ã—_        : Scalar â†’ Scalar â†’ Scalar
   field leftId     : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   field assoc      : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
#+END_src

   While this typechecks according to Agda standards, it is not ideal to human
   standards since the level of the resulting package is larger than necessary.
   The meta-primitive ~:level~ allows us to ~inc~-rement or ~dec~-crement the
   current level of a PackageFormer, so we may instead define:
#+BEGIN_src agda
{-700
ğ’±-typeclassâ‚‚ = record âŸ´ :waist 2 :level dec
MonoidTâ‚‚      = MonoidP typeclassâ‚‚
-}
        #+END_SRC

        #+BEGIN_SRC results-agda :tangle no
record MonoidTâ‚‚ (Carrier : Set) (_â¨¾_ : Carrier â†’ Carrier â†’ Carrier) : Set where
    field Id        : Carrier
    field assoc     : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    field leftId        : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    field rightId       : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x
        #+END_SRC

        #+BEGIN_SRC results-agda :tangle no
{-700
ğ’±-typeclassâ‚‚    = :kind record :waist-strings ("field") :waist 2 :level dec
M-Set-Typeclassâ‚‚ = M-Set typeclassâ‚‚
-}
record M-Set-Typeclassâ‚‚ (Scalar : Set) (Vector : Set) : Set where
   field _Â·_        : Scalar â†’ Vector â†’ Vector
   field ğŸ™      : Scalar
   field _Ã—_        : Scalar â†’ Scalar â†’ Scalar
   field leftId     : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   field assoc      : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
#+END_src

  Unlike records, typeclasses scream to have an argument: The height of the waist.
  Variationals may have arguments and we will cover this issue in a later subsection
  in preference to continuing our purview of the meta-primitives.

  For fun, here are a few more to play with:
#+BEGIN_SRC agda
{-700
MonoidTâ‚ƒ         = MonoidP record âŸ´ :waist 3 :level dec
M-Set-Typeclassâ‚‚ = M-Set record âŸ´ typeclassâ‚‚
-}
#+END_SRC

In particular, the last example suggest that our composition is idempotent, but this is clearly not the case.
Indeed, here's a pretty alternative to the meta-primitive ~:waist~ that is not âŸ´-idempotent
but is in-fact a homomorphism: ~exposing n âŸ´ exposing m â‰ˆ exposing (n + m)~.
#+BEGIN_SRC lisp :tangle "variationals.tmp"
(ğ’± exposing n
 = "Make the first N elements as parameters to the PackageFormer"
   :waist n)
#+END_SRC
Play with it! We'll return to arguments later on.
#+BEGIN_SRC agda
{-700
MonoidTâ‚ƒ-again = MonoidP âŸ´ record âŸ´ exposing 3
-}
#+END_SRC

** Primed Decoration and ~rename-mixfix~
   :PROPERTIES:
   :CUSTOM_ID: Primed-Decoration-and-the-Meta-Primitive-~alter-elements~
   :END:

    When we have two occurrences of a structure, we may want one of them to be decorated
    say with a prime so as to disambiguate them easily rather than have to qualify all
    of their components.

#+BEGIN_src agda
{-700
-- Intensionally erroenous attempt.
ğ’±-primed-attempt = :alter-elements (Î» es â†’ (--map (map-name (Î» n â†’ (rename-mixfix (Î» op â†’ (concat op "â€²")) n)) it) es))

-- M-Setâ€²-attempt = M-Set record âŸ´ primed-attempt
-}
#+END_SRC

#+BEGIN_SRC results-agda :tangle no
record M-Setâ€²-attempt : Setâ‚ where
   field Scalarâ€²        : Set
   field Vectorâ€²        : Set
   field _Â·â€²_       : Scalar â†’ Vector â†’ Vector
   field ğŸ™â€²     : Scalar
   field _Ã—â€²_       : Scalar â†’ Scalar â†’ Scalar
   field leftIdâ€²        : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   field assocâ€²     : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
{- This is crashing Agda code; as expected. Working improvements below. -}
#+END_src

   There are number of issues to address.

   1. The system comes with a Lisp methods ~map-name~ and ~map-type~ that yield the name and type part,
      respectively, of a PackageFormer element.

   2. The ~:key value~ pairs have legitimate Lisp for the ~value~ positions.

      The basics of list processing, such as maps/filters/folds, with Lisp suffice for a rich
      inventory of possible configurations. Moreover, the functional nature of such higher-order
      functions ought to be familiar to any Agda coder [[https://www.phrases.org.uk/meanings/worth-ones-salt.html][worth their salt]].

      Here's a terse tutorial rendered as an [[https://alhassy.github.io/ElispCheatSheet/][Elisp Cheat Sheet]].

   3. One would expect catenating a prime to the mixfix name ~_Ã—_~ would yield ~_Ã—_â€²~ but above
      it yielded ~_Ã—â€²_~. Indeed, the former would yield confusing expressions of the form
      ~1 Ã— 2 â€²~ whereas the latter permits ~1 Ã—â€² 2~. It is with this pragmatic usage that
      ~rename-mixfix~ performs a rewrite to a name by jumping over the Agda mixfix marker, ~_~,
      if it occurs at the start or end of a name.

      As an additional example, the name
      ~_â‰ˆ_âˆ¶_~, under the above scheme, would have rewritten to ~_â‰ˆ_âˆ¶â€²_~ thereby
      allowing terms such as ~x â‰ˆ y âˆ¶ A  â†’  f x â‰ˆ f y âˆ¶â€² B~ ---a elegant way to
      express that, say, ~f~ is a setoid homomorphism.
      If the prime scheme were instead a prepend, we would have obtained the name
      ~_â€²â‰ˆ_âˆ¶_~.

   # Notice that the generated code is commented out: The current type of the package
   # is not an admissible construct in Agda.

   # Moreover, if we try to instantiate this package further, say as in    ~Mâ€² = M-Setâ€²-attempt record~

   Notice that
   we have fields such as ~ğŸ™â€² : Scalar~
   whose type is a free variable: ~Scalar~ no longer refers to any field.
   As such, the above code is ill-typed.
   The solution then is to /propagate/ any changes a name has down to its siblings.

   Indeed, /propagating the name changes:/
#+BEGIN_SRC agda
{-lisp
(ğ’± primer = :alter-elements (lambda (es)
   (let* ((esnew es)
         ;; Let's try to accomodate for names with underscores
         (names_ (--map (element-name it) es))
         (names  (--map (s-replace "_" "" it) names_))
         (oldies (append names names_)))

     (loop for old in oldies
           for new in (--map (rename-mixfix (Î» n â†’ (concat n "â€²")) it) oldies)
           do
           (setq esnew (--map (element-replace old new it) esnew)))

     ;; return value
     esnew)))
-}
#+END_SRC

Then, for example:
#+BEGIN_SRC agda
{-700
MRâ€² = M-Set record âŸ´ primer
-}
        #+END_SRC

        #+BEGIN_SRC results-agda :tangle no
record MRâ€² : Setâ‚ where
   field Scalarâ€²        : Set
   field Vectorâ€²        : Set
   field _Â·â€²_       : Scalarâ€² â†’ Vectorâ€² â†’ Vectorâ€²
   field ğŸ™â€²     : Scalarâ€²
   field _Ã—â€²_       : Scalarâ€² â†’ Scalarâ€² â†’ Scalarâ€²
   field leftIdâ€²        : {ğ“‹ : Vectorâ€²}  â†’  ğŸ™â€² Â·â€² ğ“‹  â‰¡  ğ“‹
   field assocâ€²     : {a b : Scalarâ€²} {ğ“‹ : Vectorâ€²} â†’ (a Ã—â€² b) Â·â€² ğ“‹  â‰¡  a Â·â€² (b Â·â€² ğ“‹)
#+END_SRC

:maybe_not:
   Since 700-declarations must be single lines, we are forced to have something like
   the following ---which you are not expected to understand, but it serves as a nice
   comparison and motivation for the alternative approach below.
#+BEGIN_SRC results-agda :tangle no
{-700

ğ’±-primedâ‚—â‚‘â‚œ = :alter-elements (lambda (fs) (-as-> (-unzip (--zip-with `(,other  ,(format "let %s = %s in " (get-name it) (get-name other))) fs (--map (map-name (concat name "â€²") it) fs))) yup (--zip-with (map-type (concat (s-join "" it) type) other) (-inits (cadr yup)) (car yup))))

MonoidRâ€²   =  MonoidP record âŸ´ primedâ‚—â‚‘â‚œ
-}

record MonoidRâ€² : Setâ‚ where
  field
    Carrierâ€² : Set
    _â¨¾â€²_ : let Carrier = Carrierâ€² in Carrier â†’ Carrier â†’ Carrier
    Idâ€² : let Carrier = Carrierâ€² in let _â¨¾_ = _â¨¾â€²_ in Carrier
    assocâ€² : let Carrier = Carrierâ€² in let _â¨¾_ = _â¨¾â€²_ in let Id = Idâ€² in âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftIdâ€² : let Carrier = Carrierâ€² in let _â¨¾_ = _â¨¾â€²_ in let Id = Idâ€² in let assoc = assocâ€² in âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightIdâ€² : let Carrier = Carrierâ€² in let _â¨¾_ = _â¨¾â€²_ in let Id = Idâ€² in let assoc = assocâ€² in let leftId = leftIdâ€² in âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x

#+END_SRC
:End:

** First-class PackageFormers
   :PROPERTIES:
   :CUSTOM_ID: Composition-~âŸ´~-and-First-class-PackageFormers
   :END:

   The previous example caused an Agda typechecking error, however if we do not
   invoke the ~record~ variational then the result is a non-Agda syntactical item
   which can only be the subject of further alteration via PackageFormer combinators.
#+BEGIN_src agda
{-700
M-Setâ€²-attempt-raw = M-Set primed-attempt
-}
        #+END_SRC

        #+BEGIN_SRC results-agda :tangle no
{- Kind â€œPackageFormerâ€ does not correspond  to a concrete Agda type.
PackageFormer M-Setâ€²-attempt-raw : Setâ‚ where
   Scalarâ€²      : Set
   Vectorâ€²      : Set
   _Â·â€²_     : Scalar â†’ Vector â†’ Vector
   ğŸ™â€²       : Scalar
   _Ã—â€²_     : Scalar â†’ Scalar â†’ Scalar
   leftIdâ€²      : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   assocâ€²       : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹) -}
#+END_src

    This is interesting: We have not generated a concrete ---legitimate Agda construct---
    but instead yielded a new abstract grouping mechanism which may be instantiated later on,
    whenever desired.

    Likewise, we have already declared ~M-Set-Record = M-Set record~ and now we may apply
    our priming variational.
    #+BEGIN_src results-agda :tangle no
{- M-Set-Recordâ€² = M-Set-Record primed-attempt -}
record M-Set-Recordâ€² : Setâ‚ where
   field Scalarâ€²        : Set
   field Vectorâ€²        : Set
   field _Â·â€²_       : Scalar â†’ Vector â†’ Vector
   field ğŸ™â€²     : Scalar
   field _Ã—â€²_       : Scalar â†’ Scalar â†’ Scalar
   field leftIdâ€²        : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   field assocâ€²     : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
#+END_src

    | /We may apply  variationals even to concrete Agda packaging constructs!/ |

    Of-course, we may simply want to obtain ~M-Set-Recordâ€²~ without having first
    to define ~M-Set-Record~, and so we may use the variational composition operator ~âŸ´~.

#+BEGIN_src results-agda :tangle no
{- M-Set-Recordâ€² = M-Set record âŸ´ primed-attempt -}
record M-Set-Recordâ€² : Setâ‚ where
   field Scalarâ€²        : Set
   field Vectorâ€²        : Set
   field _Â·â€²_       : Scalar â†’ Vector â†’ Vector
   field ğŸ™â€²     : Scalar
   field _Ã—â€²_       : Scalar â†’ Scalar â†’ Scalar
   field leftIdâ€²        : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   field assocâ€²     : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
#+END_src

   Since the ~record~ and ~primed~ configurations are â€˜disjointâ€™, they commute
   with respect to composition. The reader may want to confirm the following identifications:
#+BEGIN_SRC agda :tangle no
      M-Set-Recordâ€²
   â‰ˆ  M-Set record âŸ´ primed-attempt
   â‰ˆ  M-Set primed-attempt âŸ´ record
   â‰ˆ  M-Setâ€² record
   â‰ˆ  M-Set-Record primed-attempt
#+END_SRC

It is important to remember that these primed perspectives do /not/ typecheck in Agda due to the free-variable
issue mentioned earlier. We are only demonstrating composition, ~âŸ´~, in this section; in a later section we
fix-up ~primed~.

** Variationals with Arguments ---~map, rename, [co]decorated, subscriptedáµ¢, renaming~
   :PROPERTIES:
   :CUSTOM_ID: Variationals-with-Arguments----~map,-rename,-[co]decorated,-renaming~
   :END:

    Thus far our variationals have been nullary, let's consider otherwise.

    For example, let's add arguments to the typeclass variational from earlier.
    :Not_now:
    An issue with this is that it may decrement the level too much; e.g., try it with
    no args given to M-Set.
    #+BEGIN_SRC lisp :tangle no
(ğ’± typeclass (height 1) (level 'dec)
  = "Expose the first element and decrese the package's level ---c.f. Haskell typeclass.

     The optional keywords HEIGHT and LEVEL may be used to expose any number of
     elements and possibly increment the level, respectively.
    "
    record âŸ´ :waist height :level level)
    #+END_SRC
    :End:
    #+BEGIN_src agda
{-700
ğ’±-typeclass height (level 'dec) = record âŸ´ :waist height :level level
M-Set2-Typeclassâ‚ƒ = M-Set typeclass 3 :level 'inc
M-Set0-Typeclassâ‚ƒ = M-Set typeclass 3
-}
        #+END_SRC

        #+BEGIN_SRC results-agda :tangle no
record M-Set2-Typeclassâ‚ƒ (Scalar : Set) (Vector : Set) (_Â·_ : Scalar â†’ Vector â†’ Vector) : Setâ‚‚ where
   field ğŸ™      : Scalar
   field _Ã—_        : Scalar â†’ Scalar â†’ Scalar
   field leftId     : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   field assoc      : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)

record M-Set0-Typeclassâ‚ƒ (Scalar : Set) (Vector : Set) (_Â·_ : Scalar â†’ Vector â†’ Vector) : Set where
   field ğŸ™      : Scalar
   field _Ã—_        : Scalar â†’ Scalar â†’ Scalar
   field leftId     : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   field assoc      : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
#+END_src

   + Argument come before the ~=~ in a variational's definition and
     the may be used as if they were constants on the right-hand side.
     0. Above we introduced the named arguments ~height~ and ~level~.
     1. The first is positional, and the second is a keyword argument
        with /default/ value being a decrement value.
     2. We then passed the /argument/ ~level~ to the /meta-primitive/ ~:level~.

   + Invocation of variationals has positional arguments first then named arguments afterwards.
     One supplies a named argument in the form ~:argument-name the-value~ ---this is Lisp-inspired syntax.

     Consequently, order is irrelevant for named arguments.

     - Supplying ~:key value~ pairs where the ~key~ is not a named argument of
       the variational yields a error message indicating the allowable keys.

   # â± If an argument is not supplied or its value is unacceptable, the cute
   # error-reporting mechanism is activated ---as is the case with other
   # pertinent aspects of loading such declarations.

   Let's code up the priming operation as a reusable pattern ---call it ~map~.
#+BEGIN_SRC lisp :tangle "variationals.tmp"
(ğ’± map elements (support-mixfix-names t)
   = "Apply function ELEMENTS that acts on PackageFormer elements,
      then propogate all new name changes to subsequent elements.

      There is minimal support for mixfix names, but it may be
      ignored by setting SUPPORT-MIXFIX-NAMES to be nil.
     "
     :alter-elements (lambda (es)
    (let* ((esnew   (mapcar elements es))
           (_       (if support-mixfix-names "" "_"))
           (names   (--map (s-replace "_" _ (element-name it)) es))
           (namesâ€²  (--map (s-replace "_" _ (element-name it)) esnew)))
      (loop for old in names
            for new in namesâ€²
            do (setq esnew (--map (element-replace old new it) esnew)))
      ;; return value
      esnew)))
#+END_SRC

  This is a prototype; ideally the variational definition would be rendered in
  Agda code. Rather than using functional combinators such as
  ~unzip, map, zip-with~, for diversity, we used imperative constructs.

Important observations include:

1. The Lisp code lives in a ~{-lisp â‹¯ -}~ block.

2. 700-comments have single-line ~ğ’±-name args = rhs~, whereas lisp-blocks
   have multi-line ~(ğ’± name args = rhs)~ ---the dash after the ğ’± is gone and outer-most
   parenthesis are added.

3. To provide minimal accommodation for mixfix names, we simply remove the
   Agda argument indicator â€˜_â€™ when performing rewrites.

   E.g., Agda let's you
   declare a name such as ~_âŠ•_~ and use it without mentioning the underscore
   as in ~x âŠ• y~ and so the rename ~_âŠ•_ â†¦ _âŠ•â€²_~ would have no effect since ~_âŠ•_~
   does not occur as a substring in ~x âŠ• y~, whence the need to ignore the underscores.

Trying it out:
#+BEGIN_SRC agda
{-700
MRğ•    = M-Set record âŸ´ map (Î» e â†’ (map-name (Î» n â†’ (rename-mixfix (Î» x â†’ (concat x "ğ•")) n)) e))
-}
        #+END_SRC
#+BEGIN_SRC results-agda :tangle no
record MRğ• : Setâ‚ where
   field Scalarğ•        : Set
   field Vectorğ•        : Set
   field _Â·ğ•_       : Scalarğ• â†’ Vectorğ• â†’ Vectorğ•
   field ğŸ™ğ•     : Scalarğ•
   field _Ã—ğ•_       : Scalarğ• â†’ Scalarğ• â†’ Scalarğ•
   field leftIdğ•        : {ğ“‹ : Vectorğ•}  â†’  ğŸ™ğ• Â·ğ• ğ“‹  â‰¡  ğ“‹
   field assocğ•     : {a b : Scalarğ•} {ğ“‹ : Vectorğ•} â†’ (a Ã—ğ• b) Â·ğ• ğ“‹  â‰¡  a Â·ğ• (b Â·ğ• ğ“‹)
#+END_SRC

Now for some useful corollaries.
# For diversity, we render these in lisp-blocks.
#+BEGIN_SRC  lisp :tangle "variationals.tmp"
(ğ’± rename f (support-mixfix-names t)
  =  "Rename elements using a string-to-string function F acting on names.

      There is minimal support for mixfix names, but it may be
      ignored by setting SUPPORT-MIXFIX-NAMES to be nil.
     "
     map (Î» e â†’ (map-name (Î» n â†’ (rename-mixfix f n)) e))
         :support-mixfix-names 'support-mixfix-names)
#+END_SRC

Let's try this out.
#+BEGIN_SRC agda
{-700
MRğ•ª    = M-Set record âŸ´ rename (Î» n â†’ (concat n "ğ•ª"))
MR-oh  = M-Set record âŸ´ rename (Î» n â†’ (pcase n ("Scalar" "S") ("ğŸ™" "Îµ") (else else)))
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record MRğ•ª : Setâ‚ where
   field Scalarğ•ª        : Set
   field Vectorğ•ª        : Set
   field _Â·ğ•ª_       : Scalarğ•ª â†’ Vectorğ•ª â†’ Vectorğ•ª
   field ğŸ™ğ•ª     : Scalarğ•ª
   field _Ã—ğ•ª_       : Scalarğ•ª â†’ Scalarğ•ª â†’ Scalarğ•ª
   field leftIdğ•ª        : {ğ“‹ : Vectorğ•ª}  â†’  ğŸ™ğ•ª Â·ğ•ª ğ“‹  â‰¡  ğ“‹
   field assocğ•ª     : {a b : Scalarğ•ª} {ğ“‹ : Vectorğ•ª} â†’ (a Ã—ğ•ª b) Â·ğ•ª ğ“‹  â‰¡  a Â·ğ•ª (b Â·ğ•ª ğ“‹)


{- MR-oh  = M-Set record âŸ´ rename (Î» n â†’ (pcase n ("Scalar" "S") ("ğŸ™" "Îµ") (else else))) -}
record MR-oh : Setâ‚ where
   field S      : Set
   field Vector     : Set
   field _Â·_        : S â†’ Vector â†’ Vector
   field Îµ      : S
   field _Ã—_        : S â†’ S â†’ S
   field leftId     : {ğ“‹ : Vector}  â†’  Îµ Â· ğ“‹  â‰¡  ğ“‹
   field assoc      : {a b : S} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
                        #+END_SRC

We would expect it to be common to prefix and suffix symbols, so let's make
variationals for these patterns.
#+BEGIN_SRC lisp :tangle "variationals.tmp"
(ğ’± decorated by
  = "Rename all elements by suffixing string BY to them."
     rename (Î» name â†’ (concat name by)))

(ğ’± co-decorated by
  = "Rename all elements by prefixing string BY to them."
     rename (Î» name â†’ (concat by name)))

(ğ’± primed
  = "All elements are renamed with a postfix prime."
    decorated "â€²")
#+END_SRC

Likewise, for the casing approach, let's make a â€œto listâ€.
For now, such lists are necessarily enclosed in double-quotes.
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp"
(ğ’± renaming by
  = "Rename elements using BY, a â€œ;â€-separated string of â€œtoâ€-separated pairs."
  rename '(lambda (name)
      (let (clauses)
        (thread-last by
          (s-split ";")
          (--map (s-split " to " it))
          (--map (list (s-trim (car it)) (s-trim (cadr it))))
          (-cons* 'pcase 'name)
          (setq clauses)
        )
        (eval (append clauses '((otherwise otherwise)))))))
#+END_SRC

We may also prefer writing ~subscriptedáµ¢~ rather than ~decorated "áµ¢"~.
With a bit of Lisp meta-programming, we can generate these variationals.
#+BEGIN_SRC lisp :tangle "variationals.tmp"
(defun to-subscript (n)
  "Associate a digit â€˜nâ€™ with its subscript."
  (nth n '("â‚€" "â‚" "â‚‚" "â‚ƒ" "â‚„" "â‚…" "â‚†" "â‚‡" "â‚ˆ" "â‚‰")))

(loop for i from 0 to 9
      do (let* ((áµ¢    (to-subscript i))
               (docs (format "Subscript all elementes by suffixing them with %s." i)))
               (eval `(ğ’± ,(intern (format "subscripted%s" áµ¢)) = ,docs decorated ,áµ¢))))
#+END_SRC

Here are some example uses.
#+BEGIN_SRC agda
{-700
MRâ‚â‚‚   = M-Set record âŸ´ decorated "â‚" âŸ´ decorated "â‚‚"
the-MR = M-Set record âŸ´ co-decorated "the-"
MRâ‚ƒâ‚„   = M-Set record âŸ´ subscriptedâ‚ƒ âŸ´ subscriptedâ‚„
MRâ‚œâ‚’   = M-Set record âŸ´ renaming "Scalar to S; Vector to V; Â· to nice"
NearMonoid = M-Set record âŸ´ renaming "Scalar to Carrier; Vector to Carrier; Â· to Ã—"
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
{- MRâ‚â‚‚   = M-Set record âŸ´ decorated "â‚" âŸ´ decorated "â‚‚" -}
record MRâ‚â‚‚ : Setâ‚ where
   field Scalarâ‚â‚‚       : Set
   field Vectorâ‚â‚‚       : Set
   field _Â·â‚â‚‚_      : Scalarâ‚â‚‚ â†’ Vectorâ‚â‚‚ â†’ Vectorâ‚â‚‚
   field ğŸ™â‚â‚‚        : Scalarâ‚â‚‚
   field _Ã—â‚â‚‚_      : Scalarâ‚â‚‚ â†’ Scalarâ‚â‚‚ â†’ Scalarâ‚â‚‚
   field leftIdâ‚â‚‚       : {ğ“‹ : Vectorâ‚â‚‚}  â†’  ğŸ™â‚â‚‚ Â·â‚â‚‚ ğ“‹  â‰¡  ğ“‹
   field assocâ‚â‚‚        : {a b : Scalarâ‚â‚‚} {ğ“‹ : Vectorâ‚â‚‚} â†’ (a Ã—â‚â‚‚ b) Â·â‚â‚‚ ğ“‹  â‰¡  a Â·â‚â‚‚ (b Â·â‚â‚‚ ğ“‹)

{- the-MR = M-Set record âŸ´ co-decorated "the-" -}
record the-MR : Setâ‚ where
   field the-Scalar     : Set
   field the-Vector     : Set
   field _the-Â·_        : the-Scalar â†’ the-Vector â†’ the-Vector
   field the-ğŸ™      : the-Scalar
   field _the-Ã—_        : the-Scalar â†’ the-Scalar â†’ the-Scalar
   field the-leftId     : {ğ“‹ : the-Vector}  â†’  the-ğŸ™ the-Â· ğ“‹  â‰¡  ğ“‹
   field the-assoc      : {a b : the-Scalar} {ğ“‹ : the-Vector} â†’ (a the-Ã— b) the-Â· ğ“‹  â‰¡  a the-Â· (b the-Â· ğ“‹)

{- MRâ‚ƒâ‚„   = M-Set record âŸ´ subscriptedâ‚ƒ âŸ´ subscriptedâ‚„ -}
record MRâ‚ƒâ‚„ : Setâ‚ where
   field Scalarâ‚ƒâ‚„       : Set
   field Vectorâ‚ƒâ‚„       : Set
   field _Â·â‚ƒâ‚„_      : Scalarâ‚ƒâ‚„ â†’ Vectorâ‚ƒâ‚„ â†’ Vectorâ‚ƒâ‚„
   field ğŸ™â‚ƒâ‚„        : Scalarâ‚ƒâ‚„
   field _Ã—â‚ƒâ‚„_      : Scalarâ‚ƒâ‚„ â†’ Scalarâ‚ƒâ‚„ â†’ Scalarâ‚ƒâ‚„
   field leftIdâ‚ƒâ‚„       : {ğ“‹ : Vectorâ‚ƒâ‚„}  â†’  ğŸ™â‚ƒâ‚„ Â·â‚ƒâ‚„ ğ“‹  â‰¡  ğ“‹
   field assocâ‚ƒâ‚„        : {a b : Scalarâ‚ƒâ‚„} {ğ“‹ : Vectorâ‚ƒâ‚„} â†’ (a Ã—â‚ƒâ‚„ b) Â·â‚ƒâ‚„ ğ“‹  â‰¡  a Â·â‚ƒâ‚„ (b Â·â‚ƒâ‚„ ğ“‹)

{- MRâ‚œâ‚’ = M-Set record âŸ´ renaming "Scalar to S; Vector to V; Â· to nice" -}
record MRâ‚œâ‚’ : Setâ‚ where
   field S      : Set
   field V      : Set
   field _nice_     : S â†’ V â†’ V
   field ğŸ™      : S
   field _Ã—_        : S â†’ S â†’ S
   field leftId     : {ğ“‹ : V}  â†’  ğŸ™ nice ğ“‹  â‰¡  ğ“‹
   field assoc      : {a b : S} {ğ“‹ : V} â†’ (a Ã— b) nice ğ“‹  â‰¡  a nice (b nice ğ“‹)

{- NearMonoid = M-Set record âŸ´ renaming "Scalar to Carrier; Vector to Carrier; Â· to Ã—" -}
record NearMonoid : Setâ‚ where
   field Carrier        : Set
   field _Ã—_        : Carrier â†’ Carrier â†’ Carrier
   field ğŸ™      : Carrier
   field leftId     : {ğ“‹ : Carrier}  â†’  ğŸ™ Ã— ğ“‹  â‰¡  ğ“‹
   field assoc      : {a b : Carrier} {ğ“‹ : Carrier} â†’ (a Ã— b) Ã— ğ“‹  â‰¡  a Ã— (b Ã— ğ“‹)
#+END_SRC

Some observations are in order:

0. Example ~Mâ‚â‚‚~ demonstrates that composition, âŸ´, is sequential from left to right.
   That is, â€œâŸ´â€ is just forwards composition: We thread the given PackageFormer
   through the variationals ~váµ¢~ in order. Operationally:

   | Pf vâ‚€ âŸ´ â‹¯ âŸ´ vâ‚™ â‰ˆ ((Pf vâ‚€) vâ‚) â‹¯) vâ‚™ |
   | Pf âŸ´ v  â‰ˆ  Pf v âŸ´  â‰ˆ  Pf v          |

   Note: In the concrete syntax, parenthesisation is not permitted.

1. Notice that the ~NearMonoid~ example demonstrates multiplicity of PackageFormer elements is irrelevant.
   That is, elements are algebraically a the free monoid with the axiom ~xs âŠ• ys âŠ• xs â‰ˆ xs âŠ• ys~.

2. *Notice that we wanted  Agda-style renaming via ~to~-lists, so we simply code that up!*
   This is so cool: We can just extend the system with whatever pattern we prefer!
   No more bending to the will of language designers! More power to the user!

   For example, we can codify the previous ~NearMonoid~ scheme into a top-level pattern.
#+BEGIN_SRC lisp :tangle "variationals.tmp"
(defun is-sort (element)
  "Check whether the target of â€˜elementâ€™s type is â€œSetâ€. "
  (s-contains? "Set" (target (element-type element))))
  ;; Method â€˜targetâ€™ is defined in the next subsection, on ADTs.

(ğ’± single-sorted with-sort
  = "Replace all nullary sorts with the provided WITH-SORT string
     as the name of the new single sort, the universe of discourse."
    map (Î» e â†’ (if (is-sort e) (map-name (Î» _ â†’ with-sort) e) e)))
#+END_SRC

   Then the previous PackageFormer can be obtained with:
   Note that the following differs from ~NearMonoid~ since it has two binary operations:
   Our new variational one alters the number and name of sorts, not other elements.
#+BEGIN_SRC agda
{-700
NearMonoidÂ¹ = M-Set record âŸ´ single-sorted "Carrier"
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record NearMonoidÂ¹ : Setâ‚ where
   field Carrier        : Set
   field _Â·_        : Carrier â†’ Carrier â†’ Carrier
   field ğŸ™      : Carrier
   field _Ã—_        : Carrier â†’ Carrier â†’ Carrier
   field leftId     : {ğ“‹ : Carrier}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   field assoc      : {a b : Carrier} {ğ“‹ : Carrier} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
#+END_SRC

*Exercise:*
Write a variational ~remove-sorts~ that strips out all sorts from a PackageFormer.
If elements depend on sorts, as they normally do, then one must remove them as well;
ignore this for now, and we shall return to subgenerated PackageFormers later on.
** Forming Syntax and the Special ~$ğ‘›ğ‘ğ‘šğ‘’~ Variable
   :PROPERTIES:
   :CUSTOM_ID: Forming-Syntax-and-the-Special-~$ğ‘›ğ‘ğ‘šğ‘’~-Variable
   :END:

  |  /Records provide a semantics, what if we want the syntax?/ |

Since ~data~ declarations consist of constructors, whose target type necessarily
begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.
To do so, we use the helper function ~target~ which takes a declaration ~name : type0 â†’ â‹¯ â†’ typeN~ and yields ~typeN~.

#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp"
(defun target (thing)
  " Given a type-name â€˜[name :] Ï„â‚€ â†’ â‹¯ â†’ Ï„â‚™â€™, yield â€˜Ï„â‚™â€™;
    the â€˜nameâ€™ porition is irrelevant.
  "
  (car (-take-last 1 (s-split "â†’" thing))))
#+END_SRC

With this in hand, a ~data~ presentation requires a designated ~carrier~ which is used to
keep only those elements that target it. Finally, as data constructor must target the
type being defined, we alter the filtered elements by changing every instance of the
carrier name with the name of the newly defined PackageFormer ---which we may access
using the special identifier ~$ğ‘›ğ‘ğ‘šğ‘’~. In a ~lisp~ block, we formalise this algorithm as follows.
#+BEGIN_src emacs-lisp  :tangle "variationals.tmp"
(ğ’± data carrier
  = "Reify as an Agda â€œdataâ€ type.

     Only elements targeting CARRIER are kept.
    "
    :kind  data
    :level dec
    :alter-elements (lambda (es)
      (thread-last es
        (--filter (s-contains? carrier (target (element-type it))))
        (--map (map-type (Î» Ï„ â†’ (s-replace carrier $ğ‘›ğ‘ğ‘šğ‘’ Ï„)) it)))))
#+END_SRC

For example:
#+BEGIN_SRC agda
{-   700
ScalarTerm = M-Set data "Scalar"
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
data ScalarTerm : Set where
   ğŸ™        : ScalarTerm
   _Ã—_      : ScalarTerm â†’ ScalarTerm â†’ ScalarTerm
#+END_SRC

Again:
The meta-primitive ~:alter-elements~ is instructed to map over those
elements ~e~ that contain the ~carrier~ in their ~target~ type
by replacing the given ~carrier~ with the newly-minted ~$ğ‘›ğ‘ğ‘šğ‘’~ of
the grouping mechanism being constructed. Those that do not
contain the given ~carrier~ in their target type are filtered out.

Notice that ~$ğ‘›ğ‘ğ‘šğ‘’~ is a special variable that refers to the newly defined PackageFormer's name.
- It is written using ~\Mi~ with Agda input; e.g., ~\Min~ gives ~ğ‘›~.
- The â€˜$â€™ is intended to further mark the special nature of this variable.

** COMMENT TODO: another adt example
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-TODO:-another-adt-example
   :END:
*Important*: Notice that, in the second example above,
#+BEGIN_SRC results-agda :tangle no
{- ScalarSyntax = M-Set primer âŸ´ data :carrier "Scalarâ€²" -}
data ScalarSyntax : Set where
   ğŸ™â€² : ScalarSyntax
   _Ã—â€²_ : ScalarSyntax â†’ ScalarSyntax â†’ ScalarSyntax
#+END_src
the name of the carrier is ~Scalarâ€²~ since we changed the
PackageFormer to prime all elements, including the ~Scalar~, element.
#+BEGIN_SRC results-agda  :tangle no
{- No = M-Set primer âŸ´ data :carrier "Scalar" -}
data No : Set where
   ğŸ™â€² : Noâ€²
   _Ã—â€²_ : Noâ€² â†’ Noâ€² â†’ Noâ€²

{- Crashes since type Noâ€² is not defined! -}
#+END_SRC

** Shallow Renaming with Agda's ~open â‹¯ public â‹¯ renaming â‹¯~      :out_of_date:
   :PROPERTIES:
   :CUSTOM_ID: Shallow-Renaming-with-Agda's-~open-â‹¯-public-â‹¯-renaming-â‹¯~
   :END:
    The previous approach to renaming altered field names literally which is not
    desirable when one only wants to refer to field names of multiple instances
    of the same record ---e.g., when forming homomorphisms.

    A common pattern in Agda is then to open the record and perform the desired
    shallow renames. This pattern is so common that the standard library is littered
    with instances of it. We can codify the pattern as a method rather than as a
    manual technique.

    Let's go from zero to one-hundred ---again: There's a Lisp Cheat Sheet that should
    have been consulted at one point.

    Zero: A module where the elements are all parameters.
#+BEGIN_SRC results-agda
{-700
ğ’±-empty-module = :kind module :level none :waist 999
Neato = M-Set empty-module
-}

module Neato (Scalar : Set) (Vector : Set) (_Â·_ : Scalar â†’ Vector â†’ Vector) (ğŸ™ : Scalar) (_Ã—_ : Scalar â†’ Scalar â†’ Scalar) (leftId : {ğ“‹ : Vector} â†’ ğŸ™ Â· ğ“‹ â‰¡ ğ“‹) (assoc : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹ â‰¡ a Â· (b Â· ğ“‹)) where
#+END_SRC

   One-hundred: A one-parameter module where elements may be renamed.
#+BEGIN_SRC emacs-lisp
;; â€œwithâ€ is a renaming string-to-string function.
(ğ’± open with
  = :kind module
    :level none
    :waist 1
    :waist-strings '("")
    :alter-elements  (lambda (fs)
      (let ((kind "{! !}"))
        (thread-last
           (--map (format "%s to %s" (get-name it) (rename-mixfix with (get-name it))) fs)
           ;; Resulting elements must be a list, so we make a singleton list.
           (s-join "\n       ; ")
           (format "    ( %s\n       )")
           list

           ;; Stick on the renaming, which in turn requires an opening clause;
           ;; which in turn requires a module parameter.
           (cons "  renaming")
           (cons (format "open %s â„› public" $ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡))
           (cons (format "â„› : %s" $ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡)))))
)

(ğ’± open-with decoration
  = open :with (lambda (x) (concat x decoration)))
#+END_SRC

  Here is an example use ---where we first declare a ~record~ perspective of ~M-Set~'s then
  use that to produce two decorated variants.
#+BEGIN_SRC results-agda
{-700
M-Set-R = M-Set record
M-Set-Râ‚ = M-Set-R open :with (lambda (x) (concat x "â‚"))
M-Set-Râ‚‚ = M-Set-R open-with :decoration "â‚‚"
-}

module M-Set-Râ‚ (â„› : M-Set-R) where
   open M-Set-R â„› public
     renaming
       ( Scalar to Scalarâ‚
       ; Vector to Vectorâ‚
       ; _Â·_ to _Â·â‚_
       ; ğŸ™ to ğŸ™â‚
       ; _Ã—_ to _Ã—â‚_
       ; leftId to leftIdâ‚
       ; assoc to assocâ‚
       )

module M-Set-Râ‚‚ (â„› : M-Set-R) where
   open M-Set-R â„› public
     renaming
       ( Scalar to Scalarâ‚‚
       ; Vector to Vectorâ‚‚
       ; _Â·_ to _Â·â‚‚_
       ; ğŸ™ to ğŸ™â‚‚
       ; _Ã—_ to _Ã—â‚‚_
       ; leftId to leftIdâ‚‚
       ; assoc to assocâ‚‚
       )
#+END_SRC

   These kind of open-renamings are so common that the tedium
   is actually acceptable by most users ---it shouldn't be
   and now it no longer has to be that way.

** Subpacakges with ~generated, sorts, signature~                 :out_of_date:
   :PROPERTIES:
   :CUSTOM_ID: Subpacakges-with-~generated,-sorts,-signature~
   :END:

    A common grouping operation is to zoom-in to the minimal well-formed
    package that contains only certain specified elements. For example,
    in our ~M-Set~ grouping, we may want to keep only ~ğŸ™~ but to be well-defined
    we are forced to also keep the elements on which it depends ---namely, ~Scalar~.

    In particular, the following naive approach only works if the elements are
    independent of one another ---which is rarely the case for Agda users.
#+BEGIN_SRC emacs-lisp
;; cute, but too brutish.
ğ’±-generated by = :alter-elements (lambda (fs) (-filter by fs))
#+END_SRC

    The coherent scheme is straightforward to implement.
    For clarity, rather than efficiency,
    the algorithm below forms a list ~yeses~ of the elements that should be kept
    then traverses the elements list, adding all elements needed to ensure that list
    is coherent. Moreover, for generality, we consider a predicate rather than an explicit
    listing of items to be retained.

#+BEGIN_SRC emacs-lisp
;; â€œbyâ€ is a predicate on elements.
(ğ’± generated by
  = :alter-elements  (lambda (fs)
      (let* ( (yeses (--map (funcall by it) fs))
              (get-yeses (lambda () (--filter it (--zip-with (if it other) yeses fs))))
              (in-yeses (lambda (e)
                          (--any
                           (s-contains? (s-replace "_" " " (get-name e)) (get-type it))
                           (funcall get-yeses)))))

        (loop for _ in fs do
              (loop for f in fs
                    for i from 0
                    do ;; when f in yess, set f to be yes.
                    (when (funcall in-yeses f) (setf (nth i yeses) t))))

        (funcall get-yeses))))
#+END_SRC

Here's an immediate application: Obtaining the types declared in a grouping mechanism.
#+BEGIN_SRC results-agda
{-700
ğ’±-sorts = generated :by (lambda (f) (s-contains? "Set" (target (get-type f))))

M-Set-Sorts = M-Set record âŸ´ sorts
-}
record M-Set-Sorts : Setâ‚ where
 field
   Scalar  : Set
   Vector  : Set
#+END_SRC

We can even obtain a sub-signature wholesale:
#+BEGIN_SRC results-agda
{-700
MonoidSignature = M-Set record âŸ´ generated :by (lambda (f) (and (s-contains? "Scalar" f) (not (s-contains? "Vector" f))))
-}
record MonoidSignature : Setâ‚ where
 field
   Scalar  : Set
   ğŸ™       : Scalar
   _Ã—_     : Scalar â†’ Scalar â†’ Scalar
#+END_SRC

This pattern of having a lawless grouping seems sufficiently desirable that we may
codify it.
#+BEGIN_SRC results-agda
{-lisp
(defun targets-a-sort (element)
  (--any (s-contains? it (target element)) (-map #'get-name (-filter #'is-sort $ğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘ ))))

(ğ’± signature = generated :by (lambda (f) (targets-a-sort f)))
-}

{-700
MonSig = M-Set record âŸ´ signature
-}
record MonSig : Setâ‚ where
 field
   Scalar  : Set
   Vector  : Set
   _Â·_     : Scalar â†’ Vector â†’ Vector
   ğŸ™       : Scalar
   _Ã—_     : Scalar â†’ Scalar â†’ Scalar
#+END_SRC

   Neato!

** Automatically deriving homomorphism definitions â™¥â€¿â™¥          :out_of_date:
   :PROPERTIES:
   :CUSTOM_ID: Automatically-deriving-homomorphism-definitions-â™¥â€¿â™¥
   :END:

    The definition of â€œstructure preservationâ€ is, nearly always, mechanical to
    formulate and that's just what we shall do to avoid having to write it out
    by hand ever again.

    :Illuminating_yet_overkill_to-subscript_defn:
#+BEGIN_SRC emacs-lisp
(defun to-subscript (n)
  "Subscript numbers ğ“ƒ have hex-codes #x208ğ“ƒ,
   we realise the codes as characters to obtain the subscripts.

   This is preferable to casing:
  (pcase i (0 â€œâ‚€â€) (1 â€œâ‚â€) (2 â€œâ‚‚â€) â‹¯)

  When â€˜nâ€™ âˆ‰ 0..9 an error message halts execution.
  "

  (when (or (< n 0) (> n 9))
    (error "to-subscript: n must be in 0..9"))

  (thread-last
    (format "#x208%s" n)
    (read-from-string)
    car
    (format "%c")))
#+END_SRC
    :End:

    The idea is not too complicated:
    1. Suppose you have an operation ~_Â·_ : Scalar â†’ Vector â†’ Vector~.
    2. Suppose you have a numbering of the sorts; e.g., ~sortâ‚ = Scalar, sortâ‚‚ = Vector~.
    3. Form functions ~mapáµ¢ : sortáµ¢ â†’ sortáµ¢â€²~
    4. Include implicit arguments in the type: ~{xâ‚ : Scalar} â†’ {xâ‚‚ : Vector} â†’ Vector~.
    5. The target type ~Vector = sortâ‚‚~ means we need to apply ~mapâ‚‚~ to the expression
       formed from the operation's name along with the arguments.
       - The left hand side is thus ~mapâ‚‚ (_Â·_ xâ‚ xâ‚‚)~.
    6. For the right hand side, we use the target-space's name, say ~_Â·â€²_~,
       along with ~mapáµ¢~ applied to ~xáµ¢~ for each ~i~ mentioned in the type.

    7. The result:
       ~pres-Â· : {xâ‚ : Scalar} â†’ {xâ‚‚ : Vector} â†’   mapâ‚‚ (_Â·_ xâ‚ xâ‚‚)   â‰¡   _Â·â€²_ (mapâ‚ xâ‚) (mapâ‚‚ xâ‚‚)~.
      :RoughIdea:
    â‡’  _Â·_ : sortâ‚ â†’ sortâ‚‚ â†’ sortâ‚‚
    â‡’ pres-Â· : {xâ‚ : sortâ‚} {xâ‚‚ : sortâ‚‚}
         â†’   form source expression:  xâ‚ Â· xâ‚‚
           â‡’ form target expression: mapâ‚ xâ‚‚ Â·â€² mapâ‚‚ xâ‚‚
           â‡’ equate them using target sort's map:  mapâ‚‚ (xâ‚ Â· xâ‚‚) â‰¡ mapâ‚ xâ‚‚ Â·â€² mapâ‚‚ xâ‚‚
    :End:

    First, we need a helper that forms the preservation formulae. In a ~lisp~ block:
#+BEGIN_SRC emacs-lisp
(defun to-subscript (n)
  (nth n '("â‚€" "â‚" "â‚‚" "â‚ƒ" "â‚„" "â‚…" "â‚†" "â‚‡" "â‚ˆ" "â‚‰")))

(defun homify (typed-name sort)
  "Given a typed name, produce the associating â€œpreservationâ€ formula.
   E.g.,
            _Â·_    : Scalar â†’ Vector â†’ Vector
            pres-Â· : {xâ‚ : Scalar} â†’ {xâ‚‚ : Vector} â†’ mapâ‚‚ (xâ‚ Â· xâ‚‚) = mapâ‚ xâ‚ Â·â€² mapâ‚‚ xâ‚‚

  Type Ï„ gets variable xáµ¢ provided (i, Ï„) âˆˆ sorts; likewise we think of mapáµ¢ : Ï„ â†’ Ï„â€².
  Note that we must have i âˆˆ 0..9, otherwise there'll be unexpected subscripting errors.

  The target name is primed, â€œÂ·â€²â€.
 "
 (letf* ((sorts     (mapcar #'car sort))
         ((symbol-function 'index) (lambda (s) (to-subscript (cdr (assoc it sort)))))

         (tnâ†’       (s-split " â†’ " (get-type typed-name)))
         (arg-count (1- (length tnâ†’)))

         (all-indicies  (--map (index it) (--filter (member (s-trim it) sorts) tnâ†’)))
         (indicies  (-drop-last 1 all-indicies))
         (tgt-idx   (car (-take-last 1 all-indicies)))

         (op        (get-name typed-name))
         (args      (--map (concat "x" it) indicies))
         (lhs       (format "map%s (%s %s)" tgt-idx op (s-join " " args)))

         (opâ€²       (rename-mixfix (lambda (n) (concat n "â€²")) op))
         (map-args  (--map (format "(map%s x%s)" it it) indicies))
         (rhs       (format "%s %s" opâ€² (s-join " " map-args)))

         (target    (format "  %s   â‰¡   %s" lhs rhs))
 )

 ;; Change the target type.
 (setq tnâ†’ (--map (when (assoc it sort) (format "{x%s : %s}" (index it) it)) tnâ†’))
 (setf (nth arg-count tnâ†’) target)

 ;; Stick it all together, with an updated name.
 (make-tn
   (format "pres-%s" (s-replace "_" "" (get-name typed-name)))
   (s-join " â†’ " tnâ†’))
 )
)

;; Test it out.
;; (homify "_Â·_    : Scalar â†’ Vector â†’ Vector" '( ("Scalar" . 4) ("Vector" . 1)))
#+END_SRC

    Then, we form the variational as follows ---also in a ~lisp~ block.
#+BEGIN_SRC emacs-lisp
(ğ’± hom
  = record âŸ´
    :waist 2
    :waist-strings '("open M-Set-R  Src" "open M-Set-Râ€² Tgt" "field")
    :alter-elements (lambda (es)

    (let (maps eqns sorts)

      ;; Construct the mapáµ¢ : sortáµ¢ â†’ sortáµ¢â€²; keeping track of (sort . i) pairs.
      (loop for e in es
            for i from 1
       do

         (when (is-sort e)
           (push (cons (get-name e) i) sorts)
           (push (format "map%s : %s â†’ %sâ€²" (to-subscript i) (get-name e) (get-name e))
                 maps))

          (when (and (targets-a-sort e) (not (is-sort e)))
            (push (homify e sorts) eqns)))

    ;; Ensure we have a source and target space as elements.
    (-cons* "Src : M-Set-R"
            "Tgt : M-Set-R"
    (reverse (-concat eqns maps)))
)))
#+END_SRC

    Here are two examples. *Note* that the latter allows us to /rename/ the ~mapáµ¢~ as we
    wish ---which may be preferable to extending the variational to accommodate for new
    names.

#+BEGIN_SRC results-agda
{-700
Hom  = M-Set hom
HomÂ² = M-Set hom âŸ´ renaming :by "mapâ‚ to scalar; pres-ğŸ™ to unity"
-}

record Hom (Src : M-Set-R) (Tgt : M-Set-R) : Setâ‚ where
 open M-Set-R  Src
 open M-Set-Râ€² Tgt
 field
   mapâ‚ : Scalar â†’ Scalarâ€²
   mapâ‚‚ : Vector â†’ Vectorâ€²
   pres-Â· : {xâ‚ : Scalar} â†’ {xâ‚‚ : Vector} â†’   mapâ‚‚ (_Â·_ xâ‚ xâ‚‚)   â‰¡   _Â·â€²_ (mapâ‚ xâ‚) (mapâ‚‚ xâ‚‚)
   pres-ğŸ™ : mapâ‚ (ğŸ™ )   â‰¡   ğŸ™â€²
   pres-Ã— : {xâ‚ : Scalar} â†’ {xâ‚ : Scalar} â†’   mapâ‚ (_Ã—_ xâ‚ xâ‚)   â‰¡   _Ã—â€²_ (mapâ‚ xâ‚) (mapâ‚ xâ‚)

record HomÂ² (Src : M-Set-R) (Tgt : M-Set-R) : Setâ‚ where
 open M-Set-R  Src
 open M-Set-Râ€² Tgt
 field
   scalar : Scalar â†’ Scalarâ€²
   mapâ‚‚ : Vector â†’ Vectorâ€²
   pres-Â· : {xâ‚ : Scalar} â†’ {xâ‚‚ : Vector} â†’   mapâ‚‚ (_Â·_ xâ‚ xâ‚‚)   â‰¡   _Â·â€²_ (scalar xâ‚) (mapâ‚‚ xâ‚‚)
   unity : scalar (ğŸ™ )   â‰¡   ğŸ™â€²
   pres-Ã— : {xâ‚ : Scalar} â†’ {xâ‚ : Scalar} â†’   scalar (_Ã—_ xâ‚ xâ‚)   â‰¡   _Ã—â€²_ (scalar xâ‚) (scalar xâ‚)
#+END_SRC

  This is so cool (â€¢Ì€á´—â€¢Ì)Ùˆ

  We leave it to the reader to derive other constructs from a theory presentation.
  Examples can be found in these [[https://github.com/alhassy/next-700-module-systems-proposal/blob/master/JC_Program_Generation_Talk_IFIP.pdf][Metaprogramming Agda]] slides:
  Homomorphism equality, application to carrier elements, isomorphisms,
  isomorphisms where only one direction needs to preserve the structure
  and an automatically derivable proof that the other direction is also
  structure preserving, endomorphism and automorphism types, kernels,
  product & sum & other categorical types.

  + Challenge ::
      Design a scheme to produce simple Cartesian products from a given theory.

    1. The only variable to this problem is an arbitrary record, say it is ~M~.

       For this exercise to be tractable, assume ~M~ consists of declarations
       of sort symbols, function symbols, and nullary (non-implication) equations
       which may have implicit arguments.

    2. Ensure you understood the definition of the homomorphism scheme above.
    3. Mimic the homomorphism scheme to produce a typed ~Prod~ where ~Prod Aâ‚€ Aâ‚~
       consists of a ~M~ value, say ~P~, and two homomorphisms ~Hom P Aáµ¢~.
    4. Write a Lisp code that produces a function ~MakeProduct : (Aâ‚€ Aâ‚ : M) â†’ Prod Aâ‚€ Aâ‚~.

       - The projection morphisms are straightforward.
       - Every /n/-ary function ~f~ could be defined by ~fâ‚š = zipâ‚™ fâ‚€ fâ‚~.
       - Every equation ~e~ could be defined by ~eâ‚š = congâ‚‚ _,_ eâ‚€ eâ‚~.

    5. If you have actually attempted this, then go on to include the remaining
       artefacts to make the construction an actual categorical product.

** COMMENT Currying for Datatypes
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-Currying-for-Datatypes
   :END:

   :Lisp_code_that_generates_the_code_for_this_subsection:
#+BEGIN_SRC emacs-lisp :var monoid = monoid :exports both :results replace :wrap "src results-agda"
(let* ((variationals nil) (instantiations-remaining nil)
       (vs (load-variationals (s-join "\n" '(
      "ğ’±-identity = "
      "ğ’±-record  = :kind record :waist-strings (\"field\")"
      "ğ’±-whoops  = :kind recorder :waist-strings (\"field\")"
      "ğ’±-typeclass-attempt  = :kind record :waist-strings (\"field\") :waist 2"
      "ğ’±-typeclassâ‚‚  = :kind record :waist-strings (\"field\") :waist 2 :level dec"
      "ğ’±-primed-record = :kind record :waist-strings (\"field\") :alter-elements (Î» f â†’ (map-name (concat name \"â€²\") f))"
      "ğ’±-primed = :alter-elements (Î» f â†’ (map-name (concat name \"â€²\") f))"
      "ğ’±-typeclass height level = :kind record :waist-strings (\"field\") :waist height :level level"
; TODO:	  ; "ğ’±-renamed with = :alter-elements (Î» e â†’ (map-name (funcall with name) e))"
      "ğ’±-data-with carrier = :kind data :level dec :alter-elements (Î» f â†’ (if (s-contains? carrier (target (get-type f))) (map-type (s-replace carrier $ğ‘›ğ‘ğ‘šğ‘’ type) f) \"\"))"
      ))))
       (pf (load-package-former (second (get-children "PackageFormer" monoid)))))

  (--map (load-instance-declaration it)
    '(

      ; TODO: "M-Set-PF = M-Set identity :waist 2" ;; nope.

      ; "Monoid-Record = Monoid record"
      ; "Monoid-Classical = Monoid typeclass :height (1) :level (dec)"
       "MonoidOp = Monoid typeclass :height (2) :level (dec)"
      ; "M-Set-Record = M-Set whoops"
      ; "M-Set-Typeclass = M-Set typeclass-attempt"
      ; "M-Set-Typeclassâ‚‚ = M-Set typeclassâ‚‚"
      ; "M-Set-Recordâ€² = M-Set primed-record"
      ; "M-Setâ€² = M-Set primed"
      ; "M-Set-Recordâ€² = M-Set-Record primed"
      ; "M-Set-Recordâ€² = M-Set-Record record âŸ´ primed"
      ; "M-Set-Typeclassâ‚ƒ = M-Set-Record typeclass :height (3) :level (dec) :comment (why hello there)"

      ; TODO: "M-Setâ‚ = M-Set renamed :with ((Î» x â†’ x))"

      ; "ScalarSyntax = M-Set data-with :carrier (\"Scalar\")"
      ))

  (reify-instances)
)
#+END_SRC

#+RESULTS:

:End:

Suppose you're a Haskell programmer and want to have multiple monoid instances for the Booleans.
You may make isomorphic copies of the Booleans, say ~And~ and ~Any~, and implement the desired instance
for each. What about if you want a Monoid instance but insist only that the unit be ~false~, what do you do then?

With this prototype, you expose the carrier and the operation in the first case, and expose the identity in the second case.
Moreover, you only write the definition of monoid once, leading to our motto:
#+BEGIN_CENTER
/Write once, derive many!/
#+END_CENTER

Here's a formalisation of monoids:
#+NAME: monoid
#+BEGIN_SRC agda :results replace :wrap "src results-agda"
PackageFormer Monoid : Setâ‚ where
    Carrier : Set
    _â¨¾_     : Carrier â†’ Carrier â†’ Carrier
    Id      : Carrier
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x
#+END_SRC
:Hide:
#+RESULTS: monoid
#+BEGIN_src results-agda
PackageFormer Monoid : Setâ‚ where
    Carrier : Set
    _â¨¾_     : Carrier â†’ Carrier â†’ Carrier
    Id      : Carrier
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x
#+END_src
:End:

We regain the Haskell-style typeclass definition with the following declaration:
#+BEGIN_SRC agda
 Monoid-Classical = Monoid typeclass :height (1) :level (dec)
#+END_SRC
Loading the script, with ~C-c C-l~ as usual, produces a generated file that elaborate this definition as follows:
#+BEGIN_SRC results-agda
record Monoid-Classical (Carrier : Set) : Set where
  field
    _â¨¾_     : Carrier â†’ Carrier â†’ Carrier
    Id      : Carrier
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x
#+END_SRC
Notice that a name ~Carrier~ has been lifted to being a parameter instead of a field.
This is the result of the ~:height~ argument to the ~typeclass~ variational defined
in the previous subsection.

:TODO_FIXME:
We could use the letter ~m~ in-place of ~Carrier~, as is done in Haskell, as follows.
#+BEGIN_SRC agda
 Monoid-m = Monoid typeclass renaming (Carrier to m)
#+END_SRC
Which propagates ~Carrier = m~ into the fields. The propagation is necessary
if we were, for example, to rename ~_â¨¾_ to _âŠ•_~ ---otherwise we would need to parse
mixfix applications of this operator, as in ~assoc~!
#+BEGIN_SRC agda
record Monoid-m (m : Set) : Set where
  field
    _â¨¾_     : let Carrier = m in m â†’ m â†’ m
    Id      : let Carrier = m in m
    assoc   : let Carrier = m in âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : let Carrier = m in âˆ€ {x : let Carrier = m in m} â†’ Id â¨¾ x â‰¡ x
    rightId : let Carrier = m in âˆ€ {x : let Carrier = m in m} â†’ x â¨¾ Id â‰¡ x
#+END_SRC
:END:

Since Agda supports â€˜named instancesâ€™, the Haskeller's first problem is solved. However, we demonstrate
an alternative solution that will allow us to solve the second problem in a fashion that current Agda
can only awkwardly approximate.

For example, with the current setup, we may go about requesting multiple monoid instances for the Booleans:
#+BEGIN_SRC agda
open Monoid-Classical using () renaming (_â¨¾_ to Op)

yuck-one :  (X Y : Classical ğ”¹)
     â†’  Op X  â‰¡ _âˆ§_  â†’  Op Y  â‰¡ _âˆ¨_
     â†’  Set
yuck-one = ???
#+END_SRC

The following declaration lets us â€˜uncurryâ€™ the first ~N = 2~ elements
from the field-position to the parameter-position.
#+BEGIN_SRC agda
MonoidOp = Monoid typeclass :height (2) :level (dec)
#+END_SRC

This then yields:
#+BEGIN_src results-agda
record MonoidOp (Carrier : Set) (_â¨¾_ : Carrier â†’ Carrier â†’ Carrier) : Set where
  field
    Id      : Carrier
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x
#+END_src

Which let's us solve the first problem elegantly as so:
#+BEGIN_SRC agda
first-problem : MonoidOp ğ”¹ _âˆ§_  â†’  MonoidOp ğ”¹ _âˆ¨_  â†’ Set
first-problem = ???
#+END_SRC

Neato ^_^ Short and sweet.

Now for the second problem. Rather than forming a new data-type,
we hoist up the ~Id~-entity field as a parameter.
| ~TODO: Write this section~ |

#+BEGIN_SRC agda
 MonoidId = Monoid record exposing (Carrier; Id)
#+END_SRC
Which results in:
#+BEGIN_SRC agda
record MonoidId (Carrier : Set) (Id : Carrier) : Set where
  field
    _â¨¾_     : Carrier â†’ Carrier â†’ Carrier
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x
#+END_SRC

Resulting in the solution type:
#+BEGIN_SRC agda
second-problem-okay : (X Y : MonoidId ğ”¹ false) â†’ Set
second-problem-okay = ???
#+END_SRC
However, this too can get tedious if we wish to only consider monoids
with unit ~false~. In that case, we /treat/ the fields as if they where
manifest fields and instantiate them to form a new type.
#+BEGIN_SRC agda
{-700 Monoid-false = Monoid record with (Carrier to ğ”¹; Id to false) -}

record Monoid-false : Set where
  field
    _â¨¾_     : ğ”¹ â†’ ğ”¹ â†’ ğ”¹
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftfalse  : âˆ€ {x : ğ”¹} â†’ false â¨¾ x â‰¡ x
    rightfalse : âˆ€ {x : ğ”¹} â†’ x â¨¾ false â‰¡ x

second-problem-better : (X Y : Monoid-false) â†’ Set
second-problem-better = ???
#+END_SRC

The full source of this discussion is as follows.
{{{fold(CaseStudy.agda)}}}
#+INCLUDE: "CaseStudy.agda" src agda
{{{end-fold}}}

* Strings and Things
  :PROPERTIES:
  :CUSTOM_ID: Strings-and-Things
  :END:

Since our prototype is intended to be as minimally obtrusive as possible, we will
need to extract our special 700-syntactical items between delimited tokens
and process them.

The following subsections introduce:
+ ~get-children~ :: Obtaining intended items from a hierarchical listing.
+ ~sub-string-delimited-here~ :: Finding the shortest substring between a prefix
      ~ğ‘³~ and a postfix ~ğ‘¹~ by using the â€˜metavariableâ€™ ~$here~; e.g., ~â€œğ‘³ $here ğ‘¹â€.~
+ ~buffer-substring-delimited-whole-buffer~ :: Yield all portions of the
     buffer enclosed in the given delimiters, as a list of strings.
+ ~rename-mixfix~ :: Renamaing Agda mixifix names where the rename operation
     ignores the outermost (Agda) argument position markers â€˜_â€™.
+ ~extract-imports~ :: Obtain all â€˜importâ€™ clauses so that they can be
     ported over to the generated file.

First some useful libraries:
#+BEGIN_SRC emacs-lisp :tangle no
;; String and list manipulation libraries
;; https://github.com/magnars/dash.el
;; https://github.com/magnars/s.el
(require 's)               ;; â€œThe long lost Emacs string manipulation libraryâ€
(require 'dash)            ;; â€œA modern list library for Emacsâ€
(require 'fold-this)       ;; Folding away regions of text
(fold-this-mode)

(require 'ert) ;; Testing framework
#+END_SRC

** Typing mechanism
   :PROPERTIES:
   :CUSTOM_ID: Typing-mechanism
   :END:
#+BEGIN_SRC emacs-lisp :tangle yes
;; Crashes if an argument is ":"
(cl-defmacro declare-type (f key-types &rest types)
  "Attach the given list of types to the function â€˜fâ€™
   by advising the function to check its argumentsâ€™ types
   are equal to the list of given types.

   We name the advice â€˜âŸªfâŸ«-typing-adviceâ€™ so that further
   invocations to this macro overwrite the same advice function
   rather than introducing additional, unintended, constraints.

   Using type specifiers we accommodate for unions of types
   and subtypes, etc â™¥â€¿â™¥.

   â€˜key-typesâ€™ should be of the shape (:xâ‚€ tâ‚€ â‹¯ :xâ‚™ tâ‚™);
    when there are no optional types, use symbol â€œ:â€.

    E.g., (declare-type my-func (:z string :w integer) integer symbol string)
  "

  ;; Basic coherency checks. When there aren't optional types, key-types is the â€œ:â€ symbol.
  (should (and (listp types) (or (listp key-types) (symbolp key-types))))

  (letf* ((pairify (lambda (xs) (loop for i in xs by #'cddr         ;; Turn a list of flattenned pairs
                                      for j in (cdr xs) by #'cddr   ;; into a list of explicit pairs.
                                      collect (cons i j))))         ;; MA: No Lisp method for this!?
         (result-type  (car (-take-last 1 types)))
         (types        (-drop-last 1 types))
         (num-of-types (length types))
         (key-types-og (unless (symbolp key-types) key-types))
         (key-types    (funcall pairify key-types-og))
         (advice-name  (intern (format "%s-typing-advice" f)))
         (notify-user  (format "%s now typed %s â†’ %s â†’ %s."
                               `,f key-types-og types result-type)))

      `(progn
         (defun ,advice-name (orig-fun &rest args)

           ;; Split into positional and key args; optionals not yet considered.
           (letf* ((all-args
                     (-split-at
                       (or (--find-index (not (s-blank? (s-shared-start ":" (format "%s" it)))) args) ,num-of-types)
                        args)) ;; The â€œorâ€ is for when there are no keywords provided.
                  (pos-args  (car all-args))
                  (key-args  (funcall ,pairify (cadr all-args)))
                  (fun-result nil)
                  ((symbol-function 'shucks)
                     (lambda (eÏ„ e g)
                       (unless (typep g eÏ„)
                         (error "%s: Type mismatch! Expected %s %s â‰  Given %s %s."
                                (function ,f) eÏ„ e (type-of g) (prin1-to-string g))))))

         ;; Check the types of positional arguments.
         (unless (equal ,num-of-types (length pos-args))
           (error "%s: Insufficient number of arguments; given %s, %s, but %s are needed."
                  (function ,f) (length pos-args) pos-args ,num-of-types))
         (loop for (ar ty pos) in (-zip pos-args (quote ,types) (number-sequence 0 ,num-of-types))
               do (shucks ty (format "for argument %s" pos) ar))

         ;; Check the types of *present* keys.
         (loop for (k . v) in key-args
               do (shucks (cdr (assoc k (quote ,key-types))) k v))

         ;; Actually execute the orginal function on the provided arguments.
         (setq fun-result (apply orig-fun args))
         (shucks (quote ,result-type) "for the result type (!)" fun-result)

         ;; Return-value should be given to caller.
         fun-result))

      ;; Register the typing advice and notify user of what was added.
      (advice-add (function ,f) :around (function ,advice-name))
      ,notify-user )))

(defun list-of-p (Ï„ thing)
  (and (listp thing) (every (lambda (x) (typep x Ï„)) thing)))

(deftype list-of (Ï„)
  `(satisfies (lambda (thing) (list-of-p (quote ,Ï„) thing))))
#+END_SRC
#
# E.g., (declare-type fâ‚ (:z string :w list) integer symbol string)

** Finding Children in the Wild
   :PROPERTIES:
   :CUSTOM_ID: Finding-Children-in-the-Wild
   :END:

Being a prototype, we are talking a mostly string-based approach to working
with hierarchical phrases.
For example, consider the following todo list,
#+NAME: children-example
#+BEGIN_SRC org :results replace
+ item 1
  - subitem 1.1
    ,* subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 2.2
+ item 3
#+END_SRC

#+RESULTS: children-example
+ item 1
  - subitem 1.1
    * subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 2.2
+ item 3

:Example:
#+BEGIN_SRC emacs-lisp :var it = children-example
(message it)
#+END_SRC

#+RESULTS:
: + item 1
:   - subitem 1.1
:     * subsubitem 1.1.1
:   - subitem 1.2
: + item 2
:   - subitem 1.2
: + item 3
:End:

We would think that ~item 1~ has two â€˜childrenâ€™, and, moreover, one grand-child.
Whereas ~item 2~ has a single child and ~item 3~ is barren.

Here's my intuitive algorithm: We obtain the indentation of the first child,
then all subsequent lines with at least that much indentation have the same ancestor.

{{{fold(get-indentation Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(declare-type get-indentation : string integer)
(defun get-indentation (string)
  "How many spaces are there at the front of â€˜stringâ€™?

  Property: The resulting number is â€˜â‰¤ length stringâ€™.
  "
  (if string (length (s-shared-start string (s-repeat (length string) " "))) 0))
#+END_SRC
{{{end-fold}}}

{{{fold(get-children Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(declare-type get-children (:then t) string (or string list) cons)
(cl-defun get-children (parent the-wild &key (then #'identity))
  "Go into â€˜the-wildâ€™ seeking out the first occurence of â€˜parentâ€™,
   who once found, ought to have a minimal indentation for its children.

   â€œMinimalâ€ in that if there are items with a greater indentation,
    then they are children of children and should be kept.

   The first input argument is of type â€˜stringâ€™,
   the second argument may be of type â€˜stringâ€™ or â€˜listâ€™ of strings
   ---if it's a string, we split along new lines---,
   the optional â€˜thenâ€™ is a function acting on children strings.

   Result is the parent followed by its children, as a list of lines,
   where each child has been altered using the optional â€˜thenâ€™ function.
   Moreover, we also return the rest of the unconsidered portion of â€˜the-wildâ€™:

   Result list: (  unconsidered-prefix-of-the-wild
           (cons parent-line children-lines)
           unconsidered-remaining-lines )

   The first element is the porition that does not contain an occurence
   of â€˜parentâ€™. The second is the parent and its children, if possible.
   The third is the remainder of the wild.

   Implementation: Look at the indentation of the
   first child, then use that as a lower bound to find the indentation
   of the remaining children.
  "

  (let ((lines (if (stringp the-wild) (s-lines the-wild) the-wild))
    (indentation -1)
    prefix
    parent-line)

    ;; Ensure: lines â‰ˆ (cons (not-here-prefix) (cons parent-here more-lines) )
    (setq lines (--split-with (not (s-contains? parent it)) lines))

    ;; Discard prefix, for now.
    (setq prefix (car lines))
    (setq lines (cadr lines))

    ;; Discard parent, but remember its contextual line.
    (setq parent-line (car lines))
    (setq lines (cdr lines))

    ;; How far is the first child indented?
    (setq indentation (get-indentation (car lines)))

    ;; Keep only the children that have at least this level of indentation.
    (setq lines&more (--split-with (<= indentation (get-indentation it)) lines))
    (setq lines (car lines&more))
    (setq unconsidered (cadr lines&more))

    ;; Alter the children according to the given function.
    (setq lines (mapcar then lines))

    ;; Yield the parent line along with the children lines; and the unconsumed wild's prefix and suffix.
    `(,prefix ,(cons parent-line lines) ,unconsidered)))
#+END_SRC
{{{end-fold}}}

Let's try this out on our example hierarchy, ~eh~, from earlier.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(cadr (get-children "+ item 1" eh))
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 |

Excellent! Let's looks at the other parents.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(get-children "+ item 2" eh)
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 |
| + item 2 | - subitem 2.2 |                    |               |
| + item 3 |               |                    |               |

Notice that we found the parent ~+ item 2~ and its only child ~- subitem 1.2~, and
we kept the prefix of ~eh~ that did not contain the parent as well as
the remaining unconsidered portion of ~eh~. ---Moreover, it looks like we obtained
the transpose of the example hierarchy ğŸ˜›

Finally, the barren parent.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(get-children "+ item 3" eh)
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 | + item 2 | - subitem 2.2 |
| + item 3 |               |                    |               |          |               |

Everything before it is considered the prefix. Yay :smile:

Before we move on, let's try altering a child clause; e.g., I'd like
~* subitem 1.1.1~ to be renamed to ~* subitem that is super deep~.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(cadr (get-children "+ item 1" eh
 :then (lambda (x) (s-replace "1.1.1" "that is super deep" x))))
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem that is super deep | - subitem 1.2 |

Nice :grin:

Now the moment of truth, let's try this out on our example.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results table replace :wrap "src results-agda"
(cadr (get-children "PackageFormer" test))
#+END_SRC

   #+RESULTS:
#+begin_src results-agda
| PackageFormer M-Set : Setâ‚ where | Scalar  : Set | Vector  : Set | _Â·_     : Scalar â†’ Vector â†’ Vector | ğŸ™       : Scalar | _Ã—_     : Scalar â†’ Scalar â†’ Scalar | leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹ | assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹) |
#+end_src

Also, does the list variant work:
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace  :wrap "src results-agda"
(cadr (get-children "PackageFormer" (s-lines test)))
#+END_SRC

#+RESULTS:
#+begin_src results-agda
| PackageFormer M-Set : Setâ‚ where | Scalar  : Set | Vector  : Set | _Â·_     : Scalar â†’ Vector â†’ Vector | ğŸ™       : Scalar | _Ã—_     : Scalar â†’ Scalar â†’ Scalar | leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹ | assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹) |
#+end_src

Test-driven development doesn't seem bad ğŸ˜²

These pretty-coloured tests and results may be nice for exposition,
however for maintenance it is ideal to include unit tests that can
be checked without human intervention. ~M-x ert <RET> t <RET>~, after
executing the following block, will report which tests pass and tries to explain
why tests fail.

{{{fold(Tests)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest get-ind ()
  (loop for s in '(nil "" "x" "  x" "  x ")
    do (should (<= (get-indentation s) (length s))))
  )

(ert-deftest get-child ()
  (-let [eh
"+ item 1
  - subitem 1.1
    ,* subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 2.2
+ item 3"]

    ;; Consider each line above as a parent, with â€˜ehâ€™ as the wild.
    (loop for parent in (s-split "\n" eh) do
      (let* ((cs (get-children parent eh))
         (children (cdadr cs)))

      ;; Result is a list of lists: Each is either nil or a cons.
      (loop for r in cs do (should (listp r)))

      ;; The parent line contains the parent.
      (should (equal parent (caadr cs)))

      ;; The children all have the same indentation.
      (loop for c in children for d in children do (should (equal (get-indentation c) (get-indentation d))))

      ;; Extensionality: Orginal input can be regained from resulting parts.
      (should (equal eh (s-trim (s-join "\n" (--map (s-join "\n" it) cs)))))
    )
  )
))
#+END_SRC
{{{end-fold}}}

** Substrings Delimited by Tokens
   :PROPERTIES:
   :CUSTOM_ID: Substrings-Delimited-by-Tokens
   :END:

#+begin_center
/How do we find a string delimited by two tokens?/
#+end_center

Before we can get to the real stuff, we need to produce a few low-level ---string manipulation---
utilities, so that we can work with higher-level abstract datatypes.

+ ~substring-delimited~: Given ~prefix~ and ~suffix~,
  this operation takes a string of the form  ~â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯~ and yields ~needle~.
+ ~substring-delimited-here~: Given ~"âŸªprefixâŸ« $here âŸªsuffixâŸ«"~
  this operation takes a string of the form  ~â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯~ and yields ~needle~.

{{{fold(substring-delimited Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
;; This may accept argument ":", which â€œdeclare-typeâ€ cannot currently handle.
(cl-defun substring-delimited
    (prefix suffix string)
  "Assuming â€˜stringâ€™ â‰ˆ â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯, return the /first/ such needle.

    NOTE: Delimiters â€˜prefixâ€™ and â€˜suffixâ€™ may be empty.

  We convert all adjacent whitespace
  characters to a single space in the input â€˜stringâ€™ and trim any surrounding
  whitespace from the resulting output needle string.
  "

  (unless (stringp string) (error "substring-delimited: Argument â€˜stringâ€™ must be a string."))
  (let* ((new (s-collapse-whitespace string)))

  (when (not (s-blank? prefix))
    (setq new (car (-take-last (if (equal prefix suffix) 2 1) (s-split prefix new)))))

  (when (not (s-blank? suffix))
    (setq new (car (s-split suffix new))))

  (s-trim new)))
#+END_SRC

# TODO: broken
#+BEGIN_SRC emacs-lisp :tangle no
(ert-deftest subst-delimit ()
  (-let [str "ğŸ˜ ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ ğŸ"] ;; Intentionally repeated â€˜ğŸœâ€™.
    ;; Pattern for loop: (prefix postfix expected-needle :comment))
    (loop for it in `( ( "" "" ,str            :Identity)
               ( "ğŸ˜" "ğŸ" "ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ"  :Boundaries)
               ( "" "ğŸ" "ğŸ˜ ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ" :NoLeft)
               ( "ğŸ˜" "" "ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ ğŸ" :NoRight)
               ( "ğŸ " ""  ,str          :BogusL)
               ( "" "âˆ"  ,str          :BogusR)
               ( "ğŸ " "âˆ" ,str          :BogusLR)
             )
      do (should (equal (third it) (substring-delimited (first it) (second it) str))))

    (should (equal "ğŸ›" (substring-delimited "ğŸš" "ğŸœ" str)))

    ;; Identical boundaries.
    (should (equal "ğŸ™" (substring-delimited "ğ‘³" "ğ‘³" "ğ‘³ ğŸ™ ğ‘³")))
    (should (equal ""  (substring-delimited "ğ‘³" "ğ‘³" "ğ‘³ ğ‘³")))
    (should (equal ""  (substring-delimited "ğ‘³" "ğ‘³" "ğ‘³ğ‘³")))

    ;; Multiple occurances of prefix or postfix
    (should (equal "y"  (substring-delimited "ğ‘³" "ğ‘¹" "ğ‘³ x ğ‘³ y ğ‘¹")))
    (should (equal "x"  (substring-delimited "ğ‘³" "ğ‘¹" "ğ‘³ x ğ‘¹ y ğ‘¹")))
#+END_SRC
{{{end-fold}}}

# (substring-delimited "PackageFormer" ":") "PackageFormer ğ’« : Set")
# (substring-delimited-here "PackageFormer $here :" "PackageFormer ğ’« : Set")

{{{fold(substring-delimited-here Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
;; This may accept argument ":", which â€œdeclare-typeâ€ cannot currently handle.
(cl-defun substring-delimited-here (context string)
  "Assuming â€˜contextâ€™ = â€œâŸªprefixâŸ« $here âŸªsuffixâŸ«â€
   and â€˜stringâ€™ â‰ˆ â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯, return the /first/ such needle.

  NOTE: âŸªprefixâŸ« and âŸªsuffixâŸ« cannot be empty strings!

  We convert all adjacent whitespace
  characters to a single space in the input â€˜stringâ€™ and trim any surrounding
  whitespace from the resulting output needle string.
  "

  (-let [pre-post (s-split "$here" context)]
    (substring-delimited (s-trim (car pre-post)) (s-trim (cadr pre-post)) string)))

(ert-deftest subst-delimit-here ()
  (-let [str "ğŸ˜ ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ ğŸ"] ;; Intentionally repeated â€˜ğŸœâ€™.
    ;; Pattern for loop: (prefix postfix expected-needle :comment)
    (loop for it in `( ( "$here" ,str              :Identity)
               ( "ğŸ˜ $here ğŸ" "ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ"  :Boundaries)
               ( "$here ğŸ" "ğŸ˜ ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ"  :NoLeft)
               ( "ğŸ˜ $here"  "ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ ğŸ" :NoRight)
               ( "ğŸ  $here"   ,str          :BogusL)
               ( "$here âˆ"   ,str          :BogusR)
               ( "ğŸ  $here âˆ" ,str          :BogusLR)
             )
      do (should (equal (second it) (substring-delimited-here (first it) str))))

    ;; Longest substring
    (should (equal "ğŸ›" (substring-delimited-here "ğŸš $here ğŸœ" str)))

    ;; Identical boundaries.
    (should (equal "ğŸ™" (substring-delimited-here "ğŸ˜ $here ğŸ˜" "ğŸ˜ ğŸ™ ğŸ˜")))
    (should (equal ""  (substring-delimited-here "ğŸ˜ $here ğŸ˜" "ğŸ˜ ğŸ˜")))
    (should (equal ""  (substring-delimited-here "ğŸ˜ $here ğŸ˜" "ğŸ˜ğŸ˜")))

    ;; Multiple occurances of prefix or postfix
    (should (equal "y"  (substring-delimited-here "ğ‘³ $here ğ‘¹" "ğ‘³ x ğ‘³ y ğ‘¹")))
    (should (equal "x"  (substring-delimited-here "ğ‘³ $here ğ‘¹" "ğ‘³ x ğ‘¹ y ğ‘¹")))

    ;; Space irrelevance for keyword â€˜$hereâ€™:
    (should (equal "ğŸ™" (substring-delimited-here "ğ‘³ $here ğ‘¹" "ğ‘³ ğŸ™ ğ‘¹")))
    (should (equal "ğŸ™" (substring-delimited-here "ğ‘³ $hereğ‘¹" "ğ‘³ ğŸ™ ğ‘¹")))
    (should (equal "ğŸ™" (substring-delimited-here "ğ‘³$here ğ‘¹" "ğ‘³ ğŸ™ ğ‘¹")))
    (should (equal "ğŸ™" (substring-delimited-here "ğ‘³$hereğ‘¹" "ğ‘³ ğŸ™ ğ‘¹")))
    (should (equal "ğŸ™" (substring-delimited-here "ğ‘³      $here  ğ‘¹" "ğ‘³ ğŸ™ ğ‘¹")))
    ))
#+END_SRC
{{{end-fold}}}

Suppose a user provides us with an awkwardly spaced PackageFormer header,
our string manipulation setup is robust enough to get at the constituents:
#+BEGIN_SRC emacs-lisp :results replace :exports both
(-let [header "PackageFormer  Semigroup   (  v : Variation) : Set (  â„“expr)   where"]
  ;; Three kinds of invocations; the last is my preferred choice â™¥â€¿â™¥
  `( ,(substring-delimited "PackageFormer " "(" header)
     ,(substring-delimited-here "PackageFormer $here (" header)))
#+END_SRC

#+RESULTS:
| Semigroup | Semigroup |

The aim is to eventually have an interface that interacts with an buffer containing Agda code.
To that end, we propose that our fictitious syntax be directly embedded via special comments,
~{-700 â‹¯ -}~, henceforth referred to as â€œ<<<700-comments>>>â€.

+ ~(buffer-substring-delimited starting-regexp ending-regexp)~ yields the /next/ portion of the buffer
  as a string, relative to the current position of the cursor, that is contained in the â€˜parenthesisâ€™
  ~starting-regexp~ and ~ending-regexp~.

+ ~(buffer-substring-delimited-whole-buffer starting-regexp ending-regexp)~ yields /all/ portions of the buffer,
  contained in the â€˜parenthesisâ€™ ~starting-regexp~ and ~ending-regexp~, as a list of strings.

  - Cursor position is saved.
  - This function let's us obtain the contents of /all/ 700-comments.

{{{fold(buffer-substring-delimited Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
;; declare-type has no support for optionals yet
(cl-defun buffer-substring-delimited (start end &optional more &key (regexp t))
  "
  Get the current buffer's /next/ available substring that is delimited
  between the regexp tokens â€˜startâ€™ up to â€˜endâ€™, exclusively.

  If no tokens are found, an error is thrown.

  â€˜moreâ€™ is a function that is called on the found instance:
  It is a function of the start and end positions of the occurance.

  â€˜regexpâ€™ indicates whether we are using regular expression strings, or literals.
   It is â€˜nilâ€™ by default.
  "
  (let (start-pos end-pos sp ep content)
    (if regexp (re-search-forward start) (search-forward start))
    (setq start-pos (point))
    (backward-word)
    (setq sp (point))

    (if regexp (re-search-forward end) (search-forward end))
    (setq ep (point))
    (backward-word)
    (setq end-pos (point))

    (setq content  (buffer-substring-no-properties start-pos end-pos))

    (when more (funcall more sp ep))
    (when 700-folding
      (goto-char start-pos)
      (push-mark end-pos)
      (setq mark-active t)
      (fold-active-region start-pos end-pos))

    content))
#+END_SRC
{{{end-fold}}}

Where we have the following value:
#+BEGIN_SRC emacs-lisp :tangle yes
; (use-package fold-this :demand t :ensure t)
(defvar 700-folding nil
  "Should 700 and lisp blocks be folded away when C-c C-l.")
#+END_SRC

{{{fold(buffer-substring-delimited-whole-buffer Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
;; declare-type has no support for optionals yet
(cl-defun buffer-substring-delimited-whole-buffer (start end &optional more)
  "Return a list of all substrings in the current buffer that
   are delimited by regexp tokens â€˜startâ€™ and â€˜endâ€™, exclusively.

  â€˜moreâ€™ is a function that is called on the found instance:
  It is a function of the start and end positions of the occurance.
  "
  ;; Colour 700 keywords red â€œ'errorâ€
  (highlight-phrase start 'error)
  (highlight-phrase end 'error)
  (save-excursion
    (let ((l nil) (continue t))
     (beginning-of-buffer)

     (while continue
       (condition-case nil
     ;; attemptClause
     (setq l (cons (buffer-substring-delimited start end more) l))
     ;; recoveryBody
     (error (setq continue nil))))

     ;; We've collected items as we saw them, so â€˜lâ€™ is in reverse.
    (reverse l))))
#+END_SRC
{{{end-fold}}}

Here are some possible invocations, the last one being our use case.
#+BEGIN_SRC emacs-lisp
;; Get text delimited by quotes
(buffer-substring-delimited "^\"" "^\"")

;; Get text delimited by usual Agda comments
(buffer-substring-delimited "^\{-" "^-\}")

;; Execute the following in an Agda buffer to see this function in action.
(setq it (buffer-substring-delimited-whole-buffer "^\{-700" "^-\}"))
#+END_SRC

** Agda Mixfix Renaming and Imports
   :PROPERTIES:
   :CUSTOM_ID: Agda-Mixfix-Renaming-and-Imports
   :END:
   Renamaing Agda mixifix names where the rename operation ignores the outermost
   position markers â€˜_â€™.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun rename-mixfix (f op &optional avoid-mixfix-renaming)
  "Given an Agda mixfix operator, apply a function on strings â€˜fâ€™ on
   the inner-most delimiting tokens of the operator, in-particular ignoring
   outer argument markers â€˜_â€™.

   For example, if you wish to decorate an operator with a prime or a subscript,
   we cannot simply catenate else we obtain â€œ_âŠ•_â‚â€ rather than â€œ_âŠ•â‚_â€.

   Here are some sample results, assuming â€œf â‰ˆ (Î» (it) (format â€œâ‚€%sÂ¹â€ it))â€:
   _âŠ•_     â†¦  _â‚€âŠ•Â¹_
   _[_âŠ—_]  â†¦  _â‚€[_âŠ—_]Â¹
   he_lo   â†¦  â‚€he_loÂ¹
   he-lo   â†¦  â‚€he-loÂ¹

   AVOID-MIXFIX-RENAMING is optional; by default renaming â€œjumps overâ€ underscores,
   but providing a non-nil value for this argument leaves underscores alone.
   It is a matter of having, say, default â€œ_âŠ•â‚™_â€ versus â€œ_âŠ•_â‚™â€.
  "

  (let* ((parts (s-split "_" op)) (front (s-blank? (first parts))) (rear (s-blank? (car (last parts)))))

    (if avoid-mixfix-renaming
        (funcall f op)
      (--> (concat (when front "_") "$here" (when rear "_"))
           (substring-delimited-here it op)
           (funcall f it)
           (concat (when front "_") it (when rear "_"))))))
#+END_SRC

# E.g.,
# (rename-mixfix (lambda (it) (concat it "â€²")) "_âŠ•_")  ;; â‡’ _âŠ•â€²_

We also want to prefix the generated file with the imports of the current file.
{{{fold(extract-imports Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(declare-type extract-imports : string)
(cl-defun extract-imports ()
  "Return substring of buffer whose lines mention â€œimportâ€.
   Throw away any that mention the substring â€œâŸªFileNameâŸ«_Generatedâ€.
  "
  (thread-last (buffer-substring-no-properties (point-min) (point-max))
    (s-split "\n")
    (--filter (s-contains? "import " it))
    (--remove (s-contains?
           (format  "%s_Generated" (file-name-sans-extension (buffer-name))) it))
    (s-join "\n")))
#+END_SRC
{{{end-fold}}}

So much string meddling, hopefully no more ğŸ™ˆ :hear_no_evil: :speak_no_evil:

** â€œÎ»â€ for the Agda User
   :PROPERTIES:
   :CUSTOM_ID: should-be-at-top
   :END:

   Let's make this prototype more accessible to the Agda user
   by providing an abbreviation of Lisp functions ~(lambda (xâ‚€ â€¦ xâ‚™) body)~
   into the Agda-like syntax ~(Î» xâ‚€ â‹¯ xâ‚™ â†’ body)~.

 #+BEGIN_SRC emacs-lisp :tangle yes
(defmacro Î» (&rest body)
  "Implementing Agda style, interactive, lambdas; ideally for inline use:

   â€œÎ» Î± Î² â€¦ Ï‰ â†’ bodyâ€  becomes an interactive function with arguments Î±, â€¦, Ï‰.

   The args list may be empty, in which case the separator â€œâ†’â€ may be omitted
   entirely, if desired.
  "

  (let* ((parts (-split-on 'â†’ body)) args rest)

    (if (<= 2 (length parts))
        (progn (setq args (car parts)) (setq rest (cadr parts)))
         ;; Otherwise, only one part was found ---no arguments were provided.
         (setq args nil) (setq rest (car parts)))

   `(lambda ,args (interactive) ,@rest)
  ))
 #+END_SRC

* The ~package-former~ Datatype
  :PROPERTIES:
  :CUSTOM_ID: The-~package-former~-Datatype
  :END:

For this prototype's constraints, a PackageFormer will generally declared as
#+BEGIN_SRC agda :tangle no
PackageFormer Name : Set level where
     â‹®
#+END_SRC

The body, ~â‹®~, of such a declaration consists of a number of name-type declarations
and, equations ---*not yet supported*--- so let's form a type to work with these
components rather than meddle with strings all the time.

#+BEGIN_SRC emacs-lisp :tangle yes
(defstruct package-former
  "Record of components that form a PackageFormer.

   - â€˜docstringâ€™: Relevant documentation about this structure; e.g.,
      what is the instance declaration that generated this type, if any.

   - â€˜kindâ€™: PackageFormer, record, data, module, function, etc.

   - â€˜nameâ€™: The name of the grouping mechanism schema.

   - â€˜levelâ€™: The universe level that the instantiations will inhabit.
          The universe level of the PackageFormer.

   - Finally, the children fields are the typed-names that constitute the body of the
     grouping mechanism. As long as consistent indentation is selected, it does not matter how much.
     As such, we keep track of these indentation numerics ourselves in case we need to tweak them.

   - The first â€˜waistâ€™-many elements are considered parameters.

   TODO: Eventually need to support variations?
  "
  docstring
  kind
  name
  level

  waist ;; Delimits elements into parameters and fields.

  ;; children
  indentation ;; useful for when new elements are added.
  elements
)
#+END_SRC

We will keep track of all such declarations in a global list.
#+BEGIN_SRC emacs-lisp  :tangle yes
(defvar package-formers nil
  "The list of PackageFormer schema declarations in the current Agda buffer.")
#+END_SRC

** Locally Opening a PackageFormer
   :PROPERTIES:
   :CUSTOM_ID: Locally-Opening-a-PackageFormer
   :END:
It will get rather redundant to write ~(package-former-X p)~ to project the constituents of a PackageFormer ~p~. As such, let's introduce
a useful macro to â€œopen pâ€ locally.
#+BEGIN_SRC emacs-lisp :tangle yes
;; An anaphoric macro ^_^
(defmacro open-pf (p &rest body)
  `(let*
    ((docstring             (package-former-docstring ,p))
     (kind                  (package-former-kind ,p))
     (name                  (package-former-name ,p))
     (level                 (package-former-level ,p))
     (waist                 (package-former-waist ,p))
     (indentation           (package-former-indentation ,p))
     (elements              (package-former-elements ,p))

    ;; â€¼ TODO: MA: Eventually need to support variations?

    (parameters            (-take waist elements))
    (fields                (-drop waist elements)))
    ,@body
  )
)
#+END_SRC

( Lisp convention would advise this function to be named ~with-pf~, but I'm using the prefix ~open~,
as it is closer to the object language, Agda. )

  It is crucial to realise that we have just established a convention
  that partitions the elements of a PackageFormer:
  + <<<parameters>>> are the elements before the waist line.
  + <<<fields>>> are the elements after the waist line.

** Elements and Typed Names
   :PROPERTIES:
   :CUSTOM_ID: Typed-Names
   :END:
#+BEGIN_SRC emacs-lisp :tangle yes :results replace
(defstruct element

  qualifier ;; E.g., â€œprivate, fieldâ€
  name      ;; The lhs of an equation and a typed-name
  type      ;; The type of a typed-name
  equations ;; List of definitional clauses: â€œsame-name-as-above args = termâ€
)

;; make map functions
(loop for place in '(qualifier name type equations)
      do
      (-let [loc (intern (format "element-%s" place))]
        (eval `(defun ,(intern (format "map-%s" place)) (f e)
           "??? TODO:"
           (-let [eâ€² (copy-element e)]
             (setf (,loc eâ€²) (funcall f (,loc eâ€²)))
             eâ€²)))))

(defun element-replace (old new e)
  "Replace every occurance of /word/ â€˜oldâ€™ by string â€˜newâ€™
   in element â€˜eâ€™."

  (-let [eâ€² (copy-element e)]
    (loop for place in '(element-qualifier element-name element-type)
    do (eval `(setf (,place eâ€²) (replace-regexp-in-string (format "\\b%s\\b" old) new (,place eâ€²) t t))))
    ;; Replacements in the equations as well.
    (setf (element-equations eâ€²)
          (loop for eq in (element-equations eâ€²)
                collect (s-replace old new eq)))
    ;; return value
    eâ€²))


(declare-type parse-name : string string)
(defun parse-name (element)
  "Given an string representation of an â€˜elementâ€™, yield the â€˜nameâ€™ component.

   The shape of the input may be â€œqualifier lhs ~ rhsâ€ where â€˜~â€™ is either â€˜:â€™
   or â€˜=â€™. The qualifier is a â€˜specialâ€™ word: field, private.
  "
  (let (lhs name)
    (setq lhs
          (s-split " " (car (s-split " = " (car (s-split " : " element))))))
    (if (and (< 1 (length lhs)) (special (nth 0 lhs)))
        (cadr lhs)
      (car lhs))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no :results replace
(mapcar #'parse-name '("A : Set" "private B : Set" "C : â„• â†’ Set" "B = A" "C zero = A" "C (suc n) = A" "D : Set" "E : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)))" "ğ’®â„¯ğ“‰ = Set"))
#+END_SRC

#+RESULTS:
| A | B | C | B | C | C | D | E | ğ’®â„¯ğ“‰ |

#+BEGIN_SRC emacs-lisp :tangle yes :results replace
(declare-type parse-elements : (list-of string) (list-of element))
(defun parse-elements (elements)
  "Given a list of PackageFormer â€˜elementsâ€™, as strings, parse them into the
  â€˜elementâ€™ datatype. Declarations and equations may be interspersed, as along
  as equations of names follow their declarations.

   The order is preserved in-case there are declarations that make use of definitions.

   Types must always be supplied ---in general, type inference is undecidable in DTLs.
   "

  (-let [es (mapcar #'list elements)]
  ;; Maintain a list of related items.
  (loop for i from 0
        for e in es
        do
          (loop for j from 0 to (1- i)
            do
              ;; If the name of â€˜eâ€™ occurs in the prefix,
              ;; then move â€˜eâ€™ to the location in the prefix,
              ;; and zero-out the current location.
              (let (lhs name)
                 (setq name (parse-name (car e)))
                 ; (message-box "%s , %s" name (parse-name (or (car (nth j es)) "")))
                 (when (equal name (parse-name (or (car (nth j es)) "")))
                   ;; Use an empty string in-case the location is nil.
                   (setf (nth j es) (append (nth j es) e))
                   (setf (nth i es) nil)))))

   ;; Drop the nils.
  (setq es (--reject (not it) es))

  ;; We now have a list of related items,
  ;; with the car of each being a qualified typed-name
  ;; and the cdr of each being a list of equational clauses associated with that name.
  (loop for e in es
        collect
                 (let* ((Ï„ (s-split " : " (car e))) (nom (parse-name (car Ï„))) (qual (car (s-split nom (car Ï„)))))
                 (make-element :qualifier (unless (s-blank? qual) qual)
                               :name nom
                               :type (if (cdr Ï„) (s-join " : " (cdr Ï„)) (error (message-box "Error: Type not supplied for %s!" nom)))
                               :equations (cdr e))))))
#+END_SRC

#+RESULTS:
: parse-elements

Notice that the equations do not necessarily immediately follow their associated declarations.
#+BEGIN_SRC emacs-lisp :tangle no :results replace
(mapcar #'list (parse-elements
'("A : Set" "private B : Set" "C : â„• â†’ Set" "B = A" "C zero = A" "C (suc n) = A" "D : Set" "E : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)))")))
#+END_SRC

#+RESULTS:
| #s(element nil A Set nil)                                                         |
| #s(element private  B Set (B = A))                                                |
| #s(element nil C â„• â†’ Set (C zero = A C (suc n) = A))                              |
| #s(element nil D Set nil)                                                         |
| #s(element nil E {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹))) nil) |

Finally, it seems we need support for typed names ---pairs ~â€œname : typeâ€~.
We could use ~car~ and ~cdr~ on pairs, but let's use named projections instead
so we don't have this extra mental strain and implicit type-checking to ensure.
{{{fold(Working with â€œname : typeâ€ Pairs)}}}
#+BEGIN_SRC emacs-lisp :tangle no
(defun make-tn (name type)
  "Produce a typed-name pair; discard all surrounding whitespace."
  (concat (s-trim name) " : " (s-trim type)))

(defun get-name (tn)
  "Given a string â€œname : typeâ€, return the â€˜nameâ€™;
   which will not have any colons in it.
   Whitespace at the edges is trimmed away.
  "
  (s-trim (car (s-split " : " tn))))

(defun get-type (tn)
  "Given a string â€œname : typeâ€, return the longest possible â€˜typeâ€™ substring.
  Whitespace at the edges is trimmed away."
  (s-trim (s-join " : " (cdr (s-split " : " tn)))))

(defmacro map-name (fbody tn)
  "Apply string expression â€˜fbodyâ€™ to the â€˜nameâ€™ position of a typed-named structure.
   â€˜fbodyâ€™ may mention â€˜nameâ€™.
  "
  `(make-tn (rename-mixfix (lambda (name) ,fbody) (get-name ,tn)) (get-type ,tn))
)

(defmacro map-type (fbody tn)
  "Apply string expression â€˜fbodyâ€™ to the â€˜typeâ€™ position of a typed-named structure.
   â€˜fbodyâ€™ may mention â€˜typeâ€™.
  "
  `(let ((type (get-type ,tn)))
       (make-tn (get-name ,tn) ,fbody))
)

(ert-deftest tn ()
  ;; Superflous space
  (should (equal "name" (get-name "name   : type")))
  ;; Multiple â€œ:â€.
  (should (equal "âˆ€ {X : Obj ğ’} â†’ (X âŸ¶ X)"
         (get-type"Id : âˆ€ {X : Obj ğ’} â†’ (X âŸ¶ X)") )))
#+END_SRC
{{{end-fold}}}

** Package Former Parsing and Pretty Printing
   :PROPERTIES:
   :CUSTOM_ID: Package-Former-Parsing-and-Pretty-Printing
   :END:

With this in hand, let's produce a robust parser.
#+BEGIN_SRC emacs-lisp :tangle yes
; (declare-type load-package-former : (list-of string) package-former)
(declare-type load-package-former : t t)
(defun load-package-former (lines)
  "The input â€˜linesâ€™ must be a list of lines forming a full PackageFormer declaration;
   e.g., obtained by calling â€˜get-childrenâ€™.

   It is parsed and a â€˜package-formerâ€™ value is returned.

   - Whitespace is stripped off of items.
   - Docstrings are ignored.
  "

  (when (not lines)
      (error "load-package-former: Error: Input must be non-empty list."))

  (let* (pf
         (header (car lines))
         (name (substring-delimited-here "PackageFormer $here :" header))
         (level (substring-delimited-here "Set $here where" header)))

    (when 700-highlighting
      (--map (highlight-phrase (s-trim it) 'hi-yellow) (cdr lines)))

    (setq pf
          (make-package-former
           :kind                     "PackageFormer"
           :name                     name
           ;; â€˜levelâ€™ may be â€œâ€, that's okay.
           ;; It may be a subscript or implicitly zero & so no space after â€˜Setâ€™.
           :level                    level
           :waist                    0
           ;; â€¼ TODO: Currently no parameter support for arbitrary PackageFormers.
           :indentation              (get-indentation (cadr lines))
           :elements  (parse-elements (--remove (s-starts-with? "-- " it)
                                                (--map (s-trim it) (cdr lines))))))

      (push (cons name pf) package-formers)

      ;; return value
      pf))
#+END_SRC

Let's try this out.
#+BEGIN_SRC emacs-lisp :exports both :results table replace :var test=test
(load-package-former (cadr (get-children "PackageFormer" test)))
#+END_SRC

#+RESULTS:
| #s(package-former nil PackageFormer M-Set â‚ 0 nil 3 (#s(element nil Scalar Set nil) #s(element nil Vector Set nil) #s(element nil _Â·_ Scalar â†’ Vector â†’ Vector nil) #s(element nil ğŸ™ Scalar nil) #s(element nil _Ã—_ Scalar â†’ Scalar â†’ Scalar nil) #s(element nil leftId {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹ nil) #s(element nil assoc {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹) nil))) |

Conversely, let's have a pretty printer.
#+BEGIN_SRC emacs-lisp :tangle yes
(declare-type special : string t)
(defun special (f)
  "Special elements, for whatever reason are exceptional, and so
   are maked as singleton lists and their indentation is lessened.
   That is, these denote sibling fields rather than more children.

   Special elements include: field, private.

   See â€˜show-package-formerâ€™ for their use and how their printed.
  "
  (--any? (s-contains? it f) '("field" "private" "open" "top-level" "sibling")))
#+END_SRC
A â€œsiblingâ€ item has no indentation.

#+BEGIN_SRC emacs-lisp :tangle yes
(declare-type show-element (:omit-qualifier t) element string)
(cl-defun show-element (e &optional omit-qualifier)
  "Render an â€˜elementâ€™ value in the form

       qualifier name : type ; equational-clauseâ‚€ ; â‹¯ ; equational-clauseâ‚™
  "

  (s-join " ;\t" (cons
                 (format "%s%s\t\t: %s"
                         (-let [it (element-qualifier e)] (if (or (not it) omit-qualifier) "" (format "%s " it)))
                         (element-name e)
                         (element-type e))
                 (element-equations e))))

(declare-type show-package-former : package-former string)
(cl-defun show-package-former (p)
  "Pretty print a package-former record value.
  "

  (open-pf p
    (s-join "\n"
      (-cons*

       ;; The documentation string
       (when docstring (format "{- %s -}" docstring))

       ;; The schema declaration
       (s-collapse-whitespace
        (s-join " "
                (list kind
                      name
                      (s-join " " (--map (concat "(" (show-element it :omit-qualifier) ")") parameters))
                      (unless (equal level 'none) (concat ": Set" level))
                      "where")))

       ;; The elements of a PackageFormer
       (thread-last fields
         (--map (format "%s%s" (s-repeat indentation " ") (show-element it)))
         )
       ))))

         ;; Indent all elements, less indentation for the specials.
         ;; Regarding â€œtop-levelâ€ see the â€œrecordâ‚‘â€ variational in Paper0.pdf.
         ;; The extra whitespace is important.
         ;; (--map (concat (s-repeat (- indentation (if (special it) 2 0)) (if (s-starts-with? "sibling" it) "" " "))
         ;;                (if (s-starts-with? "top-level" it) (s-chop-prefix "top-level " it)
         ;;                 (if (s-starts-with? "sibling" it) (s-chop-prefix "sibling " it) it))))
#+END_SRC

Let's test it out by /introducing/ a whole new local variable and trying
to include the ~field~ Agda keyword.
#+BEGIN_SRC emacs-lisp :exports both :results replace :wrap "src results-agda" :var test=test
(let* ((raw (cadr (get-children "PackageFormer" test)))
       (pf (load-package-former raw))
       (waist 2))
  (setf (package-former-waist pf) waist)

  ;; mark all items as "fields"
  (--map (setf (element-qualifier it) "field") (package-former-elements pf))

  ;; inject new items at the waist line
  (loop for new in (parse-elements '("private n : â„•" "n = 3" "ğ’®â„¯ğ“‰ : Setâ‚" "ğ’®â„¯ğ“‰ = Set"))
        do (push new
        (cdr (nthcdr (1- waist) (package-former-elements pf)))))

   (show-package-former pf))
#+END_SRC

#+RESULTS:
#+begin_src results-agda

PackageFormer M-Set (Scalar : Set) (Vector : Set) : Setâ‚ where
   ğ’®â„¯ğ“‰		: Setâ‚ ;	ğ’®â„¯ğ“‰ = Set
   private  n		: â„• ;	n = 3
   field _Â·_		: Scalar â†’ Vector â†’ Vector
   field ğŸ™		: Scalar
   field _Ã—_		: Scalar â†’ Scalar â†’ Scalar
   field leftId		: {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   field assoc		: {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)
#+end_src

Notice that the $ğ’®â„¯ğ“‰ = Set$ alias is a top-level item, with respect to the current PackageFormer.

We can phrase an approximation of the opinion that parsing and showing
should be inverses.
#+BEGIN_SRC emacs-lisp :exports both :results table replace :var test=test
(-let [pf (cadr (get-children "PackageFormer" test))]
  (should (equal (s-collapse-whitespace (concat "\n" (s-join "\n" pf)))
     (s-collapse-whitespace (show-package-former (load-package-former pf))))))
#+END_SRC

#+RESULTS:
| t |

#+begin_center
( /In Lisp, ~t~ denotes â€œtrueâ€!/ )
#+end_center

{{{fold(Unit Tests)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest pf-parse ()

  ;; Error on empty list of lines.
   (should-error (load-package-former nil))

   ;; No crash on empty line.
   (should (load-package-former (list "")))

   ;; No crash on PackageFormer with no elements.
   (should (load-package-former (list "PackageFormer PF : Set â„“ where")))

   ;; Levels
   (should (equal "â„“" (package-former-level (load-package-former (list "PackageFormer PF : Set â„“ where")))))
   ;;
   (should (equal "" (package-former-level (load-package-former (list "PackageFormer PF : Set  where")))))
   ;;
   (should (equal "â‚ƒ" (package-former-level (load-package-former (list "PackageFormer PF : Setâ‚ƒ where")))))
   ;;
   (should (equal "(Level.suc â„“)" (package-former-level (load-package-former (list "PackageFormer PF : Set (Level.suc â„“) where")))))

   ;; Full parsing.
   (-let [pf (load-package-former (cadr (get-children "PackageFormer" test)))]
     (equal (format "%s" pf)
            "#s(package-former nil PackageFormer M-Set â‚ 0 nil 3 (Scalar  : Set Vector  : Set _Â·_     : Scalar â†’ Vector â†’ Vector ğŸ™       : Scalar _Ã—_     : Scalar â†’ Scalar â†’ Scalar leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹ assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)))"))

  (-let [pf (cadr (get-children "PackageFormer" test))]
    (should (equal (s-concat "\n" (s-join "\n" pf))
                   (show-package-former (load-package-former pf)))))

)
#+END_SRC
{{{end-fold}}}

* Variational Language
  :PROPERTIES:
  :CUSTOM_ID: Variational-Language
  :END:

  A variational has the syntactic form specfied by

#+BEGIN_SRC text
        ğ“‹   ::=  identifier (identifier)* = ğ“‹ğ’¸
        ğ“‹ğ’¸  ::= [identifier] (:key value)* (âŸ´ ğ“‹ğ’¸)*

        identifier â‰ˆ key â‰ˆ value â‰ˆ string of text
#+END_SRC

  With the intention that ~l a = r~ is a list of key-value pairs
  determined from the right-hand side where the arguments ~a~
  are to be considered place-holders. Whenever one mentions free variables,
  or terms, one actually speaks of functions. Hence, let's reify these as functions.

  Let's keep track of the user defined variationals, so that we can display them to the
  user via menus, as well as highlight them, and attach tooltips to them.
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar variationals nil
  "Association list of Agda-user defined variational operators.")
#+END_SRC

Let's be somewhat agonstic regardiing the variational composition operator;
users are welcome to use any other symbol.
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar variational-composition-operator "âŸ´"
  "The operator that composes varitionals.")
#+END_SRC

** ğ’±ğ’¸,  ğ’±-, and ğ’±
   :PROPERTIES:
   :CUSTOM_ID: ğ’±ğ’¸,--ğ’±-,-and-ğ’±
   :END:
  Variationals are refieid as functions with the prefix ğ’±-;
  doing otherwise may override existing utilities in Emacs
  ---for example, â€˜recordâ€™ is a useful name for a variational
  but is a super important utility function in Emacs.
  The apporach we take is to allow users to write â€˜recordâ€™
  but the implementation will refer to it with a prefix.

Parsing variational clauses is then straightforward:
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar *parent-context* nil
  "For error report; what is the current parent context of a child item.

   Should be set whenver a parent invokes a child.
   Since we have no grandchildren, we only need one level.
")

(defun ğ’±ğ’¸ (body-list &optional context args)
  "Parse a single ğ’±ariational ğ’¸lause, as a list, of the form â€œ[label] (:key :value)*â€.

   If there is a â€˜labelâ€™, then yield â€˜(label :key value â‹¯)â€™
   since â€˜labelâ€™ is assumed to exist as a variational having the given
   keys as arguments. The result should be a list of pairs.

   If there is no label, the parse the list of pairs.

  For example,
     (cl-defun ğ’±-test (&key height kind) (list (format \"%s & %s\" height kind)))
     (ğ’±ğ’¸ '(test :height 3 :kind 'data)) â‰ˆ (test :height 3 :kind data) â‰ˆ (â€œ3 & dataâ€)
     (ğ’±ğ’¸ '(     :height 3 :kind data))  â‰ˆ ((:height . 3) (:kind . data))

   Newer items câ‚€ âŸ´ â‹¯ âŸ´ câ‚™ should be at the front of the list;
   access should then be using â€˜assocâ€™.
  "

  (let* (res (*parent-context* context))
    (loop for clause in (-split-on 'âŸ´ body-list)
          do (setq res (-concat
                        ;; Symbols starting with â€œ:â€ are keywords.
                        (if (not (keywordp (car clause)))
                            ;; Function invocation case
                            ;; We turn everything into a string so that we may
                            ;; prepend the function name with a ğ’±-
                            ;; then turn that into Lisp with the first eval
                            ;; then invoke the resulting function call with the second eval.
                            (eval `( ,(ğ’±- (car clause)) ,@(cdr clause)))
                          ;; List of key-value pairs
                          `,(loop for key   in clause by #'cddr
                                  for value in (cdr clause) by #'cddr
                                  collect (700-wf key value context args)))  ;; â€œ700-wfâ€ is just a fancy â€œconsâ€.
                        ;; Newer items câ‚€ âŸ´ â‹¯ âŸ´ câ‚™ should be at the front of the list;
                        ;; access should then be using assoc.
                        res)))
    res))
#+END_SRC
Where we have used the following helper to prefix Lisp code with â€œğ’±-â€.
#+BEGIN_SRC emacs-lisp :results replace  :tangle yes
(defun ğ’±- (name)
  "Prefix the Lisp data â€˜nameâ€™ with a â€œğ’±-â€
   then yield that as a Lisp datum.
  "
  (should (symbolp name))
  (thread-last name
    (format "ğ’±-%s")
    read-from-string
    car))
#+END_SRC

We now handle variational declarations by introducing a DSL; i.e., a macro that
expects the syntax outlined earlier.
#+BEGIN_SRC emacs-lisp :tangle yes
(defmacro ğ’± (name &rest body)

  "Reify as Lisp a variational declaration using the following grammar.

        ğ“‹   ::= [docstring] identifier ([â€œ(â€]identifier[â€œ)â€])* = ğ“‹ğ’¸
        ğ“‹ğ’¸  ::= [identifier] (:key value)* (âŸ´ ğ“‹ğ’¸)*

    E.g., (ğ’± tes positional (keyword 3) = :kind data)
    This defines a variational with one positional and one keyword argument having
    3 as default.

    The resulting generated function has its code embeded as a docstring viewable
    with â€œC-h oâ€ ---catented after any provided user documentation.
  "

  ;; Main code follows.
  (let* ((context (mapconcat (lambda (x) (prin1-to-string x t)) (cons name body) " "))
         (args-body (-split-on '= body)) args pargs kargs argnames docs body res actual-code)
    (pcase (length args-body)
      (2 (setq args (car args-body)
               body (cadr args-body)))
      (t (setq body (car args-body))))

    ;; Realise the arguments as either ğ’«ositinal or ğ’¦ey arguments.
    (loop for a in args
          do (if (consp a) (push a kargs) (push a pargs)))

    ;; Keep track of only the argument names, omitting any default values.
    (setq argnames (append pargs (mapcar #'car kargs)))

    ;; Set any documentation string and reify the body's variational clauses.
    (when (stringp (car body)) (setq docs (car body) body (cdr body)))
    (setq res (ğ’±ğ’¸ body context argnames))

    ;; I want to be able to actually, visually, see the resulting
    ;; generated definition of a function.
    ;; Hence, I embed its source code as a string in the code.
    ;;
    ;; I'm using strings so that they appear in the docstring via C-h o.
    ;;
    (setq actual-code
    `(cl-defun ,(ğ’±- name) (,@pargs &key ,@kargs)

       ;; Stage the formal names *now*, then evaluate their values at run time.
       ;; Traverse the list of pairs and change the nested formal names with the
       ;; given values. Praise the Lord!
      (let* ((give-goal (quote ,res)) (give-goalâ‚€ give-goal))
        (when (quote ,argnames)

          "Stage the formal names *now*, then evaluate their values at run time."
          (loop for arg in (quote ,argnames)
                do (setq give-goal (subst (eval arg) arg give-goal)))

          ;; TODO, maybe.
          ;; "Check that substituted values are well-typed"
          ;; (--map (700-wf (car it) (or (cdr it)
          ;;                             ;; Mention which argument is not supplied.
          ;;                             (format "No Value for :%s Provided!"
          ;;                                     (cdr (assoc (car it) (reverse give-goalâ‚€)))))
          ;;                (s-concat (when *parent-context* (s-concat *parent-context* "\n\tâ©\t")) ,context)) give-goal)

          )

         give-goal)))

    ;; Now set the code as a documentation string in it, after the fact.
    (setq docs (format "Arguments:\t%s %s\n%s" pargs kargs
                       (if (not docs) "Undocumented user-defined variational."
                         ;; Keep paragraph structure, but ignore whitespace otherwise.
                         (thread-last docs
                           (s-split "\n\n")
                           (mapcar #'s-collapse-whitespace)
                           (mapcar #'s-trim)
                           (s-join "\n\n")
                           (s-word-wrap 70)
                           (format "\n%s\n\n\n")))))
                    ;; When the user provides documentation, they may not want to see
                    ;; the raw and expansions, so we pad extra whitespace before them.

    (put (ğ’±- name) 'function-documentation
         (format "%s\nâŸªUser DefinitionâŸ«\n\n%s\n\nâŸªLisp ElaborationâŸ«\n\n%s"
                 docs context (pp-to-string actual-code)))
    ;; Register this new item in our list of variationals.
    (push (cons name docs) variationals)
    ;; Return value:
    actual-code))
#+END_SRC

Consequently, any item declared with ğ’± now has a docstring containing its user-facing
definition as well as its Lisp realisation ^_^ ---simply press â€œC-h o ENTERâ€ on its name.

Here's an example.
#+BEGIN_SRC emacs-lisp
(ğ’± test positional (keyword 3) another = "I have two mandatory arguments and one keyword argument")

(ğ’±-test "positional argâ‚" "positional argâ‚‚" :keyword 25) ;; â‡’ nil ^_^
#+END_SRC

** Well-formed checks ---Error reporting
   :PROPERTIES:
   :CUSTOM_ID: Well-formed-checks----Error-reporting
   :END:
What is the above â€œfancy consâ€ we mentioned? Here it is.

#+BEGIN_SRC emacs-lisp  :tangle yes
(defun 700-error (condition message context)
  "Ensure â€˜conditionâ€™ is true, otherwise emit â€˜messageâ€™
   and indicate the offending â€˜contextâ€™.
  "
  (when condition
    (error (format "700: %s\n\n\tâ‡¨\t%s" message context))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
;; declare-type cannot yet accomodate optional arguments
(cl-defun 700-wf (key value &optional context args)
  "This operation checks that the â€˜valueâ€™ of â€˜keyâ€™
   is well-formed according to 700-specifications ---which are stated
   explicitly within this method--- and if it is well-formed we
   return the â€˜valueâ€™ /interpreted/ along with the â€˜keyâ€™.

   When the value is not well-formed, we use the provided â€˜contextâ€™
   in an error message. No error is reported if â€˜valueâ€™ is an â€˜argâ€™ument
   of a variational begin declared.
  "

  (let ( condition message
         (wf '( (:kind   (-contains? '(record data module PackageFormer) value)
                         (format "This kind â€œ%sâ€ is not supported by Agda!\n     Valid kinds: record, data, module, PackageFormer." value))
                (:waist  (numberp value) (format "The waist should be a number; which â€œ%sâ€ is not." value))
                (:level (-contains? '(inc dec none) value) (format "The â€œlevelâ€ must be â€œincâ€ or â€œdecâ€ or â€œnoneâ€; which â€œ%sâ€ is not." value))
                ; (:alter-elements (functionp value) (format "Componenet alter-elements should be a function; which â€œ%sâ€ is not." value))
                       )))

    (when-let ((here (assoc key wf)))
      (setq condition        (eval (nth 1 here))
            message          (eval (nth 2 here)))
      (700-error (not (or condition (-contains? args value))) message context))

    ;; Return the key-value as a pair for further processing.
    ;; :kind and :level values are symbols and so cannot be evaluated furthur.
    (cons key
          (if
           (or (-contains? args value) (-contains? '(:kind :level) key))
           value
           (eval value)))))
#+END_SRC

** Loading Variationals: Super Simple Conversion From String to Lisp
   :PROPERTIES:
   :CUSTOM_ID: Loading-Variationals:-Super-Simple-Conversion-From-String-to-Lisp
   :END:
#+begin_src emacs-lisp :tangle yes
(cl-defun load-variational (variation-string)
  "Obtain lines of the buffer that start with â€œğ’±-â€.
   Realise them as Lisp association lists.

   A line is something like:

      ğ’±-name xâ‚€ â€¦ xâ‚™  =  ([labelâ‚€] :keyâ‚€ valâ‚ â‹¯ :keyâ‚˜ valâ‚˜ âŸ´)*

   The result is a list of 3-tuples (name (xâ‚€ â‹¯ xâ‚™) ((keyâ‚€ valâ‚€) â‹¯ (keyâ‚˜ valâ‚˜))),
   containing the clause's name, argument list, and key-value pairs.

   If the optional â€˜string-listâ€™ is provided, then use
   that instead of searching the buffer. This feature
   has been added on to make the presentation of tests
   and examples easier to digest ---without the mockup
   of fletting â€˜buffer-substring-no-propertiesâ€™ to return
   what could instead be â€˜string-listâ€™. It was the addition
   of a simple â€˜orâ€™ ---far less than this string explaning it.

   For now, the RHS must be an expression of the form â€œ:keyâ‚€ valueâ‚€ â‹¯ :keyâ‚™ valueâ‚™â€
   - where the valueáµ¢ are legitmate Lisp expressions
   - and the LHS is an atomic name, possibly with argument names.
  "

  (thread-last variation-string
    (s-replace "ğ’±-" "ğ’± ")
    (format "(%s)")
    read-from-string
    car
    eval))
#+end_src

{{{fold(Unit Tests)}}}
# The extra quotes are okay; the front end supplies a single quote
# and here in the backend we need two.
# ?

#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest variationals-ğ’±ğ’¸ ()

  (should (equal (ğ’±- 'nice)
                 'ğ’±-nice))

  (should (equal (ğ’±ğ’¸ '(:height 3 :kind 'data))
                '((:height . 3) (:kind . data))))


  ;; Error along with â€œnoiceâ€.
  (should-error (ğ’±ğ’¸ '(:height 3 :kind datda) 'noice nil))

  ;; nice error.
  (should-error (ğ’±ğ’¸ '(:level 3)))

  ;;
  (cl-defun ğ’±-test (&key height kind) `( (first . ,height) (second . ,kind)))
  ;;
  (should (equal (ğ’±ğ’¸ '(test :height 3 :kind 'three âŸ´ :kind 'module))
                 '((:kind . module) (first . 3) (second . three))))
  ;;
  ;; NOTE: ğ’±-testsâ€² :kind is optional
  (should (equal (ğ’±ğ’¸ '(test :height 3 âŸ´ :kind 'module))
                 '((:kind . module) (first . 3) (second))))
  ;;
  (should (equal (ğ’±ğ’¸ '(:height 3 âŸ´ :kind 'module))
                 '((:kind . module) (:height . 3))))

  ;; Recursively place 3 (new) wherever 'it (old) occurs.
  ;; This' a standard Lisp utility.
  (should (equal
           (subst 3 'it '(1 2 it 4 (5 it) 7 (+ 8 it)))
           '(1 2 3 4 (5 3) 7 (+ 8 3))))
)
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest variationals-ğ’± ()

  ;; Nullary
  (should (ğ’± testâ‚€  = :kind 'record :waist 3))
  (should (equal (ğ’±-testâ‚€)
               '((:kind . record) (:waist . 3))))

  ;; Unary
  (should (ğ’± testâ‚ heightish = :kind 'record :waist heightish))
  (should (equal (ğ’±-testâ‚ :heightish 6)
                 '((:kind . record) (:waist . 6))))

  ;; Invoking the previously defined variational
  (should (ğ’± testâ‚‚  = :kind 'data âŸ´ testâ‚ :heightish 2))
  (should (equal (ğ’±-testâ‚‚)
                 '((:kind . record) (:waist . 2) (:kind . data))))

  ;; See a nice error message ^_^
  (should-error (ğ’± testâ‚ƒ = :kind recordd))
)
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest variationals-loading ()

  (should (load-variational "ğ’±-tc this height = :level this :waist height"))

  ;; NEATO! (Has desired error)
  ;; (-let [*parent-context* "woadh"]
  ;;   (ğ’±-tc :height 'no :this 'inc))
  ;;
  ;; Does not pass: I've commented out the type checking in ğ’± above, for now.

  (should (ğ’±-tc :height 9 :this 'inc))

  (should (equal (ğ’±ğ’¸ '(:a 'b âŸ´ tc :height 1))
                 '((:level) (:waist . 1) (:a . b))))

;
)
#+END_SRC
{{{end-fold}}}

* Loading an Agda Buffer
  :PROPERTIES:
  :CUSTOM_ID: Loading-an-Agda-Buffer
  :END:

# Herein we define the datatype of ~instance-declaration~, describe how
# to parse such entities.

Before we can parse an Agda buffer, we need to be able to parse an instantiation declaration;
for which we would later generate code.

** Loading an Instance ---The Core Utility
   :PROPERTIES:
   :CUSTOM_ID: Loading-an-Instance----The-Core-Utility
   :END:
An instance declaration is of the form:
#+BEGIN_SRC results-agda
PFâ€² = PF variationalâ‚ argsâ‚ âŸ´  â‹¯ âŸ´ variationalâ‚™ (argsâ‚™)
#+END_SRC

This gives rise to a simple nice structure:
#+BEGIN_SRC emacs-lisp :tangle yes
(defstruct instance-declaration
  "Record of components for an PackageFormer instance declaration:
   âŸªnameâŸ« = âŸªpackage-formerâŸ« (âŸ´ âŸªvariationâŸ« [âŸªargsâŸ«])*
  "

  docstring      ;; What the declaration looks like, useful for reference.
  name           ;; Left-hand side
  package-former ;; Parent grouping mechanism
  alterations    ;; List of variationals along with their arguments.
)
#+END_SRC

Loading an instantiation into our list is now trivial.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun load-instance-declaration (line &optional show-it)
  "If the current â€˜lineâ€™ string is an instance declaration,
   then produce a new PackageFormer from it. Else, do nothing.

   â‡’ Whitespace is automatically collopased from â€˜lineâ€™.
   â‡’ Nil elements are discarded; e.g., due to a filter.
   â‡’ Duplicates are discarded; e.g., due to a rename.

   Variational clauses may mention
   â‡’ $ğ‘›ğ‘ğ‘šğ‘’: The name of the PackageFormer currently being declared; i.e., the LHS name.
   â‡’ $ğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘ : Many variationals will act on individal elements, but may check a
              property relative to all elements and this name allows us to avoid
              having variationals that simply accomodate for binary functions
              that operate on an individual element while also needing to refer to all
              elements. For example, a variational that keeps an element if it's related
              to another element somehow.
  "

  (letf* (
     (pieces (s-split " " (s-collapse-whitespace line)))
     ($ğ‘›ğ‘ğ‘šğ‘’      (nth 0 pieces))
     ($ğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘     nil)
     (eqSymb     (nth 1 pieces))
     ($ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡     (nth 2 pieces))
     (variations (nthcdr 3 pieces))
     (alterations nil)
     (self (copy-package-former (cdr (assoc $ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ package-formers))))
     ((symbol-function 'â‰)
      ;; If componenet â€˜câ€™ is in the â€˜alterationsâ€™ list of the instance declaration,
      ;; then evalaute any given â€˜moreâ€™ code, get the value for â€˜câ€™ and turn it
      ;; into a string, if â€˜strâ€™ is true, then set the new PackageFormer's â€˜câ€™
      ;; componenet to be this value.
      ;; Well-formedness checks happen at the ğ’± and ğ’±ğ’¸ stages, see below.
         (lambda (c &optional str more) (when-let ((it (cdr (assoc (intern (format ":%s" c)) alterations))))
                           (eval `(progn ,@more))
                           (when str (setq it (format "%s" it)))
                           (eval `(setf (,(car (read-from-string (format "package-former-%s" c))) self) it))))

        )
     )

   ;; Ensure instance declaration is well-formed.
    (700-error (or (s-blank? (s-trim $ğ‘›ğ‘ğ‘šğ‘’)) (not (equal "=" eqSymb)) (not $ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡))
               (concat "An instance declaration is of the form "
                       "â€œnew-name = parent-package-former variational-clausesâ€.")
               line)

   ;; Let's not overwrite existing PackageFormers.
    (700-error (assoc $ğ‘›ğ‘ğ‘šğ‘’ package-formers)
               (format "PackageFormer â€œ%sâ€ is already defined; use a new name." $ğ‘›ğ‘ğ‘šğ‘’)
               line)

   ;; Ensure the PackageFormer to be instantiated is defined.
    (700-error (not self)
               (format "Parent â€œ%sâ€ not defined." $ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡)
               line)

    ;; Update the new PackageFormer with a docstring of its instantiation
    ;; as well as its name.
    (setf (package-former-docstring self) line)
    (setf (package-former-name self) $ğ‘›ğ‘ğ‘šğ‘’)
    (setq $ğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘  ; Copy so that user does not inadvertently alter shared memory locations!
          (loop for e in (package-former-elements self)
                 collect (copy-element e)))

    ;; Parse the â€œğ“‹â‚€ âŸ´ â‹¯ âŸ´ ğ“‹â‚™â€ portion of an instance declaration.
     (thread-last  variations
       (s-join " ")     ;; Stick the rest back together.
       (format "'(%s)") ;; Construe as a lisp list
       read-from-string
       cadar
       (setq variations))
     ;;
     (setq alterations (ğ’±ğ’¸ variations line))

     ;; c.f. â‰ above
     ;; Now that the aterations have been parsed, let's attach
     ;; the new components of the PackageFormer being made.

      ;; :kind â‰ˆ The vocabulary that replaces â€œPackageFormerâ€.
      (â‰ 'kind 'string-please)

      ;; :waist â‰ˆ The division between parameters and remaining elements.
      (â‰ 'waist)

      ;; :level â‰ˆ Either 'inc or 'dec, for increment or decrementing the level.
      (â‰ 'level nil ;; 'string-please
         '((let* ((lvl (package-former-level self))
                  (toLevel (lambda (n) (s-join "" (-concat
                        (-repeat n "Level.suc (") (list "Level.zero") (-repeat n ")")))))
                 (subs `("" "â‚" "â‚‚" "â‚ƒ" "â‚„" "â‚…" "â‚†" "â‚‡" "â‚ˆ" "â‚‰" ,(funcall toLevel 10)))
                 (here (-elem-index (s-trim lvl) subs)))

             (setq it
                   (if here

                       (pcase it
                         ('inc (nth (1+ here) subs))
                         ('dec (nth (1- here) subs)))

                     (pcase it
                       ('inc (format "Level.suc (%s)" lvl))
                       ('dec (s-join "suc" (cdr (s-split "suc" lvl :omit-nulls)))))))

             (unless it (setq it 'none)))))

      ;; :alter-elements â‰ˆ Access the typed name constituents list.
      ;; Perform *all* element alterations, in the left-to-right âŸ´ order; if any at all.
        (loop for ae in (reverse (mapcar #'cdr (--filter (equal ':alter-elements (car it)) alterations)))
              do
        (setq $ğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘ 
              (remove-duplicates (--filter it (funcall ae $ğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘ )) :test #'equal :from-end t)))
              ;; Filter in only the non-nil constituents & those not starting with â€œ--â€ & remove duplicates.
              ;; We do this each time, rather than at the end, since variationals
              ;; may loop over all possible elements and we do not want to consider
              ;; intermediary nils or duplicates.
        (setf (package-former-elements self) $ğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘ )

    ;; We've just formed a new PackageFormer, which can be modified, specialised, later on.
    (add-to-list 'package-formers (cons $ğ‘›ğ‘ğ‘šğ‘’ self))
    (when show-it (show-package-former self))))
#+END_SRC

** ~load-700-comments~ and ~lisp~ blocks
   :PROPERTIES:
   :CUSTOM_ID: ~load-700-comments~-and-~lisp~-blocks
   :END:

   We already two global lists ---for our loaded PackageFormers and varitionals
   declarared--- we need two additional globals: One for the contents of 700-comments,
   primarily for basic efficiency, and the other to port whatever is within
   700-comments but is not 700-syntax. The latter is for when we want definitions
   or generalised variables to be accessible in /both/ 700-comments and the
   surrounding script. Which is achieved since the matter is exported to
   the generated file in the Elisp stage, then imported at the Agda level.

   However, since content to be ported may occur between PackageFormer definitions
   and instance declarations, we need to remember the position of items that are ported.
   The simplest thing to do is simply place items for porting into the package-formers
   list ---then take care to check if an item is for porting or not when printing
   PackageFormers to a generated file.

#+BEGIN_SRC emacs-lisp  :tangle yes
(defvar 700-comments nil
  "The contents of the 700-comments.

   If this variable does not change, we short-circut all processing.
  ")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
;; ("^\\\\begin{lisp}" . "^\\\\end{lisp}"))

(cl-defun load-700-comments ()
  "Parse comments of the form â€œ{-700 â‹¯ -}â€ and add all PackageFormer declarations
   to the â€˜package-formersâ€™ list and all instantations to the
   â€˜instantiations-remainingâ€™ list.

   We also execute any valid Lisp code in â€œ{-lisp -}â€ comments;
   which may contain an arbitrary number of Lisp forms ---a â€˜prognâ€™ is auto provided.
   Lisp is executed before any 700-comments are; which is preferable
   due to Lisp's dynamic scope.
  "
  (interactive)

  ;; First, let's run all the lisp. We enclose each in a progn in-case the user
  ;; has multiple forms in a single lisp-block.
  (loop for (lispstart . lispend) in '(("^\{-lisp" . "^-\}"))
        do (loop for lispstr in (buffer-substring-delimited-whole-buffer lispstart lispend)
                 do (eval (car (read-from-string (format "(progn %s)" lispstr))))))

  ;; For now, â€˜itemâ€™ is a PackageFormer, instantiation declaration, or other Agda code.
  (let (item lines 700-cmnts)

    ;; Catenate all 700-comments into a single string.
    (setq 700-cmnts
          (s-join "\n" (buffer-substring-delimited-whole-buffer "^\{-700" "^-\}")))
    ;; (setq 700-cmnts (append 700-cmnts
    ;;                         (s-join "\n" (buffer-substring-delimited-whole-buffer "700}" "end"))))

    (if (equal 700-comments 700-cmnts)

        (message "700-comments Unchanged.")

      ;; Update global.
      (setq 700-comments 700-cmnts)

      ;; View comments as a sequence of lines, ignore empty lines
      ;; ---which are not in our grammar.
      (setq lines (--remove (s-blank? (s-collapse-whitespace it)) (s-lines 700-comments)))

      ;; Traverse the 700-comments:
      ;; â© Skip comments; lines starting with â€œ-- â€.
      ;; â© If we see a â€œğ’±-lhs = rhsâ€ equation, then load it as a variational.
      ;; â© If we view a â€œlhs = rhsâ€ equation, then load it as an instance delcaration.
      ;; â© If we view a PackageFormer declaration, then load it into our
      ;;   package-formers list.
      (while lines
        (setq item (car lines))

        (if (not (s-blank? (s-shared-start "-- " (s-trim item))))
            (setq lines (cdr lines))

          (if (not (s-blank? (s-shared-start "ğ’±-" item)))
              (progn (load-variational item) (setq lines (cdr lines)))

            (if (s-contains? " = " item)
                (progn (load-instance-declaration item) (setq lines (cdr lines)))

              ;; Else we have a PackageFormer declaration
              ;; and other possiblly-non-700 items.
              (setq item (get-children "PackageFormer" lines))
              ;; port non-700 items to generated file
              (push (cons 'porting (s-join "\n" (car item))) package-formers)
                    ;; acknowledge PackageFormer declaration, if any
                    (when (cadr item) (load-package-former (cadr item)))
                    ;; Update lines to be the unconsidered porition
                    ;; of the wild comments.
                    (setq lines (caddr item))))))

        (message "Finished parsing 700-comments."))))
#+END_SRC

# Works, but hidden out from HTML output.
#
:Neato:
Let's test this out on our sample input file, ~Testing.agda~.

#+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
(let (package-formers
      700-comments
      instantiations-remaining)

  (find-file "Testing.agda")
  (load-700-comments)
  (switch-to-buffer "PackageFormer.org")

  (s-join "\n\n"
      (list (s-trim 700-comments)
        (pp package-formers) (pp instantiations-remaining)))
)
#+END_SRC

#+RESULTS:
#+begin_src results-agda
-- The next two lines are not 700-syntax and so are ported over to the generated file.
variable
   â„“ : Level

PackageFormer MonoidP : Setâ‚ where
    Carrier : Set
    _â¨¾_     : Carrier â†’ Carrier â†’ Carrier
    Id      : Carrier
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x

PackageFormer M-Set : Setâ‚ where
   Scalar  : Set
   Vector  : Set
   _Â·_     : Scalar â†’ Vector â†’ Vector
   ğŸ™       : Scalar
   _Ã—_     : Scalar â†’ Scalar â†’ Scalar
   leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹
   assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)

-- Gives error that ğ’±-doit is not defined (à¸‡à² _à² )à¸‡
-- Whoops   =  MonoidP doit


-- Variational with empty right hand side.
ğ’±-identity =
MonoidPâ±áµˆ = MonoidP identity

-- No variational clauses needed!
MonoidPâ°  = MonoidP

-- Identity of composition âŸ´
MonoidPá¶œ = MonoidP âŸ´

-- Operationally: Pf âŸ´ v  â‰ˆ  Pf v âŸ´  â‰ˆ  Pf v

-- â€œâŸ´â€ is just forwards composition: We â€˜threadâ€™ the Pf through the compositions váµ¢ in order.



-- ğ’±-whoops              = :kind recorder :waist-strings ("field")

ğ’±-record                 = :kind record :waist-strings ("field")
ğ’±-typeclass-attempt      = :kind record :waist-strings ("field") :waist 2
ğ’±-typeclassâ‚‚             = :kind record :waist-strings ("field") :waist 2 :level dec
ğ’±-typeclass height level = record âŸ´ :waist height :level level

MonoidTâ‚ƒ   =  MonoidP record âŸ´ :waist 3 :level dec
MonoidTâ‚‚   =  MonoidP typeclassâ‚‚ âŸ´ :waist-strings ("private" "extra : Setâ‚" "extra = Set" "field")
MonoidTâ‚„   =  MonoidP typeclass :height 4 :level 'dec


M-Set-Record = M-Set record
M-Set-Typeclassâ‚ƒ = M-Set-Record typeclass :height 3 :level 'dec



-- First one is intensionally erroenous attempt.
ğ’±-primed-attempt = :alter-elements (lambda (fs) (mapcar (lambda (f) (map-name (concat name "â€²") f)) fs))

ğ’±-primedâ‚—â‚‘â‚œ = :alter-elements (lambda (fs) (-as-> (-unzip (--zip-with `(,other  ,(format "let %s = %s in " (get-name it) (get-name other))) fs (--map (map-name (concat name "â€²") it) fs))) yup (--zip-with (map-type (concat (s-join "" it) type) other) (-inits (cadr yup)) (car yup))))

-- M-Setâ€²-attempt = M-Set record âŸ´ primed-attempt

MonoidR    =  MonoidP record
MonoidRâ€²   =  MonoidP record âŸ´ primedâ‚—â‚‘â‚œ
MonoidRâ€³   =  MonoidR primedâ‚—â‚‘â‚œ

-- Operationally: Pf vâ‚€ âŸ´ â‹¯ âŸ´ vâ‚™ â‰ˆ ((Pf vâ‚€) vâ‚) â‹¯) vâ‚™
-- Note: In the concrete syntax, such parenthisation is not permitted.



ğ’±-mapâ‚€ elements = :alter-elements (lambda (fs) (-as-> (-unzip (--zip-with `(,other  ,(format "let %s = %s in " (get-name it) (get-name other))) fs (mapcar elements fs))) yup (--zip-with (map-type (concat (s-join "" it) type) other) (-inits (cadr yup)) (car yup))))

Monoidâ‚˜ = MonoidR mapâ‚€ :elements (lambda (f) (make-tn (concat (get-name f) "â‚˜") (get-type f)))

-- Note the prime on the rhs. MA: Maybe avoid this?
ğ’±-renameâ‚€ elements = mapâ‚€ :elements 'elements

ğ’±-renameâ‚ elements = mapâ‚€ :elements (lambda (f) (make-tn (rename-mixfix elements (get-name f)) (get-type f)))

Monoidâ‚™ = MonoidR renameâ‚ :elements (lambda (name) (concat name "â‚™"))


MRâ€² = M-Set record âŸ´ primer


MRâ‚â‚‹â‚‚    = M-Set record âŸ´ decorated :by "â‚" âŸ´ decorated :by "â‚‚"
the-MR   = M-Set record âŸ´ co-decorated :by "the-"


MR-oh  = M-Set record âŸ´ rename :elements (lambda (name) (pcase name ("Scalar" "S") (x x)))


MRâ‚œâ‚’ = M-Set record âŸ´ renaming :by "Scalar to S; Vector to V; Â· to nice"
MRâ‚œâ‚’_ = M-Set record âŸ´ renaming_ :by "Scalar to S; Vector to V; _Â·_ to _nice_"
NearMonoid = M-Set record âŸ´ renaming :by "Scalar to Carrier; Vector to Carrier; Â· to Ã—"


NearMonoidÂ¹ = M-Set record âŸ´ single-sorted :with-sort "Carrier"


ğ’±-empty-module = :kind module :level none :waist 999
Neato = M-Set empty-module


M-Set-R = M-Set record
M-Set-Râ‚ = M-Set-R open :with (lambda (x) (concat x "â‚"))
M-Set-Râ€² = M-Set-R open-with :decoration "â€²"


ğ’±-sorts = generated :by (lambda (f) (s-contains? "Set" (target (get-type f))))

M-Set-Sorts = M-Set record âŸ´ sorts


MonoidSignature = M-Set record âŸ´ generated :by (lambda (f) (and (s-contains? "Scalar" f) (not (s-contains? "Vector" f))))


MonSig = M-Set record âŸ´ signature


Hom  = M-Set-R hom
HomÂ² = M-Set-R hom âŸ´ renaming :by "mapâ‚ to scalar; pres-ğŸ™ to unity"

(("HomÂ²" . #s(package-former "HomÂ² = M-Set-R hom âŸ´ renaming :by \"mapâ‚ to scalar; pres-ğŸ™ to unity\"" "record" "HomÂ²" "â‚" 2
                             ("open M-Set-R  Src" "open M-Set-Râ€² Tgt" "field")
                             3
                             ("Src : M-Set-R" "Tgt : M-Set-R" "scalar : Scalar â†’ Scalarâ€²" "mapâ‚‚ : Vector â†’ Vectorâ€²" "pres-Â· : {xâ‚ : Scalar} â†’ {xâ‚‚ : Vector} â†’   mapâ‚‚ (_Â·_ xâ‚ xâ‚‚)   â‰¡   _Â·â€²_ (scalar xâ‚) (mapâ‚‚ xâ‚‚)" "unity : scalar (ğŸ™ )   â‰¡   ğŸ™â€²" "pres-Ã— : {xâ‚ : Scalar} â†’ {xâ‚ : Scalar} â†’   scalar (_Ã—_ xâ‚ xâ‚)   â‰¡   _Ã—â€²_ (scalar xâ‚) (scalar xâ‚)")))
 ("Hom" . #s(package-former "Hom  = M-Set-R hom" "record" "Hom" "â‚" 2
                            ("open M-Set-R  Src" "open M-Set-Râ€² Tgt" "field")
                            3
                            ("Src : M-Set-R" "Tgt : M-Set-R" "mapâ‚ : Scalar â†’ Scalarâ€²" "mapâ‚‚ : Vector â†’ Vectorâ€²" "pres-Â· : {xâ‚ : Scalar} â†’ {xâ‚‚ : Vector} â†’   mapâ‚‚ (_Â·_ xâ‚ xâ‚‚)   â‰¡   _Â·â€²_ (mapâ‚ xâ‚) (mapâ‚‚ xâ‚‚)" "pres-ğŸ™ : mapâ‚ (ğŸ™ )   â‰¡   ğŸ™â€²" "pres-Ã— : {xâ‚ : Scalar} â†’ {xâ‚ : Scalar} â†’   mapâ‚ (_Ã—_ xâ‚ xâ‚)   â‰¡   _Ã—â€²_ (mapâ‚ xâ‚) (mapâ‚ xâ‚)")))
 ("MonSig" . #s(package-former "MonSig = M-Set record âŸ´ signature" "record" "MonSig" "â‚" 0
                               ("field")
                               3
                               ("Scalar  : Set" "Vector  : Set" "_Â·_     : Scalar â†’ Vector â†’ Vector" "ğŸ™       : Scalar" "_Ã—_     : Scalar â†’ Scalar â†’ Scalar")))
 ("MonoidSignature" . #s(package-former "MonoidSignature = M-Set record âŸ´ generated :by (lambda (f) (and (s-contains? \"Scalar\" f) (not (s-contains? \"Vector\" f))))" "record" "MonoidSignature" "â‚" 0
                                        ("field")
                                        3
                                        ("Scalar  : Set" "ğŸ™       : Scalar" "_Ã—_     : Scalar â†’ Scalar â†’ Scalar")))
 ("M-Set-Sorts" . #s(package-former "M-Set-Sorts = M-Set record âŸ´ sorts" "record" "M-Set-Sorts" "â‚" 0
                                    ("field")
                                    3
                                    ("Scalar  : Set" "Vector  : Set")))
 ("M-Set-Râ€²" . #s(package-former "M-Set-Râ€² = M-Set-R open-with :decoration \"â€²\"" "module" "M-Set-Râ€²" none 1
                                 ("")
                                 3
                                 ("â„› : M-Set-R" "open M-Set-R â„› public" "  renaming" "    ( Scalar to Scalarâ€²\n       ; Vector to Vectorâ€²\n       ; _Â·_ to _Â·â€²_\n       ; ğŸ™ to ğŸ™â€²\n       ; _Ã—_ to _Ã—â€²_\n       ; leftId to leftIdâ€²\n       ; assoc to assocâ€²\n       )")))
 ("M-Set-Râ‚" . #s(package-former "M-Set-Râ‚ = M-Set-R open :with (lambda (x) (concat x \"â‚\"))" "module" "M-Set-Râ‚" none 1
                                 ("")
                                 3
                                 ("â„› : M-Set-R" "open M-Set-R â„› public" "  renaming" "    ( Scalar to Scalarâ‚\n       ; Vector to Vectorâ‚\n       ; _Â·_ to _Â·â‚_\n       ; ğŸ™ to ğŸ™â‚\n       ; _Ã—_ to _Ã—â‚_\n       ; leftId to leftIdâ‚\n       ; assoc to assocâ‚\n       )")))
 ("M-Set-R" . #s(package-former "M-Set-R = M-Set record" "record" "M-Set-R" "â‚" 0
                                ("field")
                                3
                                ("Scalar  : Set" "Vector  : Set" "_Â·_     : Scalar â†’ Vector â†’ Vector" "ğŸ™       : Scalar" "_Ã—_     : Scalar â†’ Scalar â†’ Scalar" "leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹" "assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)")))
 ("Neato" . #s(package-former "Neato = M-Set empty-module" "module" "Neato" none 999 nil 3
                              ("Scalar  : Set" "Vector  : Set" "_Â·_     : Scalar â†’ Vector â†’ Vector" "ğŸ™       : Scalar" "_Ã—_     : Scalar â†’ Scalar â†’ Scalar" "leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹" "assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)")))
 ("NearMonoidÂ¹" . #s(package-former "NearMonoidÂ¹ = M-Set record âŸ´ single-sorted :with-sort \"Carrier\"" "record" "NearMonoidÂ¹" "â‚" 0
                                    ("field")
                                    3
                                    ("Carrier : Set" "_Â·_ : Carrier â†’ Carrier â†’ Carrier" "ğŸ™ : Carrier" "_Ã—_ : Carrier â†’ Carrier â†’ Carrier" "leftId : {ğ“‹ : Carrier}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹" "assoc : {a b : Carrier} {ğ“‹ : Carrier} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)")))
 ("NearMonoid" . #s(package-former "NearMonoid = M-Set record âŸ´ renaming :by \"Scalar to Carrier; Vector to Carrier; Â· to Ã—\"" "record" "NearMonoid" "â‚" 0
                                   ("field")
                                   3
                                   ("Carrier : Set" "_Ã—_ : Carrier â†’ Carrier â†’ Carrier" "ğŸ™ : Carrier" "leftId : {ğ“‹ : Carrier}  â†’  ğŸ™ Ã— ğ“‹  â‰¡  ğ“‹" "assoc : {a b : Carrier} {ğ“‹ : Carrier} â†’ (a Ã— b) Ã— ğ“‹  â‰¡  a Ã— (b Ã— ğ“‹)")))
 ("MRâ‚œâ‚’_" . #s(package-former "MRâ‚œâ‚’_ = M-Set record âŸ´ renaming_ :by \"Scalar to S; Vector to V; _Â·_ to _nice_\"" "record" "MRâ‚œâ‚’_" "â‚" 0
                              ("field")
                              3
                              ("S : Set" "V : Set" "_nice_ : S â†’ V â†’ V" "ğŸ™ : S" "_Ã—_ : S â†’ S â†’ S" "leftId : {ğ“‹ : V}  â†’  ğŸ™ nice ğ“‹  â‰¡  ğ“‹" "assoc : {a b : S} {ğ“‹ : V} â†’ (a Ã— b) nice ğ“‹  â‰¡  a nice (b nice ğ“‹)")))
 ("MRâ‚œâ‚’" . #s(package-former "MRâ‚œâ‚’ = M-Set record âŸ´ renaming :by \"Scalar to S; Vector to V; Â· to nice\"" "record" "MRâ‚œâ‚’" "â‚" 0
                             ("field")
                             3
                             ("S : Set" "V : Set" "_nice_ : S â†’ V â†’ V" "ğŸ™ : S" "_Ã—_ : S â†’ S â†’ S" "leftId : {ğ“‹ : V}  â†’  ğŸ™ nice ğ“‹  â‰¡  ğ“‹" "assoc : {a b : S} {ğ“‹ : V} â†’ (a Ã— b) nice ğ“‹  â‰¡  a nice (b nice ğ“‹)")))
 ("MR-oh" . #s(package-former "MR-oh  = M-Set record âŸ´ rename :elements (lambda (name) (pcase name (\"Scalar\" \"S\") (x x)))" "record" "MR-oh" "â‚" 0
                              ("field")
                              3
                              ("S : Set" "Vector : Set" "_Â·_ : S â†’ Vector â†’ Vector" "ğŸ™ : S" "_Ã—_ : S â†’ S â†’ S" "leftId : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹" "assoc : {a b : S} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)")))
 ("the-MR" . #s(package-former "the-MR   = M-Set record âŸ´ co-decorated :by \"the-\"" "record" "the-MR" "â‚" 0
                               ("field")
                               3
                               ("the-Scalar : Set" "the-Vector : Set" "_the-Â·_ : the-Scalar â†’ the-Vector â†’ the-Vector" "the-ğŸ™ : the-Scalar" "_the-Ã—_ : the-Scalar â†’ the-Scalar â†’ the-Scalar" "the-leftId : {ğ“‹ : the-Vector}  â†’  the-ğŸ™ the-Â· ğ“‹  â‰¡  ğ“‹" "the-assoc : {a b : the-Scalar} {ğ“‹ : the-Vector} â†’ (a the-Ã— b) the-Â· ğ“‹  â‰¡  a the-Â· (b the-Â· ğ“‹)")))
 ("MRâ‚â‚‹â‚‚" . #s(package-former "MRâ‚â‚‹â‚‚    = M-Set record âŸ´ decorated :by \"â‚\" âŸ´ decorated :by \"â‚‚\"" "record" "MRâ‚â‚‹â‚‚" "â‚" 0
                              ("field")
                              3
                              ("Scalarâ‚â‚‚ : Set" "Vectorâ‚â‚‚ : Set" "_Â·â‚â‚‚_ : Scalarâ‚â‚‚ â†’ Vectorâ‚â‚‚ â†’ Vectorâ‚â‚‚" "ğŸ™â‚â‚‚ : Scalarâ‚â‚‚" "_Ã—â‚â‚‚_ : Scalarâ‚â‚‚ â†’ Scalarâ‚â‚‚ â†’ Scalarâ‚â‚‚" "leftIdâ‚â‚‚ : {ğ“‹ : Vectorâ‚â‚‚}  â†’  ğŸ™â‚â‚‚ Â·â‚â‚‚ ğ“‹  â‰¡  ğ“‹" "assocâ‚â‚‚ : {a b : Scalarâ‚â‚‚} {ğ“‹ : Vectorâ‚â‚‚} â†’ (a Ã—â‚â‚‚ b) Â·â‚â‚‚ ğ“‹  â‰¡  a Â·â‚â‚‚ (b Â·â‚â‚‚ ğ“‹)")))
 ("MRâ€²" . #s(package-former "MRâ€² = M-Set record âŸ´ primer" "record" "MRâ€²" "â‚" 0
                            ("field")
                            3
                            ("Scalarâ€²  : Set" "Vectorâ€²  : Set" "_Â·â€²_     : Scalarâ€² â†’ Vectorâ€² â†’ Vectorâ€²" "ğŸ™â€²       : Scalarâ€²" "_Ã—â€²_     : Scalarâ€² â†’ Scalarâ€² â†’ Scalarâ€²" "leftIdâ€²  : {ğ“‹ : Vectorâ€²}  â†’  ğŸ™â€² Â·â€² ğ“‹  â‰¡  ğ“‹" "assocâ€²   : {a b : Scalarâ€²} {ğ“‹ : Vectorâ€²} â†’ (a Ã—â€² b) Â·â€² ğ“‹  â‰¡  a Â·â€² (b Â·â€² ğ“‹)")))
 ("Monoidâ‚™" . #s(package-former "Monoidâ‚™ = MonoidR renameâ‚ :elements (lambda (name) (concat name \"â‚™\"))" "record" "Monoidâ‚™" "â‚" 0
                                ("field")
                                4
                                ("Carrierâ‚™ : Set" "_â¨¾â‚™_ : let Carrier = Carrierâ‚™ in Carrier â†’ Carrier â†’ Carrier" "Idâ‚™ : let Carrier = Carrierâ‚™ in let _â¨¾_ = _â¨¾â‚™_ in Carrier" "assocâ‚™ : let Carrier = Carrierâ‚™ in let _â¨¾_ = _â¨¾â‚™_ in let Id = Idâ‚™ in âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)" "leftIdâ‚™ : let Carrier = Carrierâ‚™ in let _â¨¾_ = _â¨¾â‚™_ in let Id = Idâ‚™ in let assoc = assocâ‚™ in âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x" "rightIdâ‚™ : let Carrier = Carrierâ‚™ in let _â¨¾_ = _â¨¾â‚™_ in let Id = Idâ‚™ in let assoc = assocâ‚™ in let leftId = leftIdâ‚™ in âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x")))
 ("Monoidâ‚˜" . #s(package-former "Monoidâ‚˜ = MonoidR mapâ‚€ :elements (lambda (f) (make-tn (concat (get-name f) \"â‚˜\") (get-type f)))" "record" "Monoidâ‚˜" "â‚" 0
                                ("field")
                                4
                                ("Carrierâ‚˜ : Set" "_â¨¾_â‚˜ : let Carrier = Carrierâ‚˜ in Carrier â†’ Carrier â†’ Carrier" "Idâ‚˜ : let Carrier = Carrierâ‚˜ in let _â¨¾_ = _â¨¾_â‚˜ in Carrier" "assocâ‚˜ : let Carrier = Carrierâ‚˜ in let _â¨¾_ = _â¨¾_â‚˜ in let Id = Idâ‚˜ in âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)" "leftIdâ‚˜ : let Carrier = Carrierâ‚˜ in let _â¨¾_ = _â¨¾_â‚˜ in let Id = Idâ‚˜ in let assoc = assocâ‚˜ in âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x" "rightIdâ‚˜ : let Carrier = Carrierâ‚˜ in let _â¨¾_ = _â¨¾_â‚˜ in let Id = Idâ‚˜ in let assoc = assocâ‚˜ in let leftId = leftIdâ‚˜ in âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x")))
 ("MonoidRâ€³" . #s(package-former "MonoidRâ€³   =  MonoidR primedâ‚—â‚‘â‚œ" "record" "MonoidRâ€³" "â‚" 0
                                 ("field")
                                 4
                                 ("Carrierâ€² : Set" "_â¨¾â€²_ : let Carrier = Carrierâ€² in Carrier â†’ Carrier â†’ Carrier" "Idâ€² : let Carrier = Carrierâ€² in let _â¨¾_ = _â¨¾â€²_ in Carrier" "assocâ€² : let Carrier = Carrierâ€² in let _â¨¾_ = _â¨¾â€²_ in let Id = Idâ€² in âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)" "leftIdâ€² : let Carrier = Carrierâ€² in let _â¨¾_ = _â¨¾â€²_ in let Id = Idâ€² in let assoc = assocâ€² in âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x" "rightIdâ€² : let Carrier = Carrierâ€² in let _â¨¾_ = _â¨¾â€²_ in let Id = Idâ€² in let assoc = assocâ€² in let leftId = leftIdâ€² in âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x")))
 ("MonoidRâ€²" . #s(package-former "MonoidRâ€²   =  MonoidP record âŸ´ primedâ‚—â‚‘â‚œ" "record" "MonoidRâ€²" "â‚" 0
                                 ("field")
                                 4
                                 ("Carrierâ€² : Set" "_â¨¾â€²_ : let Carrier = Carrierâ€² in Carrier â†’ Carrier â†’ Carrier" "Idâ€² : let Carrier = Carrierâ€² in let _â¨¾_ = _â¨¾â€²_ in Carrier" "assocâ€² : let Carrier = Carrierâ€² in let _â¨¾_ = _â¨¾â€²_ in let Id = Idâ€² in âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)" "leftIdâ€² : let Carrier = Carrierâ€² in let _â¨¾_ = _â¨¾â€²_ in let Id = Idâ€² in let assoc = assocâ€² in âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x" "rightIdâ€² : let Carrier = Carrierâ€² in let _â¨¾_ = _â¨¾â€²_ in let Id = Idâ€² in let assoc = assocâ€² in let leftId = leftIdâ€² in âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x")))
 ("MonoidR" . #s(package-former "MonoidR    =  MonoidP record" "record" "MonoidR" "â‚" 0
                                ("field")
                                4
                                ("Carrier : Set" "_â¨¾_     : Carrier â†’ Carrier â†’ Carrier" "Id      : Carrier" "assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)" "leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x" "rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x")))
 ("M-Set-Typeclassâ‚ƒ" . #s(package-former "M-Set-Typeclassâ‚ƒ = M-Set-Record typeclass :height 3 :level 'dec" "record" "M-Set-Typeclassâ‚ƒ" "" 3
                                         ("field")
                                         3
                                         ("Scalar  : Set" "Vector  : Set" "_Â·_     : Scalar â†’ Vector â†’ Vector" "ğŸ™       : Scalar" "_Ã—_     : Scalar â†’ Scalar â†’ Scalar" "leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹" "assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)")))
 ("M-Set-Record" . #s(package-former "M-Set-Record = M-Set record" "record" "M-Set-Record" "â‚" 0
                                     ("field")
                                     3
                                     ("Scalar  : Set" "Vector  : Set" "_Â·_     : Scalar â†’ Vector â†’ Vector" "ğŸ™       : Scalar" "_Ã—_     : Scalar â†’ Scalar â†’ Scalar" "leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹" "assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)")))
 ("MonoidTâ‚„" . #s(package-former "MonoidTâ‚„   =  MonoidP typeclass :height 4 :level 'dec" "record" "MonoidTâ‚„" "" 4
                                 ("field")
                                 4
                                 ("Carrier : Set" "_â¨¾_     : Carrier â†’ Carrier â†’ Carrier" "Id      : Carrier" "assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)" "leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x" "rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x")))
 ("MonoidTâ‚‚" . #s(package-former "MonoidTâ‚‚   =  MonoidP typeclassâ‚‚ âŸ´ :waist-strings (\"private\" \"extra : Setâ‚\" \"extra = Set\" \"field\")" "record" "MonoidTâ‚‚" "" 2
                                 ("private" "extra : Setâ‚" "extra = Set" "field")
                                 4
                                 ("Carrier : Set" "_â¨¾_     : Carrier â†’ Carrier â†’ Carrier" "Id      : Carrier" "assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)" "leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x" "rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x")))
 ("MonoidTâ‚ƒ" . #s(package-former "MonoidTâ‚ƒ   =  MonoidP record âŸ´ :waist 3 :level dec" "record" "MonoidTâ‚ƒ" "" 3
                                 ("field")
                                 4
                                 ("Carrier : Set" "_â¨¾_     : Carrier â†’ Carrier â†’ Carrier" "Id      : Carrier" "assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)" "leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x" "rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x")))
 ("MonoidPá¶œ" . #s(package-former "MonoidPá¶œ = MonoidP âŸ´" "PackageFormer" "MonoidPá¶œ" "â‚" 0 nil 4
                                 ("Carrier : Set" "_â¨¾_     : Carrier â†’ Carrier â†’ Carrier" "Id      : Carrier" "assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)" "leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x" "rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x")))
 ("MonoidPâ°" . #s(package-former "MonoidPâ°  = MonoidP" "PackageFormer" "MonoidPâ°" "â‚" 0 nil 4
                                 ("Carrier : Set" "_â¨¾_     : Carrier â†’ Carrier â†’ Carrier" "Id      : Carrier" "assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)" "leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x" "rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x")))
 ("MonoidPâ±áµˆ" . #s(package-former "MonoidPâ±áµˆ = MonoidP identity" "PackageFormer" "MonoidPâ±áµˆ" "â‚" 0 nil 4
                                  ("Carrier : Set" "_â¨¾_     : Carrier â†’ Carrier â†’ Carrier" "Id      : Carrier" "assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)" "leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x" "rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x")))
 ("M-Set" . #s(package-former nil "PackageFormer" "M-Set" "â‚" 0 nil 3
                              ("Scalar  : Set" "Vector  : Set" "_Â·_     : Scalar â†’ Vector â†’ Vector" "ğŸ™       : Scalar" "_Ã—_     : Scalar â†’ Scalar â†’ Scalar" "leftId  : {ğ“‹ : Vector}  â†’  ğŸ™ Â· ğ“‹  â‰¡  ğ“‹" "assoc   : {a b : Scalar} {ğ“‹ : Vector} â†’ (a Ã— b) Â· ğ“‹  â‰¡  a Â· (b Â· ğ“‹)")))
 (porting . "")
 ("MonoidP" . #s(package-former nil "PackageFormer" "MonoidP" "â‚" 0 nil 4
                                ("Carrier : Set" "_â¨¾_     : Carrier â†’ Carrier â†’ Carrier" "Id      : Carrier" "assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)" "leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x" "rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x")))
 (porting . "variable\n   â„“ : Level"))


nil
#+end_src
:End:

* Emacs Interface
  :PROPERTIES:
  :CUSTOM_ID: Emacs-Interface
  :END:

Let's finally declare the variable for keeping track of whether 700-syntactical
should be coloured or not. Below we use a particular set of default colours.
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar 700-highlighting t
  "Should 700 syntactical items be coloured?

   â© Yellow for PackageFormer content.
   â© Red for delimiters â€œ700â€ and â€œlispâ€.
   â© Green for names of variationals.
  ")
#+END_SRC

** Tooltips
   :PROPERTIES:
   :CUSTOM_ID: Tooltips
   :END:

   It gets rather tedious to jump to the generated files to see the elaborations
   of 700-syntactical items. As such, let's tie existing occurrences of a PackageFormer's
   name to its elaboration.

 #+BEGIN_SRC emacs-lisp :tangle yes
;; Nearly instantaneous display of tooltips.
(setq tooltip-delay 0)

;; Give user 30 seconds before tooltip automatically disappears.
(setq tooltip-hide-delay 30)

(defun tooltipify (phrase notification)
  "Add a tooltip to every instance of â€œphraseâ€ to show â€œnotificationâ€.

   We only add tooltips to â€œphraseâ€ as a standalone word, not as a subword.

  Useful info on tooltips:
  http://kitchingroup.cheme.cmu.edu/blog/2013/04/12/Tool-tips-on-text-in-Emacs/
  https://www.gnu.org/software/emacs/manual/html_node/elisp/Changing-Properties.html
  http://kitchingroup.cheme.cmu.edu/blog/2016/03/16/Getting-graphical-feedback-as-tooltips-in-Emacs/
  https://stackoverflow.com/questions/293853/defining-new-tooltips-in-emacs

  The second resource above shows how to alter the phrase's font to indicate that it has
  a tooltip. It is not desirable for us, since we want to add onto Agda's coluring.
  "
  (should (stringp phrase))
  (should (stringp notification))
  (save-excursion  ;; Return cursour to current-point afterwards.
    (goto-char 1)
    ;; The \b are for empty-string at the start or end of a word.
    (while (search-forward-regexp (format "\\b%s\\b" phrase) (point-max) t)
      (put-text-property (match-beginning 0) (match-end 0) 'help-echo (s-trim notification)))))
 #+END_SRC

 New textual occurrences of a name obtain tooltips when ~C-c C-l~ is invoked.
** Advising our Beloved ~C-c C-l~
   :PROPERTIES:
   :CUSTOM_ID: Advising-our-Beloved-~C-c-C-l~
   :END:

 Let's give the current buffer access to the location of the generated file.
 #+BEGIN_SRC emacs-lisp  :tangle yes
(defun insert-generated-import (name-of-generated-file)
  "In the current file, find the top-most module declaration
   then insert an import of the generated file.
  "
  (interactive)

  (save-excursion
    (beginning-of-buffer)
    (condition-case the-err
        ;; attemptClause:
        (re-search-forward (concat "open import " name-of-generated-file))
      ;; recoveryBody:
      (error ;; (message-box (format "%s" the-err))
       (re-search-forward "\\(module.*\\)")
       (replace-match (concat "\\1\nopen import " name-of-generated-file))))))
 #+END_SRC

 The aim is to process test enclosed in ~{-700 â‹¯ -}~ comments,
 produce legitimate Agda from that, and ensure the generated Agda is accessible to the
 current buffer automatically.

 #+BEGIN_SRC emacs-lisp :tangle yes
(defun reify-package-formers (orig-fun &rest args)
  (interactive)

  (let (generated-file-name
        printed-pfs
        (parent-imports (extract-imports)))

    ;; Sometimes we may want the full name due to files being in a nested
    ;; directory hierarchy: (file-name-sans-extension buffer-file-name)
    (setq generated-file-name
          (concat(file-name-sans-extension (buffer-name))
                 "_Generated"))

    ;; Load variationals, PackageFormers, instantiations, and porting list.
    ;; Setting the following to nil each time is not ideal.
    (setq	variationals (-take-last â™¯standard-variationals variationals) ;; take last n items, those being exported into the .el.
            package-formers           nil
            700-comments              nil)

    (load-700-comments)

    (with-temp-buffer
      (beginning-of-buffer)

      ;; Copy/paste imports from parent file.
      (insert (s-join "\n" `(
         "{- This file is generated ;; do not alter. -}\n"
         ,parent-imports
         "open import Level as Level"
         ,(format "module %s where " generated-file-name)
         )))

     ;; Print the package-formers
      (setq printed-pfs
            (--map
             (if (equal 'porting (car it)) (format "%s" (cdr it))
               (format
                (if (equal "PackageFormer" (package-former-kind (cdr it)))
                    (concat "{- Kind â€œPackageFormerâ€ does not correspond "
                            " to a concrete Agda type. \n%s -}")
                       "%s") (show-package-former (cdr it))))
             (reverse package-formers)))
      ;;
      (insert (s-join "\n\n\n" printed-pfs))
      ;; (setq package-formers nil) ;; So no accidental

      ;; Replace tabs with spaces
      (untabify (point-min) (point-max))

      (write-region (beginning-of-buffer) (end-of-buffer)
                    (concat generated-file-name ".agda")))

    (insert-generated-import generated-file-name))

  ;; Need to revert buffer to discard old colours.
  ;; (save-buffer) (revert-buffer t t t)

  ;; call agda2-load
  (apply orig-fun args)

  ;; Agda attaches â€œjump to definitionâ€ tooltips; we add to those.
  ;; For some reason we need a slight delay between when Agda is done checking
  ;; and when we can add on our tooltips.
  ;; Attach tooltips only for existing occurrences; update happens with C-c C-l.
  (sleep-for 0.5)
  (loop for (name . pf) in package-formers
        do (unless (equal 'porting name)
             (tooltipify name (show-package-former pf))))

  ;; Let's also add tooltips for the variationals & colour them.
  (loop for (v . docs) in variationals
        do (tooltipify (format "%s" v) docs)
        ;; For beauty, let's colour variational names green.
        ;; Only colour occurances that have a space before or after.
        (when 700-highlighting
          (highlight-phrase (format "[- \\| ]%s " v) 'hi-green)))

  (message "700 âˆ· All the best coding! (â€¢Ì€á´—â€¢Ì)Ùˆ"))

; Users can enable this feature if they're interested in using it; disbale it otherwise.
; (advice-add 'agda2-load :around #'reify-package-formers)
 #+END_SRC

 Personal note:
 Using ~(write-file "Generated.agda")~ means we make a file
 then the temporary buffer /visits/ the Agda file, which loads the
 Agda process therein, which is undesirable since it could leave
 Agda working on the buffer even after it has been killed!
 + This would necessiate calling ~(agda2-restart)~ afterwards.
 + Instead we write the whole region, without visiting the resuting file.

** Menu matter
   :PROPERTIES:
   :CUSTOM_ID: Menu-matter
   :END:
 Let's quickly add a menu bar that allows users to enable or disable using PackageFormer's;
 along with a brief help menu.

 {{{fold(The global map)}}}
 #+BEGIN_SRC emacs-lisp :tangle yes
(defvar 700-menu-bar (make-sparse-keymap "700 PackageFormers"))

(define-key global-map [menu-bar 700menu] (cons "700PackageFormers" 700-menu-bar))
 #+END_SRC
 {{{end-fold}}}

 {{{fold( Enabling the feature )}}}
 #+BEGIN_SRC emacs-lisp :tangle yes
(define-key 700-menu-bar [enable-package-formers]
  '(menu-item "Enable PackageFormer Generation" enable-package-formers))

(defun enable-package-formers ()
 (interactive)
 (advice-add 'agda2-load :around #'reify-package-formers)
 (message-box "C-c C-l now reifies â€œ700-commentsâ€ into legitimate Agda."))
 #+END_SRC
 {{{end-fold}}}

 {{{fold( Disabling the feature )}}}
 #+BEGIN_SRC emacs-lisp :tangle yes
(define-key 700-menu-bar [disable-package-formers]
  '(menu-item "Disable PackageFormer Generation" disable-package-formers))

(defun disable-package-formers ()
 (interactive)
 (advice-remove 'agda2-load #'reify-package-formers)
 (setq global-mode-string (remove "700 (â€¢Ì€á´—â€¢Ì)Ùˆ " global-mode-string))
  (message-box "C-c C-l now behaves as it always has."))
 #+END_SRC
 {{{end-fold}}}

 {{{fold( About menu )}}}
 #+BEGIN_SRC emacs-lisp :tangle yes
(define-key 700-menu-bar [package-formers-about]
  '(menu-item "About PackageFormers" package-formers-about))

(defun package-formers-about ()
 (interactive)
 (switch-to-buffer "*PackageFormer-About*") (insert
  " This is an editor extension prototyping â€œthe next 700 module systemsâ€ proposed research.

    An informal documentation, with examples, page can be found at
    https://alhassy.github.io/next-700-module-systems-proposal/PackageFormer.html

    The technical matter can be found at https://alhassy.github.io/next-700-module-systems-proposal/

    If you experience anything â€œgoing wrongâ€ or have any ideas for improvement,
    please contact Musa Al-hassy at alhassy@gmail.com; thank-you â™¥â€¿â™¥
  "))
 #+END_SRC
 {{{end-fold}}}

 {{{fold( Bare Bones Agda )}}}
 #+BEGIN_SRC emacs-lisp :tangle yes
(define-key 700-menu-bar [700-bare-bones]
  '(menu-item "Copy file with 700 annotations stripped away" 700-bare-bones))

(defun 700-bare-bones ()
 (interactive)

 (let* ((src (file-name-sans-extension (buffer-name)))
        (src-agda (format "%s.agda" src))
        (bare-agda (format "%s_Bare.agda" src)))
   (with-temp-buffer
     (insert-file-contents src-agda)
     (beginning-of-buffer)
       (re-search-forward (format "module %s" src))
       (replace-match (format "module %s_Bare" src))
     (loop for pre in '("^\{-lisp" "^\{-700")
      do
      (beginning-of-buffer)
      (buffer-substring-delimited-whole-buffer pre "^-\}"
           (lambda (sp ep)
             (save-excursion
             (goto-char (- sp 2))
             (push-mark ep)
             (setq mark-active t)
             (delete-region (- sp 2) ep)))))
     (write-file bare-agda))
     (message "%s_Bare.agda has been written." src)))
 #+END_SRC
 {{{end-fold}}}

 {{{fold( Menu of Defined 700 Contents )}}}
 #+BEGIN_SRC emacs-lisp :tangle yes
(define-key 700-menu-bar [show-variationals]
  '(menu-item "Show all registered variationals" show-variationals))

(defun show-variationals ()
 (interactive)
 (occur "ğ’±[ \\|-]"))

(define-key 700-menu-bar [show-pfs]
  '(menu-item "Show all concrete PackageFormers" show-pfs))

(defun show-pfs ()
 (interactive)
 (occur "PackageFormer .* where"))
 #+END_SRC
 {{{end-fold}}}

 {{{fold( Folding Away 700-Comments  )}}}
 #+BEGIN_SRC emacs-lisp :tangle yes
(define-key 700-menu-bar [fold-700-matter]
  '(menu-item "Toggle folding away â€œ700â€ and â€œlispâ€ blocks" fold-700-matter))

(defun fold-700-matter ()
 (interactive)
 (setq 700-folding (not 700-folding))
 (if 700-folding
     (message "C-c C-l will now fold away â€œ700â€ and â€œlispâ€ blocks. Press ENTER to unfold a block. ")
     (fold-this-unfold-all)
     (message "Blocks â€œ700â€ and â€œlispâ€ have been unfolded.")))
 #+END_SRC
 {{{end-fold}}}

 Let's pack these together into a minor mode.
 {{{fold( Minor mode )}}}
 #+BEGIN_SRC emacs-lisp :tangle yes
(define-minor-mode 700-mode
    "This is an editor extension prototyping â€œthe next 700 module systemsâ€ proposed research.

    An informal documentation, with examples, page can be found at
    https://alhassy.github.io/next-700-module-systems-proposal/PackageFormer.html

    The technical matter can be found at https://alhassy.github.io/next-700-module-systems-proposal/

    If you experience anything â€œgoing wrongâ€ or have any ideas for improvement,
    please contact Musa Al-hassy at alhassy@gmail.com; thank-you â™¥â€¿â™¥
  "
  :lighter " 700 (â€¢Ì€á´—â€¢Ì)Ùˆ" ;; Icon to display indicating the mode is enabled.
  :require 'foo

  ;; Toggle the menu bar
  ;; (define-key global-map [menu-bar 700menu] t)(not 700-mode))
  (define-key global-map [menu-bar 700menu] (and 700-mode (cons "700PackageFormers" 700-menu-bar)))

  (letf (( (symbol-function 'message-box) #'message))
  (if 700-mode
      ;; Initilisation
      (enable-package-formers)

      ;; Closing
      (disable-package-formers))))
 #+END_SRC
 {{{end-fold}}}

* Future Work
  :PROPERTIES:
  :CUSTOM_ID: Work
  :END:

Well, that was a lot of Lisp I had to learn ~(à¸‡à² _à² )à¸‡~

Hopefully the resulting prototype will be useful to others;
drop me a line if you're interested in this effort or have
any feedback or pointers!

#+begin_center org
â˜… â˜… â˜…
#+end_center

Below are some desirable features to work on.

#
# Check them off, rather than deleting them,
# to produce a â€˜tadaâ€™ list of features ;-)
#


   # + For now, arguments must be enclosed in parenthesis.
   #  - This is likely to be dropped in a future edition of the system.


+ [X] Colouring for 700-syntactical items.

+ [X] Tooltips

+ [ ] Some menu items are a bit buggy ---this is low-priority.

+ [ ] MA: WK: hiding â†¦ dropping

+ [ ] Use buffer-substring-delimited-whole-buffer to parse /multiple/
      700-comments!

+ [ ] Add a level component to an instance structure; reduce it if Carrier is a parameter and otherwise leave it alone.
      Instead, let the level of a PackageFormer denote the level of the typeclass instantiation, then with this in mind
      we increase the level component of an instance structure only for those variations that keep the carrier as a field.
      When we move to multi-sorted, as in Graphs, this issue will need to be revisited.

+ [X] Currently can only perform simple variational clauses; need to support complex clauses.

+ [X] Support for equations in PackageFormers: Easy, nothing new needed! Thank-you ~alter-elements~!

+ [ ]   Examples from the user-manual
        should be exported into an Agda file which is then easily checked;
        or the resulting generated code should be generated when export happens.

+ [ ] We can only perform â€œLHS = PF ğ“‹ğ’¸â€, do we also want stand-alone â€œPF ğ“‹ğ’¸â€?
      - Maybe not? Maybe it suffices to use, say, â€œ_ = PF ğ“‹ğ’¸â€?

   # TODO: Give an example making use of suffix-fields to â€˜extendâ€™ a packageformer with new fields. E.g., PackageFormer B = A extended-by cs ought to be valid but so should I = A vs extended-by cs which is amicable syntax for the instantation (A extended-by cs) vs. Should this automatically yield forgetful coercisions â€œIâ‡’Aâ€? For now, maybe yes by default and no if we use, say, fields instead of extended-by. There will be issues of coherency when we add items.

+ [X] Need to implement a *front-end* system to extend variational clauses.

+ [ ] The ~elements~ of a PackageFormer should be  an alist, ~'(name . type)~.
  - Maybe not, the front-end lets users treat them as strings, easily.
  - Maybe such a view is useful for the user? It is provided via ~get-name~ and ~get-type~.

+ [X] Refactor load-instantions function to make use of an ~alter~ field rather than overloading alter-fields in reify-instances.

+ [X] Refactor ~instantiate~ to make use of an ~instance~ structure, rather than 13 arguments.
      - In my defence, 13 arguments was because I was trying to find out what were the key ingredients
        necessary to form different variational presentations. It seems I only needed 5 ^_^

+ [ ] Why does â€˜buffer-substring-delimited-whole-bufferâ€™ return a list of strings? Why not join its result to simply return a list?

+ [X] Generated.agda needs to inherit all open/import declarations from parent.

+ [ ] Give an example PackageFormer with some definitions or derived constructs, then hoist-up your waist so that the non-defined items are ~module~ parameters.

+ [ ] ~B = cs âŸ¨+ A âŸ¨+ csâ€²~ where each cs is a single name-type declaration and the operation is left-associative, and A is an existing packageformer. This gives us a nice way to build a hierarchy. Note that since only A has a name, we may form a forgetful coercion Bâ‡’A automatically.
  E.g., ~Monoid = Type âŸ¨+ Pointed âŸ¨+ (Magma renaming (_âŠ•_ to _â¨¾_)) âŸ¨+ LeftUnital âŸ¨+ RightUnital âŸ¨+ assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)~ gives, automatically, ~Monoidâ‡’Type, Monoidâ‡’Pointed, Monoidâ‡’Magma, Monoidâ‡’LeftUnital, Magmaâ‡’RightUnital~ (â€¢Ì€á´—â€¢Ì)Ùˆ MA: To begin with, ignore the rename and work up the sequence one âŸ¨+ at a time.

+ [X] PF's should account for equations. For simplicity they become components of a record & module, but derived operations on datatypes.

+ [ ] Demonstrate how generative modules can be emulated.

+ [ ] For now, PackageFormer's have no other parameters besides the variation symbol ---not even that atm.

+ [ ] The global variables package-formers & instance-declaration should be /buffer/ specific?

+ [X] Assign to a local var, check equality against global 700-comments,
      if identical, no more processing since everything already generated.

+ [ ] Make use of docstring so that when a user enters a key sequence or selects from a menu, we can show them a listing of all â€˜majorâ€™ components of a program: An org-mode file is displayed with an enumeration of the items, each being a link to the source, and only their docstring is shown. This is a nice â€˜overviewâ€™ of the program source.

+ [X] Currently it looks like we are a minor mode, but this is not true. We only have a menu and the icon (â€¢Ì€á´—â€¢Ì)Ùˆ is displayed when our feature is supported.
      - Now a minor mode.

+ [ ] Generate all instances of a PackageFormer schema.

+ [ ] Allow package formers to have explicit ~Variation~ parameters; but
      how do we then deal with nested invocations? What are the uses of
      having differing invocations?

      For example,
      #+BEGIN_SRC agda
PackageFormer LawfullyPointed (v : Variation) : Set where
   point : LawfullyPointed v
   law   : LawfullyPointed FOL {- Concrete variation -}

                         #+END_SRC
      Would elaborate to something like:
      #+BEGIN_SRC agda
       data LP-Term (Vars : Set) : Set where
        {- Abstract fields from constituents of packageformer -}
        Point    : LP-Term
        {- Fragment of first order logic term formation -}
        _â€²       : Vars â†’ LP-Term {- Injection of vars as terms -}
        _â‰ˆ_      : LP-Term â†’ LP-Term â†’ LP-Term
        âˆ€â€² âˆƒâ€²    : (Vars â†’ LP-Term) â†’ LP-Term

       record LP : Setâ‚ where
     constructor _,_,_
     field
        Carrier : Set
        point   : Carrier
        law     : LP-Term Carrier
#+END_SRC

      With the following example uses.
      #+BEGIN_SRC agda
      Contractable : (A : Set) (a : A) â†’ LP
      Contractable A a =  A , a , âˆ€â€² (Î» x â†’ x â‰ˆ a â€²)

      Indistinguishable : (A : Set)  â†’  LP hiding point
      Indistinguishable A a =  A , âˆ€â€² (Î» x â†’ âˆ€â€² (Î» y â†’ x â‰ˆ y))
      #+END_SRC
      Where ~PF hiding c~ is the largest sub-PackageFormer of ~PF~ with constituent ~c~
      removed ---in particular, constituents that depend on ~c~ would also be dropped.

      :Hide:
    #+BEGIN_SRC emacs-lisp
(defun generate-all-instances () ;; TODO
  "For each PackageFormer â€˜pfâ€™, produce the default instances:
   â€˜pf-recordâ€™, â€˜pf-typeclassâ€™, â€˜pf-dataâ€™.

   Use: You want a particular instance in rapid developement and don't want
   to be bothered to give it a name. Or experimenting and unsure which instance
   is most desirable, so have access to all of them.

   Possible extensions:
   0. Introduce concrete syntax â€œGenerateDefaultInstances pfâ€ to invoke this command.
   1. Have a global list of default instances.
  "

  (interactive)

    ;; Keep this around since we may want to produce variations wholesale with
  ;; names: packageformer-variation; e.g., Magma-typeclass.
  ;;
  ;;
  ;; the variations
;;  (setq the-vars-shush (--map (car it) (--map (-take-last 1 it) (--map (s-split " " it) decls-vars-shush))))
  ;;
  ;; (dolist (variation the-vars-shush ll)
  ;;  (setq ll (cons (make-typeclass decls (concat pf-name "-" variation)) ll)))

  )
#+END_SRC
      :End:

+ ~MR = M-Set primed~ crashes!

* Appending PackageFormer.el with the useful variationals :ignore:noexport:
  :PROPERTIES:
  :CUSTOM_ID: Appending-PackageFormer.el-with-the-useful-variationals
  :END:

:Hide:
  #+BEGIN_SRC emacs-lisp :exports none :tangle "PackageFormer.el" :var it=(file-as-string "variationals.tmp")
(setq â™¯standard-variationals (s-count-matches-all "(ğ’±" it))
(eval (car (read-from-string (format "(progn %s)" it))))
 #+END_SRC

   We read in the temporary variationals file, then tangle the result into the PackageFormer.el file.

   This must come at the end since it uses things like ğ’± which need to be defined first.
   :End:

* COMMENT Cool stuffs, but now obsolete -e.g., :itify:
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-Cool-stuffs,-but-now-obsolete--e.g.,
  :END:
** itify
   :PROPERTIES:
   :CUSTOM_ID: itify
   :END:

+ ~itify~ :: A macro that generates macros!

  A common pattern I've observed is code of the form
  ~(f (lambda (x) body-with-x) arg)~ ---i.e., there is a useful
  function ~f~ that is invoked with two arguments; the first being a
  function. The declaration ~(itify f~) will produce a macro named ~f-it~
  that takes two arguments where the first is an expression involving
  a free variable ~it~ such that
         | /(f-it expr-with-it more)  â‰ˆ  (f (Î» (it) expr-with-it) more)/  |

  We then test this out on the utility ~rename-mixfix~.
  - ~rename-mixfix~ :: Ignore outermost Agda argument markers â€˜_â€™
             when renaming an mixfix argument;
             e.g., ~_[_âŠ—_]  â†¦  _â‚€[_âŠ—_]Â¹~ where this particular renaming
             is a prefix subscript 0 and postfix 1.


** ~Itify~: A macro that makes macros â™¥â€¿â™¥
   :PROPERTIES:
   :CUSTOM_ID: ~Itify~:-A-macro-that-makes-macros-â™¥â€¿â™¥
   :END:

  A common pattern I've observed is code of the form
  ~(f (lambda (x) body-with-x) arg)~ ---i.e., there is a useful
  function ~f~ that is invoked with two arguments; the first being a
  function. The declaration ~(itify f~) will produce a macro named ~f-it~
  that takes two arguments where the first is an expression involving
  a free variable ~it~ such that
         | ~(f-it expr-with-it more)  â‰ˆ  (f (Î» (it) expr-with-it) more)~ |

I'm only considering binary functions, since they're my most common
case ---it's little trouble to move to the general case.

Let's consider the simplest binary operator whose first argument is
necessarily a function ---namely, function application.
#+BEGIN_SRC emacs-lisp
(defun ap (f x) "bye" (funcall f x))
#+END_SRC

Let's form the desired macro:
#+BEGIN_SRC emacs-lisp
(defmacro ap-it (itbody more)
  (list 'ap (list 'lambda '(it) itbody) more)
  ;; â‰ˆ `(ap (lambda (it) ,itbody) ,more)
  )
#+END_SRC

We have elected to present this with the ~list~ form
rather than the quasi-quote, since it's clear how to
yield the former as part of a macro /result/.

#+BEGIN_SRC emacs-lisp :tangle yes
(defmacro itify (fname)
  "
   From a function (h f x), obtain a macro (h-it (â‹¯itâ‹¯) x) that rewrites into
   the orginal such that the first (functional) argument  may now be an expression
   with free variable â€˜itâ€™. One declates (itify h) for a named top-level function â€˜hâ€™.

   NOTE: Since functions are of the form (cons 'macro-or-fun (function (lambda args body)))
   we can obtain the number of args by getting â€˜argsâ€™ and taking its length.
   Then we can change any of its indices to take an expression rather than a function.
   Indeed, (macroexpand '(itify ap))
     â‡’ (defalias (quote ap-it) (cons (quote macro) (function (lambda (itbody more)
         (list (quote ap) (list (quote lambda) (quote (it)) itbody) more)))))      .
  "

  `(defmacro ,(intern (format "%s-it" (symbol-name fname))) (itbody more)
       (list (quote ,fname) (list 'lambda '(it) itbody) more))
)
#+END_SRC

Let's test this out.
#+BEGIN_SRC emacs-lisp
;; 0. Too clunky
(ap (lambda (it) (+ 2 it)) 3) ;; â‡’ 5

;; 1. Desired
(itify ap)
(ap-it (+ 2 it) 3) ;; nice.

;; 2. Works with lambdas?
((lambda (e) (ap-it (+ 2 it) e)) 2)

;; 3. Scoping is fine?
;; Outermost â€˜itâ€™ belongs to --map; inner-most â€˜itâ€™ belongs to ap-it. (â”€â€¿â€¿â”€)
(--map (ap-it (+ 2 it) it) '(1 2 3)) ;; â‡’ (3 4 5)

;; 4. Works well with read/eval?
(ap-it (eval (car (read-from-string "(+ 2 it)"))) 3) ;; â‡’ 5
#+END_SRC

A common use of the following will be when â€˜threadsâ€™ are used for
sequential processing.
#+BEGIN_SRC emacs-lisp :tangle yes
(itify funcall)
#+END_SRC

Now for a more useful and complex setting.
<<<rename-mixfix>>> source block here.

{{{fold(Unit Tests)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest rename-mixfix ()

  (should (equal (rename-mixfix #'identity "_âŠ•_") "_âŠ•_"))

  (should (equal "_âŠ•â€²_" (rename-mixfix-it (eval (car (read-from-string "(concat it \"â€²\")"))) "_âŠ•_")))

  (should  (equal (--map (rename-mixfix-it (format "â‚€%sÂ¹" it) it) '("_âŠ•_" "_[_âŠ—_]" "he_lo" "he-lo"))
       ;; Outermost â€˜itâ€™ belongs to --map; inner-most â€˜itâ€™ belongs to rename-mixfix-it.
  '("_â‚€âŠ•Â¹_" "_â‚€[_âŠ—_]Â¹" "â‚€he_loÂ¹" "â‚€he-loÂ¹"))))
#+END_SRC
{{{end-fold}}}
** recursively replacement; i.e., Lisps' subst
   :PROPERTIES:
   :CUSTOM_ID: recursively-replacement;-i.e.,-Lisps'-subst
   :END:

Accidentally_reimplemented_Lisps_subst
#+BEGIN_SRC emacs-lisp :results replace :tangle yes
;; This is Lisp's â€œsubstâ€, lol ^_^
(defun rec-replace (old new thing)
  "Traverse â€˜thingâ€™ and seek out all, possibly nested, instances
   of â€˜oldâ€™ and replace them with â€˜newâ€™."
  (cond
   ((equal thing old) new  )
   ((atom thing)      thing)
   ((consp thing)     (cons (rec-replace old new (car thing))
                            (rec-replace old new (cdr thing))))))

;; test
;; (rec-replace 'it 3
;;              '(1 2 it 4 (5 it) 7 (+ 8 it))
;;             )
;; Neato!
#+END_SRC

**  ğ’±                                                             :posterity:
   :PROPERTIES:
   :CUSTOM_ID: ğ’±
   :END:
#+BEGIN_SRC emacs-lisp :results replace  :tangle yes
;; Posterity
(defmacro ğ’±â‚€ (name &rest body)
  "lhs args = key-value pairs   â‡’  a Lisp lambda taking args, yielding the pairs"
  (let* ((it body) (args-pairs (-split-on '= body)) args pairs pp)
    (pcase (length args-pairs)
      (2 (setq args  (car args-pairs)
               pairs (cadr args-pairs)))
      (t (setq pairs (car args-pairs))))

    `(lambda ,args
    ,(-let [res
        `,(loop for key   in pairs by #'cddr
                      for value in (cdr pairs) by #'cddr
                      collect (cons key value))]

       ;; Stage the formal names *now*, then evaluate their values at run time.
       ;; Traverse the list of pairs and change the nested formal names with the
       ;; given values. Praise the Lord!
      `(loop for a in (quote ,args)
            collect (subst (eval a) a (quote ,res)))

  ))))
#+END_SRC

** Variationals                                                :old_approach:
   :PROPERTIES:
   :CUSTOM_ID: Variationals
   :END:

   Let's parse arguments as legitimate Lisp forms.
#+begin_src emacs-lisp :tangle yes
(cl-defun to-lisp (string)
  "Parse Agda â€˜stringâ€™ to obtain a Lisp expression.

   + (Î» x â†’ B)   â†¦  (lambda (x) Bâ€²)
   + B may contain ++, in which case the result is a â€˜concatâ€™.
   - B may not contain â€˜â†’â€™.

  If B is a parens-enclosed expression, then we expect it to
  already be a legitimate Lisp form and so leave it alone.
  "

  (assert (stringp string))

  (let* ((expr (s-collapse-whitespace string))
     args
     (body expr)
     (isÎ» (equal "(Î»" (s-shared-start "(Î»" expr))))

    (when isÎ»
      (thread-last string
    (s-chop-prefix "(Î»")
    (s-chop-suffix ")")
    (s-split "â†’")
    (setq expr))

      (setq args (car expr))
      (setq body (cadr expr))
    )

    ;; (error "%s" body)

    ;; Ensure â€˜bodyâ€™ is a lisp expression.
    (when  (and (s-blank? (s-shared-start "(" body))
        (s-blank? (s-shared-end ")" body)))

     (when (and isÎ» (s-contains? " ++ " body))
       (thread-last body
         (s-replace "++" " ")
         (format "(concat %s)")
         (setq body)))

     )

    ;; Realise it as Lisp
    (setq expr (if isÎ» (format "(lambda (%s) %s)" args body)
           body))
    (car (read-from-string expr))
))

(ert-deftest to-lisp ()
  (should (equal 'data (to-lisp "data")))
  (should (equal '(list 'a 'b 'c) (to-lisp "(list 'a 'b 'c)")))
  (should (equal '('a 'b 'c) (to-lisp "('a 'b 'c)")))
  (should (equal '("a" "b") (to-lisp "(\"a\" \"b\")")))
  (should (equal '(lambda (x) Bx) (to-lisp "(Î» x â†’ Bx)")))
  (should (equal '(lambda (x) (when t x)) (to-lisp "(Î» x â†’ (when t x))")))
  (should (equal '(lambda (x) just this) (to-lisp "(Î» x â†’ just this")))
  (should (equal '(lambda (x) (concat x "â€²")) (to-lisp "(Î» x â†’ x ++ \"â€²\")")))
)
#+end_src

#+begin_src emacs-lisp :tangle yes :results replace
(cl-defun update-state (xs ys)
  "Given ys, a list of key-value pairs, where the keys appear free in list of pairs xs,
   update the values of xs making use of these new pairs.

   E.g., (setq xs '((a . (list b d)) (c . d)))
         (setq ys '((b . ğ’·) (d . ğ’¹)))
         â‡’    (update-state xs ys)
            â‰ˆ '((a . (list â€œğ’·â€ â€œğ’¹â€)) (c . â€œğ’¹â€)))
  "
  (loop for (key . val) in xs
         collect (cons key
            (eval `(progn ,@(--map `(setq ,(car it) ,(format "%s" (cdr it))) ys)
              ,(car (read-from-string (format "%s" val)))))))
  )

;; (update-state xx yy)
#+end_src

#+begin_src emacs-lisp :tangle yes :results replace
(cl-defun parse-variational-clause (line)

  "Given a string of items â€œname :keyâ‚€ valâ‚€ â€¦ :keyâ‚™ valueâ‚™â€
   seperated by âŸ´, and where the â€˜nameâ€™ string may be empty,
   turn it into a list of such items; i.e., a list of tuples
   (name pairs) where the â€˜pairsâ€™ refers to the key-value
   components."

  (let (variations label alterations)

  ;; For now, variation must be separated by âŸ´.
     (setq variations (s-split "âŸ´" line))

     (setq alterations
     (loop for va in variations
       do (setq label (car (s-split " " (s-trim va))))
         ;; If the variation begins with a â€œ:key valueâ€ pair, then
         ;; it is anonymous & its label is nil;
         ;; otherwise it is a variational application.
         (setq label (unless (equal ":" (s-shared-start ":" (s-trim va)))
             (car (s-split " " (s-trim va)))))
         collect
         (thread-last
             ;; Split along â€œ:key valueâ€ pairs;
             ;; Drop first non-key item, the label, if any.
             (s-split ":" (s-join " "
                                  (funcall (if label #'cdr #'identity)
                                           (s-split " " va :omit-nulls))))

             ;; Split along the space to get key and value.
           (--map (s-split " " it :omit-nulls))
           cdr
           (--map (cons (to-lisp (car it))           ;; Transform it into legitimate Lisp.
                (to-lisp (s-join " " (cdr it)))))
           (cons (or label 'anonymous)))))

     ;; We know have the declared alterations in the given order.
     ;; alterations â‰ˆ list of (name (list-of (key value))) tuples
     ;; (should (--every? (equal 2 (length it)) alterations))

     alterations
    )
  )


;; TODO: Might as well throw away load-instance-declaration now.
;
(parse-variational-clause ":waist 2 âŸ´ :kind record âŸ´ more :yarg x :barg y")
#+end_src

#+RESULTS:
| anonymous | (waist . 2)     |            |
| anonymous | (kind . record) |            |
| more      | (yarg . x)      | (barg . y) |

** â€œto listsâ€
   :PROPERTIES:
   :CUSTOM_ID: â€œto-listsâ€
   :END:
For uniformity, the ~args~ will generally be a single function.
We introduce â€œto listsâ€ as a nice concrete syntax for functions involving
case analysis. These meta-lists occur in existing Agda notation and so
we overload them for sake of familiarity ---in actuality, we are generalising the existing form.

{{{fold(~parse-labelled-to-list~)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun parse-labelled-to-list (label the-list &key (no-to nil))

     "Given a â€œto-listâ€ of the form â€œlabel (xâ‚€ to yâ‚€; â€¦; xâ‚™ to yâ‚™; Î» x â†’ Bx)â€
      yield the Lisp list of dotted pairs â€œ( ((xâ‚€ . yâ‚€) â‹¯ (xâ‚™ . yâ‚™)) â€œ(lambda (x) Bx)â€)â€
      where the *optional* final clause of the to-list is considered a default or â€˜otherwiseâ€™
      case and is converted into a legitimate Lisp function.

      No label results in to-list becoming a dotted list.
      When the otherwise clause is absent, it defaults to the identity function.

      If â€œno-toâ€ is true, then we do not parse the to-clauses, yielding
      a list of strings.

      Errors on an empty list. Yields nil if the label is not found.
      Note that n = 0 is fine, provided the otherwise clause
      is present.
     "

     (when (or (equal (car (s-split " " (s-trim the-list))) label) (s-blank? (s-trim label)))

     (-let* ( ;; (label "var") (the-list "var ()") no-to
         (result (thread-last the-list

              ;; Discard identifying label
              (substring-delimited-here (format "%s ($here)" label))

              ;; Split along semicolons.
              (s-split ";")

              ;; Removed superflous whitespace
              (--map (s-trim it))))

         otherwise var)

       ;; If there is a â€œotherwiseâ€ function to apply,
       ;; then turn it into a Lisp function and drop it
       ;; from the prefix of the to-list. Else, set otherwise to identity.
       (if (not (s-contains? "Î»" (car (-take-last 1 result))))

       (setq otherwise #'identity)

     ;; Drop the Agda's Î»â†’ in-favour of Lisp's (lambda â‹¯).
     ;; Replace Agda catenation's with Lisp concat.
     (setq otherwise (thread-last (car (-take-last 1 result))
           (s-replace "++" " ")
           (substring-delimited-here "Î» $here")
           (s-split " â†’ ")
           (funcall-it (format "(lambda (%s) (concat %s))" (car it) (cadr it)))
           read-from-string
           car
           ))

     (setq result (-drop-last 1 result)))

       ;; Turn into dotted pairs, unless suggested otherwise.
       ;; Need to ensure â€˜resultâ€™ is non-empty; since it may
       ;; be a singleton that was dropped into the â€˜otherwiseâ€™.
       (when (and result (not no-to))
     (setq result (thread-last result
         (--map (s-split " to " it))
         ;; Need to ensure it's a list of pairs; otherwise something went wrong.
         ;; Suffices to ensure the head element has a second component.
         (funcall-it (if (cadar it)
         (--map (cons (s-trim (first it)) (s-trim (second it))) it)
         (message "parse-labelled-to-list: Is this â€œto-listâ€ well-formed: %s â‡" (pp it)) it))))) ;; No desire to error since we may parse non 700-syntax.
       (list result otherwise)
)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest parse-tos ()

  ;; Expected use
  (should (equal '(("a" . "b") ("c" . "d")) (car(parse-labelled-to-list "map"  "map (a to b; c to d)"))))
  (should (equal '(("a" . "b")) (car(parse-labelled-to-list "map"  "map (a to b)"))))
  (should (equal '(("a" . "b")) (car(parse-labelled-to-list "map"  "map (a to b; Î» x â†’ x)"))))
  (should (equal (lambda (x) (concat x)) (cadr(parse-labelled-to-list "map"  "map (a to b; Î» x â†’ x)"))))
  (should (equal (lambda (x) (concat x "â€²")) (cadr(parse-labelled-to-list "map"  "map (a to b; Î» x â†’ x ++ \"â€²\")"))))
  (should (equal (lambda (x) (concat x "â€²")) (cadr(parse-labelled-to-list "map" "map (Î» x â†’ x ++ \"â€²\")"))))

  ;; Empty list is fine.
  (should (equal '((("")) identity)  (parse-labelled-to-list "map" "map ()")))

  ;; Singleton list
  (should (equal '(("a" . "b")) (car (parse-labelled-to-list "map"  "map (a to b)"))))
    (should (equal '(("one-arg")) (car (parse-labelled-to-list "map" "map (one-arg)"))))

  ;; No label results in to-list becoming a dotted list.
  (should (equal '(("a" . "b") ("c" . "d")) (car(parse-labelled-to-list ""  "(a to b; c to d)"))))

  ;; Unmatched label.
  (should (equal nil (car(parse-labelled-to-list "mapp"  "map (a to b)"))))

  ;; Not ill-formed list ---one arg list!
  (should (parse-labelled-to-list "map"  "map (a what b)"))
)
#+END_SRC
{{{end-fold}}}

* COMMENT Old, possibly no longer needed, code fragments
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-Old,-possibly-no-longer-needed,-code-fragments
  :END:
** Methods to obtain PackageFormer name & variation sumbol
   :PROPERTIES:
   :CUSTOM_ID: Methods-to-obtain-PackageFormer-name-&-variation-sumbol
   :END:

 As such, we form a method for
 obtaining the name, the variation symbol, and a method to rewrite substrings of the
 children ---wait, we already have the last one: ~get-children~ with optional ~:then~
 keyword.

 #+BEGIN_SRC emacs-lisp
;; The following two only work on headers of PackageFormer declarations.

(defun package-former-name (declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (v : Variation) : Set whereâ€
   return the name â€œSemigroupâ€.
  "
  (s-chop-prefix "PackageFormer "
    (s-chop-suffix " ("
      (car (s-match "PackageFormer .* (" declaration))))
)


(defun variation-symbol (declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (v : Variation) : Set whereâ€
   return the name â€œvâ€.
  "
  (s-chop-prefix "("
    (s-chop-suffix " : Variation)"
      (car (s-match "(.*)" declaration))))
)
 #+END_SRC

 Let's test these two out.
 #+BEGIN_SRC emacs-lisp
(package-former-name "PackageFormer Semigroup (v : Variation) : Set where")
;; â‡’ "Semigroup"

(variation-symbol "PackageFormer Semigroup (v : Variation) : Set where")
;; â‡’ "v"
 #+END_SRC

** Parameter Erasure & Insertion
   :PROPERTIES:
   :CUSTOM_ID: Parameter-Erasure-&-Insertion
   :END:
 MA: Just change the package-former-variation to package-former-parameter ---which is a pair, â€œname : typeâ€.
 This may make it easier later to transition to having multiple parameters.

 When a PackageFormer such as the following is instantiated, say, to a typeclass
 variation, we must erase the variation parameter and insert a new type parameter.
 #+BEGIN_SRC agda
   PackageFormer Semigroup (v : Variation) : Set where â€¦
â†¦  record Semigroup (Carrier : Set) : Set  where â‹¯
 #+END_SRC

 #+RESULTS:
 : <interactive>:5:1: error: parse error on input â€˜â†¦â€™

 #+BEGIN_SRC emacs-lisp
;; The following only work on headers of PackageFormer declarations.

(defun erase-parameters (declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (existing-params) : Set â„“ whereâ€
   return
   â€œPackageFormer Semigroup : Set â„“ whereâ€
  "
  (s-collapse-whitespace ;; Convert all adjacent whitespace chars to a single space.
   (s-replace
      (car (s-match "(.*) : Set" declaration))
      ": Set"
      declaration))
)

(defun insert-parameter (param declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (existing-params) : Set â„“ whereâ€
   return
   â€œPackageFormer Semigroup (existing-params) â€˜paramâ€™ : Set â„“ whereâ€

   Precondition: â€˜paramâ€™ is a string.
  "
  (let ((rest-of-line (car (s-match ": Set.*" declaration))))
  (s-replace
      rest-of-line
      (concat param " " rest-of-line)
      declaration)
  )
)
 #+END_SRC

 #+RESULTS:
 : insert-parameter

 Let's test these out:
 #+BEGIN_SRC emacs-lisp :exports both
(erase-parameters "PackageFormer Semigroup (v : Variation) (C : Set) : Set where")
 #+END_SRC

 #+RESULTS:
 : PackageFormer Semigroup : Set where

 # Notice the superfluous whitespace is /not/ collapsed for parameter insertion.
 #+BEGIN_SRC emacs-lisp :exports both
(insert-parameter "(Carrier : Set)"
  (erase-parameters "PackageFormer Semigroup (v : Variation) : Set where"))
 #+END_SRC

 #+RESULTS:
 : PackageFormer Semigroup (Carrier : Set) : Set where

 A naturally expected property is if we obtain the variation symbol of a package former,
 erase said parameter, then insert it; then we have essentially done nothing.
 #+BEGIN_SRC emacs-lisp :exports both :results replace
(let* ((ex "PackageFormer Semigroup (ww : Variation) : Set where")
       (vd "(%ww : Variation)"))

  (and (equal "PackageFormer Semigroup : Set where" (erase-parameters ex))
       (equal ex (insert-parameter vd (erase-parameters ex))))
)
 #+END_SRC

 #+RESULTS:
   | nil |

 Excellent ğŸ˜

** COMMENT ~instantiate~ ---the /backend/ core utility                :posterity:
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-~instantiate~----the-/backend/-core-utility
   :END:
 Let's put the pieces together.
 #+BEGIN_SRC emacs-lisp
(cl-defun instantiate (decls &key
  new-name (type "record") carrier
  name-suffix
  (variation-replacement "")
  (prefix-fields "") (suffix-fields "") omit-field-header
  (keep-fields (lambda (x) t))
  (alter-raw-fields #'identity)
  (alter-fields #'identity)
  )

  "Given a PackageFormer declaration, instantiate it into a concrete Agda type.

   Remarks or example values:

   - â€˜declsâ€™ is immediately provided to â€˜get-childrenâ€™, so it may be a string
      or a list.

   - â€˜typeâ€™: The replacement for â€œPackageFormerâ€; default is â€œrecordâ€.

   - â€˜carrierâ€™: What is the carrier of this new instance? E.g., â€œCarrierâ€.
      By default it's the â€˜new-nameâ€™; but this is unresonable when, say, a typeclass
      variation is requested.

   - â€˜name-suffixâ€™: When no â€˜new-nameâ€™ is provided, the default is
      â€œâŸªPackageFormer'sNameâŸ«-âŸªvariationâŸ«-g*â€, where â€˜*â€™ is an arbitrarily generated number.

     This may be useful for rapid development when one does not want to provide
     a name to an instance, but simply wants the instance to exist.

   - â€˜variation-replacementâ€™: â€œ(Carrier : Set)â€; empty string by default.

   - â€˜prefix-fieldsâ€™: List of fields, â€œname : typeâ€, to be added at the beginning
      of the field declaration. Default is empty string.

   - â€˜suffix-fieldsâ€™: List of fields, â€œname : typeâ€, to be added at the beginning
      of the field declaration. Default is empty string.

   - â€˜omit-field-headerâ€™: Should the â€œfieldâ€ word be removed? No by default.

   - â€˜keep-fieldsâ€™: Predicate that determines which fields should be kept.
      By default, no fields are dropped.

   - â€˜alter-raw-fieldsâ€™: A function that alters the list of fields of a PackageFormer *before*
     any processing has transpiried. This is the identity function by default.

   - â€˜alter-fieldsâ€™: A function to alter existing fields *after* processing;
     it does not alter inserted fields via â€˜prefix-fieldsâ€™ nor â€˜suffix-fieldsâ€™.
     This is the identity function by default.
  "

  (let* ((pf (cadr (get-children "PackageFormer" decls)))
     (header     (car pf))
     (pf-name (package-former-name header))
     (pf-variation (variation-symbol header))
     (field-decl (cadr pf)) ;; In order to maintain user-provided indentation.
     (fields     (funcall alter-raw-fields (cddr pf)))
     (indentation (s-repeat (if fields (get-indentation (car fields)) 0) " "))
       (preFields   (--map (concat indentation it) prefix-fields))
       (postFields  (--map (concat indentation it) suffix-fields))
     (tc nil)
     )

  ;; Default value of â€˜new-nameâ€™ & â€˜carrierâ€™ are âŸªPackageFormer'sNameâŸ«-âŸªname-suffixâŸ«.
  (unless new-name (setq new-name (format "%s-%s-%s" pf-name name-suffix (gensym))))
  (unless carrier  (setq carrier new-name))

  ;; Replace "(? : Variation)" with the provided â€˜variation-replacementâ€™
  (setq header (insert-parameter variation-replacement (erase-parameters header)))

  ;; Replace "PackageFormer" with â€˜typeâ€™.
  (setq header (s-replace "PackageFormer" type header))

  ;; Replace PackageFormer's name with provided instantiation name.
  (setq header (s-replace pf-name new-name header))

  ;; Replace all occurences of â€œpackage-former-name followed by variationâ€
  ;; with â€˜carrierâ€™.
  (setq fields (--map (s-replace (concat pf-name " " pf-variation) carrier it) fields))

  ;; Perform any processing on the fields.
  (setq fields (funcall alter-fields (-filter keep-fields fields)))

  ;; Stick all the pieces together, along with the new fields.
  (setq tc (s-join "\n"
    (-cons* header
    (-concat
       (if omit-field-header () (list field-decl))
       preFields fields  postFields))))

  ;; Declare generation source matter.
  (concat
   "\n{- This was generated from the PackageFormer " pf-name " -}\n"
    tc)
 )
)
 #+END_SRC

 #+RESULTS:
 : instantiate

 Let's instantiate our test example from earlier to produce a typeclass.
 #+BEGIN_SRC emacs-lisp :var test = test :exports both
(instantiate test   ;; :new-name "SemigroupT"
            :name-suffix "typeclass"
            :kind "record"
            :variation-replacement "(Carrier : Set)"
            :carrier "Carrier"
            )
 #+END_SRC

 #+RESULTS:
 :
 : {- This was generated from the PackageFormer Semigroup -}
 : record Semigroup-typeclass-g105 (Carrier : Set) : Set where
 :   field
 :     _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
 :     Id  : Carrier
 :     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

 #+BEGIN_SRC emacs-lisp :var test = test :exports both
;; (instantiate test)

(setq _test (show (car package-formers)))

(instantiate _test :variation-replacement "noice")

;; (erase-parameters _test)
; (insert-parameter "(nn : ?)" (erase-parameters _test)))

;; (instantiate-as-typeclass (show (car package-formers)))
;; (instantiate (show (car package-formers)))
;; -as-typeclass (show (car package-formers)))
;; (stringp (show (car package-formers)))
 #+END_SRC

 #+RESULTS:
 :
 : {- This was generated from the PackageFormer Semigroup -}
 : record Semigroup-nil-g106 noice : Set where
 :   field
 :     _â¨¾_ : Semigroup-nil-g106 â†’ Semigroup-nil-g106 â†’ Semigroup-nil-g106
 :     Id  : Semigroup-nil-g106
 :     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

 What about a bundled up record declaration?
 #+BEGIN_SRC emacs-lisp :var test = test :exports both
(instantiate test   ;; :new-name "SemigroupT"
            :name-suffix "semantics"
            :kind "record"
            :carrier "Carrier"
            :prefix-fields '("Carrier : Set")
            )
 #+END_SRC

 #+RESULTS:
 :
 : {- This was generated from the PackageFormer Semigroup -}
 : record Semigroup-semantics-g107  : Set where
 :   field
 :     Carrier : Set
 :     _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
 :     Id  : Carrier
 :     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

 Records provide a semantics, what if we want the syntax?
 Since ~data~ declarations consist of constructors, whose target type necessarily
 begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.

 First, a helper function.
 #+BEGIN_SRC emacs-lisp
(defun target (field)
  " Given a declaration â€œname : type0 â†’ â‹¯ â†’ typeNâ€, yield â€œtypeNâ€. "
  (car (-take-last 1 (s-split "â†’" field)))
)
 #+END_SRC

 #+RESULTS:
 : target

 Let's test it out:
 #+BEGIN_SRC emacs-lisp :var test = test :exports both
(-let [package-former-name "Semigroup-syntax"]

  (list (s-contains? package-former-name (target "     Id  : Semigroup-syntax"))
    (s-contains? package-former-name (target "_â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax"))
    (s-contains? package-former-name (target "     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)")))
)
 #+END_SRC

 #+RESULTS:
 | t | t | nil |

 The results are as expected, so let's move to the real use case.
 #+BEGIN_SRC emacs-lisp :var test = test :exports both
(-let [package-former-name "Semigroup-syntax"]

  (instantiate test  :name-suffix "syntax"
             :kind "data"
             :omit-field-header t
               :new-name package-former-name
               ;; :carrier package-former-name
             :keep-fields (lambda (f) (s-contains? package-former-name (target f)))
            )
)
 #+END_SRC

 #+RESULTS:
 :
 : {- This was generated from the PackageFormer Semigroup -}
 : data Semigroup-syntax  : Set where
 :     _â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax
 :     Id  : Semigroup-syntax

 Yeehaw! We've got three variations and possibly much more from a single fancy well-toggled
 function ğŸ¤  We can emulate generative modules this way too! ğŸ˜»

 Let's package these particular toggle configurations into their own functions.
 #+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-typeclass (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda â€œtypeclassâ€.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (instantiate decls :new-name new-name
             :name-suffix "typeclass"
             :kind "record"
             :variation-replacement (format "(%s : Set)" carrier)
             :carrier carrier
            )
)
 #+END_SRC

 #+RESULTS:
 : instantiate-as-typeclass

 #+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-record (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (instantiate test :new-name new-name
            :name-suffix "record"
            :kind "record"
            :carrier carrier
            :prefix-fields `(,(format "%s : Set" carrier))
            )
)

 #+END_SRC

 #+RESULTS:
 : instantiate-as-record

 #+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-data (decls &key new-name (carrier "Carrier") (alter-fields #'identity))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (let* ((pf (cadr (get-children "PackageFormer" decls)))
     (header     (car pf))
     (pf-name (package-former-name header)))

    (instantiate test  :new-name new-name
               :name-suffix "syntax"
               :kind "data"
               :omit-field-header t
               :keep-fields (lambda (f) (s-contains? pf-name (target f)))
               :alter-fields alter-fields
              )
  )
)
 #+END_SRC

 #+RESULTS:
 : instantiate-as-data

 #+BEGIN_SRC emacs-lisp :var test = test :exports both
(s-join "\n" `(
,(instantiate-as-typeclass test)
,(instantiate-as-record test)
,(instantiate-as-data test)
))
 #+END_SRC

 #+RESULTS:
 #+begin_example

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-typeclass-g108 (Carrier : Set) : Set where
  field
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-record-g109  : Set where
  field
    Carrier : Set
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup -}
data Semigroup-syntax-g110  : Set where
    _â¨¾_ : Semigroup-syntax-g110 â†’ Semigroup-syntax-g110 â†’ Semigroup-syntax-g110
    Id  : Semigroup-syntax-g110
 #+end_example

 Notice that the results contained generated names since no names were provided.

** Instantiate all items in ~instantiations-remaining~
   :PROPERTIES:
   :CUSTOM_ID: Instantiate-all-items-in-~instantiations-remaining~
   :END:

 #+BEGIN_SRC emacs-lisp :tangle yes
;; Function combinators; e.g., -partial/-cut, -const, -compose, -orfn & -andfn for generalised âˆƒ/âˆ€.
;; (use-package dash) ;; https://github.com/magnars/dash.el
 #+END_SRC

 #+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun reify-instances ()
 "Instantiate all items in â€˜instantiations-remainingâ€™."

 (interactive)

 (let* (result)

   ;; We parsed them top-down, so they're in the wrong order.
   ;; Order matters since declarations yield new PackageFormers
   ;; which may be used in subsequent declarations.
   (dolist (inst (reverse instantiations-remaining))

     ;; Add to list of results. The empty string yields a new line between each generated instantiation.
      (setq result (-cons* (instantiate inst) "" result))
     )

   ;; Output results as a string.
     (s-join "\n" (reverse result))
))
 #+END_SRC

 Super cool stuff ~(à¸‡à² _à² )à¸‡~

 :Thoughts_TODO:
 #+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
;; As always, let's ensure this works as intended.
(let (package-formers instantiations-remaining 700-comments porting-list variationals)

  (find-file "Testing.agda")
  (load-700-comments)
  (load-variationals)

  (switch-to-buffer "PackageFormer.org")

  (reify-instances)
)

 #+END_SRC



 Note that the renaming clause must have its old forms appear in the same order that they appear in the original declaration.
 This could be avoided by obtaining the names of the continents, then intersecting that with the renames list, along the first component.
 :End:

 NOTE: Level polymorphism with generalised variables does not work for
 data declaration.
* COMMENT Referencing Text From Code Blocks ---Attaching prose as doc strings :noexport:ignore:
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-Referencing-Text-From-Code-Blocks----Attaching-prose-as-doc-strings
  :END:

Sources:
+ John Kitchin https://lists.gnu.org/archive/html/emacs-orgmode/2018-05/msg00350.html
+ https://kdr2.com/tech/emacs/1805-approach-org-ref-code-to-text.html

# NAME: get-named-text
#+NAME: commentary
#+BEGIN_SRC emacs-lisp :var name="" :results replace
(let ((el (org-element-map (org-element-parse-buffer) org-element-all-elements
        (lambda (el)
          (when (string= (org-element-property :name el) name)
        el))
        nil t)))
  (let ((s (buffer-substring (org-element-property :contents-begin el)
                 (org-element-property :contents-end el))))
    (replace-regexp-in-string "\\\"" "\\\\\"" s)))
#+END_SRC

** COMMENT Example
   :PROPERTIES:
   :CUSTOM_ID: COMMENT-Example
   :END:
For example:
#+NAME: ADD
#+BEGIN_SRC emacs-lisp -n -r :noweb yes :tangle test.el
(defun add (x y)
  "One line description of adding X and Y.
  <<get-named-text("DOC-OF-ADD")>> ;; code to code
  <<get-named-text("add-options")>>"
  (+ x y)
  )
#+END_SRC

#+NAME: DOC-OF-ADD
We use the function add to calculate the sum of two numbers.

#+NAME: add-options
- one
- two
- three
- and of course "optional things"

*** There is a reason we only support two args
    :PROPERTIES:
    :ID:       BAD97113-3561-4A4A-BA07-0CD5BF6BA35F
    :CUSTOM_ID: There-is-a-reason-we-only-support-two-args
    :END:

* COMMENT PackageFormers *as* Agda Datatypes      :Eventually::after_prototype_is_done:
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-PackageFormers-*as*-Agda-Datatypes
  :END:

#+BEGIN_SRC agda
open import Function using (id)
open import Data.List using (List; map)
open import Data.String using () renaming (String to Name)
open import Data.String using () renaming (String to Type)
open import Data.Product using (_Ã—_) renaming (map to bimap)

data VarExpr : Set where
  :kind : String â†’ VarExpr
  :alter-elements : String â†’ VarExpr


{- No lambda's allowed; all arguments must be to the left of the â€˜=â€™. -}
{- Definition must be one liner. -}
ğ‘½-adorn : List (Name Ã— Type) â†’ (Name â†’ Name) â†’ List (Name Ã— Type)
ğ‘½-adorn xs f = map (bimap f id) xs

import Data.Maybe as Maybe
open Maybe using (Maybe; just; nothing)
import Data.List as List
open import Data.List using (_++_ ; _âˆ·_)
data Kind : Set where
  â€µdata â€µrecord â€µmodule â€µfunction â€µpackageformer : Kind
  --
  -- note that pf's are not necessary, we can work with records then
  -- reify them as other groupingmechanisms.
  -- BUT it's preferable to be as unbiased as possible
  -- hence we keep the generic package-former kind.

record PF : Set where
  field
    kind       : Kind
    name       : Name
    level      : Level
    {- The following four are the â€œconstiutentsâ€ or â€œelementsâ€ of a PackageFormer -}

    -- old, remove me
    variation  : Maybe Name
    carrier    : Maybe Name

    parameters : List (Name Ã— Type)
    fields     : List (Name Ã— Type)

{-
pfâ€² = pf variational (args; otherwise)

variational : (new-name : Name) (args : â‹¯) (otherwise : ? â†’ ?) â†’ PF
variational pfâ€² args otherwise = ???
-}

_Variationalâ‚ : {â„“ : Level} (X : Set â„“) â†’ Set â„“
X Variationalâ‚ = (new-name : Name) (to-list : List (Name Ã— X)) (otherwise : Name â†’ X)
               â†’ PF â†’ PF

_Variationalâ‚€ : {â„“ : Level} (X : Set â„“) â†’ Set â„“
X Variationalâ‚€ = (new-name : Name) (to-list : List X) (otherwise : Name â†’ X)
               â†’ PF â†’ PF

open import Data.Product using (_,_)
open import Data.String using (String)
postulate string-replace : (old new : String) â†’ String â†’ String

ğ‘½-record : Name Variationalâ‚
ğ‘½-record new-name to-list otherwise pf = let open PF pf in
  record
    { kind       = â€µrecord
    ; name       = new-name
    ; variation  = nothing
    ; level      = Level.suc level
    ; carrier    = just "Carrier"
    ; parameters = List.[]
    ; fields     =    parameters
                   ++ ("Carrier" , "Set level")  -- HACK!
                   âˆ· List.map (bimap (string-replace "name variation" "Carrier") id) fields   -- HACK!
    }

{- Thisâ€™ a lot at once; let's instead focus on small combinators. -}

-- as-kind : Kind â†’ PF â†’ PF
-- as-kind k

{-
with-carrier : Name â†’ PF â†’ PF
with-carrier c pf = let open PF pf in
  record
    { kind       = kind
    ; name       = name
    ; level      = level
    ; variation  = variation
    ; carrier    = just c
    ; parameters = List.map (bimap f id) parameters
    ; fields     = List.map (bimap f id) fields
    }


alter-elements : (Name â†’ Name) â†’ PF â†’ PF
alter-elements f pf = let open PF pf in
  record
    { kind       = kind
    ; name       = name
    ; level      = level
    ; variation  = variation
    ; carrier    = Maybe.map f carrier
    ; parameters = List.map (bimap f id) parameters
    ; fields     = List.map (bimap f id) fields
    }

-}

{-00

Woah = Monoid record adorn (Î» x â†’ x ++ "â‚")

-}




-- Since seven-hundred comments generate code which is imported, we may use their results
-- seemingly before their definition

-- _ = MonoidR
-- open MonoidRâ€²

{-00
MonoidR   = Monoid record
MonoidRâ€²  = Monoid opening MonoidR (Î» x â†’ x ++ "â€²")
MonoidRâ‚  = Monoid opening MonoidR (Î» x â†’ x ++ "â‚")
MonoidRâ‚‚  = Monoid opening MonoidR (Î» x â†’ x ++ "â‚‚")


record Monoid-Hom (ğ’® ğ’¯ : MonoidR) : Set where
  open MonoidRâ‚ ğ’®; open MonoidRâ‚‚ ğ’¯
  field
    mor     : Carrierâ‚ â†’ Carrierâ‚‚
    id-pres : mor Idâ‚ â‰¡ Idâ‚‚
    op-pres : âˆ€ {x y} â†’ mor (x â¨¾â‚ y) â‰¡ mor x â¨¾â‚‚ mor y
-}

{- Below are other examples, from the past. -}

{-00
MonoidTypeclass = Monoid typeclass hiding (_â¨¾_)
MonoidT         = Monoid typeclass renaming (Carrier to C; _â¨¾_ to _âŠ•_)
MonoidE         = Monoid record exposing (Carrier; Id)
MonoidB         = Monoid record with (Carrier to Bool; Id to false)
MonoidD         = Monoid data renaming (_â¨¾_ to _Î”_)


-- MonoidR         = Monoid record unbundling 2
-- MonoidDâ€²        = Monoid data decorated (Î» it â†’ "â•²" ++ it ++ "â•±")

-- Accidentally â€œdatarâ€ instead of â€œdataâ€.
-- Whoops = Monoid datar

_ = MonoidTypeclass
{- record MonoidTypeclass (Carrier : Set) : Set where â€¦ -}

_ = MonoidT ; open MonoidT using (_âŠ•_)
{- record MonoidT (C : Set) : Set where â€¦ -}

_ = MonoidR
{- record MonoidR (Carrier : Set) (_â¨¾_ : Carrier â†’ Carrier â†’ Carrier) : Set where â€¦ -}

_ = MonoidD
{- data MonoidD : Set where â€¦ -}

_ = MonoidE
{- record MonoidE (Carrier : Set) (Id : Carrier) : Set where â€¦ -}

_ = MonoidB ; open MonoidB using (leftfalse)
{- record MonoidB : Setâ‚€ where â€¦ -}

-- _ = MonoidDâ€²

-}
#+END_SRC

* COMMENT footer
  :PROPERTIES:
  :CUSTOM_ID: COMMENT-footer
  :END:

# Local Variables:
# eval: (visual-line-mode t)
# compile-command: (progn (org-babel-tangle) (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# End:
