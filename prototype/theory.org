#+title: Progressing on a type theory for =PackageFormer=
#+author: Musa Al-hassy
#+agda_version: 2.6.0.1

# Some blocks are marked “haskell” so that they are coloured and #not#
# interpreted as agda blocks. They're informal and do not typecheck.

* Table of Contents                                    :Github:TOC_4:
- [[#introduction][Introduction]]
- [[#preamble][Preamble]]
  - [[#module-header][Module header]]
  - [[#imports][Imports]]
  - [[#syntax-declarations][Syntax Declarations]]
  - [[#helper-utilities][Helper Utilities]]
    - [[#level-polymorphic-unit-type][Level-Polymorphic Unit Type]]
    - [[#singleton-types][Singleton Types]]
- [[#what-is-a-type-theory][What is “a type theory”?]]
- [[#our-ambient-type-theory][Our Ambient Type Theory]]
- [[#contexts-over-contexts][“Contexts over Contexts”]]
- [[#packageformers-as-pairs-of-contexts-demarcated-by-a-waist][PackageFormers as Pairs of Contexts Demarcated by a Waist]]
- [[#mutally-associative-sets][‘M’utally ‘A’ssociative Sets]]
  - [[#two-sanity-checks][Two Sanity Checks]]
    - [[#actually-write-a-grouping-mechanism][Actually write a grouping mechanism]]
    - [[#packageformers-are-ma-sets][PackageFormers are MA-Sets]]
  - [[#ma-sets-form-a-category][MA-Sets form a Category]]

* Introduction

  For brevity, every PackageFormer declaration can essentially be seen as a
  sequence of declarations, some of which are considered /parameters/ and the rest
  are the /body/. Whence, a PackageFormer is a pair of contexts.

  Let's try to explain that idea.

  Perhaps with canonical forms for PackageFormers we can furnish them with
  initial semantics.

* Preamble
** Module header
#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
-- The .agda file is trangled from an org file.
module semantics-via-MA-Sets where
#+END_SRC
** Imports
#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
open import Data.Product
open import Data.Nat
open import Data.Sum
open import Relation.Binary.PropositionalEquality hiding ([_])
open ≡-Reasoning
open import Level renaming (zero to ℓ₀; suc to ℓsuc; _⊔_ to _⊍_)
#+END_SRC
** Syntax Declarations
#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
Σ∶• : ∀ {a b} (A : Set a) (B : A → Set b) → Set _
Σ∶• = Σ

infix -666 Σ∶•
syntax Σ∶• A (λ x → B) = Σ x ∶ A • B
#+END_SRC

** Helper Utilities
*** Level-Polymorphic Unit Type
#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
record ⊤ {ℓ} : Set ℓ where
  constructor tt
#+END_SRC
*** Singleton Types
We'll be treating contexts as sets and so will require a singleton types for
adjoining declarations.
#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
data Just {ℓ} {A : Set ℓ} : A → Set where
  just : (a : A) → Just a
#+END_SRC
* What is “a type theory”?
  To get anything done, we'll need an ambient type theory that provides us with
  a set of variable names 𝕍 and typing judgements. The comments below are what
  a classical type theory would have.
#+BEGIN_SRC agda2
record TypeTheory : Set₁ where
  field
    -- An infinite set of variable names
    𝕍       : Set
    -- A collection of name-type pairs
    Context : Set
    -- Possible expressions in a given context
    Expr    : Context → Set
    -- When is an expression considered a ‘type’
    _⊢_type : (Γ : Context) → Expr Γ → Set
    -- When is a term considered to be “of a type”
    _⊢_∶_   : (Γ : Context) → Expr Γ → Expr Γ → Set
#+END_SRC
When Γ is fixed and if we denote ~Γ ⊢ e ∶ τ~ by ~e ⟶ τ~ then we obtained a directed
graph where an edge may be construed as ‘abstract interpreter’ relationship
---the ‘value’ of an expression is its type.

It seems that with the typing judgement, we can regain the kinding judgement:
~Γ ⊢ τ type ⇔ ∀ (v : 𝕍) → Γ ⊢ v ∶ τ~.

Within a type theory, we can define a notion of declarations.
#+BEGIN_SRC agda2
  data Declaration (Γ : Context) : Set where
    _∶_≔_ : (n : 𝕍) {τ δ : Expr Γ} → Γ ⊢ τ type → Γ ⊢ δ ∶ τ → Declaration Γ
#+END_SRC

  :Informal_Type_of_Declarations:
  Given an ambient type theory 𝑻, we define the type =Declaration= to be the
  triples ~n ∶ τ ≔ δ~ where =n= is a ‘name’, =τ= is a type of the given type theory, and
  =δ= is a term over that type theory, possibly adjoined with other declarations
  =nᵢ : τᵢ ≔ δᵢ=; i.e., the context ~𝑻, n₀ : τ₀ ≔ δ₀, …, nₘ : τₘ ≔ δₘ~ ensures ~τ~ is
  a type and ~δ~ is of that type, and ~n~ must be a fresh name.
  :End:

* Our Ambient Type Theory
Rather than working with an opaque, and generic, instance of a type theory, we
will work with a particular instance.

| We ignore syntax and jump straight to semantics ---whence no expression type! |

0. At the level of semantics, we may use Agda's variables instead of a
   dedicated variable type.
1. A <<context>> is nothing more than a set.
   - With the ‘smart constructors’ below, a context is a dependent product of
     types wherein later type-declarations may depend on earlier ones.
2. A <<type>> determined by a context is a set than can be obtained
   using the context.

#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
Context = λ ℓ → Set ℓ

type : ∀ {ℓ} → Context ℓ → Set (ℓsuc ℓ)
type {ℓ} Γ = Γ → Set ℓ
#+END_SRC

With this elementary setup, we can, for example, denote context extension with
dependent products ---whose unit, a singleton type, acts as the “empty context”:
#+BEGIN_SRC agda2
∅ : Context ℓ₀
∅ = ⊤

_⨾_ : ∀ {ℓ} (Γ : Context ℓ) (τ : type Γ) → Context ℓ
Γ ⨾ τ = Σ γ ∶ Γ • τ γ
#+END_SRC
These names are not exported to the resulting Agda file, since they are
not needed. In particular, we will ‘reuse’ these names until we have
‘satisfactory’ definitions.

* “Contexts over Contexts”

Informally =x₀ : τ₀, … ❙ y₀ : τ₀; …=  denotes two contexts, ~Γ₁ ❙ Γ₂~, where the
first is an elementary context and the latter is a context whose declarations
not only may use earlier ~yᵢ~ declarations but /additionally/ may use the entirety
of the context ~Γ₁~. We say =Γ₂= is a /context over context/ =Γ₁=.

1. A <<context over a context>>> is a dependent-type, from contexts to contexts.
2. A <<type over a dependent-context>> is an context-indexed family of sets.

#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
Context′ : ∀ {ℓ} → Context ℓ → Set (ℓsuc ℓ)
Context′ {ℓ} Ξ  =  Ξ → Set ℓ

type′ : ∀ {ℓ} {Ξ : Context ℓ} → Context′ Ξ → Set (ℓsuc ℓ)
type′ {ℓ} Γ = ∀ {ξ} → Γ ξ → Set ℓ
#+END_SRC

We may index the previous ‘smart constructors’ for contexts over contexts:
#+BEGIN_SRC agda2
∅ : ∀ {ℓ} {Ξ : Context ℓ} → Context′ Ξ
∅ = λ _ → ⊤

_⨾_ : ∀ {ℓ} {Ξ : Context ℓ} → (Γ : Context′ Ξ) (τ : type′ Γ) → Context′ Ξ
Γ ⨾ τ = λ ξ → Σ γ ∶ Γ ξ • τ γ
#+END_SRC
Note: These names are not exported to the resulting Agda file, since they are
not needed.

* PackageFormers as Pairs of Contexts Demarcated by a Waist

As already mentioned, a PackageFormer is a pair of contexts where the latter
depends on the former.
#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
record PackageFormer (ℓ : Level) : Set (ℓsuc ℓ) where
  constructor _❙_
  field
    parameters : Context ℓ
    body       : Context′ parameters
    #+END_SRC

Unsurprisingly every PackageFormer can be coerced into a context:
#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
  toContext : Context ℓ
  toContext = Σ γ ∶ parameters • body γ
#+END_SRC

Note that the level-polymorphism is not to be facetious;
a PackageFormer is a grouping mechanism containing ‘smaller’
entities, the smallness of which is captured with the level.
- E.g., the grouping consisting of a single set is a PackageFormer at level 1.

The smart constructors from before can be lifted to this notion
---we suffix PackageFormer entities uniformly for clarity.

#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
∅ₚ : ∀ {ℓ} → PackageFormer ℓ
∅ₚ = ⊤ ❙ (λ _ → ⊤)

typeₚ : ∀ {ℓ} → PackageFormer ℓ → Set (ℓsuc ℓ)
typeₚ {ℓ} (parameters ❙ body) = (Σ ξ ∶ parameters • body ξ) → Set ℓ
#+END_SRC

* ‘M’utally ‘A’ssociative Sets

  The simplest thing we can do with contexts is ‘stick them together’,
  but a more natural operation is to extend a context with a new declaration.

  #+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
_⊎ₚ_ : ∀ {ℓ} → PackageFormer ℓ → PackageFormer ℓ → PackageFormer ℓ
(Γ₁ ❙ Γ₂) ⊎ₚ (Γ₁′ ❙ Γ₂′) = (Γ₁ ⊎ Γ₁′) ❙ [ Γ₂ , Γ₂′ ]

_⨾ₚ_ :  ∀ {ℓ} (p : PackageFormer ℓ) → typeₚ p → PackageFormer ℓ
(parameters ❙ body) ⨾ₚ d = parameters ❙ λ ξ → Σ β ∶ body ξ • d (ξ , β)
#+END_SRC


*Remark:* Contexts have a monoidal structure determined by pushouts; i.e.,
disjoint unions ⊎ and the empty PackageFormer ∅.  Indeed, we have a
mutual-associativity law ~(Γ₁ ⊎ Γ₂) ⨾ e ≈ Γ₁ ⊎ (Γ₂ ⨾ e)~ ---up to some /equivalence
relation/.

*Remark:* We do not have a monoidal action since ⨾ and ⊎ do not satisfiy the
necessary coherence laws ---even worse, the right law ~(Γ ⨾ e₁) ⨾ e₂ = Γ ⨾ (e₁ ⊎
e₂)~ and the left law ~Γ₁ ⨾ (Γ₂ ⨾ e) = (Γ₁ ⊎ Γ₂) ⨾ e~ are both ill-typed. Hence, we
have no hope of using ⊎/⨾ to trivially obtain a left/right monoidal action.

We can abstract out this structure in the hopes that a semantics for
PackageFormers can be determined via these new algebras.
:More:
In order to define a semantics, we need a notion of models in which to interpret
the syntactic PackageFormer entities.  Since left and right monoid-sets have
been ruled out, we shall formulate another species to fit the structure embedded
in PackageFormer.
:End:

Define a “<<MA-Set>>”, or a ‘M’utually ‘A’ssocitive structure to be a triple (ℳ,
𝒜, ·) where ℳ is a monoid, 𝒜 is a dependent family indexed by ℳ, and ~_·_ : (m :
ℳ) → 𝒜 m → ℳ~ is a ‘dependent action’ that is mutually associative with the
monoidal operation, ~(m₁ ⊕ m₂) · y ≈ m₁ ⊕ (m₂ · π y)~ where ~π : 𝒜 (m₁ ⊕ m₂) → 𝒜 m₂~
is a ‘weakening’ rule.

+ For now, we only implement the substructure that is necessary.
+ Perhaps additional structure needs to be added, or other to be removed.

#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
record MA-Set (ℓ₁ ℓ₂ : Level) : Set (ℓsuc (ℓ₁ ⊍ ℓ₂)) where
  field
    ℳ  : Set ℓ₁
    _⊕_ : ℳ → ℳ → ℳ
    Id  : ℳ
    𝒜 :  ℳ → Set ℓ₂
    _·_ : (m : ℳ) → 𝒜 m → ℳ  -- Note the dependency
    -- TODO: Ommiting axioms for now; likely want a setoid structure.

open MA-Set
#+END_SRC

# - This is nearly an M-Set, but the functoriality law has been replaced by the
#   an associtivity law.

- Unlike M-Sets in which a monoids “acts” on a set, in a MA-Set we have the
  dependent set acting on the monoid /such that/ the ‘type of possible actions’
  is determined by monoid elements.

** Two Sanity Checks
*** Actually write a grouping mechanism
#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
MonoidPF : PackageFormer (ℓsuc ℓ₀)
MonoidPF = (((∅ₚ
           ⨾ₚ λ{ (tt , _) → Set})
           ⨾ₚ λ{ (tt , (tt , Carrier)) → Lift (ℓsuc ℓ₀) Carrier})
           ⨾ₚ λ{ (tt , ((tt , Carrier), lift point))
                 → Lift (ℓsuc ℓ₀) (Carrier → Carrier → Carrier)})
           ⨾ₚ λ{ (tt , (((tt , Carrier) , lift point) , lift _⊕_))
                 → Lift (ℓsuc ℓ₀) (∀ {x} → x ⊕ point ≡ x × point ⊕ x ≡ x)}
#+END_SRC
TODO: Obtain working monad syntax.
*** PackageFormers are MA-Sets
#+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
PFs-are-MA-Sets : ∀ {ℓ} → MA-Set (ℓsuc ℓ) (ℓsuc ℓ)
PFs-are-MA-Sets {ℓ} = record
  { ℳ   = PackageFormer ℓ
  ; _⊕_ = _⊎ₚ_
  ; Id  = ∅ₚ
  ; 𝒜   = typeₚ
  ; _·_ = _⨾ₚ_
  }
#+END_SRC

** MA-Sets form a Category

Given two MA-Sets (ℳ, 𝒜, ·) and (ℳ′, 𝒜′, ·′), define a /MA-Set homomorphism/ to be
a pair of functions /h₁ : ℳ → ℳ′, h₂ : 𝒜 → 𝒜′/ that preserve the structure on each
set and respect the action; i.e.,
1. =h₁= is a monoid homomorphism
2. =h₁ (m · a) ≈ h₁ m ·′ h₂ a=, a reasonable coherence condition.

   Notice that when ~a : 𝒜 m~ then necessarily ~h₂ a : 𝒜′ (h₁ m)~.

 #+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
record Hom {ℓ₁ ℓ₂} (Src Tgt : MA-Set ℓ₁ ℓ₂) : Set (ℓsuc (ℓ₁ ⊍ ℓ₂)) where
  field
    mor₁ : ℳ Src → ℳ Tgt
    mor₂ : ∀ {m} → 𝒜 Src m → 𝒜 Tgt (mor₁ m)
    pres-Id : mor₁ (Id Src) ≡ Id Tgt
    pres-⊕  : ∀ {x y} → mor₁ (_⊕_ Src x y) ≡ _⊕_ Tgt (mor₁ x) (mor₁ y)
    coherence : ∀ {m a} → mor₁ (_·_ Src m a) ≡ _·_ Tgt (mor₁ m) (mor₂ a)

open Hom
 #+END_SRC

Conjectures:
1. (Id, Id) is a MA-Set homomorphism for any (ℳ, 𝒜)-set.
   - Sketch: Id is a monoid homomorphism, and the coherence
     condition is true by ≈-reflexivity.

   - Formally:
      #+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda

id : ∀ {ℓ₁ ℓ₂} {MA : MA-Set ℓ₁ ℓ₂} → Hom MA MA
id = record
  { mor₁      = λ x → x
  ; mor₂      = λ x → x
  ; pres-Id   = refl
  ; pres-⊕    = refl
  ; coherence = refl
  }
 #+END_SRC

2. MA-Set homomorphisms are closed under composition.
   - Sketch: The composition of monoid homomorphisms is again
     a homomorphism; it remains to check coherence:
    #+BEGIN_SRC haskell
     (f₁ ∘ g₁) (m · a)
    = f₁ (g₁ (m · a))
    = f₁ (g₁ m · g₂ a)
    = f₁ (g₁ m) · f₂ (g₂ a)
    = (f₁ ∘ g₁) m · (f₂ ∘ g₂) a
#+END_SRC
    Whence, the coherence condition is true.

   - Formally:
    #+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
_∘_ : ∀ {ℓ₁ ℓ₂} {MA MB MC : MA-Set ℓ₁ ℓ₂} → Hom MB MC → Hom MA MB → Hom MA MC
_∘_ {MA = MA} {MB} {MC} F G = record
  { mor₁ = λ x → mor₁ F (mor₁ G x)
  ; mor₂ = λ x → mor₂ F (mor₂ G x)
  ; pres-Id = trans (cong (mor₁ F) (pres-Id G)) (pres-Id F)
  ; pres-⊕ = λ {x y} → begin
      mor₁ F (mor₁ G (_⊕_ MA x y))          ≡⟨ cong (mor₁ F) (pres-⊕ G) ⟩
      mor₁ F (_⊕_ MB (mor₁ G x) (mor₁ G y)) ≡⟨ pres-⊕ F ⟩
      _⊕_ MC (mor₁ F (mor₁ G x)) (mor₁ F (mor₁ G y)) ∎
  ; coherence = λ {m a} → begin
      mor₁ F (mor₁ G (_·_ MA m a)) ≡⟨ cong (mor₁ F) (coherence G) ⟩
      mor₁ F (_·_ MB (mor₁ G m) (mor₂ G a)) ≡⟨ coherence F ⟩
      _·_ MC (mor₁ F (mor₁ G m)) (mor₂ F (mor₂ G a)) ∎ }
 #+END_SRC

3. MA-Sets form a category.

The goal is then to show that MA-Sets have PackageFormer as an initial object!
---Initial semantics!

* COMMENT Monad Syntax 🚧                              :construction_site:

-- _▷_ : ∀ {ℓ} → (P : PackageFormer ℓ) → Declaration (toContext P) → PackageFormer ℓ
-- (parameters ❙ body) ▷ d@(n ∶ τ ≔ δ) = parameters ❙ λ p → body p ⊎ Just d

--------------------------------------------------------------------------------

-- TODO: Monad notation for PackageFormer
-- The type mismatch in >>= gives a quick, but unsound, implementation.

MA: Use Context′ instead! Neato ^_^
Then maybe “waist n” beforehand to run it into a PackageFormer.

infixr 1 _>>=_ _>>_

open PackageFormer

_>>=_ : ∀ {ℓ}
      → (P : PackageFormer ℓ)
      → ((Σ ξ ∶ parameters P • body P ξ) → Set ℓ) → PackageFormer ℓ
p >>= τ = p ⨾ₚ τ

_>>_ : ∀ {ℓ} → PackageFormer ℓ → PackageFormer ℓ → PackageFormer ℓ
p >> q = p ⊎ₚ q

‵_ : ∀ {ℓ} → Set ℓ → PackageFormer ℓ
‵ typ = Empty ⨾ₚ λ _ → typ

MonoidPF′ : PackageFormer {!!}
MonoidPF′ = do carrier ← ‵ Set
               point  ← ‵ Set
               ⊤

{-
typeP : ∀ {ℓ} → PackageFormer ℓ → Set (ℓsuc ℓ)
typeP {ℓ} (parameters ❙ body) = (Σ ξ ∶ parameters • body ξ) → Set ℓ

_⨾ₚ_ :  ∀ {ℓ} (p : PackageFormer ℓ)
       → typeP p
       → PackageFormer ℓ
(parameters ❙ body) ⨾ₚ d = parameters ❙ λ ξ → Σ β ∶ body ξ • d (ξ , β)
-}

* COMMENT Here are some laws that allow one to reach the claimed canonical form:
  1. `:waist w ⟴ :kind k ≈ :kind k ⟴ :waist w`

     Hence, we can always ensure `waist` appears before `kind`.

  2. More generally, `f ⟴ g ≈ g ⟴ f` whenever `f` and `g` are ‘disjoint’; whence
     ⨾-extensions also share this property with `:waist` and `:kind`.

     Thus we can always ensure ⨾-extensions appear before `:waist` and `:kind` clauses.

  3. `f₁ ⟴ f₂ ≈ f₂` for `fᵢ` both being either `:waist` clauses or `:kind` clauses.

     Hence, there will always be only one `:waist` and one `:kind` clause.

  Of-course these rules only permit the constructions `⟴, :waist, :kind` and
  ⨾-extensions. E.g., if the hammer `:alter-elements` is admitted, then little
  can be said since, say, one may re-arrange ⨾-extension elements according to
  their waist and kind, as is the case of Agda modules, wherein items above
  the waist *cannot* have definitional clauses.

* COMMENT Normal Forms 🚧                                 :construction_site:

  Ignoring the concrete syntax, every PackageFormer has a canonical flattened form:
#+begin_example haskell
LHS = ∅ ⨾ n₀ ∶ τ₀ ≔ d₀ ⨾ ⋯ ⨾ nₘ ∶ τₘ ≔ dₘ ⟴ :waist 𝓌 ⟴ :kind 𝓀
#+end_example

The “⨾” is read “extended-by” and the definitional clauses $dₖ$ may involve any
of the names $nᵢ$ for $i < k$.  It is an a *right* action:
#+begin_example haskell
_⨾_ : PackageFormer → Declaration → PackageFormer
#+end_example

# Where the semigroup structure on declarations is determined
# by sequential composition: If ~eᵢ~ are declarations, then ~e₀⨾⋯⨾eₙ~
# is a ‘single’ declaration.

The canonical form suggests that /PackageFormers are triples/
consisting of a context, a number, and a tag.

Instead of $∅ ⨾ n₀ ∶ τ₀ ≔ d₀ ⨾ ⋯ ⨾ nₘ ∶ τₘ ≔ dₘ ⟴ :waist 𝓌 ⟴ :kind 𝓀$ let us
write $e₀ ⨾ … ⨾ e_𝓌 ❙_{𝓀} e_{𝓌+1}⨾ … eₘ$.
- When the kind 𝓀 is uninteresting, or may be arbitrary, we shall omit it from
  the notation altogether. Likewise for the separator ‘❙’.

We may now define a composition operation on PackageFormers, via
pushout or disjoint union; e.g., $(Γ₁ ❙ Γ₂) ⊎ (Γ₁′ ❙ Γ₂′) = Γ₁″ ❙ Γ₂″$ where Γᵢ″
is catenation of Γᵢ and Γᵢ′, in some fixed chosen order.

We may also define a dual form of extension, known as “snoc” when ⨾ is read
“cons”.
#+begin_src haskell
_⸵_ : Declaration → PackageFormer → PackageFormer
e ⸵ (Γ₁ ❙ Γ₂) = ((∅ ⨾ e) ⊎ Γ₁) ❙ Γ₂
#+end_src

In the informal notation of contexts of type theory, the three operations ⸵, ⨾,
⊎ are denoted “,”.

*** PackageFormers and derived =_⊎_=
 #+BEGIN_SRC agda2 :tangle semantics-via-MA-Sets.agda
record PackageFormer : Set₁ where
  constructor _❙_
  field
    parameters : Context
    body       : Context′ parameters

_⊎ₚ_ : PackageFormer → PackageFormer → PackageFormer
(Γ₁ ❙ Γ₂) ⊎ₚ (Γ₁′ ❙ Γ₂′) = (Γ₁ ⊎ Γ₁′) ❙ [ Γ₂ , Γ₂′ ]
 #+END_SRC

* COMMENT Meta-Primitives as Functions 🚧                 :construction_site:

With a notation and understanding of what a PackageFormer
consists of, we are in a position to provide a semantics
for the meta-primitives.

# :waist, :kind, ▷, and ⟴ are syntactic constructors.

First, ~waist~ is lifted from a syntactic construct to a function operation on
PackageFormers as follows.
#+begin_src haskell
_waist_ : PackageFormer → ℕ → PackageFormer
(Γ₁ ❙ Γ₂) waist 0       = ∅ ❙ (Γ₁ ⊎ Γ₂)
(Γ₁ ❙ Γ₂) waist (n + 1) = (head Γ₁) ◁ (tail Γ₁ ❙ Γ₂) waist n

where head : PackageFormer → Maybe Declaration
      head ∅ = Nothing
      head (e₁, …, eₙ ❙ Γ₂) = Just e₁

      tail : PackageFormer → PackageFormer
      tail ∅ = ∅
      tail (e₁ ◁ Γ) = Γ
#+end_src

That is, if $Γ = e₀⨾ ⋯⨾ eₘ$, ignoring the separator, then
$Γ waist n ≈ e₀⨾ ⋯⨾ eₙ ❙ eₙ₊₁⨾ ⋯⨾ eₘ$. That is, =waist= introduces
a partition in a context. Operationally, only the associated number
component of a PackageFormer has been altered.

* COMMENT Shallow Embedding Approach :typechecks:

In the setup below, it seems using the context approach can sometimes be easier
than using the λ approach, even though they are essentially the same.
Intuitively:
| What doing? | Easier to use |
|-------------+---------------|
| Reasoning   | Context       |
| Programming | Functions     |

** Imports
 #+BEGIN_SRC agda2
module pf where

open import Level renaming (zero to ℓzero; suc to ℓsuc; _⊔_ to _⊍_)
open import Relation.Binary.PropositionalEquality using (_≡_; refl)
open import Data.Nat
open import Data.Unit
open import Data.Empty
open import Data.Bool
open import Data.List
open import Data.List.Membership.Propositional
open import Data.List.Relation.Unary.Any using (here; there)
open import Relation.Nullary using (yes; no)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.String using (String) renaming (_==_ to _==ₛ_; _≟_ to _≟ₛ_; _++_ to _++ₛ_)
open import Data.Product using (Σ ; proj₁ ; proj₂ ; _×_ ; _,_)

 #+END_SRC

** Syntax Declarations
 #+BEGIN_SRC agda2

Name = String

Σ∶• : ∀ {a b} (A : Set a) (B : A → Set b) → Set _
Σ∶• = Σ

infix -666 Σ∶•
syntax Σ∶• A (λ x → B) = Σ x ∶ A • B

infixr 10 Π
syntax Π A (λ x → B) = Π x ∶ A • B

infix 9 _⊢Term_

 #+END_SRC
** Contexts, types, and terms

   Contexts are types, level-indexed types are functions, τ-terms are functions taking
   the context and yielding a value.

  #+BEGIN_SRC agda2
PackageFormer : (i : Level) → Set (ℓsuc i)
PackageFormer i = Set i
 #+END_SRC

*** types
  Next, object-level universes are implemented using meta-level universes.
  - Note: =Γ ⊢Type 𝒾  ≡  Γ ⊢Term (𝒰 𝒾)=.

  #+BEGIN_SRC agda2
_⊢Type_ :  ∀ {i} → PackageFormer i → (j : Level) → Set (i ⊍ ℓsuc j)
Γ ⊢Type 𝒾 = Γ → Set 𝒾

𝒰 : ∀ {i} {Γ : PackageFormer i} (j : Level) → Γ ⊢Type (ℓsuc j)
𝒰 j = λ γ → Set j
  #+END_SRC
*** terms
  #+BEGIN_SRC agda2
_⊢Term_ : ∀ {i j} → (Γ : PackageFormer i) → Γ ⊢Type j → Set (i ⊍ j)
Γ ⊢Term τ = (γ : Γ) → τ γ
  #+END_SRC

  After all, a classical context ~x₁ : τ₁, …, xₙ : τₙ ⊢ e : τ~ only /asserts/ =e : τ=
  /provided/ =xᵢ : τᵢ=, and so the latter is a function of the former! Indeed, as the
  λ-introduction rule shows, *all contexts are the humble function*
  ---e.g., with church encodings, we have that algebraic data-types are also
  functions, the eliminators.
  + MA: Perhaps with this neato observation, I should simply focus on functions?

*** context constructors

  The empty context is the unit type and context extension is interpreted using Σ-types.
  The identity of dependent products is the unit type, whence it denotes the empty PackageFormer.

 #+BEGIN_SRC agda2
ε : PackageFormer ℓzero
ε = ⊤

_▷_ : ∀ {i j} (Γ : PackageFormer i) → Γ ⊢Type j → PackageFormer (i ⊍ j)
Γ ▷ A = Σ γ ∶ Γ • A γ

  #+END_SRC
** Coercisions and Π

 #+BEGIN_SRC agda2
weaken : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type k}
       → Γ ⊢Type j → (Γ ▷ A) ⊢Type j
weaken τ (γ , a) = τ γ

pf-refl : ∀ {i j} {Γ : PackageFormer i} {A : Γ ⊢Type j}
        → (Γ ▷ A) ⊢Term weaken A
pf-refl = proj₂

Π : ∀ {i j k} {Γ : PackageFormer i} (A : Γ ⊢Type j) (B : (Γ ▷ A) ⊢Type k)
  → Γ ⊢Type (j ⊍ k)
Π A B = λ γ → ∀ (a : A γ) → B (γ , a)

_⇒_ : ∀ {i j k} {Γ : PackageFormer i} (A : Γ ⊢Type j) (B : Γ ⊢Type k)
    → Γ ⊢Type (j ⊍ k)
A ⇒ B = Π A (weaken B)

 #+END_SRC
** =lam= and =app=
 Abstraction and application are just Currying & Uncurrying
 #+BEGIN_SRC agda2
lam : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type j} {B : (Γ ▷ A) ⊢Type k}
    → (Γ ▷ A) ⊢Term B  →  Γ ⊢Term (Π A B)
lam g = λ γ → λ a → g (γ , a)

app : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type j} {B : (Γ ▷ A) ⊢Type k}
      →  Γ ⊢Term (Π A B)  → (Γ ▷ A) ⊢Term B
app g = λ{(γ , a) → g γ a}
 #+END_SRC

 Here are other forms of function application.
 #+BEGIN_SRC agda2
cut′ : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type j} {B : Γ ⊢Type k}
      →  (Γ ▷ A) ⊢Term weaken B
      →  Γ       ⊢Term A
      →  Γ       ⊢Term B
cut′ f a = λ γ → f (γ , a γ)

_on_ : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type j}
      → (Γ ▷ A) ⊢Type k
      →  Γ ⊢Term A
      →  Γ ⊢Type k
f on a = λ γ → f (γ , a γ)

cut : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type j} {B : (Γ ▷ A) ⊢Type k}
      →  (Γ ▷ A) ⊢Term B
      →  (a : Γ  ⊢Term A)
      →  Γ       ⊢Term (B on a)
cut f a = λ γ → f (γ , a γ)

_$_ : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type j} {B : (Γ ▷ A) ⊢Type k}
      → Γ ⊢Term (Π A B)
      → (a : Γ ⊢Term A)
      → Γ ⊢Term (B on a)
_$_ g = λ a γ → g γ (a γ)
 #+END_SRC

** Example terms!

 #+BEGIN_SRC agda2
‵id : ε ⊢Term Π A ∶ 𝒰 ℓzero • let A′ = λ _ → proj₂ A -- weakening.
                              in (A′ ⇒ A′) ε
‵id = lam (lam proj₂)
 #+END_SRC

 Let's try to show that =pf-refl= really is the identity function, up to isomorphism.
 #+BEGIN_SRC agda2
‵id₂ : ∀ {i j} {Γ : PackageFormer i} {A : Γ ⊢Type j}
     → Γ ⊢Term A ⇒ A
‵id₂ = lam pf-refl
 #+END_SRC

 Neato! Progress, finally (งಠ_ಠ)ง
* COMMENT Old Approach using Deep Embedding :incomplete:holes:

  #+begin_example agda2
module pf where
#+end_example
** Imports
#+begin_example agda2
open import Relation.Binary.PropositionalEquality using (_≡_; refl)
open import Data.Nat
open import Data.Unit
open import Data.Empty
open import Data.Bool
open import Data.List
open import Data.List.Membership.Propositional
open import Data.List.Relation.Unary.Any using (here; there)
open import Relation.Nullary using (yes; no)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.String using (String) renaming (_==_ to _==ₛ_; _≟_ to _≟ₛ_; _++_ to _++ₛ_)
open import Data.Product using (Σ ; proj₁ ; proj₂ ; _×_ ; _,_)
Name = String
#+end_example
** Fixity & syntax declarations
#+begin_example agda2
infix 11 eq
syntax eq τ l r  =  l ‵≡ r ∶ τ

infixr 10 _‵→_ ‵∀
syntax ‵∀ τ (λ η → γ) = Π η ∶ τ • γ -- “Z-notation”

-- infixl 9 _∶_ _∶_≔_
infixl 9 _∶_

infixl 5 _extended-by_

Σ∶• : ∀ {a b} (A : Set a) (B : A → Set b) → Set _
Σ∶• = Σ

infix -666 Σ∶•
syntax Σ∶• A (λ x → B) = Σ x ∶ A • B
#+end_example
** Declarations for mutually recursive DTL concepts
#+begin_example agda2
data PF : Set                          -- Syntax of PackageFormers; i.e., contexts
data _⊢Type (Γ : PF) : Set             -- Types in context
type-names-of : PF → List Name
-- types-of : (Γ : PF) → List (Γ ⊢Type)   -- The collection of types mentioned in a context
record _⊢constituent (Γ : PF) : Set    -- The type of terms
data _⊢Term:_ (Γ : PF) : Γ ⊢Type → Set -- Terms in context
#+end_example
** PackageFormer syntax
#+begin_example agda2
data PF where
  empty : PF
  _extended-by_ : (Γ : PF) → Γ ⊢constituent → PF
#+end_example
** “declarations in context”
#+begin_example agda2
record _⊢constituent Γ where
  -- constructor _∶_≔_
  constructor _∶_
  inductive
  field
    name     : Name
    type     : Γ ⊢Type
    -- equation : Maybe (Γ ⊢Term: type)
    -- Ommitted for brevity

open _⊢constituent

{-
_∶_ : ∀ {Γ} → Name → Γ ⊢Type → Γ ⊢constituent
x ∶ τ = x ∶ τ ≔ nothing
-}
#+end_example
** Decision procedure for tedious proofs
#+begin_example agda2
-- Soundness: Let's construct a decision procedure that actually provides tedious proofs.
-- This is used in the ADT “_⊢Type”.

data Error : String → Set where

present? : Name → List Name → Set
present? η []       = Error ("The type “" ++ₛ η ++ₛ "” is not in the parent context!")
present? η (n ∷ ns) with η ==ₛ n
...| true  = ⊤
...| false = present? η ns

soundness : ∀ {η ns} → present? η ns → η ∈ ns
soundness {η} {n ∷ ns} p with η ≟ₛ n
...| yes q = here q
...| no ¬q = there (soundness p)

tedious-example : "C" ∈ ("A" ∷ "B" ∷ "C" ∷ "D" ∷ [])
tedious-example = there (there (here refl))

improved-example : "C" ∈ ("A" ∷ "B" ∷ "C" ∷ "D" ∷ [])
improved-example = soundness tt

-- Uncomment to see an error since c is not in the list.
-- useful-error-msg : "c" ∈ ("A" ∷ "B" ∷ "C" ∷ "D" ∷ [])
-- useful-error-msg = soundness tt
#+end_example
** “types in context”
#+begin_example agda2
{-
  τ ∷= Set       “universe of types”
     | τ → τ     “function types”
     | α         “atomic types mentioned in the context”
     | e ≡ d     “term equality in context”
-}

data _⊢Type Γ where

  ‵Set  : Γ ⊢Type                                        -- type of small types

  -- ‵∀ : (τ : Γ ⊢Type) (body : Γ ⊢Term: τ → Γ ⊢Type) → Γ ⊢Type -- Pi types, we fail the positivity checker.
  -- In the spirit of gradual typing, we use a weaker form: The assumed term losses any possible definiens, equations.
  ‵∀ : (τ : Γ ⊢Type) (body : (η : Name) → (Γ extended-by η ∶ τ) ⊢Type) → Γ ⊢Type

  _‵→_ : Γ ⊢Type → Γ ⊢Type → Γ ⊢Type -- function type; making this derived requires a weak form of commuatvity at the context level

  -- variable case; the name must be mentioned in Γ
  ‵_   : (η : Name) {{_ : present? η (type-names-of Γ)}} → Γ ⊢Type

  eq : (τ : Γ ⊢Type) (l r : Γ ⊢Term: τ) → Γ ⊢Type

{-
_‵→_ : {Γ : PF} → Γ ⊢Type → Γ ⊢Type → Γ ⊢Type -- function type
τ ‵→ γ = Π _ ∶ τ • weaken γ
-}
#+end_example
** =type-names-of=
#+begin_example agda2
type-names-of empty = []
type-names-of (pf extended-by name₁ ∶ ‵Set) = name₁ ∷ type-names-of pf
type-names-of (pf extended-by _) = type-names-of pf
#+end_example
** A hierarchy of dependent weakening rules
#+begin_example agda2
{-
weaken1 : ∀ {Γ e} → Γ ⊢Type → (Γ extended-by e) ⊢Type

insert-before-last : ∀ {Γ η e τ} → (Γ extended-by η ∶ τ) ⊢Type
                                 → (Γ extended-by e extended-by η ∶ weaken1 τ) ⊢Type

insert-before-second-last : ∀ {Γ η₁ η₂ τ₁ τ₂ e}
 → (Γ extended-by               η₁ ∶         τ₁ extended-by η₂ ∶  τ₂) ⊢Type
 → (Γ extended-by e extended-by η₁ ∶ weaken1 τ₁ extended-by η₂ ∶ insert-before-last τ₂) ⊢Type
insert-before-second-last τ = {!!}

insert-before-last ‵Set = ‵Set
insert-before-last (‵∀ τ body) = Π η ∶ insert-before-last τ •  insert-before-second-last (body η)
insert-before-last (τ ‵→ τ₁) = {!!}
insert-before-last (‵ η) = {!!}
insert-before-last (eq τ l r) = {!!}

weaken1 ‵Set        = ‵Set
weaken1 (‵∀ τ body) = Π η ∶ weaken1 τ • insert-before-last (body η)
weaken1 (τ ‵→ τ₁)   = {!!}
weaken1 (‵ η)       = {!!}
weaken1 (eq τ l r)  = {!!}
-}

{- Other weakening rules
weaken-cons : ∀ {Γ e} → Γ ⊢constituent → (Γ extended-by e) ⊢constituent

weaken-mid : ∀ {Γ pre post new} → (Γ extended-by pre extended-by post) ⊢Type
                                → (Γ extended-by pre extended-by new extended-by weaken-cons post) ⊢Type
-}
#+end_example
** How many ‘arguments’ does a type have?
#+begin_example agda2
{-

arity : ∀ {Γ} → Γ ⊢Type → ℕ
arity ‵Set        = 0
arity (‵∀ τ body) = 1 + arity (body "_") -- Hack; possible since names are strings.
arity (τ ‵→ τ₁)   = 1 + arity γ  -- E.g., α ‵→ (β ‵→ γ) has 2 arguments.
arity (‵ η)       = {!!} -- Need to consider its type in Γ
arity (eq τ l r)  = 0
-}
#+end_example
** The subparts of a type expression
#+begin_example agda2
{--

-- An alias for _≡_; a singleton type
data JustThis {A : Set} : A → Set where
  this : (a : A) → JustThis a

-- If arity τ = 0 then ⊤ else the type of the first argument.
type-head : ∀ {Γ} → Γ ⊢Type → Set
type-head ‵Set      = ⊤
type-head (τ ‵→ _)  = JustThis τ
type-head _  = ⊤

-- If arity τ = 0 then ⊤ else the type of the first argument.
type-tail : ∀ {Γ} → Γ ⊢Type → Γ ⊢Type
type-tail τ = {!!}
-}
#+end_example
** “terms in context”
#+begin_example agda2
data _⊢Term:_ Γ where

  -- TODO: “x must be fresh for Γ”; variable case
  ‵_  : {τ : Γ ⊢Type} (x : Name) → Γ ⊢Term: τ

  -- curried function application
  -- _$_ : (f : Γ ⊢constituent) → type-head (type f) → Γ ⊢Term: type-tail (type f) -- Omitted for brevity
#+end_example
** Examples
#+begin_example agda2
Type : PF
Type = empty extended-by "Carrier" ∶ ‵Set

Indistinguishable : PF
Indistinguishable = Type extended-by
                         "blind" ∶ Π 𝓁 ∶ ‵ "Carrier" • Π 𝓇 ∶ ‵ "Carrier" • ‵ 𝓁 ‵≡ ‵ 𝓇 ∶ ‵ "Carrier"

Pointed : PF
Pointed = Type extended-by "𝟙" ∶ ‵ "Carrier"
-- Typos such as forgetting the final letter produce type-checking errors:
-- The type “Carrie” is not in the parent context!
-- Pointed = Type extended-by "𝟙" ∶ ‵ "Carrie"

Magma : PF
Magma = Type extended-by "_·_" ∶ ‵ "Carrier" ‵→ ‵ "Carrier" ‵→ ‵ "Carrier"
#+end_example
** Semantics
#+begin_example agda2
terms : PF → List (Σ Γ ∶ PF • Γ ⊢constituent)
terms empty = []
terms (p extended-by x) = terms p ++ [ p , x ]

Type-names-of : PF → Set
Type-names-of Γ = Σ η ∶ Name • present? η (type-names-of Γ)

semₜ : ∀ {Γ} → (Type-names-of Γ → Set₁) → Γ ⊢Type → Set₂
semₑ : ∀ {Γ} {τ : Γ ⊢Type} (σ : Type-names-of Γ → Set₁) → Γ ⊢Term: τ → Set₁ -- semₜ σ τ  ⇐  free variables are just placeholders for the types they represent

semₑ {Γ} {τ} σ (‵ x) = {!semₜ σ τ!}

open import Level using (Lift)

semₜ σ ‵Set          = Set₁
semₜ σ (‵∀ τ body)   = ∀ (x : semₜ σ τ) → ⊥ -- TODO
semₜ σ (τ ‵→ γ)      = semₜ σ τ → semₜ σ γ
semₜ σ (‵_ η {{p}})  = Lift _ (σ (η , p))
semₜ σ (eq τ l r)    = semₑ σ l ≡ semₑ σ r  -- ARGH: semₑ must yield Set₁ so it can be used in semₜ !!!!!!  -- JC, what do?

{-
present?-tn : ∀ {η Γ e} →   present? η (type-names-of (Γ extended-by e))
                          ≡ (if   (η ==ₛ name e)
                             then ⊤
                             else present? η (type-names-of Γ))
present?-tn {η} {Γ} {e} with type-names-of (Γ extended-by e) | η ==ₛ name e
present?-tn {η} {Γ} {e} | [] | false = {!!}
present?-tn {η} {Γ} {e} | [] | true = {!!}
present?-tn {η} {Γ} {e} | x ∷ xs | t = {!!}


weaken-present? : ∀ {η Γ e} → present? η (type-names-of Γ)
                            → present? η (type-names-of (Γ extended-by e))
weaken-present? {η} {Γ = Γ} p with type-names-of Γ | p
weaken-present? {η} {Γ = Γ} p | x ∷ xs | q with η ==ₛ x
weaken-present? {η} {Γ} p | x ∷ xs | q | false = {!!}
weaken-present? {η} {Γ} p | x ∷ xs | q | true = {!!}
-}

weaken : ∀ {Γ e}  → Γ ⊢Type → (Γ extended-by e) ⊢Type
weaken ‵Set        = ‵Set
weaken (‵∀ τ body) = {!!}
weaken (τ ‵→ γ)   = weaken τ ‵→ weaken γ
weaken (‵_ η {{p}})       = ‵_ η {{{!!}}}
weaken (eq τ l r)  = {!!}

terms′ : (Γ : PF) (σ : Γ ⊢Type → Set) → List (Σ Γ′ ∶ PF • Set × Γ′ ⊢constituent)
terms′ empty σ = []
terms′ (p extended-by e@(η ∶ τ)) σ = terms′ p (λ x → σ (weaken x)) ++ [ p , σ (weaken τ) , e ] -- terms′ p {!!} ++ [ p , {!!} , {!x!} ]
-- terms p ++ [ p , x ]


{-
sem : (Γ : PF) (σ : Γ ⊢Type → Set) (α : (η : Name) → Σ T ∶ Set • T) → Set
sem p σ α with terms p
...| [] = ⊥
...| (_ , η ∶ τ) ∷ xs = {!!}
  where -- function patching
        α′ : Name → Σ T ∶ Set • T
        α′ n = if n ==ₛ η then (σ {!!}) , {!!} else α n
-}

#+end_example
** Further experiments
#+begin_example agda2
{-
-- TODO: Add support for catenating PFs.
--
-- _⌢_ : PF → PF → PF
-- l ⌢ empty = l
-- l ⌢ (r extended-by x) = (l ⌢ r) extended-by {! need a weakening rule!}
--

monoid : PF
monoid = empty extended-by "Carrier" ∶ ‵Set
               extended-by "_·_" ∶ ‵ "Carrier" ‵→ ‵ "Carrier" ‵→ ‵ "Carrier"
               extended-by "𝟙" ∶ ‵ "Carrier"
               extended-by "assoc" ∶ {!!}
-}
  #+end_example
