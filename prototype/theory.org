#+title: Progressing on a type theory for =PackageFormer=
#+author: Musa Al-hassy
#+agda_version: 2.6.0.1

# Some blocks are marked ‚Äúhaskell‚Äù so that they are coloured and #not#
# interpreted as agda blocks. They're informal and do not typecheck.
#
# Could have used agda2-example blocks, but wanted the colouring.

*Status:* I cannot seem to phrase, let alone prove, the =stablity‚Ä≤= claim for
 dynamic systems.
+ See the very bottom of this article.

# (shell-command "ln -s theory.org readme.org")

* Table of Contents                                    :Github:TOC_4:
- [[#introduction][Introduction]]
- [[#preamble][Preamble]]
  - [[#module-header][Module header]]
  - [[#imports][Imports]]
  - [[#syntax-declarations][Syntax Declarations]]
  - [[#helper-utilities][Helper Utilities]]
    - [[#level-polymorphic-unit-type][Level-Polymorphic Unit Type]]
- [[#what-is-a-type-theory][What is ‚Äúa type theory‚Äù?]]
- [[#our-ambient-type-theory][Our Ambient Type Theory]]
- [[#user-interface-for-context-declaration][User Interface for Context Declaration]]
  - [[#smart-constructors-as-do-notation][Smart Constructors as Do Notation]]
  - [[#example-records-of-ùìÉ-many-pointed-sets][Example: Records of ùìÉ-many Pointed Sets]]
    - [[#types][Types]]
    - [[#instances][Instances]]
  - [[#doubly-pointed-example----on-the-nature-of-parameters-Œæ][Doubly-Pointed Example -- On the nature of parameters Œû]]
  - [[#example--a-record-type-with-invariants][Example ‚Äì A record type with invariants]]
- [[#parameterised-records][Parameterised Records]]
  - [[#header][Header]]
    - [[#reflection-helpers][Reflection Helpers]]
    - [[#products-and-tuple-notation][Products and ‚ü®Tuple‚ü© Notation]]
  - [[#introduction-1][Introduction]]
  - [[#definitions-context-_-end][Definitions: ~Context, ‚Äµ_, End~]]
  - [[#definitions-__][Definitions: ~_>>_~]]
  - [[#example-dynamical-systems][Example: Dynamical Systems]]
  - [[#theorems-stablity][Theorems: ~stablity~]]
  - [[#natural-number-instance][Natural Number Instance]]
  - [[#œÄŒª-and-modus-ponens][Œ†‚ÜíŒª and Modus Ponens]]
  - [[#defining-_waist_][Defining =_:waist_=]]
  - [[#further-natural-number-instances-and-fixing-parameters][Further Natural Number Instances and Fixing Parameters]]
  - [[#example----collections][Example ---Collections]]
  - [[#projections][Projections]]

* Introduction

  For brevity, every PackageFormer declaration can essentially be seen as a
  sequence of declarations, some of which are considered /parameters/ and the rest
  are the /body/. Whence, a PackageFormer is a pair of contexts.

  Let's try to explain that idea.

  + We shall embed the syntax of PackageFormers using semantics functions.
  + For now, we only focus on the record semantics of a PackageFormer. ---i.e.,
    ~:kind record~.

* Preamble
** Module header
#+BEGIN_SRC agda2 :tangle semantics.agda
-- The .agda file is trangled from an org file.
module semantics where
#+END_SRC
** Imports
#+BEGIN_SRC agda2 :tangle semantics.agda
open import Data.Product
open import Data.Nat
open import Data.Sum
open import Relation.Binary.PropositionalEquality hiding ([_])
open ‚â°-Reasoning
open import Level renaming (zero to ‚Ñì‚ÇÄ; suc to ‚Ñìsuc; _‚äî_ to _‚äç_)

import Data.Nat  as ‚Ñï
open import Data.Fin  as Fin using (Fin)
open import Data.Bool renaming (Bool to ùîπ)
#+END_SRC
** Syntax Declarations
#+BEGIN_SRC agda2 :tangle semantics.agda
Œ£‚à∂‚Ä¢ : ‚àÄ {a b} (A : Set a) (B : A ‚Üí Set b) ‚Üí Set _
Œ£‚à∂‚Ä¢ = Œ£

infix -666 Œ£‚à∂‚Ä¢
syntax Œ£‚à∂‚Ä¢ A (Œª x ‚Üí B) = Œ£ x ‚à∂ A ‚Ä¢ B
#+END_SRC

** Helper Utilities
*** Level-Polymorphic Unit Type
#+BEGIN_SRC agda2 :tangle semantics.agda
record ‚ä§ {‚Ñì} : Set ‚Ñì where
  constructor tt
#+END_SRC
*** COMMENT Singleton Types
We'll be treating contexts as sets and so will require a singleton types for
adjoining declarations.
#+BEGIN_SRC agda2 :tangle semantics.agda
data Just {‚Ñì} {A : Set ‚Ñì} : A ‚Üí Set where
  just : (a : A) ‚Üí Just a
#+END_SRC
* What is ‚Äúa type theory‚Äù?
  To get anything done, we'll need an ambient type theory that provides us with
  a set of variable names ùïç and typing judgements. The comments below are what a
  classical type theory would have.
#+BEGIN_SRC agda2
record TypeTheory : Set‚ÇÅ where
  field
    -- An infinite set of variable names
    ùïç       : Set
    -- A collection of name-type pairs
    Context : Set
    -- Possible expressions in a given context
    Expr    : Context ‚Üí Set
    -- When is an expression considered a ‚Äòtype‚Äô
    _‚ä¢_type : (Œì : Context) ‚Üí Expr Œì ‚Üí Set
    -- When is a term considered to be ‚Äúof a type‚Äù
    _‚ä¢_‚à∂_   : (Œì : Context) ‚Üí Expr Œì ‚Üí Expr Œì ‚Üí Set
#+END_SRC
When Œì is fixed and if we denote ~Œì ‚ä¢ e ‚à∂ œÑ~ by ~e ‚ü∂ œÑ~ then we obtained a directed
graph where an edge may be construed as ‚Äòabstract interpreter‚Äô relationship
---the ‚Äòvalue‚Äô of an expression is its type.

It seems that with the typing judgement, we can regain the kinding judgement:
~Œì ‚ä¢ œÑ type ‚áî ‚àÄ (v : ùïç) ‚Üí Œì ‚ä¢ v ‚à∂ œÑ~.

Within a type theory, we can define a notion of declarations.
#+BEGIN_SRC agda2
  data Declaration (Œì : Context) : Set where
    _‚à∂_‚âî_by_and_ : (n : ùïç) (œÑ Œ¥ : Expr Œì) ‚Üí Œì ‚ä¢ œÑ type ‚Üí Œì ‚ä¢ Œ¥ ‚à∂ œÑ ‚Üí Declaration Œì
#+END_SRC

  :Informal_Type_of_Declarations:
  Given an ambient type theory ùëª, we define the type =Declaration= to be the
  triples ~n ‚à∂ œÑ ‚âî Œ¥~ where =n= is a ‚Äòname‚Äô, =œÑ= is a type of the given type theory, and
  =Œ¥= is a term over that type theory, possibly adjoined with other declarations
  =n·µ¢ : œÑ·µ¢ ‚âî Œ¥·µ¢=; i.e., the context ~ùëª, n‚ÇÄ : œÑ‚ÇÄ ‚âî Œ¥‚ÇÄ, ‚Ä¶, n‚Çò : œÑ‚Çò ‚âî Œ¥‚Çò~ ensures ~œÑ~ is
  a type and ~Œ¥~ is of that type, and ~n~ must be a fresh name.
  :End:

The purpose of this section is merely to make it clear what a type theory
consists of ---we will not make any instances of the ~TypeTheory~ record type.
+ It is a learning moment, for me.

* Our Ambient Type Theory
Rather than working with an opaque, and generic, instance of a type theory, we
will work with a particular instance: Agda's type theory.

| We ignore syntax and jump straight to semantics ---whence no expression type! |

0. At the level of semantics, we may use Agda's variables instead of a
   dedicated variable type.
1. A context is nothing more than a set.
   - With the ‚Äòsmart constructors‚Äô below, a context is a dependent sum of types
     wherein later type-declarations may depend on earlier ones.
2. A type /determined by/ a context is a set than can be obtained
   using the context.

#+BEGIN_SRC agda2 :tangle semantics.agda
Context = Œª ‚Ñì ‚Üí Set ‚Ñì
#+END_SRC
#+BEGIN_SRC agda2
type : ‚àÄ {‚Ñì} ‚Üí Context ‚Ñì ‚Üí Set (‚Ñìsuc ‚Ñì)
type {‚Ñì} Œì = Œì ‚Üí Set ‚Ñì
#+END_SRC

With this elementary setup, we can, for example, denote context extension with
existentials, also known as dependent products ---whose unit, a singleton type,
acts as the ‚Äúempty context‚Äù:
#+BEGIN_SRC agda2
‚àÖ : Context ‚Ñì‚ÇÄ
‚àÖ = ‚ä§

_‚®æ_ : ‚àÄ {‚Ñì} (Œì : Context ‚Ñì) (œÑ : type Œì) ‚Üí Context ‚Ñì
Œì ‚®æ œÑ = Œ£ Œ≥ ‚à∂ Œì ‚Ä¢ œÑ Œ≥
#+END_SRC
These names are not exported to the resulting Agda file, since they are not
needed. In particular, we will ‚Äòreuse‚Äô these names until we have ‚Äòsatisfactory‚Äô
definitions.

* User Interface for Context Declaration

** Smart Constructors as Do Notation
  Agda allows one to use an imperative style of programming ---using
  ~do~-notation--- provided there are mixfix functions ~_>>=_~ and ~_>>_~ in scope.
  + Importantly, only their existence is required; nothing else is assumed.
  + In particular, no monadic type constructor need be implicitly available.
    - This is the feature we exploit.

#+BEGIN_SRC agda2 :tangle semantics.agda
infixr 1 _>>=_

_>>=_ : ‚àÄ {a ‚Ñì}
      ‚Üí (Œì : Context a)
      ‚Üí (Œì ‚Üí Context ‚Ñì)
      ‚Üí Context (a ‚äç ‚Ñì)
Œì >>= f = (Œ£ Œ≥ ‚à∂ Œì ‚Ä¢ f Œ≥)
-- The new piece, f Œ≥, is kept along with the old existing context via ‚ÄúŒ≥ ‚à∂ Œì‚Äù.

-- Using the default definition of _>>_
infixr 1 _>>_
_>>_ : ‚àÄ {a b} ‚Üí Context a ‚Üí Context b ‚Üí Context (a ‚äç b)
p >> q = p >>= (Œª _ ‚Üí q)
#+END_SRC

The notation may be ~do‚Ä¶End~ using the following combinator.
However, in general, it may be ~do‚Ä¶ùíÆ~ for any set expression ùíÆ.
#+BEGIN_SRC agda2 :tangle semantics.agda
End : ‚àÄ {‚Ñì} ‚Üí Context ‚Ñì
End {‚Ñì} = ‚ä§ {‚Ñì}
#+END_SRC

These two pieces together are the aforementioned ‚Äòsmart constructors‚Äô:
+ ~Œì ‚®æ œÑ~ is given the new syntax as ~Œì >>= œÑ~.
+ ~‚àÖ~ is given the syntax ~End~.

# You could define _>>=_ and End as aliases for _‚®æ_ and ‚àÖ.

/It is important to remember that these smart constructors form grouping
mechanisms, not instances of them/; which is accomplished using tuples.

** Example: Records of ùìÉ-many Pointed Sets

   What do PackageFormers look like using the ~do~-notation and what do their
   instances look like? Surprisingly close to existing Agda record syntax for
   declarations and Agda tuples for instances.

*** Types
Let's form a grouping consisting of a single type and a value of that type,
along with an instance of the parameter type Œû.
#+BEGIN_SRC agda2 :tangle semantics.agda
PointedPF : (Œû : Context (‚Ñìsuc ‚Ñì‚ÇÄ)) ‚Üí Context (‚Ñìsuc ‚Ñì‚ÇÄ)
PointedPF Œû = do Carrier ‚Üê Set
                 point   ‚Üê Carrier
                 Œû
#+END_SRC

Let's consider concrete instances of the parameter Œû.
#+BEGIN_SRC agda2 :tangle semantics.agda
-- A record type --- Œ£ Set ‚à∂ Carrier ‚Ä¢ Œ£ point ‚à∂ Carrier ‚Ä¢ ‚ä§
PointedSet = PointedPF ‚ä§

-- An extended record type
-- Œ£ Set ‚à∂ Carrier‚ÇÅ ‚Ä¢ Œ£ point‚ÇÅ ‚à∂ Carrier‚ÇÅ ‚Ä¢ (Œ£ Carrier‚ÇÇ ‚à∂ Set ‚Ä¢ Œ£ point‚ÇÇ ‚à∂ Carrier‚ÇÅ ‚Ä¢ ‚ä§)
TwoPointedSets = PointedPF PointedSet
#+END_SRC
More generally:
#+BEGIN_SRC agda2 :tangle semantics.agda
_PointedSets : ‚Ñï ‚Üí Set‚ÇÅ
zero  PointedSets = ‚ä§
suc n PointedSets = PointedPF (n PointedSets)

-- C-c C-n 4 PointedSets ‚áí Somewhat readable definition of the record!
#+END_SRC

Here we already have power: It's difficult to create the family of types =n
PointedSets= using existing Agda record syntax since the number of fields, /2 √ó n/,
depends on =n=.

| Record /structure/ can be dependent on values! |

*** Instances
#+BEGIN_SRC agda2 :tangle semantics.agda
example‚ÇÅ : PointedSet
example‚ÇÅ = ‚Ñï , 0 , tt

example‚ÇÇ : PointedSet
example‚ÇÇ = Fin.Fin 3 , Fin.suc Fin.zero , tt

example‚ÇÉ : TwoPointedSets
example‚ÇÉ = ùîπ , true , example‚ÇÅ
-- A pointed nat extended by a pointed bool, with particular choices for both.
#+END_SRC

** Doubly-Pointed Example -- On the nature of parameters Œû
What is a parameter exactly?

#+BEGIN_SRC agda2 :tangle semantics.agda
TwoParameterPoints : ‚àÄ {‚Ñì} (Œû : Context ‚Ñì) ‚Üí Context ‚Ñì
TwoParameterPoints {‚Ñì} Œû = do one   ‚Üê Œû
                              two   ‚Üê Œû
                              End {‚Ñì}

-- C-c C-n TwoParameterPoints   ‚áí   Œª Œû ‚Üí Œ£ one ‚à∂ Œû ‚Ä¢ Œ£ two ‚à∂ Œû ‚Ä¢ ‚ä§

-- Emphasise when sets are to be thought of as contexts
LitCtx : ‚àÄ {‚Ñì} ‚Üí Set ‚Ñì ‚Üí Context ‚Ñì
LitCtx = Œª c ‚Üí c

example‚ÇÑ : TwoParameterPoints (LitCtx ùîπ)
example‚ÇÑ = false , false , tt  -- Obtained with C-c C-a

example‚ÇÖ : TwoParameterPoints PointedSet
example‚ÇÖ = example‚ÇÅ , example‚ÇÇ , tt
#+END_SRC

** Example ‚Äì A record type with invariants

We can simulate definitions in a record via type invariants.

#+BEGIN_SRC agda2 :tangle semantics.agda
infix -1000 Property_
Property_ : ‚àÄ {‚Ñì} ‚Üí Set ‚Ñì ‚Üí Context ‚Ñì -- Intended as invariants.
Property_ = Œª c ‚Üí c                   -- In some contexts, the values could be irrelevant.

PointedMagma : ‚àÄ {‚Ñì} ‚Üí Context ‚Ñì ‚Üí Context (‚Ñìsuc ‚Ñì)
PointedMagma {‚Ñì} Œû = do Carrier ‚Üê Set ‚Ñì
                        _‚äï_     ‚Üê (Carrier ‚Üí Carrier ‚Üí Carrier)
                        one     ‚Üê Carrier
                        two     ‚Üê Carrier
                        three   ‚Üê Carrier
                        Property two   ‚â° one ‚äï one
                        Property three ‚â° one ‚äï two
#+END_SRC
The multiple laws, along with the following instance, increase confidence
in our definitions of ~_>>=_~ and ~_>>_~.
#+BEGIN_SRC agda2 :tangle semantics.agda
example‚ÇÜ : PointedMagma ‚ä§
example‚ÇÜ = ‚Ñï , ‚Ñï._+_ , 4 , 8 , 12 , refl {x = 8} , refl {x = 12}
#+END_SRC

* Parameterised Records

** Header
  #+begin_src agda2 :tangle semantics-with-waist.agda
module semantics-with-waist where

open import Level renaming (_‚äî_ to _‚äç_; suc to ‚Ñìsuc; zero to ‚Ñì‚ÇÄ)
open import Data.Nat
open import Relation.Binary.PropositionalEquality
open import Relation.Nullary
open import Data.Empty
open import Data.Bool using (Bool ; true ; false)
open import Data.List using (List ; [] ; _‚à∑_ ; _‚à∑ ≥_)

-- ‚Äús ‚âî v‚Äù is just a way to document v with string s.
open import Data.String using (String)
_‚âî_ : ‚àÄ {‚Ñì} {A : Set ‚Ñì} ‚Üí String ‚Üí A ‚Üí A
s ‚âî v = v
infix 9 _‚âî_

-- Used in an example later on; too boring to be placed there.
data Digit : Set where
  #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 : Digit

#‚Üí‚Ñï : Digit ‚Üí ‚Ñï
#‚Üí‚Ñï #0 = 0
#‚Üí‚Ñï #1 = 1
#‚Üí‚Ñï #2 = 2
#‚Üí‚Ñï #3 = 3
#‚Üí‚Ñï #4 = 4
#‚Üí‚Ñï #5 = 5
#‚Üí‚Ñï #6 = 6
#‚Üí‚Ñï #7 = 7
#‚Üí‚Ñï #8 = 8
#‚Üí‚Ñï #9 = 9
     #+end_src

*** Reflection Helpers
     #+begin_src agda2 :tangle semantics-with-waist.agda
import Data.Unit as Unit
open import Reflection hiding (name; Type) renaming (_>>=_ to _>>=‚Çò_)

-- Single argument application
_app_ : Term ‚Üí Term ‚Üí Term
(def f args) app arg‚Ä≤ = def f (args ‚à∑ ≥ arg (arg-info visible relevant) arg‚Ä≤) -- keep existing arguments!
{-# CATCHALL #-}
tm app arg‚Ä≤ = tm

-- Reify ‚Ñï term encodings as ‚Ñï values
to‚Ñï : Term ‚Üí ‚Ñï
to‚Ñï (lit (nat n)) = n
{-# CATCHALL #-}
to‚Ñï _ = 0
#+end_src

*** Products and ‚ü®Tuple‚ü© Notation
 #+begin_src agda2 :tangle semantics-with-waist.agda
open import Data.Product

Œ£‚à∂‚Ä¢ : ‚àÄ {a b} (A : Set a) (B : A ‚Üí Set b) ‚Üí Set _
Œ£‚à∂‚Ä¢ = Œ£

infix -666 Œ£‚à∂‚Ä¢
syntax Œ£‚à∂‚Ä¢ A (Œª x ‚Üí B) = Œ£ x ‚à∂ A ‚Ä¢ B

record ‚ä§ {‚Ñì} : Set ‚Ñì where
  constructor tt

-- Expressions of the form ‚Äú‚ãØ , tt‚Äù may now be written ‚Äú‚ü® ‚ãØ ‚ü©‚Äù
infixr 5 ‚ü® _‚ü©
‚ü®‚ü© : ‚àÄ {‚Ñì} ‚Üí ‚ä§ {‚Ñì}
‚ü®‚ü© = tt

‚ü® : ‚àÄ {‚Ñì} {S : Set ‚Ñì} ‚Üí S ‚Üí S
‚ü® s = s

_‚ü© : ‚àÄ {‚Ñì} {S : Set ‚Ñì} ‚Üí S ‚Üí S √ó ‚ä§ {‚Ñì}
s ‚ü© = s , tt
   #+end_src
** Introduction
  We want to write
  #+begin_example agda2
do X ‚Üê Set
   z ‚Üê X
   s ‚Üê (X ‚Üí X)

:  ‚Ñï ‚Üí Set
  #+end_example
  Which desugars into:
  #+begin_example agda2
‚Äµ Set >>= Œª X ‚Üí ‚Äµ X >>= Œª z ‚Üí ‚Äµ (X ‚Üí X)  where ‚Äµ_ : Set ‚Üí (‚Ñï ‚Üí Set)
  #+end_example

  The definition of the quote is forced due to the necessary typing of ~>>=~.
** Definitions: ~Context, ‚Äµ_, End~
  Hence, the definition of a context suggests itself:
  #+begin_src agda2 :tangle semantics-with-waist.agda
Context = Œª ‚Ñì ‚Üí ‚Ñï ‚Üí Set ‚Ñì

infix -1000 ‚Äµ_
‚Äµ_ : ‚àÄ {‚Ñì} ‚Üí Set ‚Ñì ‚Üí Context ‚Ñì
‚Äµ S = Œª _ ‚Üí S

End : ‚àÄ {‚Ñì} ‚Üí Context ‚Ñì
End = ‚Äµ ‚ä§
  #+end_src

** Definitions: ~_>>_~
Next we define the bind operator to account for the current waist: If zero, we
have records, otherwise functions.
#+begin_example agda2
_>>=_ : ‚àÄ {a b}
      ‚Üí (Œì : Context a)
      ‚Üí (‚àÄ {n} ‚Üí Œì n ‚Üí Context b)
      ‚Üí Context (a ‚äç b)
(Œì >>= f) ‚Ñï.zero  = Œ£ Œ≥ ‚à∂ Œì 0 ‚Ä¢ f Œ≥ 0
(Œì >>= f) (suc n) = (Œ≥ : Œì n) ‚Üí f Œ≥ n
#+end_example

Unfortunately, this would require too many calls to quote; e.g.,
#+begin_example agda2
do X ‚Üê ‚Äµ Set
   z ‚Üê ‚Äµ X
   s ‚Üê ‚Äµ (X ‚Üí X)
   End
#+end_example

So let's ‚Äúbuild it into the definition of >>=‚Äù:
  #+begin_src agda2 :tangle semantics-with-waist.agda
_>>=_ : ‚àÄ {a b}
      ‚Üí (Œì : Set a)  -- Main diference
      ‚Üí (Œì ‚Üí Context b)
      ‚Üí Context (a ‚äç b)
(Œì >>= f) ‚Ñï.zero  = Œ£ Œ≥ ‚à∂ Œì ‚Ä¢ f Œ≥ 0
(Œì >>= f) (suc n) = (Œ≥ : Œì) ‚Üí f Œ≥ n
  #+end_src

Let's see this in action:
  #+begin_src agda2 :tangle semantics-with-waist.agda
Monoid : ‚àÄ ‚Ñì ‚Üí Context (‚Ñìsuc ‚Ñì)
Monoid ‚Ñì = do Carrier ‚Üê Set ‚Ñì
              Id      ‚Üê Carrier
              _‚äï_     ‚Üê (Carrier ‚Üí Carrier ‚Üí Carrier)
              leftId  ‚Üê ‚àÄ {x : Carrier} ‚Üí x ‚äï Id ‚â° x
              rightId ‚Üê ‚àÄ {x : Carrier} ‚Üí Id ‚äï x ‚â° x
              assoc   ‚Üê ‚àÄ {x y z} ‚Üí (x ‚äï y) ‚äï z  ‚â°  x ‚äï (y ‚äï z)
              End {‚Ñì}
  #+end_src

But what does all of this /mean/? Let's return to the dynamic system at the start
of this discussion.

** Example: Dynamical Systems

  #+begin_src agda2 :tangle semantics-with-waist.agda
DynamicSystem : Context (‚Ñìsuc Level.zero)
DynamicSystem = do X ‚Üê Set
                   z ‚Üê X
                   s ‚Üê (X ‚Üí X)
                   End {Level.zero}
#+end_src

We can now ‚Äúsee‚Äù ---with ~C-c C-n~--- what a dynamical system looks like /at/ a
particular waist.
#+begin_src agda2 :tangle semantics-with-waist.agda
-- Records with ùìÉ-Parameters, ùìÉ : 0..3
A B C D : Set‚ÇÅ
A = DynamicSystem 0 -- Œ£ X ‚à∂ Set  ‚Ä¢ Œ£ z ‚à∂ X  ‚Ä¢ Œ£ s ‚à∂ X ‚Üí X  ‚Ä¢ ‚ä§
B = DynamicSystem 1 --  (X ‚à∂ Set) ‚Üí Œ£ z ‚à∂ X  ‚Ä¢ Œ£ s ‚à∂ X ‚Üí X  ‚Ä¢ ‚ä§
C = DynamicSystem 2 --  (X ‚à∂ Set)    (z ‚à∂ X) ‚Üí Œ£ s ‚à∂ X ‚Üí X  ‚Ä¢ ‚ä§
D = DynamicSystem 3 --  (X ‚à∂ Set)    (z ‚à∂ X) ‚Üí  (s ‚à∂ X ‚Üí X) ‚Üí ‚ä§
#+end_src

It is important to note that these are /not/ functions, but instead
are /function types/!

** Theorems: ~stablity~

Observe that there are no more ‚Äòinteresting‚Äô ways to form a dynamical system.
#+begin_src agda2 :tangle semantics-with-waist.agda
stablity : ‚àÄ {n} ‚Üí   DynamicSystem (3 + n)
                   ‚â° DynamicSystem  3
stablity = refl
  #+end_src

  Moreover, by the nature of a dynamical system, there cannot ever be such a
  system with an empty state space, and so ~B~.
#+begin_src agda2 :tangle semantics-with-waist.agda
B-is-empty : ¬¨ B
B-is-empty b = proj‚ÇÅ( b ‚ä•)
#+end_src

** Natural Number Instance
Let's form an instances at height 0; i.e., a record.
  #+begin_src agda2 :tangle semantics-with-waist.agda
ùí©‚ÇÄ : DynamicSystem 0
ùí©‚ÇÄ = ‚Ñï , 0 , suc , tt
  #+end_src

With the expected sugar, we gain an extra grain of readability.
  #+begin_src agda2 :tangle semantics-with-waist.agda
ùí© : DynamicSystem 0
ùí© = ‚ü® ‚Ñï , 0 , suc ‚ü©
  #+end_src

Neato: One declares a PackageFormer with ~do‚Ä¶End~ then forms a 0-waist value
using ~‚ü®‚ãØ‚ü©~.

** Œ†‚ÜíŒª and Modus Ponens
Unfortunately, since ~B, C, D~ are all of type ~Set‚ÇÅ~ and so are not functions,
there is no trivial way to ‚Äúinstantiate‚Äù any of ~B, C, D~'s arguments to obtain
versions of ~A~ wherein certain fields are already ‚Äúfixed‚Äù.

I'd like to write =B on ‚Ñï=, for example. However, a definition of ~_on_~ seems to
want to pattern match on sorts.
  #+begin_src agda2 :tangle semantics-with-waist.agda
B-on-‚Ñï : Set
B-on-‚Ñï = let X = ‚Ñï in Œ£ z ‚à∂ X  ‚Ä¢ Œ£ s ‚à∂ (X ‚Üí X)  ‚Ä¢ ‚ä§

ex : B-on-‚Ñï
ex = ‚ü® 0 , suc ‚ü©
  #+end_src

Let's oblige, and pattern match on sorts ---by using reflection.

The /values/ ~B,C,D~ are all of the form ~‚àÄ X ‚Üí ‚ãØ~, in-order to /apply/ them
we need to transform them into values of the form ~Œª X ‚Üí ‚ãØ~, for which application
is actually sensible. As far as I know, there is no natural operation
transforming a function-type into a function-value, so we make the necessary
transformation /syntactically/.

Here's an instance of moving from the Œ†-type-level to the Œª-value-level.
  #+begin_src agda2 :tangle semantics-with-waist.agda
idœÑ : Set‚ÇÅ
idœÑ = ‚àÄ (X : Set) (e : X) ‚Üí X

id‚ÇÅ : ‚àÄ (X : Set) ‚Üí Set
id‚ÇÅ = Œª (X : Set) ‚Üí ((e : X) ‚Üí X)

id‚ÇÇ : ‚àÄ (X : Set) (e : X) ‚Üí Set
id‚ÇÇ = Œª (X : Set) (e : X) ‚Üí X
   #+end_src
Let's code to make the transformation ~idœÑ ‚Ü¶ id‚ÇÇ~ feasible.

We start with Agda terms.
   #+begin_src agda2 :tangle semantics-with-waist.agda
Œ†‚ÜíŒª-helper : Term ‚Üí Term
Œ†‚ÜíŒª-helper (pi  a b)         = lam visible b
Œ†‚ÜíŒª-helper (lam a (abs x y)) = lam a (abs x (Œ†‚ÜíŒª-helper y))
{-# CATCHALL #-}
Œ†‚ÜíŒª-helper x = x
#+end_src

+ We case on type formation, then rewrite the first encountered Œ†-type into a Œª-value.
+ If a Œª is encountered, we go inside to make the rewrite.
  - The intention is that sequential rewrite invocations are easily expressed.
+ We could have added the following case before the catchall, however it is
  undesirable since in general we do not want to unwind as much as possible,
  but only as much waist as provided.
  #+begin_example agda2
Œ†‚ÜíŒª-helper (pi a (abs x y)) = lam visible (abs x (Œ†‚ÜíŒª-helper y))
  #+end_example

Here are two sample uses.
#+begin_example agda2
-- Error: Failed to resolve sort constraints
_ : unquote (unify (Œ†‚ÜíŒª-helper (quoteTerm (‚àÄ (X : Set) (x : X) ‚Üí X)))) ‚â° Œª X ‚Üí X ‚Üí X
_ = refl

-- Ekk! No normalisation!
_ : Œ†‚ÜíŒª-helper (quoteTerm idœÑ) ‚â° quoteTerm idœÑ
_ = refl
#+end_example

As it stands, this syntactic rewrite is pathetic from a usage point of view: We
need to quote arguments provided to it, then unquote them back into working
code. Moreover, due to Agda's weak reflection mechanism, such a bungled mess
usually results in errors failing to solve sort constraints.  /Even worse/, it
does not account for normal forms; e.g., a constant name is just that, a name,
rather than what it expands to.
Let's remedy these two issues.
#+begin_src agda2 :tangle semantics-with-waist.agda
macro
  Œ†‚ÜíŒª : Term ‚Üí Term ‚Üí TC Unit.‚ä§
  Œ†‚ÜíŒª tm goal = normalise tm >>=‚Çò Œª tm‚Ä≤ ‚Üí unify (Œ†‚ÜíŒª-helper tm‚Ä≤) goal
  #+end_src

+ We normalise a given term /then/ invoke the previously formed helper.
+ Due to the currently poor state of reflection in Agda, we are /forced/ to
  construct the auxiliary function since macros cannot be recursive.
    #+begin_example agda2
-- Error: Cannot unquote non-canonical type checking computation
macro
  lame : ‚Ñï ‚Üí Term ‚Üí Term ‚Üí TC Unit.‚ä§
  lame zero t g    = unify t g
  lame (suc n) t g = lame n t g
  #+end_example

At this point, our goals are reasonably achieved:
#+begin_src agda2 :tangle semantics-with-waist.agda
_ : Œ†‚ÜíŒª idœÑ ‚â° id‚ÇÅ
_ = refl

-- Too much yellow, sort constraints cannot be solved. It's okay.
-- _ : Œ†‚ÜíŒª (Œ†‚ÜíŒª idœÑ) ‚â° id‚ÇÇ
-- _ = refl
  #+end_src

Reflection was not the first route attempted.  A more natural approach would be
to form a ‚Äòuniverse‚Äô type ~ùïå~ which has a constructor ~‚ÄµŒ†~ for encoding dependent
function types, one then defines ~Œ†‚ÜíŒª~ by requesting a ‚â°-proof that the given type
is indeed a function-type, i.e., is equivalent to the semantics of an encoding
~‚ÄµŒ†~.  However, such encodings always led to some technical issue.  Most notable
being that we cannot view ~Set‚ÇÅ~ via our encoding ~ùïå~ since such a function ~Set‚ÇÅ ‚Üí ùïå~
would fail to encode types without having a pre-existing way to pattern match
against the inhabitants of ~Set‚ÇÅ~.  As such, we have solved the problem in the
meta-theory.

It is curious that this problem is reminiscent of currying.
#+begin_src agda2
-- Given:
œÑ : Set‚ÇÅ
œÑ = ‚àÄ (X : Set) ‚Üí ‚ãØ

-- Obtain:
œÑf : ‚àÄ (X : Set) ‚Üí Set‚ÇÅ
œÑf = Œª (X : Set) ‚Üí ‚ãØ
#+end_src
| The type of ~œÑ~ merely states it to be a grouping mechanism!        |
| The type of ~œÑf~ /exposes/ that ~œÑ~ is a parmeterised grouping mechanism! |

Perhaps this is related to indexing vs parameters.

+ We can apply =œÑf= and so it's more concrete than =œÑ=.
+ Hence, we may call =Œ†‚ÜíŒª= a ‚Äútype constructor reification‚Äù.

** Defining =_:waist_=
   Multiple invocations of ~Œ†‚ÜíŒª~ along with a raw waist exposes the structure of
   a parameterised record, as in the following examples.
  #+begin_src agda2 :tangle semantics-with-waist.agda
_ : Œ†‚ÜíŒª (DynamicSystem 1) ‚â° Œª Œ≥ ‚Üí Œ£ Œ≥ (Œª _ ‚Üí Œ£ ((x : Œ≥) ‚Üí Œ≥) (Œª _ ‚Üí ‚ä§))
_ = refl

CC : ‚àÄ (X : Set) (x : X) ‚Üí Set
CC = Œ†‚ÜíŒª (Œ†‚ÜíŒª (DynamicSystem 2))   -- c.f., C above and C‚Ä≤ below.
   #+end_src
   Let's abstract away the raw waist, 2 above, and the 2-many invocations of
   ~Œ†‚ÜíŒª~.

   As mentioned earlier, we must perform recursion outside of ~macro~ clauses, so
   we must have an auxiliary function.
   #+begin_src agda2 :tangle semantics-with-waist.agda
waist-helper : ‚Ñï ‚Üí Term ‚Üí Term
waist-helper zero t    = t
-- waist-helper (suc n) t = waist-helper n (Œ†‚ÜíŒª t)
waist-helper (suc n) t = waist-helper n (Œ†‚ÜíŒª-helper t)
  #+end_src

  It is important to note that the commented out line could /not/ have been used
  and instead the ~Œ†‚ÜíŒª~ macro's underlying helper must be invoked instead.  Why?
  This subtlety is due to the implicit-quotation invocation style of macros: If
  ~f : Term ‚Üí Name ‚Üí Bool ‚Üí Term ‚Üí TC ‚ä§~ is declared a macro, then an application
  ~f u v w~ desugars into ~unquote (f (quoteTerm u) (quote v) w)~.

We now use the helper to form the necessary combinator.
  #+begin_src agda2 :tangle semantics-with-waist.agda
macro
  _:waist_ : Term ‚Üí Term ‚Üí Term ‚Üí TC Unit.‚ä§
  _:waist_ t ùìÉ goal =      normalise (t app ùìÉ)
                      >>=‚Çò Œª t‚Ä≤ ‚Üí unify (waist-helper (to‚Ñï ùìÉ) t‚Ä≤) goal
#+end_src

Note that it's important we /apply/ the given context to a raw waist,
then /normalise/ that before moving on. Indeed, ~waist-helper~ invokes ~Œ†‚ÜíŒª‚Üíhelper~,
which performs no normalisation.

+ ~:waist~ could not have been defined as a top level function operating on ~Set ‚Ñì~
  since it cannot be typed! It needs to operate on syntax and so is a macro.
  - Indeed, ~Œì :waist n~ may sometimes return a function of types, values of ~Set‚ÇÅ~,
    or a function of other types, such as ~‚Ñï~. We shall show this below when
    forming ~A‚Ä≤, B‚Ä≤, C‚Ä≤, D‚Ä≤~.

 How are these two indexing mechanisms related?
 0. =C :waist n= is an n-ary type constructor; given n inputs, a record type is returned.
 1. =C n= is a ‚Äúfactory‚Äù: Given n inputs ùìç, it will produce a value of =(C :waist n) ùìç=.

** Further Natural Number Instances and Fixing Parameters

Let's now demonstrate how convenient it is to use ~_:waist_~.
  #+begin_src agda2 :tangle semantics-with-waist.agda
A‚Ä≤ : Set‚ÇÅ
B‚Ä≤ : ‚àÄ (X : Set) ‚Üí Set
C‚Ä≤ : ‚àÄ (X : Set) (x : X) ‚Üí Set
D‚Ä≤ : ‚àÄ (X : Set) (x : X) (s : X ‚Üí X) ‚Üí Set
#+end_src
Each type /exposes/ more and more information about what kind of grouping
structure we have at hand. The definitions are super simple sweetness.
#+begin_src agda2 :tangle semantics-with-waist.agda
A‚Ä≤ = DynamicSystem :waist 0
B‚Ä≤ = DynamicSystem :waist 1
C‚Ä≤ = DynamicSystem :waist 2
D‚Ä≤ = DynamicSystem :waist 3
  #+end_src

~B,C,D~ are parameterised records: Given values of the parameters, record values
are created. What if, we want to simply supply parameters and obtain new
parameterised records; i.e., do not go all the way down to the creation level.
These ‚Äòpartial applied‚Äô types are ~B‚Ä≤, C‚Ä≤, D‚Ä≤~. That is, ~:waist~ essentially
allows us to unbundle, or uncurry, records! So cool (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

  The following /instances/ of these grouping /types/ demonstrate how /information
moves from the body level to the parameter level/!
  #+begin_src agda2 :tangle semantics-with-waist.agda
ùí©‚Å∞ : A‚Ä≤
ùí©‚Å∞ = ‚ü® ‚Ñï , 0 , suc ‚ü©

ùí©¬π : B‚Ä≤ ‚Ñï
ùí©¬π = ‚ü® 0 , suc ‚ü©

ùí©¬≤ : C‚Ä≤ ‚Ñï 0
ùí©¬≤ = ‚ü® suc ‚ü©

ùí©¬≥ : D‚Ä≤ ‚Ñï 0 suc
ùí©¬≥ = ‚ü®‚ü©
#+end_src

Notice that with ~A‚Ä≤, B‚Ä≤, C‚Ä≤, D‚Ä≤~ we may fix certain parameters ahead of time.
Above the type ~B‚Ä≤ ‚Ñï~ is the type of ‚Äúdynamic systems over carrier ‚Ñï‚Äù whereas ~C‚Ä≤ ‚Ñï
0~ is the type of ‚Äúdynamic systems over carrier ‚Ñï and start state 0‚Äù.  Neato!

One would expect the stablity result from earlier to continue to hold, but
there is a type error in even phrasing it naively.
#+begin_example agda2
-- Type error: LHS and RHS of ‚Äò‚â°‚Äô do not agree.
stablity‚Ä≤ : ‚àÄ {n : ‚Ñï} ‚Üí
            DynamicSystem :waist (3 + n)
          ‚â° DynamicSystem :waist 3
stablity‚Ä≤ = refl
#+end_example

** Example ---Collections

   Here's a specification of a collection, which includes an element type;
   along with an instance-former; i.e., a value at a non-zero waist. ---Thanks Wolfram!
#+begin_src agda2 :tangle semantics-with-waist.agda
Collection : ‚àÄ ‚Ñì ‚Üí Context (‚Ñìsuc ‚Ñì)
Collection ‚Ñì = do
  Elem    ‚Üê Set ‚Ñì
  Carrier ‚Üê Set ‚Ñì
  insert  ‚Üê (Elem ‚Üí Carrier ‚Üí Carrier)
  ‚àÖ       ‚Üê Carrier
  isEmpty ‚Üê (Carrier ‚Üí Bool)
  insert-nonEmpty ‚Üê ‚àÄ {e : Elem} {x : Carrier} ‚Üí isEmpty (insert e x) ‚â° false
  End {‚Ñì}

ListColl : {‚Ñì : Level} ‚Üí Collection ‚Ñì 1
ListColl E = ‚ü® List E
             , _‚à∑_
             , []
             , (Œª { [] ‚Üí true; _ ‚Üí false})
             , (Œª {x} {x = x‚ÇÅ} ‚Üí refl)
             ‚ü©
           #+end_src

The neat thing here is that a value of ~Collection ‚Ñì~ is an element type
along with collection type over said elements; whereas a value of ~Collection ‚Ñì 1~
is a way to form collections for given element types.

Here's another example.

Enumerated types can always be encoded as values of ‚Ñï and so ‚Ñï can be thought
of as a way to collect values of the enumeration.
  #+begin_src agda2 :tangle semantics-with-waist.agda
‚ÑïCollection = (Collection ‚Ñì‚ÇÄ :waist 2)
                ("Elem"    ‚âî Digit)
                ("Carrier" ‚âî ‚Ñï)
--
-- i.e., (Collection ‚Ñì‚ÇÄ :waist 2) Digit ‚Ñï
#+end_src

  + Note that the ~"key" ‚âî value~ pairs are just syntactic sugar for ~value~,
    that document it via ~"key"~.
  + ~Digit~ is the enumerated type of values ~#ùíæ~ for ~ùíæ : 0..9~.

More concretely, if the enumerated has ùìÉ-many values, we can form a stack by
starting with 0 and pushing elements ~d~ ‚Äúto then end of our running total $s$‚Äù to
obtain =s * 10‚Åø + d=, for example.  Then we pop elements off via division. Here's
an instance for the digit enumeration type.

#+begin_src agda2 :tangle semantics-with-waist.agda
stack : ‚ÑïCollection
stack = ‚ü® "insert"      ‚âî (Œª d s ‚Üí suc (10 * s + #‚Üí‚Ñï d))
        , "empty stack" ‚âî 0
        , "is-empty"    ‚âî (Œª { 0 ‚Üí true; _ ‚Üí false})
        -- Properties --
        , (Œª {d : Digit} {s : ‚Ñï} ‚Üí refl {x = false})
        ‚ü©
  #+end_src

+ The ~suc~, in ~"insert"~, is to make the coherence property easily proven.

Super neat stuff (‚îÄ‚Äø‚Äø‚îÄ)

** Projections

   Since records are just products, we may project to obtain their fields.
   - The following meta-program yields a type error when trying to project
     fields that do not exist.
#+begin_src agda2 :tangle semantics-with-waist.agda
Field‚ÇÄ : ‚Ñï ‚Üí Term ‚Üí Term
Field‚ÇÄ zero c    = def (quote proj‚ÇÅ) (arg (arg-info visible relevant) c ‚à∑ [])
Field‚ÇÄ (suc n) c = Field‚ÇÄ n (def (quote proj‚ÇÇ) (arg (arg-info visible relevant) c ‚à∑ []))

macro
  Field : ‚Ñï ‚Üí Term ‚Üí Term ‚Üí TC Unit.‚ä§
  Field n t goal = unify goal (Field‚ÇÄ n t)
#+end_src

Agda macros do not support Œ∑-equivalence and so definitions
of particular projections are necessarily of the form ~Œª C ‚Üí Field ùíæ C~.

#+begin_src agda2 :tangle semantics-with-waist.agda
Elem      : ‚àÄ {‚Ñì} ‚Üí Collection ‚Ñì 0 ‚Üí Set ‚Ñì
Elem      = Œª C   ‚Üí Field 0 C
          #+end_src

Nullary types like ~Collection ‚Ñì 0~ all have a similar projection form.
There is a neat interesting shift when we move positive-argument types.
          #+begin_src agda2 :tangle semantics-with-waist.agda
Carrier   : ‚àÄ {‚Ñì} ‚Üí Collection ‚Ñì 0 ‚Üí Set ‚Ñì
Carrier‚ÇÅ  : ‚àÄ {‚Ñì} ‚Üí Collection ‚Ñì 1 ‚Üí (Œ≥ : Set ‚Ñì) ‚Üí Set ‚Ñì
Carrier‚ÇÅ‚Ä≤ : ‚àÄ {‚Ñì} {Œ≥ : Set ‚Ñì} (C : (Collection ‚Ñì :waist 1) Œ≥) ‚Üí Set ‚Ñì

Carrier   = Œª C   ‚Üí Field 1 C
Carrier‚ÇÅ  = Œª C Œ≥ ‚Üí Field 0 (C Œ≥)
Carrier‚ÇÅ‚Ä≤ = Œª C   ‚Üí Field 0 C
          #+end_src

The differences are subtle, so let's try exposing more arguments.

          #+begin_src agda2 :tangle semantics-with-waist.agda
insert   : ‚àÄ {‚Ñì} (C : Collection ‚Ñì 0) ‚Üí (Elem C ‚Üí Carrier C ‚Üí Carrier C)
insert‚ÇÅ  : ‚àÄ {‚Ñì} (C : Collection ‚Ñì 1) (Œ≥ : Set ‚Ñì) ‚Üí  Œ≥ ‚Üí Carrier‚ÇÅ C Œ≥ ‚Üí Carrier‚ÇÅ C Œ≥
insert‚ÇÅ‚Ä≤ : ‚àÄ {‚Ñì} {Œ≥ : Set ‚Ñì} (C : (Collection ‚Ñì :waist 1) Œ≥) ‚Üí Œ≥ ‚Üí Carrier‚ÇÅ‚Ä≤ C ‚Üí Carrier‚ÇÅ‚Ä≤ C

insert    = Œª C   ‚Üí Field 2 C
insert‚ÇÅ   = Œª C Œ≥ ‚Üí Field 1 (C Œ≥)
insert‚ÇÅ‚Ä≤  = Œª C   ‚Üí Field 1 C
#+end_src

Notice that ~insert‚ÇÅ~'s ~C~ must be passed inputs each time it is used ---since ~C~ is
a ‚Äúfactory‚Äù, as mentioned earlier. In contrast, ~insert‚ÇÅ‚Ä≤~'s ~C~ has no arguments
as they are fixed ahead of time.

The need to invoke a factory with its inputs seems to have a slightly greater
impact at the definition level, as seen below.
#+begin_src agda2 :tangle semantics-with-waist.agda
insert‚ÇÇ  : ‚àÄ {‚Ñì} (C : Collection ‚Ñì 2) (El Cr : Set ‚Ñì) ‚Üí El ‚Üí Cr ‚Üí Cr
insert‚ÇÇ‚Ä≤ : ‚àÄ {‚Ñì} {El Cr : Set ‚Ñì} (C : (Collection ‚Ñì :waist 2) El Cr) ‚Üí El ‚Üí Cr ‚Üí Cr

insert‚ÇÇ = Œª C El Cr ‚Üí Field 0 (C El Cr)
insert‚ÇÇ‚Ä≤ = Œª C ‚Üí Field 0 C
  #+end_src

Neato petito!

** COMMENT ~:exposing~ --no

     Set‚ÇÅ
‚áí ‚àÄ X‚ÇÅ ‚Üí ‚ãØ ‚Üí ‚àÄ X‚Çô ‚Üí Set
‚âÖ ‚àÄ X‚Çô ‚Üí ‚àÄ X‚ÇÅ ‚Üí ‚ãØ ‚Üí ‚àÄ X‚Çô‚Çã‚ÇÅ ‚Üí Set
‚áí ‚àÄ X‚Çô ‚Üí Set

Given a function /type/ such as ~‚àÄ (A B : Set) ‚Üí B~, we cannot write a
function to swap the order of the input types, ~A~ and ~B~, since that would
require we pattern match on the function /type/ to expose its structure. As
such, we must use reflection. However, a mere switch of Œ†-constructors also does
not work since the underlying debrujin reference of the final ~B~ is ~var 0~, in
reference to the 0-th away bound variable ~B~, and so a simple Œ†-variable swap
would leave the reference as ~var 0~ which then refers to ~A~. Hence, in
general, we need to update all debrujin indices, increasing some and decreasing
others.
* COMMENT ‚ÄúContexts over Contexts‚Äù

Informally =x‚ÇÄ : œÑ‚ÇÄ, ‚Ä¶ ‚ùô y‚ÇÄ : œÑ‚ÇÄ; ‚Ä¶=  denotes two contexts, ~Œì‚ÇÅ ‚ùô Œì‚ÇÇ~, where the
first is an elementary context and the latter is a context whose declarations
not only may use earlier ~y·µ¢~ declarations but /additionally/ may use the entirety
of the context ~Œì‚ÇÅ~. We say =Œì‚ÇÇ= is a /context over context/ =Œì‚ÇÅ=.

1. A <<context over a context>>> is a dependent-type, from contexts to contexts.
2. A <<type over a dependent-context>> is an context-indexed family of sets.

#+BEGIN_SRC agda2 :tangle semantics.agda
Context‚Ä≤ : ‚àÄ {‚Ñì} ‚Üí Context ‚Ñì ‚Üí Set (‚Ñìsuc ‚Ñì)
Context‚Ä≤ {‚Ñì} Œû  =  Œû ‚Üí Set ‚Ñì

type‚Ä≤ : ‚àÄ {‚Ñì} {Œû : Context ‚Ñì} ‚Üí Context‚Ä≤ Œû ‚Üí Set (‚Ñìsuc ‚Ñì)
type‚Ä≤ {‚Ñì} Œì = ‚àÄ {Œæ} ‚Üí Œì Œæ ‚Üí Set ‚Ñì
#+END_SRC

We may index the previous ‚Äòsmart constructors‚Äô for contexts over contexts:
#+BEGIN_SRC agda2
‚àÖ : ‚àÄ {‚Ñì} {Œû : Context ‚Ñì} ‚Üí Context‚Ä≤ Œû
‚àÖ = Œª _ ‚Üí ‚ä§

_‚®æ_ : ‚àÄ {‚Ñì} {Œû : Context ‚Ñì} ‚Üí (Œì : Context‚Ä≤ Œû) (œÑ : type‚Ä≤ Œì) ‚Üí Context‚Ä≤ Œû
Œì ‚®æ œÑ = Œª Œæ ‚Üí Œ£ Œ≥ ‚à∂ Œì Œæ ‚Ä¢ œÑ Œ≥
#+END_SRC
Note: These names are not exported to the resulting Agda file, since they are
not needed.

* COMMENT *Current Status*

 I've been working on taking something as follows,
 #+begin_src agda2
do X ‚Üê Set
   e ‚Üê X
   e ‚â° e
 #+end_src
 That is ~Set >>= Œª X ‚Üí X >>= Œª e ‚Üí e ‚â° e~, but I want to seed it with an initial
 number ùìÉ which is reduced with each line. Instead of ~>>=~, let me write ~‚äï‚Çô~:
 ~(m >>= Œª x ‚Üí e) = ((x ‚à∂ m) ‚äï‚Çô e)~.

 Then, I'd like to have the above example desugar to ~(X : Set) ‚äï‚ÇÅ (e : X) ‚äï‚ÇÄ (e ‚â°
 e)~ ---where the family ~‚äï‚Çô~ is right associative and we are using seed ~ùìÉ = 1~.

 - ‚û© The family ~‚äï‚Çô~ serves to demarcate parameters from the remainder of a context.
 - ‚û© ~m ‚äï‚Çô f = (Œ£ m f)~ if /n = 0/ and ~m ‚äï‚Çô f = (x : m) ‚Üí f x~ if /n ‚â† 0/.

 The past week I've been trying multiple approaches to define ~Context~ and to
 defined ~‚äï~. Here are some I've tried.

 :Hide:
 #+begin_src agda2 :tangle semantics-with-waist.agda
module semantics-with-waist.agda where

open import Level renaming (_‚äî_ to _‚äç_; suc to ‚Ñìsuc)
open import Data.Nat
open import Data.Product
Œ£‚à∂‚Ä¢ : ‚àÄ {a b} (A : Set a) (B : A ‚Üí Set b) ‚Üí Set _
Œ£‚à∂‚Ä¢ = Œ£
infix -666 Œ£‚à∂‚Ä¢
syntax Œ£‚à∂‚Ä¢ A (Œª x ‚Üí B) = Œ£ x ‚à∂ A ‚Ä¢ B
 #+end_src
 :End:
 #+begin_src agda2 :tangle semantics-with-waist.agda
Context¬π = Œª ‚Ñì ‚Üí Set ‚Ñì
_‚äï¬π_ : ‚àÄ {i j} ‚Üí (A : Context¬π i)
               ‚Üí (f : A ‚Üí Context¬π j)
               ‚Üí ‚Ñï ‚Üí Context¬π (i ‚äç j)
(Œì ‚äï¬π f) ‚Ñï.zero    = Œ£ x ‚à∂ Œì ‚Ä¢ f x
(Œì ‚äï¬π f) (‚Ñï.suc n) = (x : Œì) ‚Üí f x
 #+end_src
 The problem here is that the number ùìÉ is encountered, a decision of type former
 is selected, and ùìÉ is discarded. It should instead be ‚Äúpassed on‚Äù to other
 declarations.

 + State monad suggests itself.

 #+begin_src agda2 :tangle semantics-with-waist.agda
Context¬≤ = Œª ‚Ñì ‚Üí ‚Ñï ‚Üí ‚Ñï √ó Set ‚Ñì
set = Œª {‚Ñì} (A : Context¬≤ ‚Ñì) ‚Üí proj‚ÇÇ (A 0)
_‚äï¬≤_ : ‚àÄ {i j} ‚Üí (A : Context¬≤ i)
               ‚Üí (f : set A ‚Üí Context¬≤ j)
               ‚Üí Context¬≤ (i ‚äç j)
(Œì ‚äï¬≤ f) ‚Ñï.zero    = 0 , Œ£ x ‚à∂ (set Œì) ‚Ä¢ set (f x)
(Œì ‚äï¬≤ f) (‚Ñï.suc n) = n , ((x : set Œì) ‚Üí set (f x))
 #+end_src
 The problem here is the arbitrary definition of ~set~, and the fact that we cannot
 make use of ~f~'s alteration of ~ùìÉ~:
 | The ùìÉ lives outside, but it can only be altered as in ~f x ùìÉ~, which requires an ~x~! |

 + Lenses suggest themselves.

 #+begin_src agda2 :tangle semantics-with-waist.agda
record Context¬≥ ‚Ñì : Set (‚Ñìsuc ‚Ñì) where
  constructor MkCtx¬≥
  field
    set¬≥ : Set ‚Ñì
    put  : ‚Ñï ‚Üí set¬≥
    get  : ‚Ñï
 #+end_src

 The same problem arises: We need to alter ùìÉ, but cannot do so without calling ~f~
 which cannot be invoked without having an ~x~.

 Here are other routes I've tried and failed for similar reasons:
 + ~Context ‚Ñì = ‚Ñï √ó Set ‚Ñì~
 + ~Context ‚Ñì = (‚Ñï ‚Üí ‚Ñï) √ó Set ‚Ñì~
 + ~_‚äï_ : ‚ãØ ‚Üí (f : ‚ä§ ‚äé A ‚Üí Context ‚Ñì)~
   - In an effort to call ~f~ so as to alter ùìÉ /without/ providing an ~x~.
   - Failed horribly in actually use: ~(x : X) ‚äï‚Çô f x~ is means ~x~ it /not/ a value of
     ~X~ but rather a value of ~‚ä§ ‚äé X~ and so we always need to account for both
     cases.
 + I've tried other formulations of ‚äï and ~Context~, but unfortunately I kept no
   record of them. I honestly thought that their definitions were easy and that I
   was just a bit off the mark ---a week later I'm no longer certain.

 /Any guidance would be appreciated!/

* COMMENT type-annotation syntax
  type-annotation : ‚àÄ {‚Ñì} (A : Set ‚Ñì) ‚Üí A ‚Üí A
type-annotation A a = a
syntax type-annotation A a = a ‚à∂ A -- ‚Äúghost colon‚Äù \:

* COMMENT PackageFormers as Pairs of Contexts Demarcated by a Waist

As already mentioned, a PackageFormer is a pair of contexts where the latter
depends on the former.
#+BEGIN_SRC agda2 :tangle semantics.agda
record PackageFormer (‚Ñì : Level) : Set (‚Ñìsuc ‚Ñì) where
  constructor _‚ùô_
  field
    parameters : Context ‚Ñì
    body       : Context‚Ä≤ parameters
    #+END_SRC

Unsurprisingly every PackageFormer can be coerced into a context:
#+BEGIN_SRC agda2 :tangle semantics.agda
  toContext : Context ‚Ñì
  toContext = Œ£ Œ≥ ‚à∂ parameters ‚Ä¢ body Œ≥
#+END_SRC

Note that the level-polymorphism is not to be facetious;
a PackageFormer is a grouping mechanism containing ‚Äòsmaller‚Äô
entities, the smallness of which is captured with the level.
- E.g., the grouping consisting of a single set is a PackageFormer at level 1.

The smart constructors from before can be lifted to this notion
---we suffix PackageFormer entities uniformly for clarity.

#+BEGIN_SRC agda2 :tangle semantics.agda
‚àÖ‚Çö : ‚àÄ {‚Ñì} ‚Üí PackageFormer ‚Ñì
‚àÖ‚Çö = ‚ä§ ‚ùô (Œª _ ‚Üí ‚ä§)

type‚Çö : ‚àÄ {‚Ñì} ‚Üí PackageFormer ‚Ñì ‚Üí Set (‚Ñìsuc ‚Ñì)
type‚Çö {‚Ñì} (parameters ‚ùô body) = (Œ£ Œæ ‚à∂ parameters ‚Ä¢ body Œæ) ‚Üí Set ‚Ñì
#+END_SRC

* COMMENT ‚ÄòM‚Äôutally ‚ÄòA‚Äôssociative Sets

  The simplest thing we can do with contexts is ‚Äòstick them together‚Äô,
  but a more natural operation is to extend a context with a new declaration.

  #+BEGIN_SRC agda2 :tangle semantics.agda
_‚äé‚Çö_ : ‚àÄ {‚Ñì} ‚Üí PackageFormer ‚Ñì ‚Üí PackageFormer ‚Ñì ‚Üí PackageFormer ‚Ñì
(Œì‚ÇÅ ‚ùô Œì‚ÇÇ) ‚äé‚Çö (Œì‚ÇÅ‚Ä≤ ‚ùô Œì‚ÇÇ‚Ä≤) = (Œì‚ÇÅ ‚äé Œì‚ÇÅ‚Ä≤) ‚ùô [ Œì‚ÇÇ , Œì‚ÇÇ‚Ä≤ ]

_‚®æ‚Çö_ :  ‚àÄ {‚Ñì} (p : PackageFormer ‚Ñì) ‚Üí type‚Çö p ‚Üí PackageFormer ‚Ñì
(parameters ‚ùô body) ‚®æ‚Çö d = parameters ‚ùô Œª Œæ ‚Üí Œ£ Œ≤ ‚à∂ body Œæ ‚Ä¢ d (Œæ , Œ≤)
#+END_SRC


*Remark:* Contexts have a monoidal structure determined by pushouts; i.e.,
disjoint unions ‚äé and the empty PackageFormer ‚àÖ.  Indeed, we have a
mutual-associativity law ~(Œì‚ÇÅ ‚äé Œì‚ÇÇ) ‚®æ e ‚âà Œì‚ÇÅ ‚äé (Œì‚ÇÇ ‚®æ e)~ ---up to some /equivalence
relation/.

*Remark:* We do not have a monoidal action since ‚®æ and ‚äé do not satisfiy the
necessary coherence laws ---even worse, the right law ~(Œì ‚®æ e‚ÇÅ) ‚®æ e‚ÇÇ = Œì ‚®æ (e‚ÇÅ ‚äé
e‚ÇÇ)~ and the left law ~Œì‚ÇÅ ‚®æ (Œì‚ÇÇ ‚®æ e) = (Œì‚ÇÅ ‚äé Œì‚ÇÇ) ‚®æ e~ are both ill-typed. Hence, we
have no hope of using ‚äé/‚®æ to trivially obtain a left/right monoidal action.

We can abstract out this structure in the hopes that a semantics for
PackageFormers can be determined via these new algebras.
:More:
In order to define a semantics, we need a notion of models in which to interpret
the syntactic PackageFormer entities.  Since left and right monoid-sets have
been ruled out, we shall formulate another species to fit the structure embedded
in PackageFormer.
:End:

Define a ‚Äú<<MA-Set>>‚Äù, or a ‚ÄòM‚Äôutually ‚ÄòA‚Äôssocitive structure to be a triple (‚Ñ≥,
ùíú, ¬∑) where ‚Ñ≥ is a monoid, ùíú is a dependent family indexed by ‚Ñ≥, and ~_¬∑_ : (m :
‚Ñ≥) ‚Üí ùíú m ‚Üí ‚Ñ≥~ is a ‚Äòdependent action‚Äô that is mutually associative with the
monoidal operation, ~(m‚ÇÅ ‚äï m‚ÇÇ) ¬∑ y ‚âà m‚ÇÅ ‚äï (m‚ÇÇ ¬∑ œÄ y)~ where ~œÄ : ùíú (m‚ÇÅ ‚äï m‚ÇÇ) ‚Üí ùíú m‚ÇÇ~
is a ‚Äòweakening‚Äô rule.

+ For now, we only implement the substructure that is necessary.
+ Perhaps additional structure needs to be added, or other to be removed.

#+BEGIN_SRC agda2 :tangle semantics.agda
record MA-Set (‚Ñì‚ÇÅ ‚Ñì‚ÇÇ : Level) : Set (‚Ñìsuc (‚Ñì‚ÇÅ ‚äç ‚Ñì‚ÇÇ)) where
  field
    ‚Ñ≥  : Set ‚Ñì‚ÇÅ
    _‚äï_ : ‚Ñ≥ ‚Üí ‚Ñ≥ ‚Üí ‚Ñ≥
    Id  : ‚Ñ≥
    ùíú :  ‚Ñ≥ ‚Üí Set ‚Ñì‚ÇÇ
    _¬∑_ : (m : ‚Ñ≥) ‚Üí ùíú m ‚Üí ‚Ñ≥  -- Note the dependency
    -- TODO: Ommiting axioms for now; likely want a setoid structure.

open MA-Set
#+END_SRC

# - This is nearly an M-Set, but the functoriality law has been replaced by the
#   an associtivity law.

- Unlike M-Sets in which a monoids ‚Äúacts‚Äù on a set, in a MA-Set we have the
  dependent set acting on the monoid /such that/ the ‚Äòtype of possible actions‚Äô
  is determined by monoid elements.

** Two Sanity Checks
*** Actually write a grouping mechanism
#+BEGIN_SRC agda2 :tangle semantics.agda
MonoidPF : PackageFormer (‚Ñìsuc ‚Ñì‚ÇÄ)
MonoidPF = (((‚àÖ‚Çö
           ‚®æ‚Çö Œª{ (tt , _) ‚Üí Set})
           ‚®æ‚Çö Œª{ (tt , (tt , Carrier)) ‚Üí Lift (‚Ñìsuc ‚Ñì‚ÇÄ) Carrier})
           ‚®æ‚Çö Œª{ (tt , ((tt , Carrier), lift point))
                 ‚Üí Lift (‚Ñìsuc ‚Ñì‚ÇÄ) (Carrier ‚Üí Carrier ‚Üí Carrier)})
           ‚®æ‚Çö Œª{ (tt , (((tt , Carrier) , lift point) , lift _‚äï_))
                 ‚Üí Lift (‚Ñìsuc ‚Ñì‚ÇÄ) (‚àÄ {x} ‚Üí x ‚äï point ‚â° x √ó point ‚äï x ‚â° x)}
#+END_SRC
TODO: Obtain working monad syntax.
*** PackageFormers are MA-Sets
#+BEGIN_SRC agda2 :tangle semantics.agda
PFs-are-MA-Sets : ‚àÄ {‚Ñì} ‚Üí MA-Set (‚Ñìsuc ‚Ñì) (‚Ñìsuc ‚Ñì)
PFs-are-MA-Sets {‚Ñì} = record
  { ‚Ñ≥   = PackageFormer ‚Ñì
  ; _‚äï_ = _‚äé‚Çö_
  ; Id  = ‚àÖ‚Çö
  ; ùíú   = type‚Çö
  ; _¬∑_ = _‚®æ‚Çö_
  }
#+END_SRC

** MA-Sets form a Category

Given two MA-Sets (‚Ñ≥, ùíú, ¬∑) and (‚Ñ≥‚Ä≤, ùíú‚Ä≤, ¬∑‚Ä≤), define a /MA-Set homomorphism/ to be
a pair of functions /h‚ÇÅ : ‚Ñ≥ ‚Üí ‚Ñ≥‚Ä≤, h‚ÇÇ : ùíú ‚Üí ùíú‚Ä≤/ that preserve the structure on each
set and respect the action; i.e.,
1. =h‚ÇÅ= is a monoid homomorphism
2. =h‚ÇÅ (m ¬∑ a) ‚âà h‚ÇÅ m ¬∑‚Ä≤ h‚ÇÇ a=, a reasonable coherence condition.

   Notice that when ~a : ùíú m~ then necessarily ~h‚ÇÇ a : ùíú‚Ä≤ (h‚ÇÅ m)~.

 #+BEGIN_SRC agda2 :tangle semantics.agda
record Hom {‚Ñì‚ÇÅ ‚Ñì‚ÇÇ} (Src Tgt : MA-Set ‚Ñì‚ÇÅ ‚Ñì‚ÇÇ) : Set (‚Ñìsuc (‚Ñì‚ÇÅ ‚äç ‚Ñì‚ÇÇ)) where
  field
    mor‚ÇÅ : ‚Ñ≥ Src ‚Üí ‚Ñ≥ Tgt
    mor‚ÇÇ : ‚àÄ {m} ‚Üí ùíú Src m ‚Üí ùíú Tgt (mor‚ÇÅ m)
    pres-Id : mor‚ÇÅ (Id Src) ‚â° Id Tgt
    pres-‚äï  : ‚àÄ {x y} ‚Üí mor‚ÇÅ (_‚äï_ Src x y) ‚â° _‚äï_ Tgt (mor‚ÇÅ x) (mor‚ÇÅ y)
    coherence : ‚àÄ {m a} ‚Üí mor‚ÇÅ (_¬∑_ Src m a) ‚â° _¬∑_ Tgt (mor‚ÇÅ m) (mor‚ÇÇ a)

open Hom
 #+END_SRC

Conjectures:
1. (Id, Id) is a MA-Set homomorphism for any (‚Ñ≥, ùíú)-set.
   - Sketch: Id is a monoid homomorphism, and the coherence
     condition is true by ‚âà-reflexivity.

   - Formally:
      #+BEGIN_SRC agda2 :tangle semantics.agda

id : ‚àÄ {‚Ñì‚ÇÅ ‚Ñì‚ÇÇ} {MA : MA-Set ‚Ñì‚ÇÅ ‚Ñì‚ÇÇ} ‚Üí Hom MA MA
id = record
  { mor‚ÇÅ      = Œª x ‚Üí x
  ; mor‚ÇÇ      = Œª x ‚Üí x
  ; pres-Id   = refl
  ; pres-‚äï    = refl
  ; coherence = refl
  }
 #+END_SRC

2. MA-Set homomorphisms are closed under composition.
   - Sketch: The composition of monoid homomorphisms is again
     a homomorphism; it remains to check coherence:
    #+BEGIN_SRC haskell
     (f‚ÇÅ ‚àò g‚ÇÅ) (m ¬∑ a)
    = f‚ÇÅ (g‚ÇÅ (m ¬∑ a))
    = f‚ÇÅ (g‚ÇÅ m ¬∑ g‚ÇÇ a)
    = f‚ÇÅ (g‚ÇÅ m) ¬∑ f‚ÇÇ (g‚ÇÇ a)
    = (f‚ÇÅ ‚àò g‚ÇÅ) m ¬∑ (f‚ÇÇ ‚àò g‚ÇÇ) a
#+END_SRC
    Whence, the coherence condition is true.

   - Formally:
    #+BEGIN_SRC agda2 :tangle semantics.agda
_‚àò_ : ‚àÄ {‚Ñì‚ÇÅ ‚Ñì‚ÇÇ} {MA MB MC : MA-Set ‚Ñì‚ÇÅ ‚Ñì‚ÇÇ} ‚Üí Hom MB MC ‚Üí Hom MA MB ‚Üí Hom MA MC
_‚àò_ {MA = MA} {MB} {MC} F G = record
  { mor‚ÇÅ = Œª x ‚Üí mor‚ÇÅ F (mor‚ÇÅ G x)
  ; mor‚ÇÇ = Œª x ‚Üí mor‚ÇÇ F (mor‚ÇÇ G x)
  ; pres-Id = trans (cong (mor‚ÇÅ F) (pres-Id G)) (pres-Id F)
  ; pres-‚äï = Œª {x y} ‚Üí begin
      mor‚ÇÅ F (mor‚ÇÅ G (_‚äï_ MA x y))          ‚â°‚ü® cong (mor‚ÇÅ F) (pres-‚äï G) ‚ü©
      mor‚ÇÅ F (_‚äï_ MB (mor‚ÇÅ G x) (mor‚ÇÅ G y)) ‚â°‚ü® pres-‚äï F ‚ü©
      _‚äï_ MC (mor‚ÇÅ F (mor‚ÇÅ G x)) (mor‚ÇÅ F (mor‚ÇÅ G y)) ‚àé
  ; coherence = Œª {m a} ‚Üí begin
      mor‚ÇÅ F (mor‚ÇÅ G (_¬∑_ MA m a)) ‚â°‚ü® cong (mor‚ÇÅ F) (coherence G) ‚ü©
      mor‚ÇÅ F (_¬∑_ MB (mor‚ÇÅ G m) (mor‚ÇÇ G a)) ‚â°‚ü® coherence F ‚ü©
      _¬∑_ MC (mor‚ÇÅ F (mor‚ÇÅ G m)) (mor‚ÇÇ F (mor‚ÇÇ G a)) ‚àé }
 #+END_SRC

3. MA-Sets form a category.

The goal is then to show that MA-Sets have PackageFormer as an initial object!
---Initial semantics!

* COMMENT üöß  Other Rndm Ideas
#+BEGIN_SRC agda2 :tangle semantics.agda

-- one-fun : ‚àÄ {b ‚Ñì} {ùë© : Set ‚Ñì ‚Üí Set b} ‚Üí Œ£ A ‚à∂ Set ‚Ñì ‚Ä¢ ùë© A  -- ‚ÄúShape of given context‚Äù
--                                       ‚Üí (A : Set ‚Ñì) ‚Üí ùë© A
-- one-fun = {!!}
--
{-
Œ£ (Set _‚Ñì_511)
(Œª Carrier ‚Üí
   Œ£ (Carrier ‚Üí Carrier ‚Üí Carrier)
   (Œª _‚äï‚ÇÅ_ ‚Üí
      Œ£ Carrier (Œª one ‚Üí Œ£ Carrier (Œª two ‚Üí two ‚â° (one ‚äï‚ÇÅ one)))))
-}

--------------------------------------------------------------------------------

{-
-- ‚ÄúA -‚ü® n ‚ü©‚Üí B‚Äù ‚âà A ‚Üí ‚ãØ ‚Üí A ‚Üí B with n+1 many A‚Äôs.
_-‚ü®_‚ü©‚Üí_ : ‚àÄ {a b} (A : Set a) (n : ‚Ñï) (B : Set b) ‚Üí Set (a ‚äç b)
A -‚ü® 0 ‚ü©‚Üí B     = A ‚Üí B
A -‚ü® suc n ‚ü©‚Üí B = A ‚Üí A -‚ü® n ‚ü©‚Üí B

Prod : ‚àÄ ‚Ñì ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí Set (‚Ñìsuc ‚Ñì)
Prod ‚Ñì m ‚Ñï.zero    = ‚ä§
Prod ‚Ñì m (‚Ñï.suc n) = Œ£ A ‚à∂ Set ‚Ñì ‚Ä¢ Prod ‚Ñì m n
-}
-- waist3 : ‚àÄ {‚Ñì n} ‚Üí Prod (3 + n) ‚Üí Prod n

{-
‚Äµ_ : ‚àÄ {‚Ñì} ‚Üí Set ‚Ñì ‚Üí PackageFormer ‚Ñì
‚Äµ typ = ‚àÖ‚Çö ‚®æ‚Çö Œª _ ‚Üí typ

MonoidPF‚Ä≤ : PackageFormer {!!}
MonoidPF‚Ä≤ = do carrier ‚Üê ‚Äµ Set
               point  ‚Üê ‚Äµ Set
               ‚ä§
-}

#+END_SRC

#+BEGIN_SRC agda2
infixr 4 _‚∏¥_ -- \,
_‚∏¥_ : ‚àÄ {‚Ñì a b} {A : Set a} {B : A ‚Üí Set b}
    ‚Üí (x : A)
    ‚Üí B x
    ‚Üí Lift ‚Ñì (Œ£ x ‚à∂ A ‚Ä¢ B x)
a ‚∏¥ b = lift (a , b)
#+END_SRC

** COMMENT Explorations with =Context‚Ä≤=
#+BEGIN_SRC agda2 :tangle semantics.agda
_>>=_ : ‚àÄ {‚Ñì} {Œ± Œ≤ : Context ‚Ñì}
      ‚Üí Context‚Ä≤ Œ±
      ‚Üí (Œ± ‚Üí Context‚Ä≤ Œ≤)
      ‚Üí Context‚Ä≤ Œ≤
_>>=_ {Œ± = Œû} Œì f = Œª ŒΩ ‚Üí Œ£ Œæ ‚à∂ Œû ‚Ä¢ f Œæ ŒΩ

‚Äµ_ : ‚àÄ {‚Ñì} (C : Set ‚Ñì) ‚Üí Context‚Ä≤ C
‚Äµ typ = Œª _ ‚Üí typ

-- Not everything lives at the same level, so a helpfer to lift things.
‚Äµ‚Äµ_ : ‚àÄ {a ‚Ñì} (C : Set ‚Ñì) ‚Üí Context‚Ä≤ {‚Ñì ‚äç a} (Lift a C)
‚Äµ‚Äµ_ {a} typ = Œª _ ‚Üí Lift a typ
#+END_SRC

** COMMENT Monad Syntax üöß                                :construction_site:

 -- _‚ñ∑_ : ‚àÄ {‚Ñì} ‚Üí (P : PackageFormer ‚Ñì) ‚Üí Declaration (toContext P) ‚Üí PackageFormer ‚Ñì
 -- (parameters ‚ùô body) ‚ñ∑ d@(n ‚à∂ œÑ ‚âî Œ¥) = parameters ‚ùô Œª p ‚Üí body p ‚äé Just d
* COMMENT Here are some laws that allow one to reach the claimed canonical form:
  1. `:waist w ‚ü¥ :kind k ‚âà :kind k ‚ü¥ :waist w`

     Hence, we can always ensure `waist` appears before `kind`.

  2. More generally, `f ‚ü¥ g ‚âà g ‚ü¥ f` whenever `f` and `g` are ‚Äòdisjoint‚Äô; whence
     ‚®æ-extensions also share this property with `:waist` and `:kind`.

     Thus we can always ensure ‚®æ-extensions appear before `:waist` and `:kind` clauses.

  3. `f‚ÇÅ ‚ü¥ f‚ÇÇ ‚âà f‚ÇÇ` for `f·µ¢` both being either `:waist` clauses or `:kind` clauses.

     Hence, there will always be only one `:waist` and one `:kind` clause.

  Of-course these rules only permit the constructions `‚ü¥, :waist, :kind` and
  ‚®æ-extensions. E.g., if the hammer `:alter-elements` is admitted, then little
  can be said since, say, one may re-arrange ‚®æ-extension elements according to
  their waist and kind, as is the case of Agda modules, wherein items above
  the waist *cannot* have definitional clauses.

* COMMENT Normal Forms üöß                                 :construction_site:

  Ignoring the concrete syntax, every PackageFormer has a canonical flattened form:
#+begin_example haskell
LHS = ‚àÖ ‚®æ n‚ÇÄ ‚à∂ œÑ‚ÇÄ ‚âî d‚ÇÄ ‚®æ ‚ãØ ‚®æ n‚Çò ‚à∂ œÑ‚Çò ‚âî d‚Çò ‚ü¥ :waist ùìå ‚ü¥ :kind ùìÄ
#+end_example

The ‚Äú‚®æ‚Äù is read ‚Äúextended-by‚Äù and the definitional clauses $d‚Çñ$ may involve any
of the names $n·µ¢$ for $i < k$.  It is an a *right* action:
#+begin_example haskell
_‚®æ_ : PackageFormer ‚Üí Declaration ‚Üí PackageFormer
#+end_example

# Where the semigroup structure on declarations is determined
# by sequential composition: If ~e·µ¢~ are declarations, then ~e‚ÇÄ‚®æ‚ãØ‚®æe‚Çô~
# is a ‚Äòsingle‚Äô declaration.

The canonical form suggests that /PackageFormers are triples/
consisting of a context, a number, and a tag.

Instead of $‚àÖ ‚®æ n‚ÇÄ ‚à∂ œÑ‚ÇÄ ‚âî d‚ÇÄ ‚®æ ‚ãØ ‚®æ n‚Çò ‚à∂ œÑ‚Çò ‚âî d‚Çò ‚ü¥ :waist ùìå ‚ü¥ :kind ùìÄ$ let us
write $e‚ÇÄ ‚®æ ‚Ä¶ ‚®æ e_ùìå ‚ùô_{ùìÄ} e_{ùìå+1}‚®æ ‚Ä¶ e‚Çò$.
- When the kind ùìÄ is uninteresting, or may be arbitrary, we shall omit it from
  the notation altogether. Likewise for the separator ‚Äò‚ùô‚Äô.

We may now define a composition operation on PackageFormers, via
pushout or disjoint union; e.g., $(Œì‚ÇÅ ‚ùô Œì‚ÇÇ) ‚äé (Œì‚ÇÅ‚Ä≤ ‚ùô Œì‚ÇÇ‚Ä≤) = Œì‚ÇÅ‚Ä≥ ‚ùô Œì‚ÇÇ‚Ä≥$ where Œì·µ¢‚Ä≥
is catenation of Œì·µ¢ and Œì·µ¢‚Ä≤, in some fixed chosen order.

We may also define a dual form of extension, known as ‚Äúsnoc‚Äù when ‚®æ is read
‚Äúcons‚Äù.
#+begin_src haskell
_‚∏µ_ : Declaration ‚Üí PackageFormer ‚Üí PackageFormer
e ‚∏µ (Œì‚ÇÅ ‚ùô Œì‚ÇÇ) = ((‚àÖ ‚®æ e) ‚äé Œì‚ÇÅ) ‚ùô Œì‚ÇÇ
#+end_src

In the informal notation of contexts of type theory, the three operations ‚∏µ, ‚®æ,
‚äé are denoted ‚Äú,‚Äù.

*** PackageFormers and derived =_‚äé_=
 #+BEGIN_SRC agda2 :tangle semantics.agda
record PackageFormer : Set‚ÇÅ where
  constructor _‚ùô_
  field
    parameters : Context
    body       : Context‚Ä≤ parameters

_‚äé‚Çö_ : PackageFormer ‚Üí PackageFormer ‚Üí PackageFormer
(Œì‚ÇÅ ‚ùô Œì‚ÇÇ) ‚äé‚Çö (Œì‚ÇÅ‚Ä≤ ‚ùô Œì‚ÇÇ‚Ä≤) = (Œì‚ÇÅ ‚äé Œì‚ÇÅ‚Ä≤) ‚ùô [ Œì‚ÇÇ , Œì‚ÇÇ‚Ä≤ ]
 #+END_SRC

* COMMENT Meta-Primitives as Functions üöß                 :construction_site:

With a notation and understanding of what a PackageFormer
consists of, we are in a position to provide a semantics
for the meta-primitives.

# :waist, :kind, ‚ñ∑, and ‚ü¥ are syntactic constructors.

First, ~waist~ is lifted from a syntactic construct to a function operation on
PackageFormers as follows.
#+begin_src haskell
_waist_ : PackageFormer ‚Üí ‚Ñï ‚Üí PackageFormer
(Œì‚ÇÅ ‚ùô Œì‚ÇÇ) waist 0       = ‚àÖ ‚ùô (Œì‚ÇÅ ‚äé Œì‚ÇÇ)
(Œì‚ÇÅ ‚ùô Œì‚ÇÇ) waist (n + 1) = (head Œì‚ÇÅ) ‚óÅ (tail Œì‚ÇÅ ‚ùô Œì‚ÇÇ) waist n

where head : PackageFormer ‚Üí Maybe Declaration
      head ‚àÖ = Nothing
      head (e‚ÇÅ, ‚Ä¶, e‚Çô ‚ùô Œì‚ÇÇ) = Just e‚ÇÅ

      tail : PackageFormer ‚Üí PackageFormer
      tail ‚àÖ = ‚àÖ
      tail (e‚ÇÅ ‚óÅ Œì) = Œì
#+end_src

That is, if $Œì = e‚ÇÄ‚®æ ‚ãØ‚®æ e‚Çò$, ignoring the separator, then
$Œì waist n ‚âà e‚ÇÄ‚®æ ‚ãØ‚®æ e‚Çô ‚ùô e‚Çô‚Çä‚ÇÅ‚®æ ‚ãØ‚®æ e‚Çò$. That is, =waist= introduces
a partition in a context. Operationally, only the associated number
component of a PackageFormer has been altered.

* COMMENT Shallow Embedding Approach :typechecks:

In the setup below, it seems using the context approach can sometimes be easier
than using the Œª approach, even though they are essentially the same.
Intuitively:
| What doing? | Easier to use |
|-------------+---------------|
| Reasoning   | Context       |
| Programming | Functions     |

** Imports
 #+BEGIN_SRC agda2
module pf where

open import Level renaming (zero to ‚Ñìzero; suc to ‚Ñìsuc; _‚äî_ to _‚äç_)
open import Relation.Binary.PropositionalEquality using (_‚â°_; refl)
open import Data.Nat
open import Data.Unit
open import Data.Empty
open import Data.Bool
open import Data.List
open import Data.List.Membership.Propositional
open import Data.List.Relation.Unary.Any using (here; there)
open import Relation.Nullary using (yes; no)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.String using (String) renaming (_==_ to _==‚Çõ_; _‚âü_ to _‚âü‚Çõ_; _++_ to _++‚Çõ_)
open import Data.Product using (Œ£ ; proj‚ÇÅ ; proj‚ÇÇ ; _√ó_ ; _,_)

 #+END_SRC

** Syntax Declarations
 #+BEGIN_SRC agda2

Name = String

Œ£‚à∂‚Ä¢ : ‚àÄ {a b} (A : Set a) (B : A ‚Üí Set b) ‚Üí Set _
Œ£‚à∂‚Ä¢ = Œ£

infix -666 Œ£‚à∂‚Ä¢
syntax Œ£‚à∂‚Ä¢ A (Œª x ‚Üí B) = Œ£ x ‚à∂ A ‚Ä¢ B

infixr 10 Œ†
syntax Œ† A (Œª x ‚Üí B) = Œ† x ‚à∂ A ‚Ä¢ B

infix 9 _‚ä¢Term_

 #+END_SRC
** Contexts, types, and terms

   Contexts are types, level-indexed types are functions, œÑ-terms are functions taking
   the context and yielding a value.

  #+BEGIN_SRC agda2
PackageFormer : (i : Level) ‚Üí Set (‚Ñìsuc i)
PackageFormer i = Set i
 #+END_SRC

*** types
  Next, object-level universes are implemented using meta-level universes.
  - Note: =Œì ‚ä¢Type ùíæ  ‚â°  Œì ‚ä¢Term (ùí∞ ùíæ)=.

  #+BEGIN_SRC agda2
_‚ä¢Type_ :  ‚àÄ {i} ‚Üí PackageFormer i ‚Üí (j : Level) ‚Üí Set (i ‚äç ‚Ñìsuc j)
Œì ‚ä¢Type ùíæ = Œì ‚Üí Set ùíæ

ùí∞ : ‚àÄ {i} {Œì : PackageFormer i} (j : Level) ‚Üí Œì ‚ä¢Type (‚Ñìsuc j)
ùí∞ j = Œª Œ≥ ‚Üí Set j
  #+END_SRC
*** terms
  #+BEGIN_SRC agda2
_‚ä¢Term_ : ‚àÄ {i j} ‚Üí (Œì : PackageFormer i) ‚Üí Œì ‚ä¢Type j ‚Üí Set (i ‚äç j)
Œì ‚ä¢Term œÑ = (Œ≥ : Œì) ‚Üí œÑ Œ≥
  #+END_SRC

  After all, a classical context ~x‚ÇÅ : œÑ‚ÇÅ, ‚Ä¶, x‚Çô : œÑ‚Çô ‚ä¢ e : œÑ~ only /asserts/ =e : œÑ=
  /provided/ =x·µ¢ : œÑ·µ¢=, and so the latter is a function of the former! Indeed, as the
  Œª-introduction rule shows, *all contexts are the humble function*
  ---e.g., with church encodings, we have that algebraic data-types are also
  functions, the eliminators.
  + MA: Perhaps with this neato observation, I should simply focus on functions?

*** context constructors

  The empty context is the unit type and context extension is interpreted using Œ£-types.
  The identity of dependent products is the unit type, whence it denotes the empty PackageFormer.

 #+BEGIN_SRC agda2
Œµ : PackageFormer ‚Ñìzero
Œµ = ‚ä§

_‚ñ∑_ : ‚àÄ {i j} (Œì : PackageFormer i) ‚Üí Œì ‚ä¢Type j ‚Üí PackageFormer (i ‚äç j)
Œì ‚ñ∑ A = Œ£ Œ≥ ‚à∂ Œì ‚Ä¢ A Œ≥

  #+END_SRC
** Coercisions and Œ†

 #+BEGIN_SRC agda2
weaken : ‚àÄ {i j k} {Œì : PackageFormer i} {A : Œì ‚ä¢Type k}
       ‚Üí Œì ‚ä¢Type j ‚Üí (Œì ‚ñ∑ A) ‚ä¢Type j
weaken œÑ (Œ≥ , a) = œÑ Œ≥

pf-refl : ‚àÄ {i j} {Œì : PackageFormer i} {A : Œì ‚ä¢Type j}
        ‚Üí (Œì ‚ñ∑ A) ‚ä¢Term weaken A
pf-refl = proj‚ÇÇ

Œ† : ‚àÄ {i j k} {Œì : PackageFormer i} (A : Œì ‚ä¢Type j) (B : (Œì ‚ñ∑ A) ‚ä¢Type k)
  ‚Üí Œì ‚ä¢Type (j ‚äç k)
Œ† A B = Œª Œ≥ ‚Üí ‚àÄ (a : A Œ≥) ‚Üí B (Œ≥ , a)

_‚áí_ : ‚àÄ {i j k} {Œì : PackageFormer i} (A : Œì ‚ä¢Type j) (B : Œì ‚ä¢Type k)
    ‚Üí Œì ‚ä¢Type (j ‚äç k)
A ‚áí B = Œ† A (weaken B)

 #+END_SRC
** =lam= and =app=
 Abstraction and application are just Currying & Uncurrying
 #+BEGIN_SRC agda2
lam : ‚àÄ {i j k} {Œì : PackageFormer i} {A : Œì ‚ä¢Type j} {B : (Œì ‚ñ∑ A) ‚ä¢Type k}
    ‚Üí (Œì ‚ñ∑ A) ‚ä¢Term B  ‚Üí  Œì ‚ä¢Term (Œ† A B)
lam g = Œª Œ≥ ‚Üí Œª a ‚Üí g (Œ≥ , a)

app : ‚àÄ {i j k} {Œì : PackageFormer i} {A : Œì ‚ä¢Type j} {B : (Œì ‚ñ∑ A) ‚ä¢Type k}
      ‚Üí  Œì ‚ä¢Term (Œ† A B)  ‚Üí (Œì ‚ñ∑ A) ‚ä¢Term B
app g = Œª{(Œ≥ , a) ‚Üí g Œ≥ a}
 #+END_SRC

 Here are other forms of function application.
 #+BEGIN_SRC agda2
cut‚Ä≤ : ‚àÄ {i j k} {Œì : PackageFormer i} {A : Œì ‚ä¢Type j} {B : Œì ‚ä¢Type k}
      ‚Üí  (Œì ‚ñ∑ A) ‚ä¢Term weaken B
      ‚Üí  Œì       ‚ä¢Term A
      ‚Üí  Œì       ‚ä¢Term B
cut‚Ä≤ f a = Œª Œ≥ ‚Üí f (Œ≥ , a Œ≥)

_on_ : ‚àÄ {i j k} {Œì : PackageFormer i} {A : Œì ‚ä¢Type j}
      ‚Üí (Œì ‚ñ∑ A) ‚ä¢Type k
      ‚Üí  Œì ‚ä¢Term A
      ‚Üí  Œì ‚ä¢Type k
f on a = Œª Œ≥ ‚Üí f (Œ≥ , a Œ≥)

cut : ‚àÄ {i j k} {Œì : PackageFormer i} {A : Œì ‚ä¢Type j} {B : (Œì ‚ñ∑ A) ‚ä¢Type k}
      ‚Üí  (Œì ‚ñ∑ A) ‚ä¢Term B
      ‚Üí  (a : Œì  ‚ä¢Term A)
      ‚Üí  Œì       ‚ä¢Term (B on a)
cut f a = Œª Œ≥ ‚Üí f (Œ≥ , a Œ≥)

_$_ : ‚àÄ {i j k} {Œì : PackageFormer i} {A : Œì ‚ä¢Type j} {B : (Œì ‚ñ∑ A) ‚ä¢Type k}
      ‚Üí Œì ‚ä¢Term (Œ† A B)
      ‚Üí (a : Œì ‚ä¢Term A)
      ‚Üí Œì ‚ä¢Term (B on a)
_$_ g = Œª a Œ≥ ‚Üí g Œ≥ (a Œ≥)
 #+END_SRC

** Example terms!

 #+BEGIN_SRC agda2
‚Äµid : Œµ ‚ä¢Term Œ† A ‚à∂ ùí∞ ‚Ñìzero ‚Ä¢ let A‚Ä≤ = Œª _ ‚Üí proj‚ÇÇ A -- weakening.
                              in (A‚Ä≤ ‚áí A‚Ä≤) Œµ
‚Äµid = lam (lam proj‚ÇÇ)
 #+END_SRC

 Let's try to show that =pf-refl= really is the identity function, up to isomorphism.
 #+BEGIN_SRC agda2
‚Äµid‚ÇÇ : ‚àÄ {i j} {Œì : PackageFormer i} {A : Œì ‚ä¢Type j}
     ‚Üí Œì ‚ä¢Term A ‚áí A
‚Äµid‚ÇÇ = lam pf-refl
 #+END_SRC

 Neato! Progress, finally (‡∏á‡≤†_‡≤†)‡∏á
* COMMENT Old Approach using Deep Embedding :incomplete:holes:

  #+begin_example agda2
module pf where
#+end_example
** Imports
#+begin_example agda2
open import Relation.Binary.PropositionalEquality using (_‚â°_; refl)
open import Data.Nat
open import Data.Unit
open import Data.Empty
open import Data.Bool
open import Data.List
open import Data.List.Membership.Propositional
open import Data.List.Relation.Unary.Any using (here; there)
open import Relation.Nullary using (yes; no)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.String using (String) renaming (_==_ to _==‚Çõ_; _‚âü_ to _‚âü‚Çõ_; _++_ to _++‚Çõ_)
open import Data.Product using (Œ£ ; proj‚ÇÅ ; proj‚ÇÇ ; _√ó_ ; _,_)
Name = String
#+end_example
** Fixity & syntax declarations
#+begin_example agda2
infix 11 eq
syntax eq œÑ l r  =  l ‚Äµ‚â° r ‚à∂ œÑ

infixr 10 _‚Äµ‚Üí_ ‚Äµ‚àÄ
syntax ‚Äµ‚àÄ œÑ (Œª Œ∑ ‚Üí Œ≥) = Œ† Œ∑ ‚à∂ œÑ ‚Ä¢ Œ≥ -- ‚ÄúZ-notation‚Äù

-- infixl 9 _‚à∂_ _‚à∂_‚âî_
infixl 9 _‚à∂_

infixl 5 _extended-by_

Œ£‚à∂‚Ä¢ : ‚àÄ {a b} (A : Set a) (B : A ‚Üí Set b) ‚Üí Set _
Œ£‚à∂‚Ä¢ = Œ£

infix -666 Œ£‚à∂‚Ä¢
syntax Œ£‚à∂‚Ä¢ A (Œª x ‚Üí B) = Œ£ x ‚à∂ A ‚Ä¢ B
#+end_example
** Declarations for mutually recursive DTL concepts
#+begin_example agda2
data PF : Set                          -- Syntax of PackageFormers; i.e., contexts
data _‚ä¢Type (Œì : PF) : Set             -- Types in context
type-names-of : PF ‚Üí List Name
-- types-of : (Œì : PF) ‚Üí List (Œì ‚ä¢Type)   -- The collection of types mentioned in a context
record _‚ä¢constituent (Œì : PF) : Set    -- The type of terms
data _‚ä¢Term:_ (Œì : PF) : Œì ‚ä¢Type ‚Üí Set -- Terms in context
#+end_example
** PackageFormer syntax
#+begin_example agda2
data PF where
  empty : PF
  _extended-by_ : (Œì : PF) ‚Üí Œì ‚ä¢constituent ‚Üí PF
#+end_example
** ‚Äúdeclarations in context‚Äù
#+begin_example agda2
record _‚ä¢constituent Œì where
  -- constructor _‚à∂_‚âî_
  constructor _‚à∂_
  inductive
  field
    name     : Name
    type     : Œì ‚ä¢Type
    -- equation : Maybe (Œì ‚ä¢Term: type)
    -- Ommitted for brevity

open _‚ä¢constituent

{-
_‚à∂_ : ‚àÄ {Œì} ‚Üí Name ‚Üí Œì ‚ä¢Type ‚Üí Œì ‚ä¢constituent
x ‚à∂ œÑ = x ‚à∂ œÑ ‚âî nothing
-}
#+end_example
** Decision procedure for tedious proofs
#+begin_example agda2
-- Soundness: Let's construct a decision procedure that actually provides tedious proofs.
-- This is used in the ADT ‚Äú_‚ä¢Type‚Äù.

data Error : String ‚Üí Set where

present? : Name ‚Üí List Name ‚Üí Set
present? Œ∑ []       = Error ("The type ‚Äú" ++‚Çõ Œ∑ ++‚Çõ "‚Äù is not in the parent context!")
present? Œ∑ (n ‚à∑ ns) with Œ∑ ==‚Çõ n
...| true  = ‚ä§
...| false = present? Œ∑ ns

soundness : ‚àÄ {Œ∑ ns} ‚Üí present? Œ∑ ns ‚Üí Œ∑ ‚àà ns
soundness {Œ∑} {n ‚à∑ ns} p with Œ∑ ‚âü‚Çõ n
...| yes q = here q
...| no ¬¨q = there (soundness p)

tedious-example : "C" ‚àà ("A" ‚à∑ "B" ‚à∑ "C" ‚à∑ "D" ‚à∑ [])
tedious-example = there (there (here refl))

improved-example : "C" ‚àà ("A" ‚à∑ "B" ‚à∑ "C" ‚à∑ "D" ‚à∑ [])
improved-example = soundness tt

-- Uncomment to see an error since c is not in the list.
-- useful-error-msg : "c" ‚àà ("A" ‚à∑ "B" ‚à∑ "C" ‚à∑ "D" ‚à∑ [])
-- useful-error-msg = soundness tt
#+end_example
** ‚Äútypes in context‚Äù
#+begin_example agda2
{-
  œÑ ‚à∑= Set       ‚Äúuniverse of types‚Äù
     | œÑ ‚Üí œÑ     ‚Äúfunction types‚Äù
     | Œ±         ‚Äúatomic types mentioned in the context‚Äù
     | e ‚â° d     ‚Äúterm equality in context‚Äù
-}

data _‚ä¢Type Œì where

  ‚ÄµSet  : Œì ‚ä¢Type                                        -- type of small types

  -- ‚Äµ‚àÄ : (œÑ : Œì ‚ä¢Type) (body : Œì ‚ä¢Term: œÑ ‚Üí Œì ‚ä¢Type) ‚Üí Œì ‚ä¢Type -- Pi types, we fail the positivity checker.
  -- In the spirit of gradual typing, we use a weaker form: The assumed term losses any possible definiens, equations.
  ‚Äµ‚àÄ : (œÑ : Œì ‚ä¢Type) (body : (Œ∑ : Name) ‚Üí (Œì extended-by Œ∑ ‚à∂ œÑ) ‚ä¢Type) ‚Üí Œì ‚ä¢Type

  _‚Äµ‚Üí_ : Œì ‚ä¢Type ‚Üí Œì ‚ä¢Type ‚Üí Œì ‚ä¢Type -- function type; making this derived requires a weak form of commuatvity at the context level

  -- variable case; the name must be mentioned in Œì
  ‚Äµ_   : (Œ∑ : Name) {{_ : present? Œ∑ (type-names-of Œì)}} ‚Üí Œì ‚ä¢Type

  eq : (œÑ : Œì ‚ä¢Type) (l r : Œì ‚ä¢Term: œÑ) ‚Üí Œì ‚ä¢Type

{-
_‚Äµ‚Üí_ : {Œì : PF} ‚Üí Œì ‚ä¢Type ‚Üí Œì ‚ä¢Type ‚Üí Œì ‚ä¢Type -- function type
œÑ ‚Äµ‚Üí Œ≥ = Œ† _ ‚à∂ œÑ ‚Ä¢ weaken Œ≥
-}
#+end_example
** =type-names-of=
#+begin_example agda2
type-names-of empty = []
type-names-of (pf extended-by name‚ÇÅ ‚à∂ ‚ÄµSet) = name‚ÇÅ ‚à∑ type-names-of pf
type-names-of (pf extended-by _) = type-names-of pf
#+end_example
** A hierarchy of dependent weakening rules
#+begin_example agda2
{-
weaken1 : ‚àÄ {Œì e} ‚Üí Œì ‚ä¢Type ‚Üí (Œì extended-by e) ‚ä¢Type

insert-before-last : ‚àÄ {Œì Œ∑ e œÑ} ‚Üí (Œì extended-by Œ∑ ‚à∂ œÑ) ‚ä¢Type
                                 ‚Üí (Œì extended-by e extended-by Œ∑ ‚à∂ weaken1 œÑ) ‚ä¢Type

insert-before-second-last : ‚àÄ {Œì Œ∑‚ÇÅ Œ∑‚ÇÇ œÑ‚ÇÅ œÑ‚ÇÇ e}
 ‚Üí (Œì extended-by               Œ∑‚ÇÅ ‚à∂         œÑ‚ÇÅ extended-by Œ∑‚ÇÇ ‚à∂  œÑ‚ÇÇ) ‚ä¢Type
 ‚Üí (Œì extended-by e extended-by Œ∑‚ÇÅ ‚à∂ weaken1 œÑ‚ÇÅ extended-by Œ∑‚ÇÇ ‚à∂ insert-before-last œÑ‚ÇÇ) ‚ä¢Type
insert-before-second-last œÑ = {!!}

insert-before-last ‚ÄµSet = ‚ÄµSet
insert-before-last (‚Äµ‚àÄ œÑ body) = Œ† Œ∑ ‚à∂ insert-before-last œÑ ‚Ä¢  insert-before-second-last (body Œ∑)
insert-before-last (œÑ ‚Äµ‚Üí œÑ‚ÇÅ) = {!!}
insert-before-last (‚Äµ Œ∑) = {!!}
insert-before-last (eq œÑ l r) = {!!}

weaken1 ‚ÄµSet        = ‚ÄµSet
weaken1 (‚Äµ‚àÄ œÑ body) = Œ† Œ∑ ‚à∂ weaken1 œÑ ‚Ä¢ insert-before-last (body Œ∑)
weaken1 (œÑ ‚Äµ‚Üí œÑ‚ÇÅ)   = {!!}
weaken1 (‚Äµ Œ∑)       = {!!}
weaken1 (eq œÑ l r)  = {!!}
-}

{- Other weakening rules
weaken-cons : ‚àÄ {Œì e} ‚Üí Œì ‚ä¢constituent ‚Üí (Œì extended-by e) ‚ä¢constituent

weaken-mid : ‚àÄ {Œì pre post new} ‚Üí (Œì extended-by pre extended-by post) ‚ä¢Type
                                ‚Üí (Œì extended-by pre extended-by new extended-by weaken-cons post) ‚ä¢Type
-}
#+end_example
** How many ‚Äòarguments‚Äô does a type have?
#+begin_example agda2
{-

arity : ‚àÄ {Œì} ‚Üí Œì ‚ä¢Type ‚Üí ‚Ñï
arity ‚ÄµSet        = 0
arity (‚Äµ‚àÄ œÑ body) = 1 + arity (body "_") -- Hack; possible since names are strings.
arity (œÑ ‚Äµ‚Üí œÑ‚ÇÅ)   = 1 + arity Œ≥  -- E.g., Œ± ‚Äµ‚Üí (Œ≤ ‚Äµ‚Üí Œ≥) has 2 arguments.
arity (‚Äµ Œ∑)       = {!!} -- Need to consider its type in Œì
arity (eq œÑ l r)  = 0
-}
#+end_example
** The subparts of a type expression
#+begin_example agda2
{--

-- An alias for _‚â°_; a singleton type
data JustThis {A : Set} : A ‚Üí Set where
  this : (a : A) ‚Üí JustThis a

-- If arity œÑ = 0 then ‚ä§ else the type of the first argument.
type-head : ‚àÄ {Œì} ‚Üí Œì ‚ä¢Type ‚Üí Set
type-head ‚ÄµSet      = ‚ä§
type-head (œÑ ‚Äµ‚Üí _)  = JustThis œÑ
type-head _  = ‚ä§

-- If arity œÑ = 0 then ‚ä§ else the type of the first argument.
type-tail : ‚àÄ {Œì} ‚Üí Œì ‚ä¢Type ‚Üí Œì ‚ä¢Type
type-tail œÑ = {!!}
-}
#+end_example
** ‚Äúterms in context‚Äù
#+begin_example agda2
data _‚ä¢Term:_ Œì where

  -- TODO: ‚Äúx must be fresh for Œì‚Äù; variable case
  ‚Äµ_  : {œÑ : Œì ‚ä¢Type} (x : Name) ‚Üí Œì ‚ä¢Term: œÑ

  -- curried function application
  -- _$_ : (f : Œì ‚ä¢constituent) ‚Üí type-head (type f) ‚Üí Œì ‚ä¢Term: type-tail (type f) -- Omitted for brevity
#+end_example
** Examples
#+begin_example agda2
Type : PF
Type = empty extended-by "Carrier" ‚à∂ ‚ÄµSet

Indistinguishable : PF
Indistinguishable = Type extended-by
                         "blind" ‚à∂ Œ† ùìÅ ‚à∂ ‚Äµ "Carrier" ‚Ä¢ Œ† ùìá ‚à∂ ‚Äµ "Carrier" ‚Ä¢ ‚Äµ ùìÅ ‚Äµ‚â° ‚Äµ ùìá ‚à∂ ‚Äµ "Carrier"

Pointed : PF
Pointed = Type extended-by "ùüô" ‚à∂ ‚Äµ "Carrier"
-- Typos such as forgetting the final letter produce type-checking errors:
-- The type ‚ÄúCarrie‚Äù is not in the parent context!
-- Pointed = Type extended-by "ùüô" ‚à∂ ‚Äµ "Carrie"

Magma : PF
Magma = Type extended-by "_¬∑_" ‚à∂ ‚Äµ "Carrier" ‚Äµ‚Üí ‚Äµ "Carrier" ‚Äµ‚Üí ‚Äµ "Carrier"
#+end_example
** Semantics
#+begin_example agda2
terms : PF ‚Üí List (Œ£ Œì ‚à∂ PF ‚Ä¢ Œì ‚ä¢constituent)
terms empty = []
terms (p extended-by x) = terms p ++ [ p , x ]

Type-names-of : PF ‚Üí Set
Type-names-of Œì = Œ£ Œ∑ ‚à∂ Name ‚Ä¢ present? Œ∑ (type-names-of Œì)

sem‚Çú : ‚àÄ {Œì} ‚Üí (Type-names-of Œì ‚Üí Set‚ÇÅ) ‚Üí Œì ‚ä¢Type ‚Üí Set‚ÇÇ
sem‚Çë : ‚àÄ {Œì} {œÑ : Œì ‚ä¢Type} (œÉ : Type-names-of Œì ‚Üí Set‚ÇÅ) ‚Üí Œì ‚ä¢Term: œÑ ‚Üí Set‚ÇÅ -- sem‚Çú œÉ œÑ  ‚áê  free variables are just placeholders for the types they represent

sem‚Çë {Œì} {œÑ} œÉ (‚Äµ x) = {!sem‚Çú œÉ œÑ!}

open import Level using (Lift)

sem‚Çú œÉ ‚ÄµSet          = Set‚ÇÅ
sem‚Çú œÉ (‚Äµ‚àÄ œÑ body)   = ‚àÄ (x : sem‚Çú œÉ œÑ) ‚Üí ‚ä• -- TODO
sem‚Çú œÉ (œÑ ‚Äµ‚Üí Œ≥)      = sem‚Çú œÉ œÑ ‚Üí sem‚Çú œÉ Œ≥
sem‚Çú œÉ (‚Äµ_ Œ∑ {{p}})  = Lift _ (œÉ (Œ∑ , p))
sem‚Çú œÉ (eq œÑ l r)    = sem‚Çë œÉ l ‚â° sem‚Çë œÉ r  -- ARGH: sem‚Çë must yield Set‚ÇÅ so it can be used in sem‚Çú !!!!!!  -- JC, what do?

{-
present?-tn : ‚àÄ {Œ∑ Œì e} ‚Üí   present? Œ∑ (type-names-of (Œì extended-by e))
                          ‚â° (if   (Œ∑ ==‚Çõ name e)
                             then ‚ä§
                             else present? Œ∑ (type-names-of Œì))
present?-tn {Œ∑} {Œì} {e} with type-names-of (Œì extended-by e) | Œ∑ ==‚Çõ name e
present?-tn {Œ∑} {Œì} {e} | [] | false = {!!}
present?-tn {Œ∑} {Œì} {e} | [] | true = {!!}
present?-tn {Œ∑} {Œì} {e} | x ‚à∑ xs | t = {!!}


weaken-present? : ‚àÄ {Œ∑ Œì e} ‚Üí present? Œ∑ (type-names-of Œì)
                            ‚Üí present? Œ∑ (type-names-of (Œì extended-by e))
weaken-present? {Œ∑} {Œì = Œì} p with type-names-of Œì | p
weaken-present? {Œ∑} {Œì = Œì} p | x ‚à∑ xs | q with Œ∑ ==‚Çõ x
weaken-present? {Œ∑} {Œì} p | x ‚à∑ xs | q | false = {!!}
weaken-present? {Œ∑} {Œì} p | x ‚à∑ xs | q | true = {!!}
-}

weaken : ‚àÄ {Œì e}  ‚Üí Œì ‚ä¢Type ‚Üí (Œì extended-by e) ‚ä¢Type
weaken ‚ÄµSet        = ‚ÄµSet
weaken (‚Äµ‚àÄ œÑ body) = {!!}
weaken (œÑ ‚Äµ‚Üí Œ≥)   = weaken œÑ ‚Äµ‚Üí weaken Œ≥
weaken (‚Äµ_ Œ∑ {{p}})       = ‚Äµ_ Œ∑ {{{!!}}}
weaken (eq œÑ l r)  = {!!}

terms‚Ä≤ : (Œì : PF) (œÉ : Œì ‚ä¢Type ‚Üí Set) ‚Üí List (Œ£ Œì‚Ä≤ ‚à∂ PF ‚Ä¢ Set √ó Œì‚Ä≤ ‚ä¢constituent)
terms‚Ä≤ empty œÉ = []
terms‚Ä≤ (p extended-by e@(Œ∑ ‚à∂ œÑ)) œÉ = terms‚Ä≤ p (Œª x ‚Üí œÉ (weaken x)) ++ [ p , œÉ (weaken œÑ) , e ] -- terms‚Ä≤ p {!!} ++ [ p , {!!} , {!x!} ]
-- terms p ++ [ p , x ]


{-
sem : (Œì : PF) (œÉ : Œì ‚ä¢Type ‚Üí Set) (Œ± : (Œ∑ : Name) ‚Üí Œ£ T ‚à∂ Set ‚Ä¢ T) ‚Üí Set
sem p œÉ Œ± with terms p
...| [] = ‚ä•
...| (_ , Œ∑ ‚à∂ œÑ) ‚à∑ xs = {!!}
  where -- function patching
        Œ±‚Ä≤ : Name ‚Üí Œ£ T ‚à∂ Set ‚Ä¢ T
        Œ±‚Ä≤ n = if n ==‚Çõ Œ∑ then (œÉ {!!}) , {!!} else Œ± n
-}

#+end_example
** Further experiments
#+begin_example agda2
{-
-- TODO: Add support for catenating PFs.
--
-- _‚å¢_ : PF ‚Üí PF ‚Üí PF
-- l ‚å¢ empty = l
-- l ‚å¢ (r extended-by x) = (l ‚å¢ r) extended-by {! need a weakening rule!}
--

monoid : PF
monoid = empty extended-by "Carrier" ‚à∂ ‚ÄµSet
               extended-by "_¬∑_" ‚à∂ ‚Äµ "Carrier" ‚Äµ‚Üí ‚Äµ "Carrier" ‚Äµ‚Üí ‚Äµ "Carrier"
               extended-by "ùüô" ‚à∂ ‚Äµ "Carrier"
               extended-by "assoc" ‚à∂ {!!}
-}
  #+end_example
