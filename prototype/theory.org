#+title: Progressing on a type theory for =PackageFormer=
#+author: Musa Al-hassy
#+agda_version: 2.6.0.1

*Status:*
Algebraic data-types and (parameterised) records are obtained from the same interface.

 1. I cannot seem to phrase, let alone prove, the =stability′= claim for
    dynamic systems.
 2. Likewise for =∀ {ℓ} {Γ : Context (ℓsuc ℓ)} → Γ 0 ≡ Γ :waist 0=.
 3. The use of ~map~ makes it unclear whether the recursive calls are structurally
    smaller or not, hence the need for the ~TERMINATING~ clauses.
 4. I feel that one of the two ~sourcesᵢ~ functions is spurious!

# (shell-command "ln -s theory.org readme.org")

* Table of Contents                                    :Github:TOC_4:
- [[#introduction][Introduction]]
- [[#preamble][Preamble]]
  - [[#module-header][Module header]]
  - [[#imports][Imports]]
  - [[#syntax-declarations][Syntax Declarations]]
  - [[#helper-utilities][Helper Utilities]]
    - [[#level-polymorphic-unit-type][Level-Polymorphic Unit Type]]
- [[#what-is-a-type-theory][What is “a type theory”?]]
- [[#our-ambient-type-theory][Our Ambient Type Theory]]
- [[#user-interface-for-context-declaration][User Interface for Context Declaration]]
  - [[#smart-constructors-as-do-notation][Smart Constructors as Do Notation]]
  - [[#example-records-of-𝓃-many-pointed-sets][Example: Records of 𝓃-many Pointed Sets]]
    - [[#types][Types]]
    - [[#instances][Instances]]
  - [[#doubly-pointed-example----on-the-nature-of-parameters-ξ][Doubly-Pointed Example -- On the nature of parameters Ξ]]
  - [[#example--a-record-type-with-invariants][Example – A record type with invariants]]
- [[#parameterised-records][Parameterised Records]]
  - [[#header][Header]]
    - [[#dependent-πσ-and-tuple-notation][Dependent Π∶•/Σ∶• and ⟨Tuple⟩ Notation]]
    - [[#reflection-helpers][Reflection Helpers]]
    - [[#var-dec-decreasing-de-bruijn-indices][=var-dec=: Decreasing De Bruijn Indices]]
  - [[#introduction-1][Introduction]]
  - [[#definitions-context-_-end][Definitions: ~Context, ‵_, End~]]
  - [[#definitions-__][Definitions: ~_>>_~]]
  - [[#example-dynamical-systems][Example: Dynamical Systems]]
  - [[#theorems-stability][Theorems: ~stability~]]
  - [[#natural-number-instance][Natural Number Instance]]
  - [[#πλ-and-modus-ponens][Π→λ and Modus Ponens]]
  - [[#defining-_waist_][Defining =_:waist_=]]
  - [[#further-natural-number-instances-and-fixing-parameters][Further Natural Number Instances and Fixing Parameters]]
  - [[#example----collections][Example ---Collections]]
  - [[#projections][Projections]]
- [[#algebraic-datatypes][Algebraic Datatypes]]
  - [[#goal-driven-development----a-5-step-plan][Goal-Driven Development ---a 5-step plan]]
  - [[#steps-1--2-records-and-type-constructors][Steps 1 & 2: Records and Type Constructors]]
  - [[#step-3-sources][Step 3: Sources]]
  - [[#step-4-unions-with-σ][Step 4: Unions with ~Σ→⊎~]]
  - [[#step-5-𝔻--ℕ][Step 5: =𝔻 ≅ ℕ=]]
  - [[#termtype-the-term-language-of-a-theory][~termtype~: The term language of a theory]]
  - [[#example-the-termtype-of-monoids-is-tree-skeletons][Example: The termtype of monoids is tree skeletons]]
  - [[#example-maybe-from-pointed-structures][Example: =Maybe= from pointed structures]]
- [[#kind][=:kind=]]

* Introduction

  For brevity, every PackageFormer declaration can essentially be seen as a
  sequence of declarations, some of which are considered /parameters/ and the rest
  are the /body/. Whence, a PackageFormer is a pair of contexts.

  Let's try to explain that idea.

  + We shall embed the syntax of PackageFormers using semantics functions.
  + For now, we only focus on the record semantics of a PackageFormer. ---i.e.,
    ~:kind record~.

* Preamble
** Module header
#+BEGIN_SRC agda2 :tangle semantics.agda
-- The .agda file is trangled from an org file.
module semantics where
#+END_SRC
** Imports
#+BEGIN_SRC agda2 :tangle semantics.agda
open import Data.Product
open import Data.Nat
open import Data.Sum
open import Relation.Binary.PropositionalEquality hiding ([_])
open ≡-Reasoning
open import Level renaming (zero to ℓ₀; suc to ℓsuc; _⊔_ to _⊍_)

import Data.Nat  as ℕ
open import Data.Fin  as Fin using (Fin)
open import Data.Bool renaming (Bool to 𝔹)
#+END_SRC
** Syntax Declarations
#+BEGIN_SRC agda2 :tangle semantics.agda
Σ∶• : ∀ {a b} (A : Set a) (B : A → Set b) → Set _
Σ∶• = Σ

infix -666 Σ∶•
syntax Σ∶• A (λ x → B) = Σ x ∶ A • B
#+END_SRC

** Helper Utilities
*** Level-Polymorphic Unit Type
#+BEGIN_SRC agda2 :tangle semantics.agda
record ⊤ {ℓ} : Set ℓ where
  constructor tt
#+END_SRC
*** COMMENT Singleton Types
We'll be treating contexts as sets and so will require a singleton types for
adjoining declarations.
#+BEGIN_SRC agda2 :tangle semantics.agda
data Just {ℓ} {A : Set ℓ} : A → Set where
  just : (a : A) → Just a
#+END_SRC
* What is “a type theory”?
  To get anything done, we'll need an ambient type theory that provides us with
  a set of variable names 𝕍 and typing judgements. The comments below are what a
  classical type theory would have.
#+BEGIN_SRC agda2
record TypeTheory : Set₁ where
  field
    -- An infinite set of variable names
    𝕍       : Set
    -- A collection of name-type pairs
    Context : Set
    -- Possible expressions in a given context
    Expr    : Context → Set
    -- When is an expression considered a ‘type’
    _⊢_type : (Γ : Context) → Expr Γ → Set
    -- When is a term considered to be “of a type”
    _⊢_∶_   : (Γ : Context) → Expr Γ → Expr Γ → Set
#+END_SRC
When Γ is fixed and if we denote ~Γ ⊢ e ∶ τ~ by ~e ⟶ τ~ then we obtained a directed
graph where an edge may be construed as ‘abstract interpreter’ relationship
---the ‘value’ of an expression is its type.

It seems that with the typing judgement, we can regain the kinding judgement:
~Γ ⊢ τ type ⇔ ∀ (v : 𝕍) → Γ ⊢ v ∶ τ~.

Within a type theory, we can define a notion of declarations.
#+BEGIN_SRC agda2
  data Declaration (Γ : Context) : Set where
    _∶_≔_by_and_ : (n : 𝕍) (τ δ : Expr Γ) → Γ ⊢ τ type → Γ ⊢ δ ∶ τ → Declaration Γ
#+END_SRC

  :Informal_Type_of_Declarations:
  Given an ambient type theory 𝑻, we define the type =Declaration= to be the
  triples ~n ∶ τ ≔ δ~ where =n= is a ‘name’, =τ= is a type of the given type theory, and
  =δ= is a term over that type theory, possibly adjoined with other declarations
  =nᵢ : τᵢ ≔ δᵢ=; i.e., the context ~𝑻, n₀ : τ₀ ≔ δ₀, …, nₘ : τₘ ≔ δₘ~ ensures ~τ~ is
  a type and ~δ~ is of that type, and ~n~ must be a fresh name.
  :End:

The purpose of this section is merely to make it clear what a type theory
consists of ---we will not make any instances of the ~TypeTheory~ record type.
+ It is a learning moment, for me.

* Our Ambient Type Theory
Rather than working with an opaque, and generic, instance of a type theory, we
will work with a particular instance: Agda's type theory.

| We ignore syntax and jump straight to semantics ---whence no expression type! |

0. At the level of semantics, we may use Agda's variables instead of a
   dedicated variable type.
1. A context is nothing more than a set.
   - With the ‘smart constructors’ below, a context is a dependent sum of types
     wherein later type-declarations may depend on earlier ones.
2. A type /determined by/ a context is a set than can be obtained
   using the context.

#+BEGIN_SRC agda2 :tangle semantics.agda
Context = λ ℓ → Set ℓ
#+END_SRC
#+BEGIN_SRC agda2
type : ∀ {ℓ} → Context ℓ → Set (ℓsuc ℓ)
type {ℓ} Γ = Γ → Set ℓ
#+END_SRC

With this elementary setup, we can, for example, denote context extension with
existentials, also known as dependent products ---whose unit, a singleton type,
acts as the “empty context”:
#+BEGIN_SRC agda2
∅ : Context ℓ₀
∅ = ⊤

_⨾_ : ∀ {ℓ} (Γ : Context ℓ) (τ : type Γ) → Context ℓ
Γ ⨾ τ = Σ γ ∶ Γ • τ γ
#+END_SRC
These names are not exported to the resulting Agda file, since they are not
needed. In particular, we will ‘reuse’ these names until we have ‘satisfactory’
definitions.

* User Interface for Context Declaration

** Smart Constructors as Do Notation
  Agda allows one to use an imperative style of programming ---using
  ~do~-notation--- provided there are mixfix functions ~_>>=_~ and ~_>>_~ in scope.
  + Importantly, only their existence is required; nothing else is assumed.
  + In particular, no monadic type constructor need be implicitly available.
    - This is the feature we exploit.

#+BEGIN_SRC agda2 :tangle semantics.agda
infixr 1 _>>=_

_>>=_ : ∀ {a ℓ}
      → (Γ : Context a)
      → (Γ → Context ℓ)
      → Context (a ⊍ ℓ)
Γ >>= f = (Σ γ ∶ Γ • f γ)
-- The new piece, f γ, is kept along with the old existing context via “γ ∶ Γ”.

-- Using the default definition of _>>_
infixr 1 _>>_
_>>_ : ∀ {a b} → Context a → Context b → Context (a ⊍ b)
p >> q = p >>= (λ _ → q)
#+END_SRC

The notation may be ~do…End~ using the following combinator.
However, in general, it may be ~do…𝒮~ for any set expression 𝒮.
#+BEGIN_SRC agda2 :tangle semantics.agda
End : ∀ {ℓ} → Context ℓ
End {ℓ} = ⊤ {ℓ}
#+END_SRC

These two pieces together are the aforementioned ‘smart constructors’:
+ ~Γ ⨾ τ~ is given the new syntax as ~Γ >>= τ~.
+ ~∅~ is given the syntax ~End~.

# You could define _>>=_ and End as aliases for _⨾_ and ∅.

/It is important to remember that these smart constructors form grouping
mechanisms, not instances of them/; which is accomplished using tuples.

** Example: Records of 𝓃-many Pointed Sets

   What do PackageFormers look like using the ~do~-notation and what do their
   instances look like? Surprisingly close to existing Agda record syntax for
   declarations and Agda tuples for instances.

*** Types
Let's form a grouping consisting of a single type and a value of that type,
along with an instance of the parameter type Ξ.
#+BEGIN_SRC agda2 :tangle semantics.agda
PointedPF : (Ξ : Context (ℓsuc ℓ₀)) → Context (ℓsuc ℓ₀)
PointedPF Ξ = do Carrier ← Set
                 point   ← Carrier
                 Ξ
#+END_SRC

Let's consider concrete instances of the parameter Ξ.
#+BEGIN_SRC agda2 :tangle semantics.agda
-- A record type --- Σ Set ∶ Carrier • Σ point ∶ Carrier • ⊤
PointedSet = PointedPF ⊤

-- An extended record type
-- Σ Set ∶ Carrier₁ • Σ point₁ ∶ Carrier₁ • (Σ Carrier₂ ∶ Set • Σ point₂ ∶ Carrier₁ • ⊤)
TwoPointedSets = PointedPF PointedSet
#+END_SRC
More generally:
#+BEGIN_SRC agda2 :tangle semantics.agda
_PointedSets : ℕ → Set₁
zero  PointedSets = ⊤
suc n PointedSets = PointedPF (n PointedSets)

-- C-c C-n 4 PointedSets ⇒ Somewhat readable definition of the record!
#+END_SRC

Here we already have power: It's difficult to create the family of types =n
PointedSets= using existing Agda record syntax since the number of fields, /2 × n/,
depends on =n=.

| Record /structure/ can be dependent on values! |

*** Instances
#+BEGIN_SRC agda2 :tangle semantics.agda
example₁ : PointedSet
example₁ = ℕ , 0 , tt

example₂ : PointedSet
example₂ = Fin.Fin 3 , Fin.suc Fin.zero , tt

example₃ : TwoPointedSets
example₃ = 𝔹 , true , example₁
-- A pointed nat extended by a pointed bool, with particular choices for both.
#+END_SRC

** Doubly-Pointed Example -- On the nature of parameters Ξ
What is a parameter exactly?

#+BEGIN_SRC agda2 :tangle semantics.agda
TwoParameterPoints : ∀ {ℓ} (Ξ : Context ℓ) → Context ℓ
TwoParameterPoints {ℓ} Ξ = do one   ← Ξ
                              two   ← Ξ
                              End {ℓ}

-- C-c C-n TwoParameterPoints   ⇒   λ Ξ → Σ one ∶ Ξ • Σ two ∶ Ξ • ⊤

-- Emphasise when sets are to be thought of as contexts
LitCtx : ∀ {ℓ} → Set ℓ → Context ℓ
LitCtx = λ c → c

example₄ : TwoParameterPoints (LitCtx 𝔹)
example₄ = false , false , tt  -- Obtained with C-c C-a

example₅ : TwoParameterPoints PointedSet
example₅ = example₁ , example₂ , tt
#+END_SRC

** Example – A record type with invariants

We can simulate definitions in a record via type invariants.

#+BEGIN_SRC agda2 :tangle semantics.agda
infix -1000 Property_
Property_ : ∀ {ℓ} → Set ℓ → Context ℓ -- Intended as invariants.
Property_ = λ c → c                   -- In some contexts, the values could be irrelevant.

PointedMagma : ∀ {ℓ} → Context ℓ → Context (ℓsuc ℓ)
PointedMagma {ℓ} Ξ = do Carrier ← Set ℓ
                        _⊕_     ← (Carrier → Carrier → Carrier)
                        one     ← Carrier
                        two     ← Carrier
                        three   ← Carrier
                        Property two   ≡ one ⊕ one
                        Property three ≡ one ⊕ two
#+END_SRC
The multiple laws, along with the following instance, increase confidence
in our definitions of ~_>>=_~ and ~_>>_~.
#+BEGIN_SRC agda2 :tangle semantics.agda
example₆ : PointedMagma ⊤
example₆ = ℕ , ℕ._+_ , 4 , 8 , 12 , refl {x = 8} , refl {x = 12}
#+END_SRC

* Parameterised Records

** Header

#+begin_src agda2 :tangle semantics-with-waist.agda
module semantics-with-waist where

open import Level renaming (_⊔_ to _⊍_; suc to ℓsuc; zero to ℓ₀)
open import Data.Nat
open import Relation.Binary.PropositionalEquality
open import Relation.Nullary
open import Data.Empty
open import Data.Bool using (Bool ; true ; false)
open import Data.List as List using (List ; [] ; _∷_ ; _∷ʳ_; sum)
open import Function using (_∘_)
open import Data.Sum
open import Data.Fin  as Fin using (Fin)
open import Data.Maybe  hiding (_>>=_)

-- “s ≔ v” is just a way to document v with string s.
open import Data.String using (String)
_≔_ : ∀ {ℓ} {A : Set ℓ} → String → A → A
s ≔ v = v
infix 9 _≔_

-- Used in an example later on; too boring to be placed there.
data Digit : Set where
  #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 : Digit

#→ℕ : Digit → ℕ
#→ℕ #0 = 0
#→ℕ #1 = 1
#→ℕ #2 = 2
#→ℕ #3 = 3
#→ℕ #4 = 4
#→ℕ #5 = 5
#→ℕ #6 = 6
#→ℕ #7 = 7
#→ℕ #8 = 8
#→ℕ #9 = 9
     #+end_src

*** Dependent Π∶•/Σ∶• and ⟨Tuple⟩ Notation
 #+begin_src agda2 :tangle semantics-with-waist.agda
open import Data.Product

Σ∶• : ∀ {a b} (A : Set a) (B : A → Set b) → Set _
Σ∶• = Σ

infix -666 Σ∶•
syntax Σ∶• A (λ x → B) = Σ x ∶ A • B

Π∶• : ∀ {a b} (A : Set a) (B : A → Set b) → Set _
Π∶• A B = (x : A) → B x

infix -666 Π∶•
syntax Π∶• A (λ x → B) = Π x ∶ A • B

record ⊤ {ℓ} : Set ℓ where
  constructor tt

open import Data.Empty using (⊥)

𝟙 = ⊤ {ℓ₀}
𝟘 = ⊥

-- Expressions of the form “⋯ , tt” may now be written “⟨ ⋯ ⟩”
infixr 5 ⟨ _⟩
⟨⟩ : ∀ {ℓ} → ⊤ {ℓ}
⟨⟩ = tt

⟨ : ∀ {ℓ} {S : Set ℓ} → S → S
⟨ s = s

_⟩ : ∀ {ℓ} {S : Set ℓ} → S → S × ⊤ {ℓ}
s ⟩ = s , tt
   #+end_src
*** Reflection Helpers
     #+begin_src agda2 :tangle semantics-with-waist.agda
import Data.Unit as Unit
open import Reflection hiding (name; Type) renaming (_>>=_ to _>>=ₘ_)

-- Single argument application
_app_ : Term → Term → Term
(def f args) app arg′ = def f (args ∷ʳ arg (arg-info visible relevant) arg′) -- keep existing arguments!
{-# CATCHALL #-}
tm app arg′ = tm

-- Reify ℕ term encodings as ℕ values
toℕ : Term → ℕ
toℕ (lit (nat n)) = n
{-# CATCHALL #-}
toℕ _ = 0

    #+end_src

*** =var-dec=: Decreasing De Bruijn Indices
#+begin_src agda2 :tangle semantics-with-waist.agda
arg-term : ∀ {ℓ} {A : Set ℓ} → (Term → A) → Arg Term → A
arg-term f (arg i x) = f x

var-dec₀ : (fuel : ℕ) → Term → Term
var-dec₀ Fin.0F t  = t
-- var-dec₀ (suc n) (var Fin.0F args) = var Fin.0F args
-- Let's use an “impossible” term.
var-dec₀ (suc n) (var Fin.0F args)    = def (quote ⊥) []
var-dec₀ (suc n) (var (suc x) args)   = var x args
var-dec₀ (suc n) (con c args)         = con c (map-Args (var-dec₀ n) args)
var-dec₀ (suc n) (def f args)         = def f (map-Args (var-dec₀ n) args)
var-dec₀ (suc n) (lam v (abs s x))    = lam v (abs s (var-dec₀ n x))
var-dec₀ (suc n) (pat-lam cs args)    = pat-lam cs (map-Args (var-dec₀ n) args)
var-dec₀ (suc n) (Π[ s ∶ arg i A ] B) = Π[ s ∶ arg i (var-dec₀ n A) ] var-dec₀ n B
{-# CATCHALL #-}
-- sort, lit, meta, unknown
var-dec₀ n t = t

{-# TERMINATING #-}
lengthₜ : Term → ℕ
lengthₜ (var x args)      = 1 + sum (List.map (arg-term lengthₜ ) args)
lengthₜ (con c args)      = 1 + sum (List.map (arg-term lengthₜ ) args)
lengthₜ (def f args)      = 1 + sum (List.map (arg-term lengthₜ ) args)
lengthₜ (lam v (abs s x)) = 1 + lengthₜ x
lengthₜ (pat-lam cs args) = 1 + sum (List.map (arg-term lengthₜ ) args)
lengthₜ (Π[ x ∶ A ] Bx)   = 1 + lengthₜ Bx
{-# CATCHALL #-}
-- sort, lit, meta, unknown
lengthₜ t = 0

_ : lengthₜ (quoteTerm (Σ x ∶ ℕ • x ≡ x)) ≡ 10
_ = refl
#+end_src

The use of ~map~ makes it unclear whether the recursive calls are structurally
smaller or not, hence the need for the ~TERMINATING~ clauses.

Here's the prime function:
#+begin_src agda2 :tangle semantics-with-waist.agda
var-dec : Term → Term
var-dec t = var-dec₀ (lengthₜ t) t
#+end_src

This, below, is not ideal at all: =(Π X : Set • X) ↦ (Π X : Set • ⊥)= !  But this
is: =(Σ X : Set • X) ↦ (Set ⊎ ⊥)= !  /The crutch is when to do what!/
#+begin_src agda2 :tangle semantics-with-waist.agda
_ :   var-dec (quoteTerm ((X : Set) → X))
    ≡ pi (vArg (sort (lit 0))) (abs "X" (def (quote ⊥) []))
_ = refl
#+end_src

** Introduction
  We want to write
  #+begin_example agda2
do X ← Set
   z ← X
   s ← (X → X)

:  ℕ → Set
  #+end_example
  Which desugars into:
  #+begin_example agda2
‵ Set >>= λ X → ‵ X >>= λ z → ‵ (X → X)  where ‵_ : Set → (ℕ → Set)
  #+end_example

  The definition of the quote is forced due to the necessary typing of ~>>=~.
** Definitions: ~Context, ‵_, End~
  Hence, the definition of a context suggests itself:
  #+begin_src agda2 :tangle semantics-with-waist.agda
Context = λ ℓ → ℕ → Set ℓ

infix -1000 ‵_
‵_ : ∀ {ℓ} → Set ℓ → Context ℓ
‵ S = λ _ → S

End : ∀ {ℓ} → Context ℓ
End = ‵ ⊤
  #+end_src

** Definitions: ~_>>_~
Next we define the bind operator to account for the current waist: If zero, we
have records, otherwise functions.
#+begin_example agda2
_>>=_ : ∀ {a b}
      → (Γ : Context a)
      → (∀ {n} → Γ n → Context b)
      → Context (a ⊍ b)
(Γ >>= f) ℕ.zero  = Σ γ ∶ Γ 0 • f γ 0
(Γ >>= f) (suc n) = (γ : Γ n) → f γ n
#+end_example

Unfortunately, this would require too many calls to quote; e.g.,
#+begin_example agda2
do X ← ‵ Set
   z ← ‵ X
   s ← ‵ (X → X)
   End
#+end_example

So let's “build it into the definition of >>=”:
  #+begin_src agda2 :tangle semantics-with-waist.agda
_>>=_ : ∀ {a b}
      → (Γ : Set a)  -- Main diference
      → (Γ → Context b)
      → Context (a ⊍ b)
(Γ >>= f) ℕ.zero  = Σ γ ∶ Γ • f γ 0
(Γ >>= f) (suc n) = (γ : Γ) → f γ n
  #+end_src

Let's see this in action:
  #+begin_src agda2 :tangle semantics-with-waist.agda
Monoid : ∀ ℓ → Context (ℓsuc ℓ)
Monoid ℓ = do Carrier ← Set ℓ
              Id      ← Carrier
              _⊕_     ← (Carrier → Carrier → Carrier)
              leftId  ← ∀ {x : Carrier} → x ⊕ Id ≡ x
              rightId ← ∀ {x : Carrier} → Id ⊕ x ≡ x
              assoc   ← ∀ {x y z} → (x ⊕ y) ⊕ z  ≡  x ⊕ (y ⊕ z)
              End {ℓ}
  #+end_src

But what does all of this /mean/? Let's return to the dynamic system at the start
of this discussion.

** Example: Dynamical Systems

  #+begin_src agda2 :tangle semantics-with-waist.agda
DynamicSystem : Context (ℓsuc Level.zero)
DynamicSystem = do X ← Set
                   z ← X
                   s ← (X → X)
                   End {Level.zero}
#+end_src

We can now “see” ---with ~C-c C-n~--- what a dynamical system looks like /at/ a
particular waist.
#+begin_src agda2 :tangle semantics-with-waist.agda
-- Records with 𝓃-Parameters, 𝓃 : 0..3
A B C D : Set₁
A = DynamicSystem 0 -- Σ X ∶ Set  • Σ z ∶ X  • Σ s ∶ X → X  • ⊤
B = DynamicSystem 1 --  (X ∶ Set) → Σ z ∶ X  • Σ s ∶ X → X  • ⊤
C = DynamicSystem 2 --  (X ∶ Set)    (z ∶ X) → Σ s ∶ X → X  • ⊤
D = DynamicSystem 3 --  (X ∶ Set)    (z ∶ X) →  (s ∶ X → X) → ⊤
    #+end_src

It is important to note that these are /not/ functions, but instead
are /function types/!

Let's transform the above comments to machine checked unit tests ^_^
    #+begin_src agda2 :tangle semantics-with-waist.agda
_ : A ≡ (Σ X ∶ Set  • Σ z ∶ X  • Σ s ∶ (X → X)  • ⊤) ; _ = refl
_ : B ≡ (Π X ∶ Set  • Σ z ∶ X  • Σ s ∶ (X → X)  • ⊤) ; _ = refl
_ : C ≡ (Π X ∶ Set  • Π z ∶ X  • Σ s ∶ (X → X)  • ⊤) ; _ = refl
_ : D ≡ (Π X ∶ Set  • Π z ∶ X  • Π s ∶ (X → X)  • ⊤) ; _ = refl
#+end_src



** Theorems: ~stability~

Observe that there are no more ‘interesting’ ways to form a dynamical system.
#+begin_src agda2 :tangle semantics-with-waist.agda
stability : ∀ {n} →   DynamicSystem (3 + n)
                   ≡ DynamicSystem  3
stability = refl
  #+end_src

  Moreover, by the nature of a dynamical system, there cannot ever be such a
  system with an empty state space, and so ~B~.
#+begin_src agda2 :tangle semantics-with-waist.agda
B-is-empty : ¬ B
B-is-empty b = proj₁( b ⊥)
#+end_src

** Natural Number Instance
Let's form an instances at height 0; i.e., a record.
  #+begin_src agda2 :tangle semantics-with-waist.agda
𝒩₀ : DynamicSystem 0
𝒩₀ = ℕ , 0 , suc , tt
  #+end_src

With the expected sugar, we gain an extra grain of readability.
  #+begin_src agda2 :tangle semantics-with-waist.agda
𝒩 : DynamicSystem 0
𝒩 = ⟨ ℕ , 0 , suc ⟩
  #+end_src

Neato: One declares a PackageFormer with ~do…End~ then forms a 0-waist value
using ~⟨⋯⟩~.

** Π→λ and Modus Ponens
Unfortunately, since ~B, C, D~ are all of type ~Set₁~ and so are not functions,
there is no trivial way to “instantiate” any of ~B, C, D~'s arguments to obtain
versions of ~A~ wherein certain fields are already “fixed”.

I'd like to write =B on ℕ=, for example. However, a definition of ~_on_~ seems to
want to pattern match on sorts.
  #+begin_src agda2 :tangle semantics-with-waist.agda
B-on-ℕ : Set
B-on-ℕ = let X = ℕ in Σ z ∶ X  • Σ s ∶ (X → X)  • ⊤

ex : B-on-ℕ
ex = ⟨ 0 , suc ⟩
  #+end_src

Let's oblige, and pattern match on sorts ---by using reflection.

The /values/ ~B,C,D~ are all of the form ~∀ X → ⋯~, in-order to /apply/ them
we need to transform them into values of the form ~λ X → ⋯~, for which application
is actually sensible. As far as I know, there is no natural operation
transforming a function-type into a function-value, so we make the necessary
transformation /syntactically/.

Here's an instance of moving from the Π-type-level to the λ-value-level.
  #+begin_src agda2 :tangle semantics-with-waist.agda
idτ : Set₁
idτ = ∀ (X : Set) (e : X) → X

id₁ : ∀ (X : Set) → Set
id₁ = λ (X : Set) → ((e : X) → X)

id₂ : ∀ (X : Set) (e : X) → Set
id₂ = λ (X : Set) (e : X) → X
   #+end_src
Let's code to make the transformation ~idτ ↦ id₂~ feasible.

We start with Agda terms.
   #+begin_src agda2 :tangle semantics-with-waist.agda
Π→λ-helper : Term → Term
Π→λ-helper (pi  a b)         = lam visible b
Π→λ-helper (lam a (abs x y)) = lam a (abs x (Π→λ-helper y))
{-# CATCHALL #-}
Π→λ-helper x = x
#+end_src

+ We case on type formation, then rewrite the first encountered Π-type into a λ-value.
+ If a λ is encountered, we go inside to make the rewrite.
  - The intention is that sequential rewrite invocations are easily expressed.
+ We could have added the following case before the catchall, however it is
  undesirable since in general we do not want to unwind as much as possible,
  but only as much waist as provided.
  #+begin_example agda2
Π→λ-helper (pi a (abs x y)) = lam visible (abs x (Π→λ-helper y))
  #+end_example

Here are two sample uses.
#+begin_example agda2
-- Error: Failed to resolve sort constraints
_ : unquote (unify (Π→λ-helper (quoteTerm (∀ (X : Set) (x : X) → X)))) ≡ λ X → X → X
_ = refl

-- Ekk! No normalisation!
_ : Π→λ-helper (quoteTerm idτ) ≡ quoteTerm idτ
_ = refl
#+end_example

As it stands, this syntactic rewrite is pathetic from a usage point of view: We
need to quote arguments provided to it, then unquote them back into working
code. Moreover, due to Agda's weak reflection mechanism, such a bungled mess
usually results in errors failing to solve sort constraints.  /Even worse/, it
does not account for normal forms; e.g., a constant name is just that, a name,
rather than what it expands to.
Let's remedy these two issues.
#+begin_src agda2 :tangle semantics-with-waist.agda
macro
  Π→λ : Term → Term → TC Unit.⊤
  Π→λ tm goal = normalise tm >>=ₘ λ tm′ → unify (Π→λ-helper tm′) goal
  #+end_src

+ We normalise a given term /then/ invoke the previously formed helper.
+ Due to the currently poor state of reflection in Agda, we are /forced/ to
  construct the auxiliary function since macros cannot be recursive.
    #+begin_example agda2
-- Error: Cannot unquote non-canonical type checking computation
macro
  lame : ℕ → Term → Term → TC Unit.⊤
  lame zero t g    = unify t g
  lame (suc n) t g = lame n t g
  #+end_example

At this point, our goals are reasonably achieved:
#+begin_src agda2 :tangle semantics-with-waist.agda
_ : Π→λ idτ ≡ id₁
_ = refl

-- Too much yellow, sort constraints cannot be solved. It's okay.
-- _ : Π→λ (Π→λ idτ) ≡ id₂
-- _ = refl
  #+end_src

Reflection was not the first route attempted.  A more natural approach would be
to form a ‘universe’ type ~𝕌~ which has a constructor ~‵Π~ for encoding dependent
function types, one then defines ~Π→λ~ by requesting a ≡-proof that the given type
is indeed a function-type, i.e., is equivalent to the semantics of an encoding
~‵Π~.  However, such encodings always led to some technical issue.  Most notable
being that we cannot view ~Set₁~ via our encoding ~𝕌~ since such a function ~Set₁ → 𝕌~
would fail to encode types without having a pre-existing way to pattern match
against the inhabitants of ~Set₁~.  As such, we have solved the problem in the
meta-theory.

It is curious that this problem is reminiscent of currying.
#+begin_src agda2
-- Given:
τ : Set₁
τ = ∀ (X : Set) → ⋯

-- Obtain:
τf : ∀ (X : Set) → Set₁
τf = λ (X : Set) → ⋯
#+end_src
| The type of ~τ~ merely states it to be a grouping mechanism!        |
| The type of ~τf~ /exposes/ that ~τ~ is a parmeterised grouping mechanism! |

Perhaps this is related to indexing vs parameters.

+ We can apply =τf= and so it's more concrete than =τ=.
+ Hence, we may call =Π→λ= a “type constructor reification”.

** Defining =_:waist_=
   Multiple invocations of ~Π→λ~ along with a raw waist exposes the structure of
   a parameterised record, as in the following examples.
  #+begin_src agda2 :tangle semantics-with-waist.agda
_ : Π→λ (DynamicSystem 1) ≡ λ γ → Σ γ (λ _ → Σ ((x : γ) → γ) (λ _ → ⊤))
_ = refl

CC : ∀ (X : Set) (x : X) → Set
CC = Π→λ (Π→λ (DynamicSystem 2))   -- c.f., C above and C′ below.
   #+end_src
   Let's abstract away the raw waist, 2 above, and the 2-many invocations of
   ~Π→λ~.

   As mentioned earlier, we must perform recursion outside of ~macro~ clauses, so
   we must have an auxiliary function.
   #+begin_src agda2 :tangle semantics-with-waist.agda
waist-helper : ℕ → Term → Term
waist-helper zero t    = t
-- waist-helper (suc n) t = waist-helper n (Π→λ t)
waist-helper (suc n) t = waist-helper n (Π→λ-helper t)
  #+end_src

  It is important to note that the commented out line could /not/ have been used
  and instead the ~Π→λ~ macro's underlying helper must be invoked instead.  Why?
  This subtlety is due to the implicit-quotation invocation style of macros: If
  ~f : Term → Name → Bool → Term → TC ⊤~ is declared a macro, then an application
  ~f u v w~ desugars into ~unquote (f (quoteTerm u) (quote v) w)~.

We now use the helper to form the necessary combinator.
  #+begin_src agda2 :tangle semantics-with-waist.agda
macro
  _:waist_ : Term → Term → Term → TC Unit.⊤
  _:waist_ t 𝓃 goal =      normalise (t app 𝓃)
                      >>=ₘ λ t′ → unify (waist-helper (toℕ 𝓃) t′) goal
#+end_src

Note that it's important we /apply/ the given context to a raw waist,
then /normalise/ that before moving on. Indeed, ~waist-helper~ invokes ~Π→λ→helper~,
which performs no normalisation.

+ ~:waist~ could not have been defined as a top level function operating on ~Set ℓ~
  since it cannot be typed! It needs to operate on syntax and so is a macro.
  - Indeed, ~Γ :waist n~ may sometimes return a function of types, values of ~Set₁~,
    or a function of other types, such as ~ℕ~. We shall show this below when
    forming ~A′, B′, C′, D′~.

 How are these two indexing mechanisms related?
 0. =C :waist n= is an n-ary type constructor; given n inputs, a record type is returned.
 1. =C n= is a “factory”: Given n inputs 𝓍, it will produce a value of =(C :waist n) 𝓍=.

** Further Natural Number Instances and Fixing Parameters

Let's now demonstrate how convenient it is to use ~_:waist_~.
  #+begin_src agda2 :tangle semantics-with-waist.agda
A′ : Set₁
B′ : ∀ (X : Set) → Set
C′ : ∀ (X : Set) (x : X) → Set
D′ : ∀ (X : Set) (x : X) (s : X → X) → Set
#+end_src
Each type /exposes/ more and more information about what kind of grouping
structure we have at hand. The definitions are super simple sweetness.
#+begin_src agda2 :tangle semantics-with-waist.agda
A′ = DynamicSystem :waist 0
B′ = DynamicSystem :waist 1
C′ = DynamicSystem :waist 2
D′ = DynamicSystem :waist 3
  #+end_src

~B,C,D~ are parameterised records: Given values of the parameters, record values
are created. What if, we want to simply supply parameters and obtain new
parameterised records; i.e., do not go all the way down to the creation level.
These ‘partial applied’ types are ~B′, C′, D′~. That is, ~:waist~ essentially
allows us to unbundle, or uncurry, records! So cool (•̀ᴗ•́)و

The two notions coincide at the bottom-most waist.
  #+begin_src agda2 :tangle semantics-with-waist.agda
_ : DynamicSystem 0 ≡ DynamicSystem :waist 0
_ = refl

-- _ : ∀ {ℓ} {Γ : Context (ℓsuc ℓ)} → Γ 0 ≡ {! Γ :waist 0 !}
-- _ = refl
#+end_src

  The following /instances/ of these grouping /types/ demonstrate how /information
moves from the body level to the parameter level/!
#+begin_src agda2 :tangle semantics-with-waist.agda
𝒩⁰ : A′
𝒩⁰ = ⟨ ℕ , 0 , suc ⟩

𝒩¹ : B′ ℕ
𝒩¹ = ⟨ 0 , suc ⟩

𝒩² : C′ ℕ 0
𝒩² = ⟨ suc ⟩

𝒩³ : D′ ℕ 0 suc
𝒩³ = ⟨⟩
#+end_src

Notice that with ~A′, B′, C′, D′~ we may fix certain parameters ahead of time.
Above the type ~B′ ℕ~ is the type of “dynamic systems over carrier ℕ” whereas ~C′ ℕ
0~ is the type of “dynamic systems over carrier ℕ and start state 0”.  Neato!

One would expect the stability result from earlier to continue to hold, but
there is a type error in even phrasing it naively.
#+begin_example agda2
-- Type error: LHS and RHS of ‘≡’ do not agree.
stability′ : ∀ {n : ℕ} →
            DynamicSystem :waist (3 + n)
          ≡ DynamicSystem :waist 3
stability′ = refl
#+end_example

** Example ---Collections

   Here's a specification of a collection, which includes an element type;
   along with an instance-former; i.e., a value at a non-zero waist. ---Thanks Wolfram!
#+begin_src agda2 :tangle semantics-with-waist.agda
Collection : ∀ ℓ → Context (ℓsuc ℓ)
Collection ℓ = do
  Elem    ← Set ℓ
  Carrier ← Set ℓ
  insert  ← (Elem → Carrier → Carrier)
  ∅       ← Carrier
  isEmpty ← (Carrier → Bool)
  insert-nonEmpty ← ∀ {e : Elem} {x : Carrier} → isEmpty (insert e x) ≡ false
  End {ℓ}

ListColl : {ℓ : Level} → Collection ℓ 1
ListColl E = ⟨ List E
             , _∷_
             , []
             , (λ { [] → true; _ → false})
             , (λ {x} {x = x₁} → refl)
             ⟩
           #+end_src

The neat thing here is that a value of ~Collection ℓ~ is an element type
along with collection type over said elements; whereas a value of ~Collection ℓ 1~
is a way to form collections for given element types.

Here's another example.

Enumerated types can always be encoded as values of ℕ and so ℕ can be thought
of as a way to collect values of the enumeration.
  #+begin_src agda2 :tangle semantics-with-waist.agda
ℕCollection = (Collection ℓ₀ :waist 2)
                ("Elem"    ≔ Digit)
                ("Carrier" ≔ ℕ)
--
-- i.e., (Collection ℓ₀ :waist 2) Digit ℕ
#+end_src

  + Note that the ~"key" ≔ value~ pairs are just syntactic sugar for ~value~,
    that document it via ~"key"~.
  + ~Digit~ is the enumerated type of values ~#𝒾~ for ~𝒾 : 0..9~.

More concretely, if the enumerated has 𝓃-many values, we can form a stack by
starting with 0 and pushing elements ~d~ “to then end of our running total $s$” to
obtain =s * 10ⁿ + d=, for example.  Then we pop elements off via division. Here's
an instance for the digit enumeration type.

#+begin_src agda2 :tangle semantics-with-waist.agda
stack : ℕCollection
stack = ⟨ "insert"      ≔ (λ d s → suc (10 * s + #→ℕ d))
        , "empty stack" ≔ 0
        , "is-empty"    ≔ (λ { 0 → true; _ → false})
        -- Properties --
        , (λ {d : Digit} {s : ℕ} → refl {x = false})
        ⟩
  #+end_src

+ The ~suc~, in ~"insert"~, is to make the coherence property easily proven.

Super neat stuff (─‿‿─)

** Projections

   Since records are just products, we may project to obtain their fields.
   - The following meta-program yields a type error when trying to project
     fields that do not exist.
#+begin_src agda2 :tangle semantics-with-waist.agda
Field₀ : ℕ → Term → Term
Field₀ zero c    = def (quote proj₁) (arg (arg-info visible relevant) c ∷ [])
Field₀ (suc n) c = Field₀ n (def (quote proj₂) (arg (arg-info visible relevant) c ∷ []))

macro
  Field : ℕ → Term → Term → TC Unit.⊤
  Field n t goal = unify goal (Field₀ n t)
#+end_src

Agda macros do not support η-equivalence and so definitions
of particular projections are necessarily of the form ~λ C → Field 𝒾 C~.

#+begin_src agda2 :tangle semantics-with-waist.agda
Elem      : ∀ {ℓ} → Collection ℓ 0 → Set ℓ
Elem      = λ C   → Field 0 C
          #+end_src

Nullary types like ~Collection ℓ 0~ all have a similar projection form.
There is a neat interesting shift when we move positive-argument types.
          #+begin_src agda2 :tangle semantics-with-waist.agda
Carrier   : ∀ {ℓ} → Collection ℓ 0 → Set ℓ
Carrier₁  : ∀ {ℓ} → Collection ℓ 1 → (γ : Set ℓ) → Set ℓ
Carrier₁′ : ∀ {ℓ} {γ : Set ℓ} (C : (Collection ℓ :waist 1) γ) → Set ℓ

Carrier   = λ C   → Field 1 C
Carrier₁  = λ C γ → Field 0 (C γ)
Carrier₁′ = λ C   → Field 0 C
          #+end_src

The differences are subtle, so let's try exposing more arguments.

          #+begin_src agda2 :tangle semantics-with-waist.agda
insert   : ∀ {ℓ} (C : Collection ℓ 0) → (Elem C → Carrier C → Carrier C)
insert₁  : ∀ {ℓ} (C : Collection ℓ 1) (γ : Set ℓ) →  γ → Carrier₁ C γ → Carrier₁ C γ
insert₁′ : ∀ {ℓ} {γ : Set ℓ} (C : (Collection ℓ :waist 1) γ) → γ → Carrier₁′ C → Carrier₁′ C

insert    = λ C   → Field 2 C
insert₁   = λ C γ → Field 1 (C γ)
insert₁′  = λ C   → Field 1 C
#+end_src

Notice that ~insert₁~'s ~C~ must be passed inputs each time it is used ---since ~C~ is
a “factory”, as mentioned earlier. In contrast, ~insert₁′~'s ~C~ has no arguments
as they are fixed ahead of time.

The need to invoke a factory with its inputs seems to have a slightly greater
impact at the definition level, as seen below.
#+begin_src agda2 :tangle semantics-with-waist.agda
insert₂  : ∀ {ℓ} (C : Collection ℓ 2) (El Cr : Set ℓ) → El → Cr → Cr
insert₂′ : ∀ {ℓ} {El Cr : Set ℓ} (C : (Collection ℓ :waist 2) El Cr) → El → Cr → Cr

insert₂ = λ C El Cr → Field 0 (C El Cr)
insert₂′ = λ C → Field 0 C
  #+end_src

Neato petito!

** COMMENT ~:exposing~ --no

     Set₁
⇒ ∀ X₁ → ⋯ → ∀ Xₙ → Set
≅ ∀ Xₙ → ∀ X₁ → ⋯ → ∀ Xₙ₋₁ → Set
⇒ ∀ Xₙ → Set

Given a function /type/ such as ~∀ (A B : Set) → B~, we cannot write a
function to swap the order of the input types, ~A~ and ~B~, since that would
require we pattern match on the function /type/ to expose its structure. As
such, we must use reflection. However, a mere switch of Π-constructors also does
not work since the underlying debrujin reference of the final ~B~ is ~var 0~, in
reference to the 0-th away bound variable ~B~, and so a simple Π-variable swap
would leave the reference as ~var 0~ which then refers to ~A~. Hence, in
general, we need to update all debrujin indices, increasing some and decreasing
others.
* Algebraic Datatypes

  In addition to possibly parameterised record types, we would like to extend
  the existing computational notation for grouping mechanisms to obtain
  algebraic datatypes.

  The aim is to start with a context, such as:
#+BEGIN_SRC agda2
DynamicSystem : Context (ℓsuc Level.zero)
DynamicSystem = do X ← Set
                   z ← X
                   s ← (X → X)
                   End {Level.zero}
#+END_SRC

Then obtain a type that is isomorphic to the algebraic datatype:
#+BEGIN_SRC agda2
data 𝔻 : Set where
     zeroD : 𝔻
     sucD  : 𝔻 → 𝔻
#+END_SRC

| Goal: Obtain 𝔻 from ~DynamicSystem~ /with/ user-defined constructors ~zeroD~ and ~sucD~! |

** Goal-Driven Development ---a 5-step plan

 # Plan: Do-notation ⇒ records ⇒ functions ⇒ drop targets ⇒ rewrite Σ to ⊎ ⇒
 # fixpoints

    A declaration ~data DT = ⋯DT⋯~ is a convenient notation for the least fixpoint
    of the type constructor ~λ DT → ⋯DT⋯~. Hence, with that understanding, we shall
    form fixpoints from ~Context~ declarations. Since ~data~ is a builtin language
    construct, we can only provide a seemingly improper formulation: ~Fix~
    ---amusingly, we mimic the ~data~ construct using a ~data~ declaration.

 #+BEGIN_SRC agda2  :tangle semantics-with-waist.agda
{-# NO_POSITIVITY_CHECK #-}
data Fix {ℓ} (F : Set ℓ → Set ℓ) : Set ℓ where
  μ : F (Fix F) → Fix F
 #+END_SRC

 + Since ~Fix F ≅ F 𝟙 ⊎ F² 𝟙 ⊎ F³ 𝟙 ⊎ ⋯~, I've attempted to work with a ~Fix n F~
   which yields terms of “depth” ~n~, up to ~Fⁿ 𝟙~. The result is tremendously
   awkward to use at the relatively insignificant benefit of ensuring positivity.
 + The approach above instead even permits /friendly user-defined constructor
   pattern names!/

 Having an understanding of ~data~ constructions, which are just ~μ F~ for type
 constructors ~F~, we obtain such a ~data~ construction from a context by first
 deriving an appropriate type constructor ~F~, which we can already do using the
 existing framework.

 Here's our plan of attack!
 #+BEGIN_SRC agda2
  do X ← Set; z ← X; s ← (X → X); End
↝⟨ Records! Use existing interpretation to obtain a record. ⟩
  Σ X : Set • Σ z : X • Σ s : (X → X) • ⊤
↝⟨ Waist & Π→λ! Pull out the ‘carrier’ to obtain a type constructor. ⟩
  λ X : Set • Σ z : X • Σ s : (X → X) • ⊤
↝⟨ Sources: ADT constructors target the declared type, so only their sources matter.
   E.g., ‘z : X’ is a nullary constructor targeting the carrier ‘X’.
   This introduces 𝟙 types, so any existing occurances are dropped via 𝟘.
   ⟩
  λ X : Set • Σ z : 𝟙 • Σ s : X • 𝟘
↝⟨ Unions: ADTs are sums of products. ⟩
  λ X : Set •       𝟙   ⊎     X  ⊎ 𝟘
↝⟨ Fixpoints: ADTs are fixpoints of type constructors. ⟩
  μ (λ X • 𝟙 ⊎ X)  -- i.e., 𝔻, i.e., ℕ ^_^
 #+END_SRC

 Neato!

 | Notice: Useful programming datatypes arise from termtypes of theories (contexts)! |

 If =𝒞 : Set → Context ℓ₀= and =ℂ = λ X → termtype (𝒞 X :waist 1)= then =ℂ= can be used
 to form ‘free, lawless, 𝒞-instances’.

 For example,
 | Theory             | Termtype     |
 |--------------------+--------------|
 | Dynamical Systems  | ℕ            |
 | Pointed Structures | Maybe        |
 | Monoids            | Binary Trees |

 We shall follow the above outlined 5-point plan, then realise the
 correspondences mentioned in the above table.

 + The final item in the table is a claim mentioned briefly in a GPCE’19 paper.
   - Here we can not only formally express the problem but also prove it true
     ♥‿♥

** Steps 1 & 2: Records and Type Constructors

   The first step, realising the notation as record types has already been setup,
   so we may just use it.
   #+begin_src agda2 :tangle semantics-with-waist.agda
D₁ = DynamicSystem 0

1-records : D₁ ≡ (Σ X ∶ Set • Σ z ∶ X • Σ s ∶ (X → X) • ⊤)
1-records = refl
 #+end_src

 Progress ^_^ Yay!

 Likewise, we can use the Π→λ setup to accomplish step 2.
 #+begin_src agda2 :tangle semantics-with-waist.agda
D₂ = DynamicSystem :waist 1

2-funcs : D₂ ≡ (λ (X : Set) → Σ z ∶ X • Σ s ∶ (X → X) • ⊤)
2-funcs = refl
 #+end_src

** Step 3: Sources

   Everywhere we see a /bound variable/ ~x ∶ A → B~, we rewrite it as
   ~x ∶ A~.
   - If there is no ~A~, we take it to be ~𝟙~.
     + Since we're adding 𝟙's, any existing 𝟙's are replaced by 𝟘.
       * We do this in-preparation for step 4, unions, and step 5, fixpoints.
       * Contexts are terminated by ~End~, which is an alias for 𝟙; which
         contributes inhabitants to fixpoints. As such, we rewrite any 𝟙s with 𝟘
         to avoid unintentional inhabitants.
   - If ~A~ is implicit, then we consider ~x~ to be a “property” rather than a
     “functional symbol” and so drop it à la ~x ∶ 𝟘~.

 ⇒ I feel that one of the two ~sourcesᵢ~ functions is spurious! ⇐

     #+begin_src agda2 :tangle semantics-with-waist.agda
-- useful to motivate defn of sources₀
_ :   quoteTerm (∀ {x : ℕ} → ℕ)
    ≡ pi (arg (arg-info hidden relevant) (quoteTerm ℕ)) (abs "x" (quoteTerm ℕ))
_ = refl

sources₀ : Term → Term
-- Otherwise:
sources₀ (Π[ a ∶ arg i A ] (Π[ b ∶ arg _ Ba ] Cab)) = def (quote _×_) (vArg A ∷
  vArg (def (quote _×_) (vArg (var-dec Ba) ∷ vArg (var-dec (var-dec (sources₀ Cab))) ∷ [])) ∷ [])
  -- sources₀ (Π[ a ∶ arg i A ] (Π[ b ∶ Ba ] Cab)) = Π[ a ∶ arg i A ] Π[ b ∶ Ba ] sources₀ Cab
-- Design descision: Types starting with implicit arguments are ‘invariants’, not ‘constructors’ ⇐ Couldn't do this.
sources₀ (Π[ a ∶ arg (arg-info hidden _) A ] Ba) = quoteTerm 𝟘
-- Another attempt: If it has a “≡” then an invariant.
-- sources₀ (Π[ a ∶ arg i A ] (def (quote _≡_) args)) = quoteTerm 𝟘
sources₀ (Π[ x ∶ arg i A ] Bx) = A
{-# CATCHALL #-}
-- sort, lit, meta, unknown
sources₀ t = quoteTerm 𝟙

{-# TERMINATING #-}
sources₁ : Term → Term
sources₁ (Π[ a ∶ arg (arg-info hidden _) A ] Ba) = quoteTerm 𝟘
sources₁ (Π[ a ∶ arg i A ] (Π[ b ∶ arg _ Ba ] Cab)) = def (quote _×_) (vArg A ∷
  vArg (def (quote _×_) (vArg (var-dec Ba) ∷ vArg (var-dec (var-dec (sources₀ Cab))) ∷ [])) ∷ [])
-- sources₁ (Π[ a ∶ arg i A ] (Π[ b ∶ arg _ Ba ] Cab)) = def (quote _×_) (vArg A ∷ vArg Ba ∷ [])
sources₁ (Π[ x ∶ arg i A ] Bx) = A
sources₁ (def (quote Σ) (ℓ₁ ∷ ℓ₂ ∷ τ ∷ body)) = def (quote Σ) (ℓ₁ ∷ ℓ₂ ∷ map-Arg sources₀ τ ∷ List.map (map-Arg sources₁) body)
sources₁ (def (quote ⊤) _) = def (quote 𝟘) [] -- This function introduces 𝟙s, so let's drop any old occurances a la 𝟘.
sources₁ (lam v (abs s x))     = lam v (abs s (sources₁ x))
sources₁ (var x args) = var x (List.map (map-Arg sources₁) args)
sources₁ (con c args) = con c (List.map (map-Arg sources₁) args)
sources₁ (def f args) = def f (List.map (map-Arg sources₁) args)
sources₁ (pat-lam cs args) = pat-lam cs (List.map (map-Arg sources₁) args)
{-# CATCHALL #-}
-- sort, lit, meta, unknown
sources₁ t = t
 #+end_src

 The use of ~map~ makes it unclear whether the recursive calls are structurally
 smaller or not, hence the need for the ~TERMINATING~ clauses.

 Here is the primary utility function along with unit tests.
 #+begin_src agda2 :tangle semantics-with-waist.agda
macro
  sources : Term → Term → TC Unit.⊤
  sources tm goal = normalise tm >>=ₘ λ tm′ → unify (sources₁ tm′) goal

_ : sources (ℕ → Set) ≡ ℕ ; _ = refl
-- _ : sources (λ (x : (ℕ → Fin 3)) → ℕ) ≡ λ (x : ℕ) → ℕ ; _ = refl
_ : sources (Σ x ∶ (ℕ → Fin 3) • ℕ) ≡ (Σ x ∶ ℕ • ℕ) ; _ = refl
_ : ∀ {ℓ : Level} {A B C : Set} → sources (Σ x ∶ (A → B) • C) ≡ (Σ x ∶ A • C) ; _ = refl
-- MA: Heterogenous levels wont work; e.g., A ≔ ℕ crashes.
_ : sources (Fin 1 → Fin 2 → Fin 3) ≡ (Σ _ ∶ Fin 1 • Fin 2 × 𝟙) ; _ = refl
_ : sources (Σ f ∶ (Fin 1 → Fin 2 → Fin 3 → Fin 4) • Fin 5) ≡ (Σ f ∶ (Fin 1 × Fin 2 × Fin 3) • Fin 5) ; _ = refl
_ : ∀ {A B C : Set} → sources (A → B → C) ≡ (A × B × 𝟙) ; _ = refl
_ : ∀ {A B C D E : Set} → sources (A → B → C → D → E) ≡ Σ A (λ _ → Σ B (λ _ → Σ C (λ _ → Σ D (λ _ → ⊤)))) ; _ = refl
-- Not desirable:
-- _ : sources (∀ {x : ℕ} → x ≡ x) ≡ ℕ ; _ = refl
-- Design descision: Types starting with implicit arguments are ‘invariants’, not ‘constructors’
_ : sources (∀ {x : ℕ} → x ≡ x) ≡ 𝟘 ; _ = refl -- one implicit
_ : sources (∀ {x y z : ℕ} → x ≡ y) ≡ 𝟘 ; _ = refl   -- multiple implicits
 #+end_src

 We can finally express the third phase.
 #+begin_src agda2 :tangle semantics-with-waist.agda
D₃ = sources D₂

3-sources : D₃ ≡ λ (X : Set) → Σ z ∶ 𝟙 • Σ s ∶ X • 𝟘
3-sources = refl
 #+end_src

** Step 4: Unions with ~Σ→⊎~

   Syntactically transform Σ-types into ⊎-clauses, dropping dependent items via
   ~var-dec~ ---whose use makes it unclear whether recursive calls are structurally
   smaller thereby necessitating the ~TERMINATING~ hint.
     #+begin_src agda2 :tangle semantics-with-waist.agda
{-# TERMINATING #-}
Σ→⊎₀ : Term → Term
Σ→⊎₀ (def (quote Σ) (𝒽₁ ∷ 𝒽₀ ∷ arg i A ∷ arg i₁ (lam v (abs s x)) ∷ []))
  =  def (quote _⊎_) (𝒽₁ ∷ 𝒽₀ ∷ arg i A ∷ vArg (Σ→⊎₀ (var-dec x)) ∷ [])
  -- def (quote _⊎_) (𝒽₁ ∷ 𝒽₀ ∷ arg i (var-dec A) ∷ vArg (Σ→⊎₀ (var-dec x)) ∷ [])
Σ→⊎₀ (def (quote ⊤) _) = def (quote ⊥) [] -- Interpret “End” in do-notation to be an empty, impossible, constructor.
 -- Walk under λ's and Π's.
Σ→⊎₀ (lam v (abs s x)) = lam v (abs s (Σ→⊎₀ x))
Σ→⊎₀ (Π[ x ∶ A ] Bx) = Π[ x ∶ A ] Σ→⊎₀ Bx
{-# CATCHALL #-}
Σ→⊎₀ t = t

macro
  Σ→⊎ : Term → Term → TC Unit.⊤
  Σ→⊎ tm goal = normalise tm >>=ₘ λ tm′ → unify (Σ→⊎₀ tm′) goal

-- _ :   Σ→⊎ (Σ x ∶ ℕ • ⊤ {ℓ₀})
--     ≡ (ℕ ⊎ ⊥)
-- _ = refl

-- Fails due to the ⊥-choice above.
-- _ :   ∀ {C : Set} → Σ→⊎ (Σ x ∶ C • Σ y ∶ C • ⊤ {ℓ₀})
--                   ≡ (C ⊎ C ⊎ ⊤)
-- _ = refl

-- Unit tests
_ : Σ→⊎ (Π X ∶ Set • (X → X))     ≡ (Π X ∶ Set • (X → X)); _ = refl
_ : Σ→⊎ (Π X ∶ Set • Σ s ∶ X • X) ≡ (Π X ∶ Set • X ⊎ X)  ; _ = refl
_ : Σ→⊎ (Π X ∶ Set • Σ s ∶ (X → X) • X) ≡ (Π X ∶ Set • (X → X) ⊎ X)  ; _ = refl
_ : Σ→⊎ (Π X ∶ Set • Σ z ∶ X • Σ s ∶ (X → X) • ⊤ {ℓ₀}) ≡ (Π X ∶ Set • X ⊎ (X → X) ⊎ ⊥)  ; _ = refl
 #+end_src

 We can now derive the require ADT's underlying sum-of-products type constructor.
 #+begin_src agda2 :tangle semantics-with-waist.agda
D₄ = Σ→⊎ D₃

4-unions : D₄ ≡ λ X → 𝟙 ⊎ X ⊎ 𝟘
4-unions = refl
 #+end_src

 Neato 😄

** Step 5: =𝔻 ≅ ℕ=

   Using the ~Fix~ constructor, we may obtain the fixpoint, then using Agda's
   ~pattern~ mechanism, users may declare meaningful constructor aliases!
   - The use of ~pattern~ sidesteps a weakness in Agda's current implementation
     for reflection ---the inability to /actually/ make use of fresh names.

#+begin_src agda2 :tangle semantics-with-waist.agda
𝔻 = Fix D₄

-- Pattern synonyms for more compact presentation
pattern zeroD  = μ (inj₁ tt)       -- : 𝔻
pattern sucD e = μ (inj₂ (inj₁ e)) -- : 𝔻 → 𝔻
 #+end_src

 With neato constructors declared, let's show that our ADT ~𝔻~ is essentially
 just the natural numbers, thereby showing our transformation to achieve its
 purpose and, less importantly, demonstrate that the naturals are a “termtype”
 for dynamical systems.
 #+begin_src agda2 :tangle semantics-with-waist.agda
oh : 𝔻 → ℕ
oh zeroD    = 0
oh (sucD x) = suc (oh x)

ho : ℕ → 𝔻
ho zero    = zeroD
ho (suc n) = sucD (ho n)

oh∘ho : ∀ n → oh (ho n) ≡ n
oh∘ho zero    = refl
oh∘ho (suc n) = cong suc (oh∘ho n)

ho∘oh : ∀ d → ho (oh d) ≡ d
ho∘oh zeroD    = refl
ho∘oh (sucD x) = cong sucD (ho∘oh x)
 #+end_src

 So cool! 😎

 An alternative to user-defined constructors would be injections.
     #+begin_src agda2 :tangle semantics-with-waist.agda
Inj₀ : ℕ → Term → Term
Inj₀ zero c    = con (quote inj₁) (arg (arg-info visible relevant) c ∷ [])
Inj₀ (suc n) c = con (quote inj₂) (vArg (Inj₀ n c) ∷ [])

-- Duality!
-- 𝒾-th projection: proj₁ ∘ (proj₂ ∘ ⋯ ∘ proj₂)
-- 𝒾-th injection:  (inj₂ ∘ ⋯ ∘ inj₂) ∘ inj₁

macro
  Inj : ℕ → Term → Term → TC Unit.⊤
  Inj n t goal = unify goal (Inj₀ n t)
 #+end_src

 However, the benefit of the ~pattern~ declarations is that as users perform
 interactive casing with ~C-c C-c~, the ~agda2-make-case~ Emacs function, whenever a
 pattern matches the right-side of one of the declared ~pattern~-s, then it is
 automatically replaced by the user's meaningful left-side name. This useful
 feature was used above to make it clear that =𝔻= essentially has only two
 constructors.

** ~termtype~: The term language of a theory

 The 5 steps for moving from a context to an algebraic data type can be bundled
 up into one macro.
      #+begin_src agda2 :tangle semantics-with-waist.agda
macro
  termtype : Term → Term → TC Unit.⊤
  termtype tm goal =
                normalise tm
           >>=ₘ λ tm′ → unify goal (def (quote Fix) ((vArg (Σ→⊎₀ (sources₁ tm′))) ∷ []))
 #+end_src

 There are pragmatic and vital reasons for using a macro.
 1. An easier interface; users needn't bother with quoting and unquoting terms.
 2. Metavariable issues are resolved in the typechecking, ~TC~, monad.

 Let's expound on the second point.

 If we have a nullary context ~𝒞~, we should simply obtain its termtype via ~Fix
 (Σ→⊎ (sources (𝒞 :waist 1)))~. However, sometimes ---as in the case of pointed
 theories, below--- this expression becomes ~Fix (λ _ → ⋯)~ where the λ-variable is
 unused and its type cannot be inferred from the λ-body.  The current
 implementation of Agda's reflection mechanism will not infer the type even
 though ~Fix~ explicitly specifies it to be of type ~Set~!  Even explicit type
 annotations do not suffice. Hence, we are left with unresolved meta-variable
 issues ---and disturbing yellow-marked code.  Besides unifying two terms, the
 typechecking operation ~unify~ also solves metavariables in the process and so
 does exactly what we need ---no more yellow-code.

** Example: The termtype of monoids is tree skeletons

 Recall the theory of monoids.
 #+BEGIN_SRC agda2
Monoid   : ∀ ℓ → Context (ℓsuc ℓ)
Monoid ℓ = do Carrier ← Set ℓ
              Id      ← Carrier
              _⊕_     ← (Carrier → Carrier → Carrier)
              leftId  ← ∀ {x : Carrier} → x ⊕ Id ≡ x
              rightId ← ∀ {x : Carrier} → Id ⊕ x ≡ x
              assoc   ← ∀ {x y z} → (x ⊕ y) ⊕ z  ≡  x ⊕ (y ⊕ z)
              End {ℓ}
 #+END_SRC

 We can now mechanically derive its term language.
     #+begin_src agda2 :tangle semantics-with-waist.agda
𝕄 : Set
𝕄 = termtype (Monoid ℓ₀ :waist 1)
{- ie Fix (λ X → 𝟙         -- Id, nil leaf
               ⊎ X × X × 𝟙 -- _⊕_, branch
               ⊎ 𝟘         -- src of leftId
               ⊎ 𝟘         -- src of rightId
               ⊎ X × X × 𝟘 -- src of assoc
               ⊎ 𝟘)        -- the “End {ℓ}”
-}
 #+end_src

 As suggested, we declare constructor patterns to interface with the above definition.
 #+begin_src agda2 :tangle semantics-with-waist.agda
-- Pattern synonyms for more compact presentation
pattern emptyM      = μ (inj₁ tt)                      -- : 𝕄
pattern branchM l r = μ (inj₂ (inj₁ (l , r , tt)))     -- : 𝕄 → 𝕄 → 𝕄
pattern absurdM a   = μ (inj₂ (inj₂ (inj₂ (inj₂ a))))  -- absurd values of 𝟘
 #+end_src

 We conjecture that the termtype is really the free data type for monoids, ~TreeSkeleton~.
 #+begin_src agda2 :tangle semantics-with-waist.agda
data TreeSkeleton : Set where
  empty  : TreeSkeleton
  branch : TreeSkeleton → TreeSkeleton → TreeSkeleton
 #+end_src

 With the ~pattern~ declarations, the proof appears trivial.  ---without them, the
 proof would remain true, but be far less convincing to a human reader!
 #+begin_src agda2 :tangle semantics-with-waist.agda
𝕄→Tree : 𝕄 → TreeSkeleton
𝕄→Tree emptyM = empty
𝕄→Tree (branchM l r) = branch (𝕄→Tree l) (𝕄→Tree r)
𝕄→Tree (absurdM (inj₁ ()))
𝕄→Tree (absurdM (inj₂ ()))

𝕄←Tree : TreeSkeleton → 𝕄
𝕄←Tree empty = emptyM
𝕄←Tree (branch l r) = branchM (𝕄←Tree l) (𝕄←Tree r)

𝕄←Tree∘𝕄→Tree : ∀ m → 𝕄←Tree (𝕄→Tree m) ≡ m
𝕄←Tree∘𝕄→Tree emptyM = refl
𝕄←Tree∘𝕄→Tree (branchM l r) = cong₂ branchM (𝕄←Tree∘𝕄→Tree l) (𝕄←Tree∘𝕄→Tree r)
𝕄←Tree∘𝕄→Tree (absurdM (inj₁ ()))
𝕄←Tree∘𝕄→Tree (absurdM (inj₂ ()))

𝕄→Tree∘𝕄←Tree : ∀ t → 𝕄→Tree (𝕄←Tree t) ≡ t
𝕄→Tree∘𝕄←Tree empty = refl
𝕄→Tree∘𝕄←Tree (branch l r) = cong₂ branch (𝕄→Tree∘𝕄←Tree l) (𝕄→Tree∘𝕄←Tree r)
 #+end_src

 📗 A GPCE’19 paper mentioned in passing that the termtype of monoids is trees.
 We are in a position to not only express such a statement but have also proven
 it. 🤓

 /Claim:/ To obtain trees over some ‘value type’ Ξ, one must use
 ~Monoid′ Ξ = ⋯~, the notion of “monoids containing a given set Ξ”.

 We demonstrate this process with pointed types to obtain the ~Maybe~ type
 constructor!

** Example: =Maybe= from pointed structures

   A /pointed set/ is a set =Carrier= with an elected =point : Carrier=; e.g., C# uses
   a category of pointed sets for its types where each type ~τ~ is furnished with a
   point =default τ=. More commonly, in object-oriented programming, object types
   have ~NULL~ as a dangerous sentinel ---for this reason, the ~Maybe τ~ is sometimes
   referred to as the type of “pointers to τ values”.

   A pointed set /over/ a given set Ξ is merely a pointed set that also contains (a
   copy of) the given set Ξ. The embedding function is usually required to be injective.
   #+begin_src agda2 :tangle semantics-with-waist.agda
-- “a pointed set that contains Ξ” ─c.f., “a group over Ξ”
PointedOver  : Set → Context (ℓsuc ℓ₀)
PointedOver Ξ    = do Carrier ← Set ℓ₀
                      point   ← Carrier
                      embed   ← (Ξ → Carrier)
                      End {ℓ₀}
 #+end_src

  What is the /smallest/ pointed set over a given type?

  We claim it can be found as the termtype of ~PointedOver~.

   #+begin_src agda2 :tangle semantics-with-waist.agda
ℙ : Set → Set
ℙ X = termtype (PointedOver X :waist 1)

-- Pattern synonyms for more compact presentation
pattern nothingP = μ (inj₁ tt)       -- : ℙ
pattern justP e  = μ (inj₂ (inj₁ e)) -- : ℙ → ℙ
 #+end_src

 We can obtain ~PointedOver~ values using ~ℙ~:
 #+begin_src agda2 :tangle semantics-with-waist.agda
-- Observe that ℙ makes instances of PointdOver!
ℙ-rec : (X : Set) → PointedOver X 0
ℙ-rec X = ⟨ ℙ X , nothingP , justP ⟩
 #+end_src

 It is ‘obvious’ that =ℙ= is the =Maybe= type constructor.
 #+begin_src agda2 :tangle semantics-with-waist.agda
ℙ→Maybe : ∀ {X} → ℙ X → Maybe X
ℙ→Maybe nothingP  = nothing
ℙ→Maybe (justP x) = just x

ℙ←Maybe : ∀ {X} → Maybe X → ℙ X
ℙ←Maybe (just x) = justP x
ℙ←Maybe nothing  = nothingP

ℙ→Maybe∘ℙ←Maybe : ∀ {X} (m : Maybe X) → ℙ→Maybe (ℙ←Maybe m) ≡ m
ℙ→Maybe∘ℙ←Maybe (just x) = refl
ℙ→Maybe∘ℙ←Maybe nothing  = refl

ℙ←Maybe∘ℙ→Maybe : ∀ {X} (p : ℙ X) → ℙ←Maybe (ℙ→Maybe p) ≡ p
ℙ←Maybe∘ℙ→Maybe nothingP  = refl
ℙ←Maybe∘ℙ→Maybe (justP x) = refl
 #+end_src

 ‘Obvious’ indeed, with that syntactic sugar 🍭 😋

* =:kind=

  #+begin_src agda2 :tangle semantics-with-waist.agda
data Kind : Set where
  ‵record    : Kind
  ‵typeclass : Kind
  ‵data      : Kind

{- Nope: Since :waist may return type constructors, not sets!
_:kind_ : ∀ {ℓ} → Context ℓ → Kind → Set ℓ
𝒞 :kind ‵record    = 𝒞 :waist 0
𝒞 :kind ‵typeclass = 𝒞 :waist 1
𝒞 :kind ‵data      = termtype (𝒞 :waist 1)
-}
macro
  _:kind_ : Term → Term → Term → TC Unit.⊤
  _:kind_ t (con (quote ‵record) _)    goal = normalise (t app (quoteTerm 0))
                      >>=ₘ λ t′ → unify (waist-helper 0 t′) goal
  _:kind_ t (con (quote ‵typeclass) _) goal = normalise (t app (quoteTerm 1))
                      >>=ₘ λ t′ → unify (waist-helper 1 t′) goal
  _:kind_ t (con (quote ‵data) _) goal = normalise (t app (quoteTerm 1))
                      >>=ₘ λ t′ → normalise (waist-helper 1 t′)
                      >>=ₘ λ t″ → unify goal (def (quote Fix) ((vArg (Σ→⊎₀ (sources₁ t″))) ∷ []))
  _:kind_ t _ goal = unify t goal

-- _⟴_ : ∀ {a b} {A : Set a} {B : Set b} → A → (A → B) → B
-- x ⟴ f = f x
#+end_src

* COMMENT “Contexts over Contexts”

Informally =x₀ : τ₀, … ❙ y₀ : τ₀; …=  denotes two contexts, ~Γ₁ ❙ Γ₂~, where the
first is an elementary context and the latter is a context whose declarations
not only may use earlier ~yᵢ~ declarations but /additionally/ may use the entirety
of the context ~Γ₁~. We say =Γ₂= is a /context over context/ =Γ₁=.

1. A <<context over a context>>> is a dependent-type, from contexts to contexts.
2. A <<type over a dependent-context>> is an context-indexed family of sets.

#+BEGIN_SRC agda2 :tangle semantics.agda
Context′ : ∀ {ℓ} → Context ℓ → Set (ℓsuc ℓ)
Context′ {ℓ} Ξ  =  Ξ → Set ℓ

type′ : ∀ {ℓ} {Ξ : Context ℓ} → Context′ Ξ → Set (ℓsuc ℓ)
type′ {ℓ} Γ = ∀ {ξ} → Γ ξ → Set ℓ
#+END_SRC

We may index the previous ‘smart constructors’ for contexts over contexts:
#+BEGIN_SRC agda2
∅ : ∀ {ℓ} {Ξ : Context ℓ} → Context′ Ξ
∅ = λ _ → ⊤

_⨾_ : ∀ {ℓ} {Ξ : Context ℓ} → (Γ : Context′ Ξ) (τ : type′ Γ) → Context′ Ξ
Γ ⨾ τ = λ ξ → Σ γ ∶ Γ ξ • τ γ
#+END_SRC
Note: These names are not exported to the resulting Agda file, since they are
not needed.

* COMMENT *Current Status*

 I've been working on taking something as follows,
 #+begin_src agda2
do X ← Set
   e ← X
   e ≡ e
 #+end_src
 That is ~Set >>= λ X → X >>= λ e → e ≡ e~, but I want to seed it with an initial
 number 𝓃 which is reduced with each line. Instead of ~>>=~, let me write ~⊕ₙ~:
 ~(m >>= λ x → e) = ((x ∶ m) ⊕ₙ e)~.

 Then, I'd like to have the above example desugar to ~(X : Set) ⊕₁ (e : X) ⊕₀ (e ≡
 e)~ ---where the family ~⊕ₙ~ is right associative and we are using seed ~𝓃 = 1~.

 - ➩ The family ~⊕ₙ~ serves to demarcate parameters from the remainder of a context.
 - ➩ ~m ⊕ₙ f = (Σ m f)~ if /n = 0/ and ~m ⊕ₙ f = (x : m) → f x~ if /n ≠ 0/.

 The past week I've been trying multiple approaches to define ~Context~ and to
 defined ~⊕~. Here are some I've tried.

 :Hide:
 #+begin_src agda2 :tangle semantics-with-waist.agda
module semantics-with-waist.agda where

open import Level renaming (_⊔_ to _⊍_; suc to ℓsuc)
open import Data.Nat
open import Data.Product
Σ∶• : ∀ {a b} (A : Set a) (B : A → Set b) → Set _
Σ∶• = Σ
infix -666 Σ∶•
syntax Σ∶• A (λ x → B) = Σ x ∶ A • B
 #+end_src
 :End:
 #+begin_src agda2 :tangle semantics-with-waist.agda
Context¹ = λ ℓ → Set ℓ
_⊕¹_ : ∀ {i j} → (A : Context¹ i)
               → (f : A → Context¹ j)
               → ℕ → Context¹ (i ⊍ j)
(Γ ⊕¹ f) ℕ.zero    = Σ x ∶ Γ • f x
(Γ ⊕¹ f) (ℕ.suc n) = (x : Γ) → f x
 #+end_src
 The problem here is that the number 𝓃 is encountered, a decision of type former
 is selected, and 𝓃 is discarded. It should instead be “passed on” to other
 declarations.

 + State monad suggests itself.

 #+begin_src agda2 :tangle semantics-with-waist.agda
Context² = λ ℓ → ℕ → ℕ × Set ℓ
set = λ {ℓ} (A : Context² ℓ) → proj₂ (A 0)
_⊕²_ : ∀ {i j} → (A : Context² i)
               → (f : set A → Context² j)
               → Context² (i ⊍ j)
(Γ ⊕² f) ℕ.zero    = 0 , Σ x ∶ (set Γ) • set (f x)
(Γ ⊕² f) (ℕ.suc n) = n , ((x : set Γ) → set (f x))
 #+end_src
 The problem here is the arbitrary definition of ~set~, and the fact that we cannot
 make use of ~f~'s alteration of ~𝓃~:
 | The 𝓃 lives outside, but it can only be altered as in ~f x 𝓃~, which requires an ~x~! |

 + Lenses suggest themselves.

 #+begin_src agda2 :tangle semantics-with-waist.agda
record Context³ ℓ : Set (ℓsuc ℓ) where
  constructor MkCtx³
  field
    set³ : Set ℓ
    put  : ℕ → set³
    get  : ℕ
 #+end_src

 The same problem arises: We need to alter 𝓃, but cannot do so without calling ~f~
 which cannot be invoked without having an ~x~.

 Here are other routes I've tried and failed for similar reasons:
 + ~Context ℓ = ℕ × Set ℓ~
 + ~Context ℓ = (ℕ → ℕ) × Set ℓ~
 + ~_⊕_ : ⋯ → (f : ⊤ ⊎ A → Context ℓ)~
   - In an effort to call ~f~ so as to alter 𝓃 /without/ providing an ~x~.
   - Failed horribly in actually use: ~(x : X) ⊕ₙ f x~ is means ~x~ it /not/ a value of
     ~X~ but rather a value of ~⊤ ⊎ X~ and so we always need to account for both
     cases.
 + I've tried other formulations of ⊕ and ~Context~, but unfortunately I kept no
   record of them. I honestly thought that their definitions were easy and that I
   was just a bit off the mark ---a week later I'm no longer certain.

 /Any guidance would be appreciated!/

* COMMENT type-annotation syntax
  type-annotation : ∀ {ℓ} (A : Set ℓ) → A → A
type-annotation A a = a
syntax type-annotation A a = a ∶ A -- “ghost colon” \:

* COMMENT PackageFormers as Pairs of Contexts Demarcated by a Waist

As already mentioned, a PackageFormer is a pair of contexts where the latter
depends on the former.
#+BEGIN_SRC agda2 :tangle semantics.agda
record PackageFormer (ℓ : Level) : Set (ℓsuc ℓ) where
  constructor _❙_
  field
    parameters : Context ℓ
    body       : Context′ parameters
    #+END_SRC

Unsurprisingly every PackageFormer can be coerced into a context:
#+BEGIN_SRC agda2 :tangle semantics.agda
  toContext : Context ℓ
  toContext = Σ γ ∶ parameters • body γ
#+END_SRC

Note that the level-polymorphism is not to be facetious;
a PackageFormer is a grouping mechanism containing ‘smaller’
entities, the smallness of which is captured with the level.
- E.g., the grouping consisting of a single set is a PackageFormer at level 1.

The smart constructors from before can be lifted to this notion
---we suffix PackageFormer entities uniformly for clarity.

#+BEGIN_SRC agda2 :tangle semantics.agda
∅ₚ : ∀ {ℓ} → PackageFormer ℓ
∅ₚ = ⊤ ❙ (λ _ → ⊤)

typeₚ : ∀ {ℓ} → PackageFormer ℓ → Set (ℓsuc ℓ)
typeₚ {ℓ} (parameters ❙ body) = (Σ ξ ∶ parameters • body ξ) → Set ℓ
#+END_SRC

* COMMENT ‘M’utally ‘A’ssociative Sets

  The simplest thing we can do with contexts is ‘stick them together’,
  but a more natural operation is to extend a context with a new declaration.

  #+BEGIN_SRC agda2 :tangle semantics.agda
_⊎ₚ_ : ∀ {ℓ} → PackageFormer ℓ → PackageFormer ℓ → PackageFormer ℓ
(Γ₁ ❙ Γ₂) ⊎ₚ (Γ₁′ ❙ Γ₂′) = (Γ₁ ⊎ Γ₁′) ❙ [ Γ₂ , Γ₂′ ]

_⨾ₚ_ :  ∀ {ℓ} (p : PackageFormer ℓ) → typeₚ p → PackageFormer ℓ
(parameters ❙ body) ⨾ₚ d = parameters ❙ λ ξ → Σ β ∶ body ξ • d (ξ , β)
#+END_SRC


*Remark:* Contexts have a monoidal structure determined by pushouts; i.e.,
disjoint unions ⊎ and the empty PackageFormer ∅.  Indeed, we have a
mutual-associativity law ~(Γ₁ ⊎ Γ₂) ⨾ e ≈ Γ₁ ⊎ (Γ₂ ⨾ e)~ ---up to some /equivalence
relation/.

*Remark:* We do not have a monoidal action since ⨾ and ⊎ do not satisfiy the
necessary coherence laws ---even worse, the right law ~(Γ ⨾ e₁) ⨾ e₂ = Γ ⨾ (e₁ ⊎
e₂)~ and the left law ~Γ₁ ⨾ (Γ₂ ⨾ e) = (Γ₁ ⊎ Γ₂) ⨾ e~ are both ill-typed. Hence, we
have no hope of using ⊎/⨾ to trivially obtain a left/right monoidal action.

We can abstract out this structure in the hopes that a semantics for
PackageFormers can be determined via these new algebras.
:More:
In order to define a semantics, we need a notion of models in which to interpret
the syntactic PackageFormer entities.  Since left and right monoid-sets have
been ruled out, we shall formulate another species to fit the structure embedded
in PackageFormer.
:End:

Define a “<<MA-Set>>”, or a ‘M’utually ‘A’ssocitive structure to be a triple (ℳ,
𝒜, ·) where ℳ is a monoid, 𝒜 is a dependent family indexed by ℳ, and ~_·_ : (m :
ℳ) → 𝒜 m → ℳ~ is a ‘dependent action’ that is mutually associative with the
monoidal operation, ~(m₁ ⊕ m₂) · y ≈ m₁ ⊕ (m₂ · π y)~ where ~π : 𝒜 (m₁ ⊕ m₂) → 𝒜 m₂~
is a ‘weakening’ rule.

+ For now, we only implement the substructure that is necessary.
+ Perhaps additional structure needs to be added, or other to be removed.

#+BEGIN_SRC agda2 :tangle semantics.agda
record MA-Set (ℓ₁ ℓ₂ : Level) : Set (ℓsuc (ℓ₁ ⊍ ℓ₂)) where
  field
    ℳ  : Set ℓ₁
    _⊕_ : ℳ → ℳ → ℳ
    Id  : ℳ
    𝒜 :  ℳ → Set ℓ₂
    _·_ : (m : ℳ) → 𝒜 m → ℳ  -- Note the dependency
    -- TODO: Ommiting axioms for now; likely want a setoid structure.

open MA-Set
#+END_SRC

# - This is nearly an M-Set, but the functoriality law has been replaced by the
#   an associtivity law.

- Unlike M-Sets in which a monoids “acts” on a set, in a MA-Set we have the
  dependent set acting on the monoid /such that/ the ‘type of possible actions’
  is determined by monoid elements.

** Two Sanity Checks
*** Actually write a grouping mechanism
#+BEGIN_SRC agda2 :tangle semantics.agda
MonoidPF : PackageFormer (ℓsuc ℓ₀)
MonoidPF = (((∅ₚ
           ⨾ₚ λ{ (tt , _) → Set})
           ⨾ₚ λ{ (tt , (tt , Carrier)) → Lift (ℓsuc ℓ₀) Carrier})
           ⨾ₚ λ{ (tt , ((tt , Carrier), lift point))
                 → Lift (ℓsuc ℓ₀) (Carrier → Carrier → Carrier)})
           ⨾ₚ λ{ (tt , (((tt , Carrier) , lift point) , lift _⊕_))
                 → Lift (ℓsuc ℓ₀) (∀ {x} → x ⊕ point ≡ x × point ⊕ x ≡ x)}
#+END_SRC
TODO: Obtain working monad syntax.
*** PackageFormers are MA-Sets
#+BEGIN_SRC agda2 :tangle semantics.agda
PFs-are-MA-Sets : ∀ {ℓ} → MA-Set (ℓsuc ℓ) (ℓsuc ℓ)
PFs-are-MA-Sets {ℓ} = record
  { ℳ   = PackageFormer ℓ
  ; _⊕_ = _⊎ₚ_
  ; Id  = ∅ₚ
  ; 𝒜   = typeₚ
  ; _·_ = _⨾ₚ_
  }
#+END_SRC

** MA-Sets form a Category

Given two MA-Sets (ℳ, 𝒜, ·) and (ℳ′, 𝒜′, ·′), define a /MA-Set homomorphism/ to be
a pair of functions /h₁ : ℳ → ℳ′, h₂ : 𝒜 → 𝒜′/ that preserve the structure on each
set and respect the action; i.e.,
1. =h₁= is a monoid homomorphism
2. =h₁ (m · a) ≈ h₁ m ·′ h₂ a=, a reasonable coherence condition.

   Notice that when ~a : 𝒜 m~ then necessarily ~h₂ a : 𝒜′ (h₁ m)~.

 #+BEGIN_SRC agda2 :tangle semantics.agda
record Hom {ℓ₁ ℓ₂} (Src Tgt : MA-Set ℓ₁ ℓ₂) : Set (ℓsuc (ℓ₁ ⊍ ℓ₂)) where
  field
    mor₁ : ℳ Src → ℳ Tgt
    mor₂ : ∀ {m} → 𝒜 Src m → 𝒜 Tgt (mor₁ m)
    pres-Id : mor₁ (Id Src) ≡ Id Tgt
    pres-⊕  : ∀ {x y} → mor₁ (_⊕_ Src x y) ≡ _⊕_ Tgt (mor₁ x) (mor₁ y)
    coherence : ∀ {m a} → mor₁ (_·_ Src m a) ≡ _·_ Tgt (mor₁ m) (mor₂ a)

open Hom
 #+END_SRC

Conjectures:
1. (Id, Id) is a MA-Set homomorphism for any (ℳ, 𝒜)-set.
   - Sketch: Id is a monoid homomorphism, and the coherence
     condition is true by ≈-reflexivity.

   - Formally:
      #+BEGIN_SRC agda2 :tangle semantics.agda

id : ∀ {ℓ₁ ℓ₂} {MA : MA-Set ℓ₁ ℓ₂} → Hom MA MA
id = record
  { mor₁      = λ x → x
  ; mor₂      = λ x → x
  ; pres-Id   = refl
  ; pres-⊕    = refl
  ; coherence = refl
  }
 #+END_SRC

2. MA-Set homomorphisms are closed under composition.
   - Sketch: The composition of monoid homomorphisms is again
     a homomorphism; it remains to check coherence:
    #+BEGIN_SRC haskell
     (f₁ ∘ g₁) (m · a)
    = f₁ (g₁ (m · a))
    = f₁ (g₁ m · g₂ a)
    = f₁ (g₁ m) · f₂ (g₂ a)
    = (f₁ ∘ g₁) m · (f₂ ∘ g₂) a
#+END_SRC
    Whence, the coherence condition is true.

   - Formally:
    #+BEGIN_SRC agda2 :tangle semantics.agda
_∘_ : ∀ {ℓ₁ ℓ₂} {MA MB MC : MA-Set ℓ₁ ℓ₂} → Hom MB MC → Hom MA MB → Hom MA MC
_∘_ {MA = MA} {MB} {MC} F G = record
  { mor₁ = λ x → mor₁ F (mor₁ G x)
  ; mor₂ = λ x → mor₂ F (mor₂ G x)
  ; pres-Id = trans (cong (mor₁ F) (pres-Id G)) (pres-Id F)
  ; pres-⊕ = λ {x y} → begin
      mor₁ F (mor₁ G (_⊕_ MA x y))          ≡⟨ cong (mor₁ F) (pres-⊕ G) ⟩
      mor₁ F (_⊕_ MB (mor₁ G x) (mor₁ G y)) ≡⟨ pres-⊕ F ⟩
      _⊕_ MC (mor₁ F (mor₁ G x)) (mor₁ F (mor₁ G y)) ∎
  ; coherence = λ {m a} → begin
      mor₁ F (mor₁ G (_·_ MA m a)) ≡⟨ cong (mor₁ F) (coherence G) ⟩
      mor₁ F (_·_ MB (mor₁ G m) (mor₂ G a)) ≡⟨ coherence F ⟩
      _·_ MC (mor₁ F (mor₁ G m)) (mor₂ F (mor₂ G a)) ∎ }
 #+END_SRC

3. MA-Sets form a category.

The goal is then to show that MA-Sets have PackageFormer as an initial object!
---Initial semantics!

* COMMENT 🚧  Other Rndm Ideas
#+BEGIN_SRC agda2 :tangle semantics.agda

-- one-fun : ∀ {b ℓ} {𝑩 : Set ℓ → Set b} → Σ A ∶ Set ℓ • 𝑩 A  -- “Shape of given context”
--                                       → (A : Set ℓ) → 𝑩 A
-- one-fun = {!!}
--
{-
Σ (Set _ℓ_511)
(λ Carrier →
   Σ (Carrier → Carrier → Carrier)
   (λ _⊕₁_ →
      Σ Carrier (λ one → Σ Carrier (λ two → two ≡ (one ⊕₁ one)))))
-}

--------------------------------------------------------------------------------

{-
-- “A -⟨ n ⟩→ B” ≈ A → ⋯ → A → B with n+1 many A’s.
_-⟨_⟩→_ : ∀ {a b} (A : Set a) (n : ℕ) (B : Set b) → Set (a ⊍ b)
A -⟨ 0 ⟩→ B     = A → B
A -⟨ suc n ⟩→ B = A → A -⟨ n ⟩→ B

Prod : ∀ ℓ → ℕ → ℕ → Set (ℓsuc ℓ)
Prod ℓ m ℕ.zero    = ⊤
Prod ℓ m (ℕ.suc n) = Σ A ∶ Set ℓ • Prod ℓ m n
-}
-- waist3 : ∀ {ℓ n} → Prod (3 + n) → Prod n

{-
‵_ : ∀ {ℓ} → Set ℓ → PackageFormer ℓ
‵ typ = ∅ₚ ⨾ₚ λ _ → typ

MonoidPF′ : PackageFormer {!!}
MonoidPF′ = do carrier ← ‵ Set
               point  ← ‵ Set
               ⊤
-}

#+END_SRC

#+BEGIN_SRC agda2
infixr 4 _⸴_ -- \,
_⸴_ : ∀ {ℓ a b} {A : Set a} {B : A → Set b}
    → (x : A)
    → B x
    → Lift ℓ (Σ x ∶ A • B x)
a ⸴ b = lift (a , b)
#+END_SRC

** COMMENT Explorations with =Context′=
#+BEGIN_SRC agda2 :tangle semantics.agda
_>>=_ : ∀ {ℓ} {α β : Context ℓ}
      → Context′ α
      → (α → Context′ β)
      → Context′ β
_>>=_ {α = Ξ} Γ f = λ ν → Σ ξ ∶ Ξ • f ξ ν

‵_ : ∀ {ℓ} (C : Set ℓ) → Context′ C
‵ typ = λ _ → typ

-- Not everything lives at the same level, so a helpfer to lift things.
‵‵_ : ∀ {a ℓ} (C : Set ℓ) → Context′ {ℓ ⊍ a} (Lift a C)
‵‵_ {a} typ = λ _ → Lift a typ
#+END_SRC

** COMMENT Monad Syntax 🚧                                :construction_site:

 -- _▷_ : ∀ {ℓ} → (P : PackageFormer ℓ) → Declaration (toContext P) → PackageFormer ℓ
 -- (parameters ❙ body) ▷ d@(n ∶ τ ≔ δ) = parameters ❙ λ p → body p ⊎ Just d
* COMMENT Here are some laws that allow one to reach the claimed canonical form:
  1. `:waist w ⟴ :kind k ≈ :kind k ⟴ :waist w`

     Hence, we can always ensure `waist` appears before `kind`.

  2. More generally, `f ⟴ g ≈ g ⟴ f` whenever `f` and `g` are ‘disjoint’; whence
     ⨾-extensions also share this property with `:waist` and `:kind`.

     Thus we can always ensure ⨾-extensions appear before `:waist` and `:kind` clauses.

  3. `f₁ ⟴ f₂ ≈ f₂` for `fᵢ` both being either `:waist` clauses or `:kind` clauses.

     Hence, there will always be only one `:waist` and one `:kind` clause.

  Of-course these rules only permit the constructions `⟴, :waist, :kind` and
  ⨾-extensions. E.g., if the hammer `:alter-elements` is admitted, then little
  can be said since, say, one may re-arrange ⨾-extension elements according to
  their waist and kind, as is the case of Agda modules, wherein items above
  the waist *cannot* have definitional clauses.

* COMMENT Normal Forms 🚧                                 :construction_site:

  Ignoring the concrete syntax, every PackageFormer has a canonical flattened form:
#+begin_example haskell
LHS = ∅ ⨾ n₀ ∶ τ₀ ≔ d₀ ⨾ ⋯ ⨾ nₘ ∶ τₘ ≔ dₘ ⟴ :waist 𝓌 ⟴ :kind 𝓀
#+end_example

The “⨾” is read “extended-by” and the definitional clauses $dₖ$ may involve any
of the names $nᵢ$ for $i < k$.  It is an a *right* action:
#+begin_example haskell
_⨾_ : PackageFormer → Declaration → PackageFormer
#+end_example

# Where the semigroup structure on declarations is determined
# by sequential composition: If ~eᵢ~ are declarations, then ~e₀⨾⋯⨾eₙ~
# is a ‘single’ declaration.

The canonical form suggests that /PackageFormers are triples/
consisting of a context, a number, and a tag.

Instead of $∅ ⨾ n₀ ∶ τ₀ ≔ d₀ ⨾ ⋯ ⨾ nₘ ∶ τₘ ≔ dₘ ⟴ :waist 𝓌 ⟴ :kind 𝓀$ let us
write $e₀ ⨾ … ⨾ e_𝓌 ❙_{𝓀} e_{𝓌+1}⨾ … eₘ$.
- When the kind 𝓀 is uninteresting, or may be arbitrary, we shall omit it from
  the notation altogether. Likewise for the separator ‘❙’.

We may now define a composition operation on PackageFormers, via
pushout or disjoint union; e.g., $(Γ₁ ❙ Γ₂) ⊎ (Γ₁′ ❙ Γ₂′) = Γ₁″ ❙ Γ₂″$ where Γᵢ″
is catenation of Γᵢ and Γᵢ′, in some fixed chosen order.

We may also define a dual form of extension, known as “snoc” when ⨾ is read
“cons”.
#+begin_src haskell
_⸵_ : Declaration → PackageFormer → PackageFormer
e ⸵ (Γ₁ ❙ Γ₂) = ((∅ ⨾ e) ⊎ Γ₁) ❙ Γ₂
#+end_src

In the informal notation of contexts of type theory, the three operations ⸵, ⨾,
⊎ are denoted “,”.

*** PackageFormers and derived =_⊎_=
 #+BEGIN_SRC agda2 :tangle semantics.agda
record PackageFormer : Set₁ where
  constructor _❙_
  field
    parameters : Context
    body       : Context′ parameters

_⊎ₚ_ : PackageFormer → PackageFormer → PackageFormer
(Γ₁ ❙ Γ₂) ⊎ₚ (Γ₁′ ❙ Γ₂′) = (Γ₁ ⊎ Γ₁′) ❙ [ Γ₂ , Γ₂′ ]
 #+END_SRC

* COMMENT Meta-Primitives as Functions 🚧                 :construction_site:

With a notation and understanding of what a PackageFormer
consists of, we are in a position to provide a semantics
for the meta-primitives.

# :waist, :kind, ▷, and ⟴ are syntactic constructors.

First, ~waist~ is lifted from a syntactic construct to a function operation on
PackageFormers as follows.
#+begin_src haskell
_waist_ : PackageFormer → ℕ → PackageFormer
(Γ₁ ❙ Γ₂) waist 0       = ∅ ❙ (Γ₁ ⊎ Γ₂)
(Γ₁ ❙ Γ₂) waist (n + 1) = (head Γ₁) ◁ (tail Γ₁ ❙ Γ₂) waist n

where head : PackageFormer → Maybe Declaration
      head ∅ = Nothing
      head (e₁, …, eₙ ❙ Γ₂) = Just e₁

      tail : PackageFormer → PackageFormer
      tail ∅ = ∅
      tail (e₁ ◁ Γ) = Γ
#+end_src

That is, if $Γ = e₀⨾ ⋯⨾ eₘ$, ignoring the separator, then
$Γ waist n ≈ e₀⨾ ⋯⨾ eₙ ❙ eₙ₊₁⨾ ⋯⨾ eₘ$. That is, =waist= introduces
a partition in a context. Operationally, only the associated number
component of a PackageFormer has been altered.

* COMMENT Shallow Embedding Approach :typechecks:

In the setup below, it seems using the context approach can sometimes be easier
than using the λ approach, even though they are essentially the same.
Intuitively:
| What doing? | Easier to use |
|-------------+---------------|
| Reasoning   | Context       |
| Programming | Functions     |

** Imports
 #+BEGIN_SRC agda2
module pf where

open import Level renaming (zero to ℓzero; suc to ℓsuc; _⊔_ to _⊍_)
open import Relation.Binary.PropositionalEquality using (_≡_; refl)
open import Data.Nat
open import Data.Unit
open import Data.Empty
open import Data.Bool
open import Data.List
open import Data.List.Membership.Propositional
open import Data.List.Relation.Unary.Any using (here; there)
open import Relation.Nullary using (yes; no)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.String using (String) renaming (_==_ to _==ₛ_; _≟_ to _≟ₛ_; _++_ to _++ₛ_)
open import Data.Product using (Σ ; proj₁ ; proj₂ ; _×_ ; _,_)

 #+END_SRC

** Syntax Declarations
 #+BEGIN_SRC agda2

Name = String

Σ∶• : ∀ {a b} (A : Set a) (B : A → Set b) → Set _
Σ∶• = Σ

infix -666 Σ∶•
syntax Σ∶• A (λ x → B) = Σ x ∶ A • B

infixr 10 Π
syntax Π A (λ x → B) = Π x ∶ A • B

infix 9 _⊢Term_

 #+END_SRC
** Contexts, types, and terms

   Contexts are types, level-indexed types are functions, τ-terms are functions taking
   the context and yielding a value.

  #+BEGIN_SRC agda2
PackageFormer : (i : Level) → Set (ℓsuc i)
PackageFormer i = Set i
 #+END_SRC

*** types
  Next, object-level universes are implemented using meta-level universes.
  - Note: =Γ ⊢Type 𝒾  ≡  Γ ⊢Term (𝒰 𝒾)=.

  #+BEGIN_SRC agda2
_⊢Type_ :  ∀ {i} → PackageFormer i → (j : Level) → Set (i ⊍ ℓsuc j)
Γ ⊢Type 𝒾 = Γ → Set 𝒾

𝒰 : ∀ {i} {Γ : PackageFormer i} (j : Level) → Γ ⊢Type (ℓsuc j)
𝒰 j = λ γ → Set j
  #+END_SRC
*** terms
  #+BEGIN_SRC agda2
_⊢Term_ : ∀ {i j} → (Γ : PackageFormer i) → Γ ⊢Type j → Set (i ⊍ j)
Γ ⊢Term τ = (γ : Γ) → τ γ
  #+END_SRC

  After all, a classical context ~x₁ : τ₁, …, xₙ : τₙ ⊢ e : τ~ only /asserts/ =e : τ=
  /provided/ =xᵢ : τᵢ=, and so the latter is a function of the former! Indeed, as the
  λ-introduction rule shows, *all contexts are the humble function*
  ---e.g., with church encodings, we have that algebraic data-types are also
  functions, the eliminators.
  + MA: Perhaps with this neato observation, I should simply focus on functions?

*** context constructors

  The empty context is the unit type and context extension is interpreted using Σ-types.
  The identity of dependent products is the unit type, whence it denotes the empty PackageFormer.

 #+BEGIN_SRC agda2
ε : PackageFormer ℓzero
ε = ⊤

_▷_ : ∀ {i j} (Γ : PackageFormer i) → Γ ⊢Type j → PackageFormer (i ⊍ j)
Γ ▷ A = Σ γ ∶ Γ • A γ

  #+END_SRC
** Coercisions and Π

 #+BEGIN_SRC agda2
weaken : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type k}
       → Γ ⊢Type j → (Γ ▷ A) ⊢Type j
weaken τ (γ , a) = τ γ

pf-refl : ∀ {i j} {Γ : PackageFormer i} {A : Γ ⊢Type j}
        → (Γ ▷ A) ⊢Term weaken A
pf-refl = proj₂

Π : ∀ {i j k} {Γ : PackageFormer i} (A : Γ ⊢Type j) (B : (Γ ▷ A) ⊢Type k)
  → Γ ⊢Type (j ⊍ k)
Π A B = λ γ → ∀ (a : A γ) → B (γ , a)

_⇒_ : ∀ {i j k} {Γ : PackageFormer i} (A : Γ ⊢Type j) (B : Γ ⊢Type k)
    → Γ ⊢Type (j ⊍ k)
A ⇒ B = Π A (weaken B)

 #+END_SRC
** =lam= and =app=
 Abstraction and application are just Currying & Uncurrying
 #+BEGIN_SRC agda2
lam : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type j} {B : (Γ ▷ A) ⊢Type k}
    → (Γ ▷ A) ⊢Term B  →  Γ ⊢Term (Π A B)
lam g = λ γ → λ a → g (γ , a)

app : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type j} {B : (Γ ▷ A) ⊢Type k}
      →  Γ ⊢Term (Π A B)  → (Γ ▷ A) ⊢Term B
app g = λ{(γ , a) → g γ a}
 #+END_SRC

 Here are other forms of function application.
 #+BEGIN_SRC agda2
cut′ : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type j} {B : Γ ⊢Type k}
      →  (Γ ▷ A) ⊢Term weaken B
      →  Γ       ⊢Term A
      →  Γ       ⊢Term B
cut′ f a = λ γ → f (γ , a γ)

_on_ : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type j}
      → (Γ ▷ A) ⊢Type k
      →  Γ ⊢Term A
      →  Γ ⊢Type k
f on a = λ γ → f (γ , a γ)

cut : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type j} {B : (Γ ▷ A) ⊢Type k}
      →  (Γ ▷ A) ⊢Term B
      →  (a : Γ  ⊢Term A)
      →  Γ       ⊢Term (B on a)
cut f a = λ γ → f (γ , a γ)

_$_ : ∀ {i j k} {Γ : PackageFormer i} {A : Γ ⊢Type j} {B : (Γ ▷ A) ⊢Type k}
      → Γ ⊢Term (Π A B)
      → (a : Γ ⊢Term A)
      → Γ ⊢Term (B on a)
_$_ g = λ a γ → g γ (a γ)
 #+END_SRC

** Example terms!

 #+BEGIN_SRC agda2
‵id : ε ⊢Term Π A ∶ 𝒰 ℓzero • let A′ = λ _ → proj₂ A -- weakening.
                              in (A′ ⇒ A′) ε
‵id = lam (lam proj₂)
 #+END_SRC

 Let's try to show that =pf-refl= really is the identity function, up to isomorphism.
 #+BEGIN_SRC agda2
‵id₂ : ∀ {i j} {Γ : PackageFormer i} {A : Γ ⊢Type j}
     → Γ ⊢Term A ⇒ A
‵id₂ = lam pf-refl
 #+END_SRC

 Neato! Progress, finally (งಠ_ಠ)ง
* COMMENT Old Approach using Deep Embedding :incomplete:holes:

  #+begin_example agda2
module pf where
#+end_example
** Imports
#+begin_example agda2
open import Relation.Binary.PropositionalEquality using (_≡_; refl)
open import Data.Nat
open import Data.Unit
open import Data.Empty
open import Data.Bool
open import Data.List
open import Data.List.Membership.Propositional
open import Data.List.Relation.Unary.Any using (here; there)
open import Relation.Nullary using (yes; no)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.String using (String) renaming (_==_ to _==ₛ_; _≟_ to _≟ₛ_; _++_ to _++ₛ_)
open import Data.Product using (Σ ; proj₁ ; proj₂ ; _×_ ; _,_)
Name = String
#+end_example
** Fixity & syntax declarations
#+begin_example agda2
infix 11 eq
syntax eq τ l r  =  l ‵≡ r ∶ τ

infixr 10 _‵→_ ‵∀
syntax ‵∀ τ (λ η → γ) = Π η ∶ τ • γ -- “Z-notation”

-- infixl 9 _∶_ _∶_≔_
infixl 9 _∶_

infixl 5 _extended-by_

Σ∶• : ∀ {a b} (A : Set a) (B : A → Set b) → Set _
Σ∶• = Σ

infix -666 Σ∶•
syntax Σ∶• A (λ x → B) = Σ x ∶ A • B
#+end_example
** Declarations for mutually recursive DTL concepts
#+begin_example agda2
data PF : Set                          -- Syntax of PackageFormers; i.e., contexts
data _⊢Type (Γ : PF) : Set             -- Types in context
type-names-of : PF → List Name
-- types-of : (Γ : PF) → List (Γ ⊢Type)   -- The collection of types mentioned in a context
record _⊢constituent (Γ : PF) : Set    -- The type of terms
data _⊢Term:_ (Γ : PF) : Γ ⊢Type → Set -- Terms in context
#+end_example
** PackageFormer syntax
#+begin_example agda2
data PF where
  empty : PF
  _extended-by_ : (Γ : PF) → Γ ⊢constituent → PF
#+end_example
** “declarations in context”
#+begin_example agda2
record _⊢constituent Γ where
  -- constructor _∶_≔_
  constructor _∶_
  inductive
  field
    name     : Name
    type     : Γ ⊢Type
    -- equation : Maybe (Γ ⊢Term: type)
    -- Ommitted for brevity

open _⊢constituent

{-
_∶_ : ∀ {Γ} → Name → Γ ⊢Type → Γ ⊢constituent
x ∶ τ = x ∶ τ ≔ nothing
-}
#+end_example
** Decision procedure for tedious proofs
#+begin_example agda2
-- Soundness: Let's construct a decision procedure that actually provides tedious proofs.
-- This is used in the ADT “_⊢Type”.

data Error : String → Set where

present? : Name → List Name → Set
present? η []       = Error ("The type “" ++ₛ η ++ₛ "” is not in the parent context!")
present? η (n ∷ ns) with η ==ₛ n
...| true  = ⊤
...| false = present? η ns

soundness : ∀ {η ns} → present? η ns → η ∈ ns
soundness {η} {n ∷ ns} p with η ≟ₛ n
...| yes q = here q
...| no ¬q = there (soundness p)

tedious-example : "C" ∈ ("A" ∷ "B" ∷ "C" ∷ "D" ∷ [])
tedious-example = there (there (here refl))

improved-example : "C" ∈ ("A" ∷ "B" ∷ "C" ∷ "D" ∷ [])
improved-example = soundness tt

-- Uncomment to see an error since c is not in the list.
-- useful-error-msg : "c" ∈ ("A" ∷ "B" ∷ "C" ∷ "D" ∷ [])
-- useful-error-msg = soundness tt
#+end_example
** “types in context”
#+begin_example agda2
{-
  τ ∷= Set       “universe of types”
     | τ → τ     “function types”
     | α         “atomic types mentioned in the context”
     | e ≡ d     “term equality in context”
-}

data _⊢Type Γ where

  ‵Set  : Γ ⊢Type                                        -- type of small types

  -- ‵∀ : (τ : Γ ⊢Type) (body : Γ ⊢Term: τ → Γ ⊢Type) → Γ ⊢Type -- Pi types, we fail the positivity checker.
  -- In the spirit of gradual typing, we use a weaker form: The assumed term losses any possible definiens, equations.
  ‵∀ : (τ : Γ ⊢Type) (body : (η : Name) → (Γ extended-by η ∶ τ) ⊢Type) → Γ ⊢Type

  _‵→_ : Γ ⊢Type → Γ ⊢Type → Γ ⊢Type -- function type; making this derived requires a weak form of commuatvity at the context level

  -- variable case; the name must be mentioned in Γ
  ‵_   : (η : Name) {{_ : present? η (type-names-of Γ)}} → Γ ⊢Type

  eq : (τ : Γ ⊢Type) (l r : Γ ⊢Term: τ) → Γ ⊢Type

{-
_‵→_ : {Γ : PF} → Γ ⊢Type → Γ ⊢Type → Γ ⊢Type -- function type
τ ‵→ γ = Π _ ∶ τ • weaken γ
-}
#+end_example
** =type-names-of=
#+begin_example agda2
type-names-of empty = []
type-names-of (pf extended-by name₁ ∶ ‵Set) = name₁ ∷ type-names-of pf
type-names-of (pf extended-by _) = type-names-of pf
#+end_example
** A hierarchy of dependent weakening rules
#+begin_example agda2
{-
weaken1 : ∀ {Γ e} → Γ ⊢Type → (Γ extended-by e) ⊢Type

insert-before-last : ∀ {Γ η e τ} → (Γ extended-by η ∶ τ) ⊢Type
                                 → (Γ extended-by e extended-by η ∶ weaken1 τ) ⊢Type

insert-before-second-last : ∀ {Γ η₁ η₂ τ₁ τ₂ e}
 → (Γ extended-by               η₁ ∶         τ₁ extended-by η₂ ∶  τ₂) ⊢Type
 → (Γ extended-by e extended-by η₁ ∶ weaken1 τ₁ extended-by η₂ ∶ insert-before-last τ₂) ⊢Type
insert-before-second-last τ = {!!}

insert-before-last ‵Set = ‵Set
insert-before-last (‵∀ τ body) = Π η ∶ insert-before-last τ •  insert-before-second-last (body η)
insert-before-last (τ ‵→ τ₁) = {!!}
insert-before-last (‵ η) = {!!}
insert-before-last (eq τ l r) = {!!}

weaken1 ‵Set        = ‵Set
weaken1 (‵∀ τ body) = Π η ∶ weaken1 τ • insert-before-last (body η)
weaken1 (τ ‵→ τ₁)   = {!!}
weaken1 (‵ η)       = {!!}
weaken1 (eq τ l r)  = {!!}
-}

{- Other weakening rules
weaken-cons : ∀ {Γ e} → Γ ⊢constituent → (Γ extended-by e) ⊢constituent

weaken-mid : ∀ {Γ pre post new} → (Γ extended-by pre extended-by post) ⊢Type
                                → (Γ extended-by pre extended-by new extended-by weaken-cons post) ⊢Type
-}
#+end_example
** How many ‘arguments’ does a type have?
#+begin_example agda2
{-

arity : ∀ {Γ} → Γ ⊢Type → ℕ
arity ‵Set        = 0
arity (‵∀ τ body) = 1 + arity (body "_") -- Hack; possible since names are strings.
arity (τ ‵→ τ₁)   = 1 + arity γ  -- E.g., α ‵→ (β ‵→ γ) has 2 arguments.
arity (‵ η)       = {!!} -- Need to consider its type in Γ
arity (eq τ l r)  = 0
-}
#+end_example
** The subparts of a type expression
#+begin_example agda2
{--

-- An alias for _≡_; a singleton type
data JustThis {A : Set} : A → Set where
  this : (a : A) → JustThis a

-- If arity τ = 0 then ⊤ else the type of the first argument.
type-head : ∀ {Γ} → Γ ⊢Type → Set
type-head ‵Set      = ⊤
type-head (τ ‵→ _)  = JustThis τ
type-head _  = ⊤

-- If arity τ = 0 then ⊤ else the type of the first argument.
type-tail : ∀ {Γ} → Γ ⊢Type → Γ ⊢Type
type-tail τ = {!!}
-}
#+end_example
** “terms in context”
#+begin_example agda2
data _⊢Term:_ Γ where

  -- TODO: “x must be fresh for Γ”; variable case
  ‵_  : {τ : Γ ⊢Type} (x : Name) → Γ ⊢Term: τ

  -- curried function application
  -- _$_ : (f : Γ ⊢constituent) → type-head (type f) → Γ ⊢Term: type-tail (type f) -- Omitted for brevity
#+end_example
** Examples
#+begin_example agda2
Type : PF
Type = empty extended-by "Carrier" ∶ ‵Set

Indistinguishable : PF
Indistinguishable = Type extended-by
                         "blind" ∶ Π 𝓁 ∶ ‵ "Carrier" • Π 𝓇 ∶ ‵ "Carrier" • ‵ 𝓁 ‵≡ ‵ 𝓇 ∶ ‵ "Carrier"

Pointed : PF
Pointed = Type extended-by "𝟙" ∶ ‵ "Carrier"
-- Typos such as forgetting the final letter produce type-checking errors:
-- The type “Carrie” is not in the parent context!
-- Pointed = Type extended-by "𝟙" ∶ ‵ "Carrie"

Magma : PF
Magma = Type extended-by "_·_" ∶ ‵ "Carrier" ‵→ ‵ "Carrier" ‵→ ‵ "Carrier"
#+end_example
** Semantics
#+begin_example agda2
terms : PF → List (Σ Γ ∶ PF • Γ ⊢constituent)
terms empty = []
terms (p extended-by x) = terms p ++ [ p , x ]

Type-names-of : PF → Set
Type-names-of Γ = Σ η ∶ Name • present? η (type-names-of Γ)

semₜ : ∀ {Γ} → (Type-names-of Γ → Set₁) → Γ ⊢Type → Set₂
semₑ : ∀ {Γ} {τ : Γ ⊢Type} (σ : Type-names-of Γ → Set₁) → Γ ⊢Term: τ → Set₁ -- semₜ σ τ  ⇐  free variables are just placeholders for the types they represent

semₑ {Γ} {τ} σ (‵ x) = {!semₜ σ τ!}

open import Level using (Lift)

semₜ σ ‵Set          = Set₁
semₜ σ (‵∀ τ body)   = ∀ (x : semₜ σ τ) → ⊥ -- TODO
semₜ σ (τ ‵→ γ)      = semₜ σ τ → semₜ σ γ
semₜ σ (‵_ η {{p}})  = Lift _ (σ (η , p))
semₜ σ (eq τ l r)    = semₑ σ l ≡ semₑ σ r  -- ARGH: semₑ must yield Set₁ so it can be used in semₜ !!!!!!  -- JC, what do?

{-
present?-tn : ∀ {η Γ e} →   present? η (type-names-of (Γ extended-by e))
                          ≡ (if   (η ==ₛ name e)
                             then ⊤
                             else present? η (type-names-of Γ))
present?-tn {η} {Γ} {e} with type-names-of (Γ extended-by e) | η ==ₛ name e
present?-tn {η} {Γ} {e} | [] | false = {!!}
present?-tn {η} {Γ} {e} | [] | true = {!!}
present?-tn {η} {Γ} {e} | x ∷ xs | t = {!!}


weaken-present? : ∀ {η Γ e} → present? η (type-names-of Γ)
                            → present? η (type-names-of (Γ extended-by e))
weaken-present? {η} {Γ = Γ} p with type-names-of Γ | p
weaken-present? {η} {Γ = Γ} p | x ∷ xs | q with η ==ₛ x
weaken-present? {η} {Γ} p | x ∷ xs | q | false = {!!}
weaken-present? {η} {Γ} p | x ∷ xs | q | true = {!!}
-}

weaken : ∀ {Γ e}  → Γ ⊢Type → (Γ extended-by e) ⊢Type
weaken ‵Set        = ‵Set
weaken (‵∀ τ body) = {!!}
weaken (τ ‵→ γ)   = weaken τ ‵→ weaken γ
weaken (‵_ η {{p}})       = ‵_ η {{{!!}}}
weaken (eq τ l r)  = {!!}

terms′ : (Γ : PF) (σ : Γ ⊢Type → Set) → List (Σ Γ′ ∶ PF • Set × Γ′ ⊢constituent)
terms′ empty σ = []
terms′ (p extended-by e@(η ∶ τ)) σ = terms′ p (λ x → σ (weaken x)) ++ [ p , σ (weaken τ) , e ] -- terms′ p {!!} ++ [ p , {!!} , {!x!} ]
-- terms p ++ [ p , x ]


{-
sem : (Γ : PF) (σ : Γ ⊢Type → Set) (α : (η : Name) → Σ T ∶ Set • T) → Set
sem p σ α with terms p
...| [] = ⊥
...| (_ , η ∶ τ) ∷ xs = {!!}
  where -- function patching
        α′ : Name → Σ T ∶ Set • T
        α′ n = if n ==ₛ η then (σ {!!}) , {!!} else α n
-}

#+end_example
** Further experiments
#+begin_example agda2
{-
-- TODO: Add support for catenating PFs.
--
-- _⌢_ : PF → PF → PF
-- l ⌢ empty = l
-- l ⌢ (r extended-by x) = (l ⌢ r) extended-by {! need a weakening rule!}
--

monoid : PF
monoid = empty extended-by "Carrier" ∶ ‵Set
               extended-by "_·_" ∶ ‵ "Carrier" ‵→ ‵ "Carrier" ‵→ ‵ "Carrier"
               extended-by "𝟙" ∶ ‵ "Carrier"
               extended-by "assoc" ∶ {!!}
-}
  #+end_example
