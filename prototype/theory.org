#+title: Progressing on a type theory for =PackageFormer=
#+author: Musa Al-hassy
#+agda_version: 2.6.0.1

# Some blocks are marked â€œhaskellâ€ so that they are coloured and #not#
# interpreted as agda blocks. They're informal and do not typecheck.
#
# Could have used agda2-example blocks, but wanted the colouring.

*Status:* I cannot seem to phrase, let alone prove, the =stablityâ€²= claim for
 dynamic systems.
+ See the very bottom of this article.

# (shell-command "ln -s theory.org readme.org")

* Table of Contents                                    :Github:TOC_4:
- [[#introduction][Introduction]]
- [[#preamble][Preamble]]
  - [[#module-header][Module header]]
  - [[#imports][Imports]]
  - [[#syntax-declarations][Syntax Declarations]]
  - [[#helper-utilities][Helper Utilities]]
    - [[#level-polymorphic-unit-type][Level-Polymorphic Unit Type]]
- [[#what-is-a-type-theory][What is â€œa type theoryâ€?]]
- [[#our-ambient-type-theory][Our Ambient Type Theory]]
- [[#user-interface-for-context-declaration][User Interface for Context Declaration]]
  - [[#smart-constructors-as-do-notation][Smart Constructors as Do Notation]]
  - [[#example-records-of-ğ“ƒ-many-pointed-sets][Example: Records of ğ“ƒ-many Pointed Sets]]
    - [[#types][Types]]
    - [[#instances][Instances]]
  - [[#doubly-pointed-example----on-the-nature-of-parameters-Î¾][Doubly-Pointed Example -- On the nature of parameters Î]]
  - [[#example--a-record-type-with-invariants][Example â€“ A record type with invariants]]
- [[#parameterised-records][Parameterised Records]]
  - [[#header][Header]]
    - [[#reflection-helpers][Reflection Helpers]]
    - [[#products-and-tuple-notation][Products and âŸ¨TupleâŸ© Notation]]
  - [[#introduction-1][Introduction]]
  - [[#definitions-context-_-end][Definitions: ~Context, â€µ_, End~]]
  - [[#definitions-__][Definitions: ~_>>_~]]
  - [[#example-dynamical-systems][Example: Dynamical Systems]]
  - [[#theorems-stablity][Theorems: ~stablity~]]
  - [[#natural-number-instance][Natural Number Instance]]
  - [[#Ï€Î»-and-modus-ponens][Î â†’Î» and Modus Ponens]]
  - [[#defining-_waist_][Defining =_:waist_=]]
  - [[#further-natural-number-instances-and-fixing-parameters][Further Natural Number Instances and Fixing Parameters]]
  - [[#example----collections][Example ---Collections]]
  - [[#projections][Projections]]

* Introduction

  For brevity, every PackageFormer declaration can essentially be seen as a
  sequence of declarations, some of which are considered /parameters/ and the rest
  are the /body/. Whence, a PackageFormer is a pair of contexts.

  Let's try to explain that idea.

  + We shall embed the syntax of PackageFormers using semantics functions.
  + For now, we only focus on the record semantics of a PackageFormer. ---i.e.,
    ~:kind record~.

* Preamble
** Module header
#+BEGIN_SRC agda2 :tangle semantics.agda
-- The .agda file is trangled from an org file.
module semantics where
#+END_SRC
** Imports
#+BEGIN_SRC agda2 :tangle semantics.agda
open import Data.Product
open import Data.Nat
open import Data.Sum
open import Relation.Binary.PropositionalEquality hiding ([_])
open â‰¡-Reasoning
open import Level renaming (zero to â„“â‚€; suc to â„“suc; _âŠ”_ to _âŠ_)

import Data.Nat  as â„•
open import Data.Fin  as Fin using (Fin)
open import Data.Bool renaming (Bool to ğ”¹)
#+END_SRC
** Syntax Declarations
#+BEGIN_SRC agda2 :tangle semantics.agda
Î£âˆ¶â€¢ : âˆ€ {a b} (A : Set a) (B : A â†’ Set b) â†’ Set _
Î£âˆ¶â€¢ = Î£

infix -666 Î£âˆ¶â€¢
syntax Î£âˆ¶â€¢ A (Î» x â†’ B) = Î£ x âˆ¶ A â€¢ B
#+END_SRC

** Helper Utilities
*** Level-Polymorphic Unit Type
#+BEGIN_SRC agda2 :tangle semantics.agda
record âŠ¤ {â„“} : Set â„“ where
  constructor tt
#+END_SRC
*** COMMENT Singleton Types
We'll be treating contexts as sets and so will require a singleton types for
adjoining declarations.
#+BEGIN_SRC agda2 :tangle semantics.agda
data Just {â„“} {A : Set â„“} : A â†’ Set where
  just : (a : A) â†’ Just a
#+END_SRC
* What is â€œa type theoryâ€?
  To get anything done, we'll need an ambient type theory that provides us with
  a set of variable names ğ• and typing judgements. The comments below are what a
  classical type theory would have.
#+BEGIN_SRC agda2
record TypeTheory : Setâ‚ where
  field
    -- An infinite set of variable names
    ğ•       : Set
    -- A collection of name-type pairs
    Context : Set
    -- Possible expressions in a given context
    Expr    : Context â†’ Set
    -- When is an expression considered a â€˜typeâ€™
    _âŠ¢_type : (Î“ : Context) â†’ Expr Î“ â†’ Set
    -- When is a term considered to be â€œof a typeâ€
    _âŠ¢_âˆ¶_   : (Î“ : Context) â†’ Expr Î“ â†’ Expr Î“ â†’ Set
#+END_SRC
When Î“ is fixed and if we denote ~Î“ âŠ¢ e âˆ¶ Ï„~ by ~e âŸ¶ Ï„~ then we obtained a directed
graph where an edge may be construed as â€˜abstract interpreterâ€™ relationship
---the â€˜valueâ€™ of an expression is its type.

It seems that with the typing judgement, we can regain the kinding judgement:
~Î“ âŠ¢ Ï„ type â‡” âˆ€ (v : ğ•) â†’ Î“ âŠ¢ v âˆ¶ Ï„~.

Within a type theory, we can define a notion of declarations.
#+BEGIN_SRC agda2
  data Declaration (Î“ : Context) : Set where
    _âˆ¶_â‰”_by_and_ : (n : ğ•) (Ï„ Î´ : Expr Î“) â†’ Î“ âŠ¢ Ï„ type â†’ Î“ âŠ¢ Î´ âˆ¶ Ï„ â†’ Declaration Î“
#+END_SRC

  :Informal_Type_of_Declarations:
  Given an ambient type theory ğ‘», we define the type =Declaration= to be the
  triples ~n âˆ¶ Ï„ â‰” Î´~ where =n= is a â€˜nameâ€™, =Ï„= is a type of the given type theory, and
  =Î´= is a term over that type theory, possibly adjoined with other declarations
  =náµ¢ : Ï„áµ¢ â‰” Î´áµ¢=; i.e., the context ~ğ‘», nâ‚€ : Ï„â‚€ â‰” Î´â‚€, â€¦, nâ‚˜ : Ï„â‚˜ â‰” Î´â‚˜~ ensures ~Ï„~ is
  a type and ~Î´~ is of that type, and ~n~ must be a fresh name.
  :End:

The purpose of this section is merely to make it clear what a type theory
consists of ---we will not make any instances of the ~TypeTheory~ record type.
+ It is a learning moment, for me.

* Our Ambient Type Theory
Rather than working with an opaque, and generic, instance of a type theory, we
will work with a particular instance: Agda's type theory.

| We ignore syntax and jump straight to semantics ---whence no expression type! |

0. At the level of semantics, we may use Agda's variables instead of a
   dedicated variable type.
1. A context is nothing more than a set.
   - With the â€˜smart constructorsâ€™ below, a context is a dependent sum of types
     wherein later type-declarations may depend on earlier ones.
2. A type /determined by/ a context is a set than can be obtained
   using the context.

#+BEGIN_SRC agda2 :tangle semantics.agda
Context = Î» â„“ â†’ Set â„“
#+END_SRC
#+BEGIN_SRC agda2
type : âˆ€ {â„“} â†’ Context â„“ â†’ Set (â„“suc â„“)
type {â„“} Î“ = Î“ â†’ Set â„“
#+END_SRC

With this elementary setup, we can, for example, denote context extension with
existentials, also known as dependent products ---whose unit, a singleton type,
acts as the â€œempty contextâ€:
#+BEGIN_SRC agda2
âˆ… : Context â„“â‚€
âˆ… = âŠ¤

_â¨¾_ : âˆ€ {â„“} (Î“ : Context â„“) (Ï„ : type Î“) â†’ Context â„“
Î“ â¨¾ Ï„ = Î£ Î³ âˆ¶ Î“ â€¢ Ï„ Î³
#+END_SRC
These names are not exported to the resulting Agda file, since they are not
needed. In particular, we will â€˜reuseâ€™ these names until we have â€˜satisfactoryâ€™
definitions.

* User Interface for Context Declaration

** Smart Constructors as Do Notation
  Agda allows one to use an imperative style of programming ---using
  ~do~-notation--- provided there are mixfix functions ~_>>=_~ and ~_>>_~ in scope.
  + Importantly, only their existence is required; nothing else is assumed.
  + In particular, no monadic type constructor need be implicitly available.
    - This is the feature we exploit.

#+BEGIN_SRC agda2 :tangle semantics.agda
infixr 1 _>>=_

_>>=_ : âˆ€ {a â„“}
      â†’ (Î“ : Context a)
      â†’ (Î“ â†’ Context â„“)
      â†’ Context (a âŠ â„“)
Î“ >>= f = (Î£ Î³ âˆ¶ Î“ â€¢ f Î³)
-- The new piece, f Î³, is kept along with the old existing context via â€œÎ³ âˆ¶ Î“â€.

-- Using the default definition of _>>_
infixr 1 _>>_
_>>_ : âˆ€ {a b} â†’ Context a â†’ Context b â†’ Context (a âŠ b)
p >> q = p >>= (Î» _ â†’ q)
#+END_SRC

The notation may be ~doâ€¦End~ using the following combinator.
However, in general, it may be ~doâ€¦ğ’®~ for any set expression ğ’®.
#+BEGIN_SRC agda2 :tangle semantics.agda
End : âˆ€ {â„“} â†’ Context â„“
End {â„“} = âŠ¤ {â„“}
#+END_SRC

These two pieces together are the aforementioned â€˜smart constructorsâ€™:
+ ~Î“ â¨¾ Ï„~ is given the new syntax as ~Î“ >>= Ï„~.
+ ~âˆ…~ is given the syntax ~End~.

# You could define _>>=_ and End as aliases for _â¨¾_ and âˆ….

/It is important to remember that these smart constructors form grouping
mechanisms, not instances of them/; which is accomplished using tuples.

** Example: Records of ğ“ƒ-many Pointed Sets

   What do PackageFormers look like using the ~do~-notation and what do their
   instances look like? Surprisingly close to existing Agda record syntax for
   declarations and Agda tuples for instances.

*** Types
Let's form a grouping consisting of a single type and a value of that type,
along with an instance of the parameter type Î.
#+BEGIN_SRC agda2 :tangle semantics.agda
PointedPF : (Î : Context (â„“suc â„“â‚€)) â†’ Context (â„“suc â„“â‚€)
PointedPF Î = do Carrier â† Set
                 point   â† Carrier
                 Î
#+END_SRC

Let's consider concrete instances of the parameter Î.
#+BEGIN_SRC agda2 :tangle semantics.agda
-- A record type --- Î£ Set âˆ¶ Carrier â€¢ Î£ point âˆ¶ Carrier â€¢ âŠ¤
PointedSet = PointedPF âŠ¤

-- An extended record type
-- Î£ Set âˆ¶ Carrierâ‚ â€¢ Î£ pointâ‚ âˆ¶ Carrierâ‚ â€¢ (Î£ Carrierâ‚‚ âˆ¶ Set â€¢ Î£ pointâ‚‚ âˆ¶ Carrierâ‚ â€¢ âŠ¤)
TwoPointedSets = PointedPF PointedSet
#+END_SRC
More generally:
#+BEGIN_SRC agda2 :tangle semantics.agda
_PointedSets : â„• â†’ Setâ‚
zero  PointedSets = âŠ¤
suc n PointedSets = PointedPF (n PointedSets)

-- C-c C-n 4 PointedSets â‡’ Somewhat readable definition of the record!
#+END_SRC

Here we already have power: It's difficult to create the family of types =n
PointedSets= using existing Agda record syntax since the number of fields, /2 Ã— n/,
depends on =n=.

| Record /structure/ can be dependent on values! |

*** Instances
#+BEGIN_SRC agda2 :tangle semantics.agda
exampleâ‚ : PointedSet
exampleâ‚ = â„• , 0 , tt

exampleâ‚‚ : PointedSet
exampleâ‚‚ = Fin.Fin 3 , Fin.suc Fin.zero , tt

exampleâ‚ƒ : TwoPointedSets
exampleâ‚ƒ = ğ”¹ , true , exampleâ‚
-- A pointed nat extended by a pointed bool, with particular choices for both.
#+END_SRC

** Doubly-Pointed Example -- On the nature of parameters Î
What is a parameter exactly?

#+BEGIN_SRC agda2 :tangle semantics.agda
TwoParameterPoints : âˆ€ {â„“} (Î : Context â„“) â†’ Context â„“
TwoParameterPoints {â„“} Î = do one   â† Î
                              two   â† Î
                              End {â„“}

-- C-c C-n TwoParameterPoints   â‡’   Î» Î â†’ Î£ one âˆ¶ Î â€¢ Î£ two âˆ¶ Î â€¢ âŠ¤

-- Emphasise when sets are to be thought of as contexts
LitCtx : âˆ€ {â„“} â†’ Set â„“ â†’ Context â„“
LitCtx = Î» c â†’ c

exampleâ‚„ : TwoParameterPoints (LitCtx ğ”¹)
exampleâ‚„ = false , false , tt  -- Obtained with C-c C-a

exampleâ‚… : TwoParameterPoints PointedSet
exampleâ‚… = exampleâ‚ , exampleâ‚‚ , tt
#+END_SRC

** Example â€“ A record type with invariants

We can simulate definitions in a record via type invariants.

#+BEGIN_SRC agda2 :tangle semantics.agda
infix -1000 Property_
Property_ : âˆ€ {â„“} â†’ Set â„“ â†’ Context â„“ -- Intended as invariants.
Property_ = Î» c â†’ c                   -- In some contexts, the values could be irrelevant.

PointedMagma : âˆ€ {â„“} â†’ Context â„“ â†’ Context (â„“suc â„“)
PointedMagma {â„“} Î = do Carrier â† Set â„“
                        _âŠ•_     â† (Carrier â†’ Carrier â†’ Carrier)
                        one     â† Carrier
                        two     â† Carrier
                        three   â† Carrier
                        Property two   â‰¡ one âŠ• one
                        Property three â‰¡ one âŠ• two
#+END_SRC
The multiple laws, along with the following instance, increase confidence
in our definitions of ~_>>=_~ and ~_>>_~.
#+BEGIN_SRC agda2 :tangle semantics.agda
exampleâ‚† : PointedMagma âŠ¤
exampleâ‚† = â„• , â„•._+_ , 4 , 8 , 12 , refl {x = 8} , refl {x = 12}
#+END_SRC

* Parameterised Records

** Header
  #+begin_src agda2 :tangle semantics-with-waist.agda
module semantics-with-waist where

open import Level renaming (_âŠ”_ to _âŠ_; suc to â„“suc; zero to â„“â‚€)
open import Data.Nat
open import Relation.Binary.PropositionalEquality
open import Relation.Nullary
open import Data.Empty
open import Data.Bool using (Bool ; true ; false)
open import Data.List using (List ; [] ; _âˆ·_ ; _âˆ·Ê³_)

-- â€œs â‰” vâ€ is just a way to document v with string s.
open import Data.String using (String)
_â‰”_ : âˆ€ {â„“} {A : Set â„“} â†’ String â†’ A â†’ A
s â‰” v = v
infix 9 _â‰”_

-- Used in an example later on; too boring to be placed there.
data Digit : Set where
  #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 : Digit

#â†’â„• : Digit â†’ â„•
#â†’â„• #0 = 0
#â†’â„• #1 = 1
#â†’â„• #2 = 2
#â†’â„• #3 = 3
#â†’â„• #4 = 4
#â†’â„• #5 = 5
#â†’â„• #6 = 6
#â†’â„• #7 = 7
#â†’â„• #8 = 8
#â†’â„• #9 = 9
     #+end_src

*** Reflection Helpers
     #+begin_src agda2 :tangle semantics-with-waist.agda
import Data.Unit as Unit
open import Reflection hiding (name; Type) renaming (_>>=_ to _>>=â‚˜_)

-- Single argument application
_app_ : Term â†’ Term â†’ Term
(def f args) app argâ€² = def f (args âˆ·Ê³ arg (arg-info visible relevant) argâ€²) -- keep existing arguments!
{-# CATCHALL #-}
tm app argâ€² = tm

-- Reify â„• term encodings as â„• values
toâ„• : Term â†’ â„•
toâ„• (lit (nat n)) = n
{-# CATCHALL #-}
toâ„• _ = 0
#+end_src

*** Products and âŸ¨TupleâŸ© Notation
 #+begin_src agda2 :tangle semantics-with-waist.agda
open import Data.Product

Î£âˆ¶â€¢ : âˆ€ {a b} (A : Set a) (B : A â†’ Set b) â†’ Set _
Î£âˆ¶â€¢ = Î£

infix -666 Î£âˆ¶â€¢
syntax Î£âˆ¶â€¢ A (Î» x â†’ B) = Î£ x âˆ¶ A â€¢ B

record âŠ¤ {â„“} : Set â„“ where
  constructor tt

-- Expressions of the form â€œâ‹¯ , ttâ€ may now be written â€œâŸ¨ â‹¯ âŸ©â€
infixr 5 âŸ¨ _âŸ©
âŸ¨âŸ© : âˆ€ {â„“} â†’ âŠ¤ {â„“}
âŸ¨âŸ© = tt

âŸ¨ : âˆ€ {â„“} {S : Set â„“} â†’ S â†’ S
âŸ¨ s = s

_âŸ© : âˆ€ {â„“} {S : Set â„“} â†’ S â†’ S Ã— âŠ¤ {â„“}
s âŸ© = s , tt
   #+end_src
** Introduction
  We want to write
  #+begin_example agda2
do X â† Set
   z â† X
   s â† (X â†’ X)

:  â„• â†’ Set
  #+end_example
  Which desugars into:
  #+begin_example agda2
â€µ Set >>= Î» X â†’ â€µ X >>= Î» z â†’ â€µ (X â†’ X)  where â€µ_ : Set â†’ (â„• â†’ Set)
  #+end_example

  The definition of the quote is forced due to the necessary typing of ~>>=~.
** Definitions: ~Context, â€µ_, End~
  Hence, the definition of a context suggests itself:
  #+begin_src agda2 :tangle semantics-with-waist.agda
Context = Î» â„“ â†’ â„• â†’ Set â„“

infix -1000 â€µ_
â€µ_ : âˆ€ {â„“} â†’ Set â„“ â†’ Context â„“
â€µ S = Î» _ â†’ S

End : âˆ€ {â„“} â†’ Context â„“
End = â€µ âŠ¤
  #+end_src

** Definitions: ~_>>_~
Next we define the bind operator to account for the current waist: If zero, we
have records, otherwise functions.
#+begin_example agda2
_>>=_ : âˆ€ {a b}
      â†’ (Î“ : Context a)
      â†’ (âˆ€ {n} â†’ Î“ n â†’ Context b)
      â†’ Context (a âŠ b)
(Î“ >>= f) â„•.zero  = Î£ Î³ âˆ¶ Î“ 0 â€¢ f Î³ 0
(Î“ >>= f) (suc n) = (Î³ : Î“ n) â†’ f Î³ n
#+end_example

Unfortunately, this would require too many calls to quote; e.g.,
#+begin_example agda2
do X â† â€µ Set
   z â† â€µ X
   s â† â€µ (X â†’ X)
   End
#+end_example

So let's â€œbuild it into the definition of >>=â€:
  #+begin_src agda2 :tangle semantics-with-waist.agda
_>>=_ : âˆ€ {a b}
      â†’ (Î“ : Set a)  -- Main diference
      â†’ (Î“ â†’ Context b)
      â†’ Context (a âŠ b)
(Î“ >>= f) â„•.zero  = Î£ Î³ âˆ¶ Î“ â€¢ f Î³ 0
(Î“ >>= f) (suc n) = (Î³ : Î“) â†’ f Î³ n
  #+end_src

Let's see this in action:
  #+begin_src agda2 :tangle semantics-with-waist.agda
Monoid : âˆ€ â„“ â†’ Context (â„“suc â„“)
Monoid â„“ = do Carrier â† Set â„“
              Id      â† Carrier
              _âŠ•_     â† (Carrier â†’ Carrier â†’ Carrier)
              leftId  â† âˆ€ {x : Carrier} â†’ x âŠ• Id â‰¡ x
              rightId â† âˆ€ {x : Carrier} â†’ Id âŠ• x â‰¡ x
              assoc   â† âˆ€ {x y z} â†’ (x âŠ• y) âŠ• z  â‰¡  x âŠ• (y âŠ• z)
              End {â„“}
  #+end_src

But what does all of this /mean/? Let's return to the dynamic system at the start
of this discussion.

** Example: Dynamical Systems

  #+begin_src agda2 :tangle semantics-with-waist.agda
DynamicSystem : Context (â„“suc Level.zero)
DynamicSystem = do X â† Set
                   z â† X
                   s â† (X â†’ X)
                   End {Level.zero}
#+end_src

We can now â€œseeâ€ ---with ~C-c C-n~--- what a dynamical system looks like /at/ a
particular waist.
#+begin_src agda2 :tangle semantics-with-waist.agda
-- Records with ğ“ƒ-Parameters, ğ“ƒ : 0..3
A B C D : Setâ‚
A = DynamicSystem 0 -- Î£ X âˆ¶ Set  â€¢ Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ X â†’ X  â€¢ âŠ¤
B = DynamicSystem 1 --  (X âˆ¶ Set) â†’ Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ X â†’ X  â€¢ âŠ¤
C = DynamicSystem 2 --  (X âˆ¶ Set)    (z âˆ¶ X) â†’ Î£ s âˆ¶ X â†’ X  â€¢ âŠ¤
D = DynamicSystem 3 --  (X âˆ¶ Set)    (z âˆ¶ X) â†’  (s âˆ¶ X â†’ X) â†’ âŠ¤
#+end_src

It is important to note that these are /not/ functions, but instead
are /function types/!

** Theorems: ~stablity~

Observe that there are no more â€˜interestingâ€™ ways to form a dynamical system.
#+begin_src agda2 :tangle semantics-with-waist.agda
stablity : âˆ€ {n} â†’   DynamicSystem (3 + n)
                   â‰¡ DynamicSystem  3
stablity = refl
  #+end_src

  Moreover, by the nature of a dynamical system, there cannot ever be such a
  system with an empty state space, and so ~B~.
#+begin_src agda2 :tangle semantics-with-waist.agda
B-is-empty : Â¬ B
B-is-empty b = projâ‚( b âŠ¥)
#+end_src

** Natural Number Instance
Let's form an instances at height 0; i.e., a record.
  #+begin_src agda2 :tangle semantics-with-waist.agda
ğ’©â‚€ : DynamicSystem 0
ğ’©â‚€ = â„• , 0 , suc , tt
  #+end_src

With the expected sugar, we gain an extra grain of readability.
  #+begin_src agda2 :tangle semantics-with-waist.agda
ğ’© : DynamicSystem 0
ğ’© = âŸ¨ â„• , 0 , suc âŸ©
  #+end_src

Neato: One declares a PackageFormer with ~doâ€¦End~ then forms a 0-waist value
using ~âŸ¨â‹¯âŸ©~.

** Î â†’Î» and Modus Ponens
Unfortunately, since ~B, C, D~ are all of type ~Setâ‚~ and so are not functions,
there is no trivial way to â€œinstantiateâ€ any of ~B, C, D~'s arguments to obtain
versions of ~A~ wherein certain fields are already â€œfixedâ€.

I'd like to write =B on â„•=, for example. However, a definition of ~_on_~ seems to
want to pattern match on sorts.
  #+begin_src agda2 :tangle semantics-with-waist.agda
B-on-â„• : Set
B-on-â„• = let X = â„• in Î£ z âˆ¶ X  â€¢ Î£ s âˆ¶ (X â†’ X)  â€¢ âŠ¤

ex : B-on-â„•
ex = âŸ¨ 0 , suc âŸ©
  #+end_src

Let's oblige, and pattern match on sorts ---by using reflection.

The /values/ ~B,C,D~ are all of the form ~âˆ€ X â†’ â‹¯~, in-order to /apply/ them
we need to transform them into values of the form ~Î» X â†’ â‹¯~, for which application
is actually sensible. As far as I know, there is no natural operation
transforming a function-type into a function-value, so we make the necessary
transformation /syntactically/.

Here's an instance of moving from the Î -type-level to the Î»-value-level.
  #+begin_src agda2 :tangle semantics-with-waist.agda
idÏ„ : Setâ‚
idÏ„ = âˆ€ (X : Set) (e : X) â†’ X

idâ‚ : âˆ€ (X : Set) â†’ Set
idâ‚ = Î» (X : Set) â†’ ((e : X) â†’ X)

idâ‚‚ : âˆ€ (X : Set) (e : X) â†’ Set
idâ‚‚ = Î» (X : Set) (e : X) â†’ X
   #+end_src
Let's code to make the transformation ~idÏ„ â†¦ idâ‚‚~ feasible.

We start with Agda terms.
   #+begin_src agda2 :tangle semantics-with-waist.agda
Î â†’Î»-helper : Term â†’ Term
Î â†’Î»-helper (pi  a b)         = lam visible b
Î â†’Î»-helper (lam a (abs x y)) = lam a (abs x (Î â†’Î»-helper y))
{-# CATCHALL #-}
Î â†’Î»-helper x = x
#+end_src

+ We case on type formation, then rewrite the first encountered Î -type into a Î»-value.
+ If a Î» is encountered, we go inside to make the rewrite.
  - The intention is that sequential rewrite invocations are easily expressed.
+ We could have added the following case before the catchall, however it is
  undesirable since in general we do not want to unwind as much as possible,
  but only as much waist as provided.
  #+begin_example agda2
Î â†’Î»-helper (pi a (abs x y)) = lam visible (abs x (Î â†’Î»-helper y))
  #+end_example

Here are two sample uses.
#+begin_example agda2
-- Error: Failed to resolve sort constraints
_ : unquote (unify (Î â†’Î»-helper (quoteTerm (âˆ€ (X : Set) (x : X) â†’ X)))) â‰¡ Î» X â†’ X â†’ X
_ = refl

-- Ekk! No normalisation!
_ : Î â†’Î»-helper (quoteTerm idÏ„) â‰¡ quoteTerm idÏ„
_ = refl
#+end_example

As it stands, this syntactic rewrite is pathetic from a usage point of view: We
need to quote arguments provided to it, then unquote them back into working
code. Moreover, due to Agda's weak reflection mechanism, such a bungled mess
usually results in errors failing to solve sort constraints.  /Even worse/, it
does not account for normal forms; e.g., a constant name is just that, a name,
rather than what it expands to.
Let's remedy these two issues.
#+begin_src agda2 :tangle semantics-with-waist.agda
macro
  Î â†’Î» : Term â†’ Term â†’ TC Unit.âŠ¤
  Î â†’Î» tm goal = normalise tm >>=â‚˜ Î» tmâ€² â†’ unify (Î â†’Î»-helper tmâ€²) goal
  #+end_src

+ We normalise a given term /then/ invoke the previously formed helper.
+ Due to the currently poor state of reflection in Agda, we are /forced/ to
  construct the auxiliary function since macros cannot be recursive.
    #+begin_example agda2
-- Error: Cannot unquote non-canonical type checking computation
macro
  lame : â„• â†’ Term â†’ Term â†’ TC Unit.âŠ¤
  lame zero t g    = unify t g
  lame (suc n) t g = lame n t g
  #+end_example

At this point, our goals are reasonably achieved:
#+begin_src agda2 :tangle semantics-with-waist.agda
_ : Î â†’Î» idÏ„ â‰¡ idâ‚
_ = refl

-- Too much yellow, sort constraints cannot be solved. It's okay.
-- _ : Î â†’Î» (Î â†’Î» idÏ„) â‰¡ idâ‚‚
-- _ = refl
  #+end_src

Reflection was not the first route attempted.  A more natural approach would be
to form a â€˜universeâ€™ type ~ğ•Œ~ which has a constructor ~â€µÎ ~ for encoding dependent
function types, one then defines ~Î â†’Î»~ by requesting a â‰¡-proof that the given type
is indeed a function-type, i.e., is equivalent to the semantics of an encoding
~â€µÎ ~.  However, such encodings always led to some technical issue.  Most notable
being that we cannot view ~Setâ‚~ via our encoding ~ğ•Œ~ since such a function ~Setâ‚ â†’ ğ•Œ~
would fail to encode types without having a pre-existing way to pattern match
against the inhabitants of ~Setâ‚~.  As such, we have solved the problem in the
meta-theory.

It is curious that this problem is reminiscent of currying.
#+begin_src agda2
-- Given:
Ï„ : Setâ‚
Ï„ = âˆ€ (X : Set) â†’ â‹¯

-- Obtain:
Ï„f : âˆ€ (X : Set) â†’ Setâ‚
Ï„f = Î» (X : Set) â†’ â‹¯
#+end_src
| The type of ~Ï„~ merely states it to be a grouping mechanism!        |
| The type of ~Ï„f~ /exposes/ that ~Ï„~ is a parmeterised grouping mechanism! |

Perhaps this is related to indexing vs parameters.

+ We can apply =Ï„f= and so it's more concrete than =Ï„=.
+ Hence, we may call =Î â†’Î»= a â€œtype constructor reificationâ€.

** Defining =_:waist_=
   Multiple invocations of ~Î â†’Î»~ along with a raw waist exposes the structure of
   a parameterised record, as in the following examples.
  #+begin_src agda2 :tangle semantics-with-waist.agda
_ : Î â†’Î» (DynamicSystem 1) â‰¡ Î» Î³ â†’ Î£ Î³ (Î» _ â†’ Î£ ((x : Î³) â†’ Î³) (Î» _ â†’ âŠ¤))
_ = refl

CC : âˆ€ (X : Set) (x : X) â†’ Set
CC = Î â†’Î» (Î â†’Î» (DynamicSystem 2))   -- c.f., C above and Câ€² below.
   #+end_src
   Let's abstract away the raw waist, 2 above, and the 2-many invocations of
   ~Î â†’Î»~.

   As mentioned earlier, we must perform recursion outside of ~macro~ clauses, so
   we must have an auxiliary function.
   #+begin_src agda2 :tangle semantics-with-waist.agda
waist-helper : â„• â†’ Term â†’ Term
waist-helper zero t    = t
-- waist-helper (suc n) t = waist-helper n (Î â†’Î» t)
waist-helper (suc n) t = waist-helper n (Î â†’Î»-helper t)
  #+end_src

  It is important to note that the commented out line could /not/ have been used
  and instead the ~Î â†’Î»~ macro's underlying helper must be invoked instead.  Why?
  This subtlety is due to the implicit-quotation invocation style of macros: If
  ~f : Term â†’ Name â†’ Bool â†’ Term â†’ TC âŠ¤~ is declared a macro, then an application
  ~f u v w~ desugars into ~unquote (f (quoteTerm u) (quote v) w)~.

We now use the helper to form the necessary combinator.
  #+begin_src agda2 :tangle semantics-with-waist.agda
macro
  _:waist_ : Term â†’ Term â†’ Term â†’ TC Unit.âŠ¤
  _:waist_ t ğ“ƒ goal =      normalise (t app ğ“ƒ)
                      >>=â‚˜ Î» tâ€² â†’ unify (waist-helper (toâ„• ğ“ƒ) tâ€²) goal
#+end_src

Note that it's important we /apply/ the given context to a raw waist,
then /normalise/ that before moving on. Indeed, ~waist-helper~ invokes ~Î â†’Î»â†’helper~,
which performs no normalisation.

+ ~:waist~ could not have been defined as a top level function operating on ~Set â„“~
  since it cannot be typed! It needs to operate on syntax and so is a macro.
  - Indeed, ~Î“ :waist n~ may sometimes return a function of types, values of ~Setâ‚~,
    or a function of other types, such as ~â„•~. We shall show this below when
    forming ~Aâ€², Bâ€², Câ€², Dâ€²~.

 How are these two indexing mechanisms related?
 0. =C :waist n= is an n-ary type constructor; given n inputs, a record type is returned.
 1. =C n= is a â€œfactoryâ€: Given n inputs ğ“, it will produce a value of =(C :waist n) ğ“=.

** Further Natural Number Instances and Fixing Parameters

Let's now demonstrate how convenient it is to use ~_:waist_~.
  #+begin_src agda2 :tangle semantics-with-waist.agda
Aâ€² : Setâ‚
Bâ€² : âˆ€ (X : Set) â†’ Set
Câ€² : âˆ€ (X : Set) (x : X) â†’ Set
Dâ€² : âˆ€ (X : Set) (x : X) (s : X â†’ X) â†’ Set
#+end_src
Each type /exposes/ more and more information about what kind of grouping
structure we have at hand. The definitions are super simple sweetness.
#+begin_src agda2 :tangle semantics-with-waist.agda
Aâ€² = DynamicSystem :waist 0
Bâ€² = DynamicSystem :waist 1
Câ€² = DynamicSystem :waist 2
Dâ€² = DynamicSystem :waist 3
  #+end_src

~B,C,D~ are parameterised records: Given values of the parameters, record values
are created. What if, we want to simply supply parameters and obtain new
parameterised records; i.e., do not go all the way down to the creation level.
These â€˜partial appliedâ€™ types are ~Bâ€², Câ€², Dâ€²~. That is, ~:waist~ essentially
allows us to unbundle, or uncurry, records! So cool (â€¢Ì€á´—â€¢Ì)Ùˆ

  The following /instances/ of these grouping /types/ demonstrate how /information
moves from the body level to the parameter level/!
  #+begin_src agda2 :tangle semantics-with-waist.agda
ğ’©â° : Aâ€²
ğ’©â° = âŸ¨ â„• , 0 , suc âŸ©

ğ’©Â¹ : Bâ€² â„•
ğ’©Â¹ = âŸ¨ 0 , suc âŸ©

ğ’©Â² : Câ€² â„• 0
ğ’©Â² = âŸ¨ suc âŸ©

ğ’©Â³ : Dâ€² â„• 0 suc
ğ’©Â³ = âŸ¨âŸ©
#+end_src

Notice that with ~Aâ€², Bâ€², Câ€², Dâ€²~ we may fix certain parameters ahead of time.
Above the type ~Bâ€² â„•~ is the type of â€œdynamic systems over carrier â„•â€ whereas ~Câ€² â„•
0~ is the type of â€œdynamic systems over carrier â„• and start state 0â€.  Neato!

One would expect the stablity result from earlier to continue to hold, but
there is a type error in even phrasing it naively.
#+begin_example agda2
-- Type error: LHS and RHS of â€˜â‰¡â€™ do not agree.
stablityâ€² : âˆ€ {n : â„•} â†’
            DynamicSystem :waist (3 + n)
          â‰¡ DynamicSystem :waist 3
stablityâ€² = refl
#+end_example

** Example ---Collections

   Here's a specification of a collection, which includes an element type;
   along with an instance-former; i.e., a value at a non-zero waist. ---Thanks Wolfram!
#+begin_src agda2 :tangle semantics-with-waist.agda
Collection : âˆ€ â„“ â†’ Context (â„“suc â„“)
Collection â„“ = do
  Elem    â† Set â„“
  Carrier â† Set â„“
  insert  â† (Elem â†’ Carrier â†’ Carrier)
  âˆ…       â† Carrier
  isEmpty â† (Carrier â†’ Bool)
  insert-nonEmpty â† âˆ€ {e : Elem} {x : Carrier} â†’ isEmpty (insert e x) â‰¡ false
  End {â„“}

ListColl : {â„“ : Level} â†’ Collection â„“ 1
ListColl E = âŸ¨ List E
             , _âˆ·_
             , []
             , (Î» { [] â†’ true; _ â†’ false})
             , (Î» {x} {x = xâ‚} â†’ refl)
             âŸ©
           #+end_src

The neat thing here is that a value of ~Collection â„“~ is an element type
along with collection type over said elements; whereas a value of ~Collection â„“ 1~
is a way to form collections for given element types.

Here's another example.

Enumerated types can always be encoded as values of â„• and so â„• can be thought
of as a way to collect values of the enumeration.
  #+begin_src agda2 :tangle semantics-with-waist.agda
â„•Collection = (Collection â„“â‚€ :waist 2)
                ("Elem"    â‰” Digit)
                ("Carrier" â‰” â„•)
--
-- i.e., (Collection â„“â‚€ :waist 2) Digit â„•
#+end_src

  + Note that the ~"key" â‰” value~ pairs are just syntactic sugar for ~value~,
    that document it via ~"key"~.
  + ~Digit~ is the enumerated type of values ~#ğ’¾~ for ~ğ’¾ : 0..9~.

More concretely, if the enumerated has ğ“ƒ-many values, we can form a stack by
starting with 0 and pushing elements ~d~ â€œto then end of our running total $s$â€ to
obtain =s * 10â¿ + d=, for example.  Then we pop elements off via division. Here's
an instance for the digit enumeration type.

#+begin_src agda2 :tangle semantics-with-waist.agda
stack : â„•Collection
stack = âŸ¨ "insert"      â‰” (Î» d s â†’ suc (10 * s + #â†’â„• d))
        , "empty stack" â‰” 0
        , "is-empty"    â‰” (Î» { 0 â†’ true; _ â†’ false})
        -- Properties --
        , (Î» {d : Digit} {s : â„•} â†’ refl {x = false})
        âŸ©
  #+end_src

+ The ~suc~, in ~"insert"~, is to make the coherence property easily proven.

Super neat stuff (â”€â€¿â€¿â”€)

** Projections

   Since records are just products, we may project to obtain their fields.
   - The following meta-program yields a type error when trying to project
     fields that do not exist.
#+begin_src agda2 :tangle semantics-with-waist.agda
Fieldâ‚€ : â„• â†’ Term â†’ Term
Fieldâ‚€ zero c    = def (quote projâ‚) (arg (arg-info visible relevant) c âˆ· [])
Fieldâ‚€ (suc n) c = Fieldâ‚€ n (def (quote projâ‚‚) (arg (arg-info visible relevant) c âˆ· []))

macro
  Field : â„• â†’ Term â†’ Term â†’ TC Unit.âŠ¤
  Field n t goal = unify goal (Fieldâ‚€ n t)
#+end_src

Agda macros do not support Î·-equivalence and so definitions
of particular projections are necessarily of the form ~Î» C â†’ Field ğ’¾ C~.

#+begin_src agda2 :tangle semantics-with-waist.agda
Elem      : âˆ€ {â„“} â†’ Collection â„“ 0 â†’ Set â„“
Elem      = Î» C   â†’ Field 0 C
          #+end_src

Nullary types like ~Collection â„“ 0~ all have a similar projection form.
There is a neat interesting shift when we move positive-argument types.
          #+begin_src agda2 :tangle semantics-with-waist.agda
Carrier   : âˆ€ {â„“} â†’ Collection â„“ 0 â†’ Set â„“
Carrierâ‚  : âˆ€ {â„“} â†’ Collection â„“ 1 â†’ (Î³ : Set â„“) â†’ Set â„“
Carrierâ‚â€² : âˆ€ {â„“} {Î³ : Set â„“} (C : (Collection â„“ :waist 1) Î³) â†’ Set â„“

Carrier   = Î» C   â†’ Field 1 C
Carrierâ‚  = Î» C Î³ â†’ Field 0 (C Î³)
Carrierâ‚â€² = Î» C   â†’ Field 0 C
          #+end_src

The differences are subtle, so let's try exposing more arguments.

          #+begin_src agda2 :tangle semantics-with-waist.agda
insert   : âˆ€ {â„“} (C : Collection â„“ 0) â†’ (Elem C â†’ Carrier C â†’ Carrier C)
insertâ‚  : âˆ€ {â„“} (C : Collection â„“ 1) (Î³ : Set â„“) â†’  Î³ â†’ Carrierâ‚ C Î³ â†’ Carrierâ‚ C Î³
insertâ‚â€² : âˆ€ {â„“} {Î³ : Set â„“} (C : (Collection â„“ :waist 1) Î³) â†’ Î³ â†’ Carrierâ‚â€² C â†’ Carrierâ‚â€² C

insert    = Î» C   â†’ Field 2 C
insertâ‚   = Î» C Î³ â†’ Field 1 (C Î³)
insertâ‚â€²  = Î» C   â†’ Field 1 C
#+end_src

Notice that ~insertâ‚~'s ~C~ must be passed inputs each time it is used ---since ~C~ is
a â€œfactoryâ€, as mentioned earlier. In contrast, ~insertâ‚â€²~'s ~C~ has no arguments
as they are fixed ahead of time.

The need to invoke a factory with its inputs seems to have a slightly greater
impact at the definition level, as seen below.
#+begin_src agda2 :tangle semantics-with-waist.agda
insertâ‚‚  : âˆ€ {â„“} (C : Collection â„“ 2) (El Cr : Set â„“) â†’ El â†’ Cr â†’ Cr
insertâ‚‚â€² : âˆ€ {â„“} {El Cr : Set â„“} (C : (Collection â„“ :waist 2) El Cr) â†’ El â†’ Cr â†’ Cr

insertâ‚‚ = Î» C El Cr â†’ Field 0 (C El Cr)
insertâ‚‚â€² = Î» C â†’ Field 0 C
  #+end_src

Neato petito!

** COMMENT ~:exposing~ --no

     Setâ‚
â‡’ âˆ€ Xâ‚ â†’ â‹¯ â†’ âˆ€ Xâ‚™ â†’ Set
â‰… âˆ€ Xâ‚™ â†’ âˆ€ Xâ‚ â†’ â‹¯ â†’ âˆ€ Xâ‚™â‚‹â‚ â†’ Set
â‡’ âˆ€ Xâ‚™ â†’ Set

Given a function /type/ such as ~âˆ€ (A B : Set) â†’ B~, we cannot write a
function to swap the order of the input types, ~A~ and ~B~, since that would
require we pattern match on the function /type/ to expose its structure. As
such, we must use reflection. However, a mere switch of Î -constructors also does
not work since the underlying debrujin reference of the final ~B~ is ~var 0~, in
reference to the 0-th away bound variable ~B~, and so a simple Î -variable swap
would leave the reference as ~var 0~ which then refers to ~A~. Hence, in
general, we need to update all debrujin indices, increasing some and decreasing
others.
* COMMENT â€œContexts over Contextsâ€

Informally =xâ‚€ : Ï„â‚€, â€¦ â™ yâ‚€ : Ï„â‚€; â€¦=  denotes two contexts, ~Î“â‚ â™ Î“â‚‚~, where the
first is an elementary context and the latter is a context whose declarations
not only may use earlier ~yáµ¢~ declarations but /additionally/ may use the entirety
of the context ~Î“â‚~. We say =Î“â‚‚= is a /context over context/ =Î“â‚=.

1. A <<context over a context>>> is a dependent-type, from contexts to contexts.
2. A <<type over a dependent-context>> is an context-indexed family of sets.

#+BEGIN_SRC agda2 :tangle semantics.agda
Contextâ€² : âˆ€ {â„“} â†’ Context â„“ â†’ Set (â„“suc â„“)
Contextâ€² {â„“} Î  =  Î â†’ Set â„“

typeâ€² : âˆ€ {â„“} {Î : Context â„“} â†’ Contextâ€² Î â†’ Set (â„“suc â„“)
typeâ€² {â„“} Î“ = âˆ€ {Î¾} â†’ Î“ Î¾ â†’ Set â„“
#+END_SRC

We may index the previous â€˜smart constructorsâ€™ for contexts over contexts:
#+BEGIN_SRC agda2
âˆ… : âˆ€ {â„“} {Î : Context â„“} â†’ Contextâ€² Î
âˆ… = Î» _ â†’ âŠ¤

_â¨¾_ : âˆ€ {â„“} {Î : Context â„“} â†’ (Î“ : Contextâ€² Î) (Ï„ : typeâ€² Î“) â†’ Contextâ€² Î
Î“ â¨¾ Ï„ = Î» Î¾ â†’ Î£ Î³ âˆ¶ Î“ Î¾ â€¢ Ï„ Î³
#+END_SRC
Note: These names are not exported to the resulting Agda file, since they are
not needed.

* COMMENT *Current Status*

 I've been working on taking something as follows,
 #+begin_src agda2
do X â† Set
   e â† X
   e â‰¡ e
 #+end_src
 That is ~Set >>= Î» X â†’ X >>= Î» e â†’ e â‰¡ e~, but I want to seed it with an initial
 number ğ“ƒ which is reduced with each line. Instead of ~>>=~, let me write ~âŠ•â‚™~:
 ~(m >>= Î» x â†’ e) = ((x âˆ¶ m) âŠ•â‚™ e)~.

 Then, I'd like to have the above example desugar to ~(X : Set) âŠ•â‚ (e : X) âŠ•â‚€ (e â‰¡
 e)~ ---where the family ~âŠ•â‚™~ is right associative and we are using seed ~ğ“ƒ = 1~.

 - â© The family ~âŠ•â‚™~ serves to demarcate parameters from the remainder of a context.
 - â© ~m âŠ•â‚™ f = (Î£ m f)~ if /n = 0/ and ~m âŠ•â‚™ f = (x : m) â†’ f x~ if /n â‰  0/.

 The past week I've been trying multiple approaches to define ~Context~ and to
 defined ~âŠ•~. Here are some I've tried.

 :Hide:
 #+begin_src agda2 :tangle semantics-with-waist.agda
module semantics-with-waist.agda where

open import Level renaming (_âŠ”_ to _âŠ_; suc to â„“suc)
open import Data.Nat
open import Data.Product
Î£âˆ¶â€¢ : âˆ€ {a b} (A : Set a) (B : A â†’ Set b) â†’ Set _
Î£âˆ¶â€¢ = Î£
infix -666 Î£âˆ¶â€¢
syntax Î£âˆ¶â€¢ A (Î» x â†’ B) = Î£ x âˆ¶ A â€¢ B
 #+end_src
 :End:
 #+begin_src agda2 :tangle semantics-with-waist.agda
ContextÂ¹ = Î» â„“ â†’ Set â„“
_âŠ•Â¹_ : âˆ€ {i j} â†’ (A : ContextÂ¹ i)
               â†’ (f : A â†’ ContextÂ¹ j)
               â†’ â„• â†’ ContextÂ¹ (i âŠ j)
(Î“ âŠ•Â¹ f) â„•.zero    = Î£ x âˆ¶ Î“ â€¢ f x
(Î“ âŠ•Â¹ f) (â„•.suc n) = (x : Î“) â†’ f x
 #+end_src
 The problem here is that the number ğ“ƒ is encountered, a decision of type former
 is selected, and ğ“ƒ is discarded. It should instead be â€œpassed onâ€ to other
 declarations.

 + State monad suggests itself.

 #+begin_src agda2 :tangle semantics-with-waist.agda
ContextÂ² = Î» â„“ â†’ â„• â†’ â„• Ã— Set â„“
set = Î» {â„“} (A : ContextÂ² â„“) â†’ projâ‚‚ (A 0)
_âŠ•Â²_ : âˆ€ {i j} â†’ (A : ContextÂ² i)
               â†’ (f : set A â†’ ContextÂ² j)
               â†’ ContextÂ² (i âŠ j)
(Î“ âŠ•Â² f) â„•.zero    = 0 , Î£ x âˆ¶ (set Î“) â€¢ set (f x)
(Î“ âŠ•Â² f) (â„•.suc n) = n , ((x : set Î“) â†’ set (f x))
 #+end_src
 The problem here is the arbitrary definition of ~set~, and the fact that we cannot
 make use of ~f~'s alteration of ~ğ“ƒ~:
 | The ğ“ƒ lives outside, but it can only be altered as in ~f x ğ“ƒ~, which requires an ~x~! |

 + Lenses suggest themselves.

 #+begin_src agda2 :tangle semantics-with-waist.agda
record ContextÂ³ â„“ : Set (â„“suc â„“) where
  constructor MkCtxÂ³
  field
    setÂ³ : Set â„“
    put  : â„• â†’ setÂ³
    get  : â„•
 #+end_src

 The same problem arises: We need to alter ğ“ƒ, but cannot do so without calling ~f~
 which cannot be invoked without having an ~x~.

 Here are other routes I've tried and failed for similar reasons:
 + ~Context â„“ = â„• Ã— Set â„“~
 + ~Context â„“ = (â„• â†’ â„•) Ã— Set â„“~
 + ~_âŠ•_ : â‹¯ â†’ (f : âŠ¤ âŠ A â†’ Context â„“)~
   - In an effort to call ~f~ so as to alter ğ“ƒ /without/ providing an ~x~.
   - Failed horribly in actually use: ~(x : X) âŠ•â‚™ f x~ is means ~x~ it /not/ a value of
     ~X~ but rather a value of ~âŠ¤ âŠ X~ and so we always need to account for both
     cases.
 + I've tried other formulations of âŠ• and ~Context~, but unfortunately I kept no
   record of them. I honestly thought that their definitions were easy and that I
   was just a bit off the mark ---a week later I'm no longer certain.

 /Any guidance would be appreciated!/

* COMMENT type-annotation syntax
  type-annotation : âˆ€ {â„“} (A : Set â„“) â†’ A â†’ A
type-annotation A a = a
syntax type-annotation A a = a âˆ¶ A -- â€œghost colonâ€ \:

* COMMENT PackageFormers as Pairs of Contexts Demarcated by a Waist

As already mentioned, a PackageFormer is a pair of contexts where the latter
depends on the former.
#+BEGIN_SRC agda2 :tangle semantics.agda
record PackageFormer (â„“ : Level) : Set (â„“suc â„“) where
  constructor _â™_
  field
    parameters : Context â„“
    body       : Contextâ€² parameters
    #+END_SRC

Unsurprisingly every PackageFormer can be coerced into a context:
#+BEGIN_SRC agda2 :tangle semantics.agda
  toContext : Context â„“
  toContext = Î£ Î³ âˆ¶ parameters â€¢ body Î³
#+END_SRC

Note that the level-polymorphism is not to be facetious;
a PackageFormer is a grouping mechanism containing â€˜smallerâ€™
entities, the smallness of which is captured with the level.
- E.g., the grouping consisting of a single set is a PackageFormer at level 1.

The smart constructors from before can be lifted to this notion
---we suffix PackageFormer entities uniformly for clarity.

#+BEGIN_SRC agda2 :tangle semantics.agda
âˆ…â‚š : âˆ€ {â„“} â†’ PackageFormer â„“
âˆ…â‚š = âŠ¤ â™ (Î» _ â†’ âŠ¤)

typeâ‚š : âˆ€ {â„“} â†’ PackageFormer â„“ â†’ Set (â„“suc â„“)
typeâ‚š {â„“} (parameters â™ body) = (Î£ Î¾ âˆ¶ parameters â€¢ body Î¾) â†’ Set â„“
#+END_SRC

* COMMENT â€˜Mâ€™utally â€˜Aâ€™ssociative Sets

  The simplest thing we can do with contexts is â€˜stick them togetherâ€™,
  but a more natural operation is to extend a context with a new declaration.

  #+BEGIN_SRC agda2 :tangle semantics.agda
_âŠâ‚š_ : âˆ€ {â„“} â†’ PackageFormer â„“ â†’ PackageFormer â„“ â†’ PackageFormer â„“
(Î“â‚ â™ Î“â‚‚) âŠâ‚š (Î“â‚â€² â™ Î“â‚‚â€²) = (Î“â‚ âŠ Î“â‚â€²) â™ [ Î“â‚‚ , Î“â‚‚â€² ]

_â¨¾â‚š_ :  âˆ€ {â„“} (p : PackageFormer â„“) â†’ typeâ‚š p â†’ PackageFormer â„“
(parameters â™ body) â¨¾â‚š d = parameters â™ Î» Î¾ â†’ Î£ Î² âˆ¶ body Î¾ â€¢ d (Î¾ , Î²)
#+END_SRC


*Remark:* Contexts have a monoidal structure determined by pushouts; i.e.,
disjoint unions âŠ and the empty PackageFormer âˆ….  Indeed, we have a
mutual-associativity law ~(Î“â‚ âŠ Î“â‚‚) â¨¾ e â‰ˆ Î“â‚ âŠ (Î“â‚‚ â¨¾ e)~ ---up to some /equivalence
relation/.

*Remark:* We do not have a monoidal action since â¨¾ and âŠ do not satisfiy the
necessary coherence laws ---even worse, the right law ~(Î“ â¨¾ eâ‚) â¨¾ eâ‚‚ = Î“ â¨¾ (eâ‚ âŠ
eâ‚‚)~ and the left law ~Î“â‚ â¨¾ (Î“â‚‚ â¨¾ e) = (Î“â‚ âŠ Î“â‚‚) â¨¾ e~ are both ill-typed. Hence, we
have no hope of using âŠ/â¨¾ to trivially obtain a left/right monoidal action.

We can abstract out this structure in the hopes that a semantics for
PackageFormers can be determined via these new algebras.
:More:
In order to define a semantics, we need a notion of models in which to interpret
the syntactic PackageFormer entities.  Since left and right monoid-sets have
been ruled out, we shall formulate another species to fit the structure embedded
in PackageFormer.
:End:

Define a â€œ<<MA-Set>>â€, or a â€˜Mâ€™utually â€˜Aâ€™ssocitive structure to be a triple (â„³,
ğ’œ, Â·) where â„³ is a monoid, ğ’œ is a dependent family indexed by â„³, and ~_Â·_ : (m :
â„³) â†’ ğ’œ m â†’ â„³~ is a â€˜dependent actionâ€™ that is mutually associative with the
monoidal operation, ~(mâ‚ âŠ• mâ‚‚) Â· y â‰ˆ mâ‚ âŠ• (mâ‚‚ Â· Ï€ y)~ where ~Ï€ : ğ’œ (mâ‚ âŠ• mâ‚‚) â†’ ğ’œ mâ‚‚~
is a â€˜weakeningâ€™ rule.

+ For now, we only implement the substructure that is necessary.
+ Perhaps additional structure needs to be added, or other to be removed.

#+BEGIN_SRC agda2 :tangle semantics.agda
record MA-Set (â„“â‚ â„“â‚‚ : Level) : Set (â„“suc (â„“â‚ âŠ â„“â‚‚)) where
  field
    â„³  : Set â„“â‚
    _âŠ•_ : â„³ â†’ â„³ â†’ â„³
    Id  : â„³
    ğ’œ :  â„³ â†’ Set â„“â‚‚
    _Â·_ : (m : â„³) â†’ ğ’œ m â†’ â„³  -- Note the dependency
    -- TODO: Ommiting axioms for now; likely want a setoid structure.

open MA-Set
#+END_SRC

# - This is nearly an M-Set, but the functoriality law has been replaced by the
#   an associtivity law.

- Unlike M-Sets in which a monoids â€œactsâ€ on a set, in a MA-Set we have the
  dependent set acting on the monoid /such that/ the â€˜type of possible actionsâ€™
  is determined by monoid elements.

** Two Sanity Checks
*** Actually write a grouping mechanism
#+BEGIN_SRC agda2 :tangle semantics.agda
MonoidPF : PackageFormer (â„“suc â„“â‚€)
MonoidPF = (((âˆ…â‚š
           â¨¾â‚š Î»{ (tt , _) â†’ Set})
           â¨¾â‚š Î»{ (tt , (tt , Carrier)) â†’ Lift (â„“suc â„“â‚€) Carrier})
           â¨¾â‚š Î»{ (tt , ((tt , Carrier), lift point))
                 â†’ Lift (â„“suc â„“â‚€) (Carrier â†’ Carrier â†’ Carrier)})
           â¨¾â‚š Î»{ (tt , (((tt , Carrier) , lift point) , lift _âŠ•_))
                 â†’ Lift (â„“suc â„“â‚€) (âˆ€ {x} â†’ x âŠ• point â‰¡ x Ã— point âŠ• x â‰¡ x)}
#+END_SRC
TODO: Obtain working monad syntax.
*** PackageFormers are MA-Sets
#+BEGIN_SRC agda2 :tangle semantics.agda
PFs-are-MA-Sets : âˆ€ {â„“} â†’ MA-Set (â„“suc â„“) (â„“suc â„“)
PFs-are-MA-Sets {â„“} = record
  { â„³   = PackageFormer â„“
  ; _âŠ•_ = _âŠâ‚š_
  ; Id  = âˆ…â‚š
  ; ğ’œ   = typeâ‚š
  ; _Â·_ = _â¨¾â‚š_
  }
#+END_SRC

** MA-Sets form a Category

Given two MA-Sets (â„³, ğ’œ, Â·) and (â„³â€², ğ’œâ€², Â·â€²), define a /MA-Set homomorphism/ to be
a pair of functions /hâ‚ : â„³ â†’ â„³â€², hâ‚‚ : ğ’œ â†’ ğ’œâ€²/ that preserve the structure on each
set and respect the action; i.e.,
1. =hâ‚= is a monoid homomorphism
2. =hâ‚ (m Â· a) â‰ˆ hâ‚ m Â·â€² hâ‚‚ a=, a reasonable coherence condition.

   Notice that when ~a : ğ’œ m~ then necessarily ~hâ‚‚ a : ğ’œâ€² (hâ‚ m)~.

 #+BEGIN_SRC agda2 :tangle semantics.agda
record Hom {â„“â‚ â„“â‚‚} (Src Tgt : MA-Set â„“â‚ â„“â‚‚) : Set (â„“suc (â„“â‚ âŠ â„“â‚‚)) where
  field
    morâ‚ : â„³ Src â†’ â„³ Tgt
    morâ‚‚ : âˆ€ {m} â†’ ğ’œ Src m â†’ ğ’œ Tgt (morâ‚ m)
    pres-Id : morâ‚ (Id Src) â‰¡ Id Tgt
    pres-âŠ•  : âˆ€ {x y} â†’ morâ‚ (_âŠ•_ Src x y) â‰¡ _âŠ•_ Tgt (morâ‚ x) (morâ‚ y)
    coherence : âˆ€ {m a} â†’ morâ‚ (_Â·_ Src m a) â‰¡ _Â·_ Tgt (morâ‚ m) (morâ‚‚ a)

open Hom
 #+END_SRC

Conjectures:
1. (Id, Id) is a MA-Set homomorphism for any (â„³, ğ’œ)-set.
   - Sketch: Id is a monoid homomorphism, and the coherence
     condition is true by â‰ˆ-reflexivity.

   - Formally:
      #+BEGIN_SRC agda2 :tangle semantics.agda

id : âˆ€ {â„“â‚ â„“â‚‚} {MA : MA-Set â„“â‚ â„“â‚‚} â†’ Hom MA MA
id = record
  { morâ‚      = Î» x â†’ x
  ; morâ‚‚      = Î» x â†’ x
  ; pres-Id   = refl
  ; pres-âŠ•    = refl
  ; coherence = refl
  }
 #+END_SRC

2. MA-Set homomorphisms are closed under composition.
   - Sketch: The composition of monoid homomorphisms is again
     a homomorphism; it remains to check coherence:
    #+BEGIN_SRC haskell
     (fâ‚ âˆ˜ gâ‚) (m Â· a)
    = fâ‚ (gâ‚ (m Â· a))
    = fâ‚ (gâ‚ m Â· gâ‚‚ a)
    = fâ‚ (gâ‚ m) Â· fâ‚‚ (gâ‚‚ a)
    = (fâ‚ âˆ˜ gâ‚) m Â· (fâ‚‚ âˆ˜ gâ‚‚) a
#+END_SRC
    Whence, the coherence condition is true.

   - Formally:
    #+BEGIN_SRC agda2 :tangle semantics.agda
_âˆ˜_ : âˆ€ {â„“â‚ â„“â‚‚} {MA MB MC : MA-Set â„“â‚ â„“â‚‚} â†’ Hom MB MC â†’ Hom MA MB â†’ Hom MA MC
_âˆ˜_ {MA = MA} {MB} {MC} F G = record
  { morâ‚ = Î» x â†’ morâ‚ F (morâ‚ G x)
  ; morâ‚‚ = Î» x â†’ morâ‚‚ F (morâ‚‚ G x)
  ; pres-Id = trans (cong (morâ‚ F) (pres-Id G)) (pres-Id F)
  ; pres-âŠ• = Î» {x y} â†’ begin
      morâ‚ F (morâ‚ G (_âŠ•_ MA x y))          â‰¡âŸ¨ cong (morâ‚ F) (pres-âŠ• G) âŸ©
      morâ‚ F (_âŠ•_ MB (morâ‚ G x) (morâ‚ G y)) â‰¡âŸ¨ pres-âŠ• F âŸ©
      _âŠ•_ MC (morâ‚ F (morâ‚ G x)) (morâ‚ F (morâ‚ G y)) âˆ
  ; coherence = Î» {m a} â†’ begin
      morâ‚ F (morâ‚ G (_Â·_ MA m a)) â‰¡âŸ¨ cong (morâ‚ F) (coherence G) âŸ©
      morâ‚ F (_Â·_ MB (morâ‚ G m) (morâ‚‚ G a)) â‰¡âŸ¨ coherence F âŸ©
      _Â·_ MC (morâ‚ F (morâ‚ G m)) (morâ‚‚ F (morâ‚‚ G a)) âˆ }
 #+END_SRC

3. MA-Sets form a category.

The goal is then to show that MA-Sets have PackageFormer as an initial object!
---Initial semantics!

* COMMENT ğŸš§  Other Rndm Ideas
#+BEGIN_SRC agda2 :tangle semantics.agda

-- one-fun : âˆ€ {b â„“} {ğ‘© : Set â„“ â†’ Set b} â†’ Î£ A âˆ¶ Set â„“ â€¢ ğ‘© A  -- â€œShape of given contextâ€
--                                       â†’ (A : Set â„“) â†’ ğ‘© A
-- one-fun = {!!}
--
{-
Î£ (Set _â„“_511)
(Î» Carrier â†’
   Î£ (Carrier â†’ Carrier â†’ Carrier)
   (Î» _âŠ•â‚_ â†’
      Î£ Carrier (Î» one â†’ Î£ Carrier (Î» two â†’ two â‰¡ (one âŠ•â‚ one)))))
-}

--------------------------------------------------------------------------------

{-
-- â€œA -âŸ¨ n âŸ©â†’ Bâ€ â‰ˆ A â†’ â‹¯ â†’ A â†’ B with n+1 many Aâ€™s.
_-âŸ¨_âŸ©â†’_ : âˆ€ {a b} (A : Set a) (n : â„•) (B : Set b) â†’ Set (a âŠ b)
A -âŸ¨ 0 âŸ©â†’ B     = A â†’ B
A -âŸ¨ suc n âŸ©â†’ B = A â†’ A -âŸ¨ n âŸ©â†’ B

Prod : âˆ€ â„“ â†’ â„• â†’ â„• â†’ Set (â„“suc â„“)
Prod â„“ m â„•.zero    = âŠ¤
Prod â„“ m (â„•.suc n) = Î£ A âˆ¶ Set â„“ â€¢ Prod â„“ m n
-}
-- waist3 : âˆ€ {â„“ n} â†’ Prod (3 + n) â†’ Prod n

{-
â€µ_ : âˆ€ {â„“} â†’ Set â„“ â†’ PackageFormer â„“
â€µ typ = âˆ…â‚š â¨¾â‚š Î» _ â†’ typ

MonoidPFâ€² : PackageFormer {!!}
MonoidPFâ€² = do carrier â† â€µ Set
               point  â† â€µ Set
               âŠ¤
-}

#+END_SRC

#+BEGIN_SRC agda2
infixr 4 _â¸´_ -- \,
_â¸´_ : âˆ€ {â„“ a b} {A : Set a} {B : A â†’ Set b}
    â†’ (x : A)
    â†’ B x
    â†’ Lift â„“ (Î£ x âˆ¶ A â€¢ B x)
a â¸´ b = lift (a , b)
#+END_SRC

** COMMENT Explorations with =Contextâ€²=
#+BEGIN_SRC agda2 :tangle semantics.agda
_>>=_ : âˆ€ {â„“} {Î± Î² : Context â„“}
      â†’ Contextâ€² Î±
      â†’ (Î± â†’ Contextâ€² Î²)
      â†’ Contextâ€² Î²
_>>=_ {Î± = Î} Î“ f = Î» Î½ â†’ Î£ Î¾ âˆ¶ Î â€¢ f Î¾ Î½

â€µ_ : âˆ€ {â„“} (C : Set â„“) â†’ Contextâ€² C
â€µ typ = Î» _ â†’ typ

-- Not everything lives at the same level, so a helpfer to lift things.
â€µâ€µ_ : âˆ€ {a â„“} (C : Set â„“) â†’ Contextâ€² {â„“ âŠ a} (Lift a C)
â€µâ€µ_ {a} typ = Î» _ â†’ Lift a typ
#+END_SRC

** COMMENT Monad Syntax ğŸš§                                :construction_site:

 -- _â–·_ : âˆ€ {â„“} â†’ (P : PackageFormer â„“) â†’ Declaration (toContext P) â†’ PackageFormer â„“
 -- (parameters â™ body) â–· d@(n âˆ¶ Ï„ â‰” Î´) = parameters â™ Î» p â†’ body p âŠ Just d
* COMMENT Here are some laws that allow one to reach the claimed canonical form:
  1. `:waist w âŸ´ :kind k â‰ˆ :kind k âŸ´ :waist w`

     Hence, we can always ensure `waist` appears before `kind`.

  2. More generally, `f âŸ´ g â‰ˆ g âŸ´ f` whenever `f` and `g` are â€˜disjointâ€™; whence
     â¨¾-extensions also share this property with `:waist` and `:kind`.

     Thus we can always ensure â¨¾-extensions appear before `:waist` and `:kind` clauses.

  3. `fâ‚ âŸ´ fâ‚‚ â‰ˆ fâ‚‚` for `fáµ¢` both being either `:waist` clauses or `:kind` clauses.

     Hence, there will always be only one `:waist` and one `:kind` clause.

  Of-course these rules only permit the constructions `âŸ´, :waist, :kind` and
  â¨¾-extensions. E.g., if the hammer `:alter-elements` is admitted, then little
  can be said since, say, one may re-arrange â¨¾-extension elements according to
  their waist and kind, as is the case of Agda modules, wherein items above
  the waist *cannot* have definitional clauses.

* COMMENT Normal Forms ğŸš§                                 :construction_site:

  Ignoring the concrete syntax, every PackageFormer has a canonical flattened form:
#+begin_example haskell
LHS = âˆ… â¨¾ nâ‚€ âˆ¶ Ï„â‚€ â‰” dâ‚€ â¨¾ â‹¯ â¨¾ nâ‚˜ âˆ¶ Ï„â‚˜ â‰” dâ‚˜ âŸ´ :waist ğ“Œ âŸ´ :kind ğ“€
#+end_example

The â€œâ¨¾â€ is read â€œextended-byâ€ and the definitional clauses $dâ‚–$ may involve any
of the names $náµ¢$ for $i < k$.  It is an a *right* action:
#+begin_example haskell
_â¨¾_ : PackageFormer â†’ Declaration â†’ PackageFormer
#+end_example

# Where the semigroup structure on declarations is determined
# by sequential composition: If ~eáµ¢~ are declarations, then ~eâ‚€â¨¾â‹¯â¨¾eâ‚™~
# is a â€˜singleâ€™ declaration.

The canonical form suggests that /PackageFormers are triples/
consisting of a context, a number, and a tag.

Instead of $âˆ… â¨¾ nâ‚€ âˆ¶ Ï„â‚€ â‰” dâ‚€ â¨¾ â‹¯ â¨¾ nâ‚˜ âˆ¶ Ï„â‚˜ â‰” dâ‚˜ âŸ´ :waist ğ“Œ âŸ´ :kind ğ“€$ let us
write $eâ‚€ â¨¾ â€¦ â¨¾ e_ğ“Œ â™_{ğ“€} e_{ğ“Œ+1}â¨¾ â€¦ eâ‚˜$.
- When the kind ğ“€ is uninteresting, or may be arbitrary, we shall omit it from
  the notation altogether. Likewise for the separator â€˜â™â€™.

We may now define a composition operation on PackageFormers, via
pushout or disjoint union; e.g., $(Î“â‚ â™ Î“â‚‚) âŠ (Î“â‚â€² â™ Î“â‚‚â€²) = Î“â‚â€³ â™ Î“â‚‚â€³$ where Î“áµ¢â€³
is catenation of Î“áµ¢ and Î“áµ¢â€², in some fixed chosen order.

We may also define a dual form of extension, known as â€œsnocâ€ when â¨¾ is read
â€œconsâ€.
#+begin_src haskell
_â¸µ_ : Declaration â†’ PackageFormer â†’ PackageFormer
e â¸µ (Î“â‚ â™ Î“â‚‚) = ((âˆ… â¨¾ e) âŠ Î“â‚) â™ Î“â‚‚
#+end_src

In the informal notation of contexts of type theory, the three operations â¸µ, â¨¾,
âŠ are denoted â€œ,â€.

*** PackageFormers and derived =_âŠ_=
 #+BEGIN_SRC agda2 :tangle semantics.agda
record PackageFormer : Setâ‚ where
  constructor _â™_
  field
    parameters : Context
    body       : Contextâ€² parameters

_âŠâ‚š_ : PackageFormer â†’ PackageFormer â†’ PackageFormer
(Î“â‚ â™ Î“â‚‚) âŠâ‚š (Î“â‚â€² â™ Î“â‚‚â€²) = (Î“â‚ âŠ Î“â‚â€²) â™ [ Î“â‚‚ , Î“â‚‚â€² ]
 #+END_SRC

* COMMENT Meta-Primitives as Functions ğŸš§                 :construction_site:

With a notation and understanding of what a PackageFormer
consists of, we are in a position to provide a semantics
for the meta-primitives.

# :waist, :kind, â–·, and âŸ´ are syntactic constructors.

First, ~waist~ is lifted from a syntactic construct to a function operation on
PackageFormers as follows.
#+begin_src haskell
_waist_ : PackageFormer â†’ â„• â†’ PackageFormer
(Î“â‚ â™ Î“â‚‚) waist 0       = âˆ… â™ (Î“â‚ âŠ Î“â‚‚)
(Î“â‚ â™ Î“â‚‚) waist (n + 1) = (head Î“â‚) â— (tail Î“â‚ â™ Î“â‚‚) waist n

where head : PackageFormer â†’ Maybe Declaration
      head âˆ… = Nothing
      head (eâ‚, â€¦, eâ‚™ â™ Î“â‚‚) = Just eâ‚

      tail : PackageFormer â†’ PackageFormer
      tail âˆ… = âˆ…
      tail (eâ‚ â— Î“) = Î“
#+end_src

That is, if $Î“ = eâ‚€â¨¾ â‹¯â¨¾ eâ‚˜$, ignoring the separator, then
$Î“ waist n â‰ˆ eâ‚€â¨¾ â‹¯â¨¾ eâ‚™ â™ eâ‚™â‚Šâ‚â¨¾ â‹¯â¨¾ eâ‚˜$. That is, =waist= introduces
a partition in a context. Operationally, only the associated number
component of a PackageFormer has been altered.

* COMMENT Shallow Embedding Approach :typechecks:

In the setup below, it seems using the context approach can sometimes be easier
than using the Î» approach, even though they are essentially the same.
Intuitively:
| What doing? | Easier to use |
|-------------+---------------|
| Reasoning   | Context       |
| Programming | Functions     |

** Imports
 #+BEGIN_SRC agda2
module pf where

open import Level renaming (zero to â„“zero; suc to â„“suc; _âŠ”_ to _âŠ_)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl)
open import Data.Nat
open import Data.Unit
open import Data.Empty
open import Data.Bool
open import Data.List
open import Data.List.Membership.Propositional
open import Data.List.Relation.Unary.Any using (here; there)
open import Relation.Nullary using (yes; no)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.String using (String) renaming (_==_ to _==â‚›_; _â‰Ÿ_ to _â‰Ÿâ‚›_; _++_ to _++â‚›_)
open import Data.Product using (Î£ ; projâ‚ ; projâ‚‚ ; _Ã—_ ; _,_)

 #+END_SRC

** Syntax Declarations
 #+BEGIN_SRC agda2

Name = String

Î£âˆ¶â€¢ : âˆ€ {a b} (A : Set a) (B : A â†’ Set b) â†’ Set _
Î£âˆ¶â€¢ = Î£

infix -666 Î£âˆ¶â€¢
syntax Î£âˆ¶â€¢ A (Î» x â†’ B) = Î£ x âˆ¶ A â€¢ B

infixr 10 Î 
syntax Î  A (Î» x â†’ B) = Î  x âˆ¶ A â€¢ B

infix 9 _âŠ¢Term_

 #+END_SRC
** Contexts, types, and terms

   Contexts are types, level-indexed types are functions, Ï„-terms are functions taking
   the context and yielding a value.

  #+BEGIN_SRC agda2
PackageFormer : (i : Level) â†’ Set (â„“suc i)
PackageFormer i = Set i
 #+END_SRC

*** types
  Next, object-level universes are implemented using meta-level universes.
  - Note: =Î“ âŠ¢Type ğ’¾  â‰¡  Î“ âŠ¢Term (ğ’° ğ’¾)=.

  #+BEGIN_SRC agda2
_âŠ¢Type_ :  âˆ€ {i} â†’ PackageFormer i â†’ (j : Level) â†’ Set (i âŠ â„“suc j)
Î“ âŠ¢Type ğ’¾ = Î“ â†’ Set ğ’¾

ğ’° : âˆ€ {i} {Î“ : PackageFormer i} (j : Level) â†’ Î“ âŠ¢Type (â„“suc j)
ğ’° j = Î» Î³ â†’ Set j
  #+END_SRC
*** terms
  #+BEGIN_SRC agda2
_âŠ¢Term_ : âˆ€ {i j} â†’ (Î“ : PackageFormer i) â†’ Î“ âŠ¢Type j â†’ Set (i âŠ j)
Î“ âŠ¢Term Ï„ = (Î³ : Î“) â†’ Ï„ Î³
  #+END_SRC

  After all, a classical context ~xâ‚ : Ï„â‚, â€¦, xâ‚™ : Ï„â‚™ âŠ¢ e : Ï„~ only /asserts/ =e : Ï„=
  /provided/ =xáµ¢ : Ï„áµ¢=, and so the latter is a function of the former! Indeed, as the
  Î»-introduction rule shows, *all contexts are the humble function*
  ---e.g., with church encodings, we have that algebraic data-types are also
  functions, the eliminators.
  + MA: Perhaps with this neato observation, I should simply focus on functions?

*** context constructors

  The empty context is the unit type and context extension is interpreted using Î£-types.
  The identity of dependent products is the unit type, whence it denotes the empty PackageFormer.

 #+BEGIN_SRC agda2
Îµ : PackageFormer â„“zero
Îµ = âŠ¤

_â–·_ : âˆ€ {i j} (Î“ : PackageFormer i) â†’ Î“ âŠ¢Type j â†’ PackageFormer (i âŠ j)
Î“ â–· A = Î£ Î³ âˆ¶ Î“ â€¢ A Î³

  #+END_SRC
** Coercisions and Î 

 #+BEGIN_SRC agda2
weaken : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type k}
       â†’ Î“ âŠ¢Type j â†’ (Î“ â–· A) âŠ¢Type j
weaken Ï„ (Î³ , a) = Ï„ Î³

pf-refl : âˆ€ {i j} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j}
        â†’ (Î“ â–· A) âŠ¢Term weaken A
pf-refl = projâ‚‚

Î  : âˆ€ {i j k} {Î“ : PackageFormer i} (A : Î“ âŠ¢Type j) (B : (Î“ â–· A) âŠ¢Type k)
  â†’ Î“ âŠ¢Type (j âŠ k)
Î  A B = Î» Î³ â†’ âˆ€ (a : A Î³) â†’ B (Î³ , a)

_â‡’_ : âˆ€ {i j k} {Î“ : PackageFormer i} (A : Î“ âŠ¢Type j) (B : Î“ âŠ¢Type k)
    â†’ Î“ âŠ¢Type (j âŠ k)
A â‡’ B = Î  A (weaken B)

 #+END_SRC
** =lam= and =app=
 Abstraction and application are just Currying & Uncurrying
 #+BEGIN_SRC agda2
lam : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j} {B : (Î“ â–· A) âŠ¢Type k}
    â†’ (Î“ â–· A) âŠ¢Term B  â†’  Î“ âŠ¢Term (Î  A B)
lam g = Î» Î³ â†’ Î» a â†’ g (Î³ , a)

app : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j} {B : (Î“ â–· A) âŠ¢Type k}
      â†’  Î“ âŠ¢Term (Î  A B)  â†’ (Î“ â–· A) âŠ¢Term B
app g = Î»{(Î³ , a) â†’ g Î³ a}
 #+END_SRC

 Here are other forms of function application.
 #+BEGIN_SRC agda2
cutâ€² : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j} {B : Î“ âŠ¢Type k}
      â†’  (Î“ â–· A) âŠ¢Term weaken B
      â†’  Î“       âŠ¢Term A
      â†’  Î“       âŠ¢Term B
cutâ€² f a = Î» Î³ â†’ f (Î³ , a Î³)

_on_ : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j}
      â†’ (Î“ â–· A) âŠ¢Type k
      â†’  Î“ âŠ¢Term A
      â†’  Î“ âŠ¢Type k
f on a = Î» Î³ â†’ f (Î³ , a Î³)

cut : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j} {B : (Î“ â–· A) âŠ¢Type k}
      â†’  (Î“ â–· A) âŠ¢Term B
      â†’  (a : Î“  âŠ¢Term A)
      â†’  Î“       âŠ¢Term (B on a)
cut f a = Î» Î³ â†’ f (Î³ , a Î³)

_$_ : âˆ€ {i j k} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j} {B : (Î“ â–· A) âŠ¢Type k}
      â†’ Î“ âŠ¢Term (Î  A B)
      â†’ (a : Î“ âŠ¢Term A)
      â†’ Î“ âŠ¢Term (B on a)
_$_ g = Î» a Î³ â†’ g Î³ (a Î³)
 #+END_SRC

** Example terms!

 #+BEGIN_SRC agda2
â€µid : Îµ âŠ¢Term Î  A âˆ¶ ğ’° â„“zero â€¢ let Aâ€² = Î» _ â†’ projâ‚‚ A -- weakening.
                              in (Aâ€² â‡’ Aâ€²) Îµ
â€µid = lam (lam projâ‚‚)
 #+END_SRC

 Let's try to show that =pf-refl= really is the identity function, up to isomorphism.
 #+BEGIN_SRC agda2
â€µidâ‚‚ : âˆ€ {i j} {Î“ : PackageFormer i} {A : Î“ âŠ¢Type j}
     â†’ Î“ âŠ¢Term A â‡’ A
â€µidâ‚‚ = lam pf-refl
 #+END_SRC

 Neato! Progress, finally (à¸‡à² _à² )à¸‡
* COMMENT Old Approach using Deep Embedding :incomplete:holes:

  #+begin_example agda2
module pf where
#+end_example
** Imports
#+begin_example agda2
open import Relation.Binary.PropositionalEquality using (_â‰¡_; refl)
open import Data.Nat
open import Data.Unit
open import Data.Empty
open import Data.Bool
open import Data.List
open import Data.List.Membership.Propositional
open import Data.List.Relation.Unary.Any using (here; there)
open import Relation.Nullary using (yes; no)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.String using (String) renaming (_==_ to _==â‚›_; _â‰Ÿ_ to _â‰Ÿâ‚›_; _++_ to _++â‚›_)
open import Data.Product using (Î£ ; projâ‚ ; projâ‚‚ ; _Ã—_ ; _,_)
Name = String
#+end_example
** Fixity & syntax declarations
#+begin_example agda2
infix 11 eq
syntax eq Ï„ l r  =  l â€µâ‰¡ r âˆ¶ Ï„

infixr 10 _â€µâ†’_ â€µâˆ€
syntax â€µâˆ€ Ï„ (Î» Î· â†’ Î³) = Î  Î· âˆ¶ Ï„ â€¢ Î³ -- â€œZ-notationâ€

-- infixl 9 _âˆ¶_ _âˆ¶_â‰”_
infixl 9 _âˆ¶_

infixl 5 _extended-by_

Î£âˆ¶â€¢ : âˆ€ {a b} (A : Set a) (B : A â†’ Set b) â†’ Set _
Î£âˆ¶â€¢ = Î£

infix -666 Î£âˆ¶â€¢
syntax Î£âˆ¶â€¢ A (Î» x â†’ B) = Î£ x âˆ¶ A â€¢ B
#+end_example
** Declarations for mutually recursive DTL concepts
#+begin_example agda2
data PF : Set                          -- Syntax of PackageFormers; i.e., contexts
data _âŠ¢Type (Î“ : PF) : Set             -- Types in context
type-names-of : PF â†’ List Name
-- types-of : (Î“ : PF) â†’ List (Î“ âŠ¢Type)   -- The collection of types mentioned in a context
record _âŠ¢constituent (Î“ : PF) : Set    -- The type of terms
data _âŠ¢Term:_ (Î“ : PF) : Î“ âŠ¢Type â†’ Set -- Terms in context
#+end_example
** PackageFormer syntax
#+begin_example agda2
data PF where
  empty : PF
  _extended-by_ : (Î“ : PF) â†’ Î“ âŠ¢constituent â†’ PF
#+end_example
** â€œdeclarations in contextâ€
#+begin_example agda2
record _âŠ¢constituent Î“ where
  -- constructor _âˆ¶_â‰”_
  constructor _âˆ¶_
  inductive
  field
    name     : Name
    type     : Î“ âŠ¢Type
    -- equation : Maybe (Î“ âŠ¢Term: type)
    -- Ommitted for brevity

open _âŠ¢constituent

{-
_âˆ¶_ : âˆ€ {Î“} â†’ Name â†’ Î“ âŠ¢Type â†’ Î“ âŠ¢constituent
x âˆ¶ Ï„ = x âˆ¶ Ï„ â‰” nothing
-}
#+end_example
** Decision procedure for tedious proofs
#+begin_example agda2
-- Soundness: Let's construct a decision procedure that actually provides tedious proofs.
-- This is used in the ADT â€œ_âŠ¢Typeâ€.

data Error : String â†’ Set where

present? : Name â†’ List Name â†’ Set
present? Î· []       = Error ("The type â€œ" ++â‚› Î· ++â‚› "â€ is not in the parent context!")
present? Î· (n âˆ· ns) with Î· ==â‚› n
...| true  = âŠ¤
...| false = present? Î· ns

soundness : âˆ€ {Î· ns} â†’ present? Î· ns â†’ Î· âˆˆ ns
soundness {Î·} {n âˆ· ns} p with Î· â‰Ÿâ‚› n
...| yes q = here q
...| no Â¬q = there (soundness p)

tedious-example : "C" âˆˆ ("A" âˆ· "B" âˆ· "C" âˆ· "D" âˆ· [])
tedious-example = there (there (here refl))

improved-example : "C" âˆˆ ("A" âˆ· "B" âˆ· "C" âˆ· "D" âˆ· [])
improved-example = soundness tt

-- Uncomment to see an error since c is not in the list.
-- useful-error-msg : "c" âˆˆ ("A" âˆ· "B" âˆ· "C" âˆ· "D" âˆ· [])
-- useful-error-msg = soundness tt
#+end_example
** â€œtypes in contextâ€
#+begin_example agda2
{-
  Ï„ âˆ·= Set       â€œuniverse of typesâ€
     | Ï„ â†’ Ï„     â€œfunction typesâ€
     | Î±         â€œatomic types mentioned in the contextâ€
     | e â‰¡ d     â€œterm equality in contextâ€
-}

data _âŠ¢Type Î“ where

  â€µSet  : Î“ âŠ¢Type                                        -- type of small types

  -- â€µâˆ€ : (Ï„ : Î“ âŠ¢Type) (body : Î“ âŠ¢Term: Ï„ â†’ Î“ âŠ¢Type) â†’ Î“ âŠ¢Type -- Pi types, we fail the positivity checker.
  -- In the spirit of gradual typing, we use a weaker form: The assumed term losses any possible definiens, equations.
  â€µâˆ€ : (Ï„ : Î“ âŠ¢Type) (body : (Î· : Name) â†’ (Î“ extended-by Î· âˆ¶ Ï„) âŠ¢Type) â†’ Î“ âŠ¢Type

  _â€µâ†’_ : Î“ âŠ¢Type â†’ Î“ âŠ¢Type â†’ Î“ âŠ¢Type -- function type; making this derived requires a weak form of commuatvity at the context level

  -- variable case; the name must be mentioned in Î“
  â€µ_   : (Î· : Name) {{_ : present? Î· (type-names-of Î“)}} â†’ Î“ âŠ¢Type

  eq : (Ï„ : Î“ âŠ¢Type) (l r : Î“ âŠ¢Term: Ï„) â†’ Î“ âŠ¢Type

{-
_â€µâ†’_ : {Î“ : PF} â†’ Î“ âŠ¢Type â†’ Î“ âŠ¢Type â†’ Î“ âŠ¢Type -- function type
Ï„ â€µâ†’ Î³ = Î  _ âˆ¶ Ï„ â€¢ weaken Î³
-}
#+end_example
** =type-names-of=
#+begin_example agda2
type-names-of empty = []
type-names-of (pf extended-by nameâ‚ âˆ¶ â€µSet) = nameâ‚ âˆ· type-names-of pf
type-names-of (pf extended-by _) = type-names-of pf
#+end_example
** A hierarchy of dependent weakening rules
#+begin_example agda2
{-
weaken1 : âˆ€ {Î“ e} â†’ Î“ âŠ¢Type â†’ (Î“ extended-by e) âŠ¢Type

insert-before-last : âˆ€ {Î“ Î· e Ï„} â†’ (Î“ extended-by Î· âˆ¶ Ï„) âŠ¢Type
                                 â†’ (Î“ extended-by e extended-by Î· âˆ¶ weaken1 Ï„) âŠ¢Type

insert-before-second-last : âˆ€ {Î“ Î·â‚ Î·â‚‚ Ï„â‚ Ï„â‚‚ e}
 â†’ (Î“ extended-by               Î·â‚ âˆ¶         Ï„â‚ extended-by Î·â‚‚ âˆ¶  Ï„â‚‚) âŠ¢Type
 â†’ (Î“ extended-by e extended-by Î·â‚ âˆ¶ weaken1 Ï„â‚ extended-by Î·â‚‚ âˆ¶ insert-before-last Ï„â‚‚) âŠ¢Type
insert-before-second-last Ï„ = {!!}

insert-before-last â€µSet = â€µSet
insert-before-last (â€µâˆ€ Ï„ body) = Î  Î· âˆ¶ insert-before-last Ï„ â€¢  insert-before-second-last (body Î·)
insert-before-last (Ï„ â€µâ†’ Ï„â‚) = {!!}
insert-before-last (â€µ Î·) = {!!}
insert-before-last (eq Ï„ l r) = {!!}

weaken1 â€µSet        = â€µSet
weaken1 (â€µâˆ€ Ï„ body) = Î  Î· âˆ¶ weaken1 Ï„ â€¢ insert-before-last (body Î·)
weaken1 (Ï„ â€µâ†’ Ï„â‚)   = {!!}
weaken1 (â€µ Î·)       = {!!}
weaken1 (eq Ï„ l r)  = {!!}
-}

{- Other weakening rules
weaken-cons : âˆ€ {Î“ e} â†’ Î“ âŠ¢constituent â†’ (Î“ extended-by e) âŠ¢constituent

weaken-mid : âˆ€ {Î“ pre post new} â†’ (Î“ extended-by pre extended-by post) âŠ¢Type
                                â†’ (Î“ extended-by pre extended-by new extended-by weaken-cons post) âŠ¢Type
-}
#+end_example
** How many â€˜argumentsâ€™ does a type have?
#+begin_example agda2
{-

arity : âˆ€ {Î“} â†’ Î“ âŠ¢Type â†’ â„•
arity â€µSet        = 0
arity (â€µâˆ€ Ï„ body) = 1 + arity (body "_") -- Hack; possible since names are strings.
arity (Ï„ â€µâ†’ Ï„â‚)   = 1 + arity Î³  -- E.g., Î± â€µâ†’ (Î² â€µâ†’ Î³) has 2 arguments.
arity (â€µ Î·)       = {!!} -- Need to consider its type in Î“
arity (eq Ï„ l r)  = 0
-}
#+end_example
** The subparts of a type expression
#+begin_example agda2
{--

-- An alias for _â‰¡_; a singleton type
data JustThis {A : Set} : A â†’ Set where
  this : (a : A) â†’ JustThis a

-- If arity Ï„ = 0 then âŠ¤ else the type of the first argument.
type-head : âˆ€ {Î“} â†’ Î“ âŠ¢Type â†’ Set
type-head â€µSet      = âŠ¤
type-head (Ï„ â€µâ†’ _)  = JustThis Ï„
type-head _  = âŠ¤

-- If arity Ï„ = 0 then âŠ¤ else the type of the first argument.
type-tail : âˆ€ {Î“} â†’ Î“ âŠ¢Type â†’ Î“ âŠ¢Type
type-tail Ï„ = {!!}
-}
#+end_example
** â€œterms in contextâ€
#+begin_example agda2
data _âŠ¢Term:_ Î“ where

  -- TODO: â€œx must be fresh for Î“â€; variable case
  â€µ_  : {Ï„ : Î“ âŠ¢Type} (x : Name) â†’ Î“ âŠ¢Term: Ï„

  -- curried function application
  -- _$_ : (f : Î“ âŠ¢constituent) â†’ type-head (type f) â†’ Î“ âŠ¢Term: type-tail (type f) -- Omitted for brevity
#+end_example
** Examples
#+begin_example agda2
Type : PF
Type = empty extended-by "Carrier" âˆ¶ â€µSet

Indistinguishable : PF
Indistinguishable = Type extended-by
                         "blind" âˆ¶ Î  ğ“ âˆ¶ â€µ "Carrier" â€¢ Î  ğ“‡ âˆ¶ â€µ "Carrier" â€¢ â€µ ğ“ â€µâ‰¡ â€µ ğ“‡ âˆ¶ â€µ "Carrier"

Pointed : PF
Pointed = Type extended-by "ğŸ™" âˆ¶ â€µ "Carrier"
-- Typos such as forgetting the final letter produce type-checking errors:
-- The type â€œCarrieâ€ is not in the parent context!
-- Pointed = Type extended-by "ğŸ™" âˆ¶ â€µ "Carrie"

Magma : PF
Magma = Type extended-by "_Â·_" âˆ¶ â€µ "Carrier" â€µâ†’ â€µ "Carrier" â€µâ†’ â€µ "Carrier"
#+end_example
** Semantics
#+begin_example agda2
terms : PF â†’ List (Î£ Î“ âˆ¶ PF â€¢ Î“ âŠ¢constituent)
terms empty = []
terms (p extended-by x) = terms p ++ [ p , x ]

Type-names-of : PF â†’ Set
Type-names-of Î“ = Î£ Î· âˆ¶ Name â€¢ present? Î· (type-names-of Î“)

semâ‚œ : âˆ€ {Î“} â†’ (Type-names-of Î“ â†’ Setâ‚) â†’ Î“ âŠ¢Type â†’ Setâ‚‚
semâ‚‘ : âˆ€ {Î“} {Ï„ : Î“ âŠ¢Type} (Ïƒ : Type-names-of Î“ â†’ Setâ‚) â†’ Î“ âŠ¢Term: Ï„ â†’ Setâ‚ -- semâ‚œ Ïƒ Ï„  â‡  free variables are just placeholders for the types they represent

semâ‚‘ {Î“} {Ï„} Ïƒ (â€µ x) = {!semâ‚œ Ïƒ Ï„!}

open import Level using (Lift)

semâ‚œ Ïƒ â€µSet          = Setâ‚
semâ‚œ Ïƒ (â€µâˆ€ Ï„ body)   = âˆ€ (x : semâ‚œ Ïƒ Ï„) â†’ âŠ¥ -- TODO
semâ‚œ Ïƒ (Ï„ â€µâ†’ Î³)      = semâ‚œ Ïƒ Ï„ â†’ semâ‚œ Ïƒ Î³
semâ‚œ Ïƒ (â€µ_ Î· {{p}})  = Lift _ (Ïƒ (Î· , p))
semâ‚œ Ïƒ (eq Ï„ l r)    = semâ‚‘ Ïƒ l â‰¡ semâ‚‘ Ïƒ r  -- ARGH: semâ‚‘ must yield Setâ‚ so it can be used in semâ‚œ !!!!!!  -- JC, what do?

{-
present?-tn : âˆ€ {Î· Î“ e} â†’   present? Î· (type-names-of (Î“ extended-by e))
                          â‰¡ (if   (Î· ==â‚› name e)
                             then âŠ¤
                             else present? Î· (type-names-of Î“))
present?-tn {Î·} {Î“} {e} with type-names-of (Î“ extended-by e) | Î· ==â‚› name e
present?-tn {Î·} {Î“} {e} | [] | false = {!!}
present?-tn {Î·} {Î“} {e} | [] | true = {!!}
present?-tn {Î·} {Î“} {e} | x âˆ· xs | t = {!!}


weaken-present? : âˆ€ {Î· Î“ e} â†’ present? Î· (type-names-of Î“)
                            â†’ present? Î· (type-names-of (Î“ extended-by e))
weaken-present? {Î·} {Î“ = Î“} p with type-names-of Î“ | p
weaken-present? {Î·} {Î“ = Î“} p | x âˆ· xs | q with Î· ==â‚› x
weaken-present? {Î·} {Î“} p | x âˆ· xs | q | false = {!!}
weaken-present? {Î·} {Î“} p | x âˆ· xs | q | true = {!!}
-}

weaken : âˆ€ {Î“ e}  â†’ Î“ âŠ¢Type â†’ (Î“ extended-by e) âŠ¢Type
weaken â€µSet        = â€µSet
weaken (â€µâˆ€ Ï„ body) = {!!}
weaken (Ï„ â€µâ†’ Î³)   = weaken Ï„ â€µâ†’ weaken Î³
weaken (â€µ_ Î· {{p}})       = â€µ_ Î· {{{!!}}}
weaken (eq Ï„ l r)  = {!!}

termsâ€² : (Î“ : PF) (Ïƒ : Î“ âŠ¢Type â†’ Set) â†’ List (Î£ Î“â€² âˆ¶ PF â€¢ Set Ã— Î“â€² âŠ¢constituent)
termsâ€² empty Ïƒ = []
termsâ€² (p extended-by e@(Î· âˆ¶ Ï„)) Ïƒ = termsâ€² p (Î» x â†’ Ïƒ (weaken x)) ++ [ p , Ïƒ (weaken Ï„) , e ] -- termsâ€² p {!!} ++ [ p , {!!} , {!x!} ]
-- terms p ++ [ p , x ]


{-
sem : (Î“ : PF) (Ïƒ : Î“ âŠ¢Type â†’ Set) (Î± : (Î· : Name) â†’ Î£ T âˆ¶ Set â€¢ T) â†’ Set
sem p Ïƒ Î± with terms p
...| [] = âŠ¥
...| (_ , Î· âˆ¶ Ï„) âˆ· xs = {!!}
  where -- function patching
        Î±â€² : Name â†’ Î£ T âˆ¶ Set â€¢ T
        Î±â€² n = if n ==â‚› Î· then (Ïƒ {!!}) , {!!} else Î± n
-}

#+end_example
** Further experiments
#+begin_example agda2
{-
-- TODO: Add support for catenating PFs.
--
-- _âŒ¢_ : PF â†’ PF â†’ PF
-- l âŒ¢ empty = l
-- l âŒ¢ (r extended-by x) = (l âŒ¢ r) extended-by {! need a weakening rule!}
--

monoid : PF
monoid = empty extended-by "Carrier" âˆ¶ â€µSet
               extended-by "_Â·_" âˆ¶ â€µ "Carrier" â€µâ†’ â€µ "Carrier" â€µâ†’ â€µ "Carrier"
               extended-by "ğŸ™" âˆ¶ â€µ "Carrier"
               extended-by "assoc" âˆ¶ {!!}
-}
  #+end_example
