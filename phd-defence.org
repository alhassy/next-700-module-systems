# C-c C- e l O

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "phd-defense.pdf"))
# M-x org-beamer-export-to-pdf
#+TITLE: Do-it-yourself Module Systems
#+subtitle: Extending Dependently-Typed Languages to Implement \\ Module System Features In The Core Language
#+AUTHOR: Musa Al-hassy
#+date: April 28, 2021
#+OPTIONS: H:2 toc:nil d:nil
# +ATTR_LATEX: :width 0.9\paperwidth :height 0.85\paperheight
#

# ("" "titletoc" nil) ‚áí causes problems!
# (pop org-latex-default-packages-alist)

* Beamer Setup :ignore:
# +BEAMER_THEME: Rochester
# +BEAMER_THEME: Copenhagen
# +BEAMER_THEME: default
# +BEAMER_THEME: metropolis [numbering=fraction, progressbar=frametitle, titleformat=smallcaps]
#+BEAMER_THEME: metropolis

#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col)


#+latex_header: \institute{\vspace{2em}McMaster University,
#+latex_header: %1280 Main St. West,
#+latex_header: Hamilton, Ontario, Canada
#+latex_header: % L8S 4K1,
#+latex_header: \\
#+latex_header: \textsf{alhassy@gmail.com}
#+latex_header: }
#+latex_header:

#+BEAMER_COLOR_THEME: structure[RGB={87,83,170}]
#+LATEX_HEADER: \hypersetup{colorlinks, linkcolor=black, urlcolor=blue}
#+LATEX: \AtBeginSection{\frame{\sectionpage}}
#+LATEX_HEADER: \setbeamersize{text margin left=3mm,text margin right=3mm}
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}
#+latex_header: \usepackage{picture,xcolor,multicol}

# Needs to be before \begin{document}, hence in a latex-header.  Add numbers to
# slides.
#
#+LATEX_HEADER: \setbeamertemplate {footline}{\color{gray}\hspace{49.7em}\insertframenumber\strut\quad}
# LATEX_HEADER: \setbeamertemplate{footline}[frame number]

# HACK: minted, like other verbatim, environments is ``fragile'' wrt to beamer.
# Hence all frames with code may behave erracticly if not marked fragile.
#
# \begin{frame}[fragile]{titleHere}
#
#+LATEX_HEADER: \usepackage{minted}
# https://armkeh.github.io/unicode-sty/
#+LATEX_HEADER: \usepackage{\string~"/unicode-sty/unicode"}
#+latex_header: \usepackage{newunicodechar}
#+latex_header: \newunicodechar{‚Ä≤}{'}
#+latex_header: \newunicodechar{‚®æ}{\ensuremath{\fatsemi}}
#+latex_header: \newunicodechar{‚áå}{\ensuremath{\rightleftharpoons}}

# Removing the red box that appears in "minted" when using unicode.
# Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+LATEX_HEADER: \makeatother

# to use super tiny fonts, or large ones; e.g., \scalebox{.2}{supertiny}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{lipsum}
#+BEGIN_EXPORT latex
\newcommand\Wider[2][3em]{%
\makebox[\linewidth][c]{%
  \begin{minipage}{\dimexpr\textwidth+#1\relax}
  \raggedright#2
  \end{minipage}%
  }%
}
#+END_EXPORT


#+latex_header: \usepackage{color}
#+latex_header: \definecolor{DarkGreen}{rgb}{0,0.6,0}
#+latex_header: \definecolor{DarkRed}{rgb}{0.6,0,0}
#+latex_header: \definecolor{DarkBlue}{rgb}{0,0,0.6}
#+latex_header: \definecolor{grey}{rgb}{0.5,0.5,0.5}
#+latex_header: \definecolor{DarkGrey}{rgb}{0.4,0.4,0.4}
#+latex_header: \definecolor{DGreen}{rgb}{0,0.4,0.2}


#+latex_header: \newunicodechar{‚ü¥}{\ensuremath{\kern0.28em\oplus\kern-1.53em\longrightarrow}}
#+latex_header: % U+27F4: RIGHT ARROW WITH CIRCLED PLUS

* What is the problem?
** Overview

With a bit of reflection, we can obtain

#+ATTR_REVEAL: :frag (appear)
1. a uniform, and *practical*, syntax for both /records/ (semantics) and /termtypes/ (syntax)
2. on-the-fly unbundling; and,
3. *mechanically* obtain data structures from theories
   \pause
   #+latex: \begin{small}
   | ‚Äòtheory‚Äô œÑ     | ‚Äòdata structure‚Äô ~termtype œÑ~ |
   |----------------+-----------------------------|
   | pointed set    | ùüô                           |
   | dynamic system | ‚Ñï                           |
   | monoid         | tree skeletons              |
   | collections    | lists                       |
   | graphs         | (homogeneous) pairs         |
   | actions        | infinite streams            |
   #+latex: \end{small}

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(.5,5){\colorbox{yellow}{\Large The combinators presented in the thesis were guided}}
\put(.5,4.4){\colorbox{yellow}{\Large \emph{not} by theortetial concerns on the algebraic nature}}
\put(.5,3.8){\colorbox{yellow}{\Large of containers but rather on the}}
\put(.5,3.2){\colorbox{yellow}{\Large \textbf{practical needs of actual users working in DTLs}}}
\end{picture}
#+end_export

** COMMENT Research Question
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

#+begin_center
*Use a dependently-typed language (DTL) to implement the ‚Äòmissing‚Äô module system
features directly inside the language*
#+end_center

\pause
-----
#+LaTeX: \setminted[haskell]{fontsize=\scriptsize, breaklines}
#+begin_src haskell +n 0
-- Terms: Expressions and Types
e, œÑ ::= Œ±          -- base types and constants
    | Type·µ¢       -- ‚Äútype of types‚Äù; Universe of types at level i : ‚Ñï
    | ‚Ñï             -- ‚ÄúLevels‚Äù for the type hierarchy
    | Œ† x : œÑ ‚Ä¢ œÑ   -- ‚ÄúPi‚Äù, dependent-function type
    | Œ£ x : œÑ ‚Ä¢ œÑ   -- ‚ÄúSigma‚Äù, dependent-sum type
    | x             -- Variable
    | e e           -- Application; Œ†-elimination
    | Œª x : œÑ ‚Ä¢ e   -- Abstraction; Œ†-introduction
    | (e , e)       -- Pairing; Œ£-introduction
    | fst e | snd e -- Projections; Œ£-elimination
    | Fix ùë≠         -- Fixpoints for ùë≠ : Type·µ¢ ‚Üí Type·µ¢

-- Abbreviation: Provided Œ≤ does not refer to variable ‚Äò_‚Äô,
(Œ± ‚Üí Œ≤) :=  (Œ† _ : Œ± ‚Ä¢ Œ≤)
 #+end_src
#+latex: \vspace{-1em}
| DTL Syntax   |
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}
** COMMENT Ubiquitous *mechanical* module constructions are *out of reach* of DTL module systems...

   # [[file:~/thesis-proposal/patterns.png]]

#+latex_header: \usepackage{smartdiagram}
#+latex: \vspace{-2em}
#+begin_export latex
\begin{center}
\smartdiagram[constellation diagram]{
 {\footnotesize Monoids}
,{\footnotesize Monoids \emph{with} carrier \texttt{C}}
,{\footnotesize Homomorphisms, products, duals}
,{\footnotesize Signature (Tree skeletons)}
,{\footnotesize Pointed Magma} % (‚ÄúExclusion‚Äù)
,{\footnotesize Terms} %  (Trees with variables)
,{\footnotesize Monoids \emph{over} a setoid}
%,Universal Algebra constructions
,{\scriptsize Monoids \emph{with} carrier \texttt{C} and operation $\oplus$}
% %
% Build a program,Set up,Run,Analyze,Modify~/\\ Add,Check
}

\end{center}
#+end_export

:Hide:

\begin{figure}
\centering
 \makebox[\textwidth]{\includegraphics[width=.9\paperwidth, height=.75\paperheight]{~/thesis-proposal/images/patterns.png}}
\end{figure}

\pause
#+begin_export latex
  % X-axis to the right and Y-axis upwards
  \setlength{\unitlength}{1cm}
  \begin{picture}(0,0)(0,0)
   \put(8.5,8.5){\underline{\textbf{\emph{PL Research is about}}}}
   \put(8.5,8.0){\underline{\textbf{\emph{getting free stuff:}}}}
   \put(8.5,7.5){\underline{\textbf{\emph{We can get a lot!}}}}
\end{picture}
#+end_export

:End:

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "committee.pdf"))
** What is /in a/ monoid?

People work with monoids at various levels of *exposure* ‚Ä¶

\pause

+ ‚ÄúLet ùë¥ be a *monoid*, ‚Ä¶‚Äù
  \vspace{1em}\pause
+ ‚ÄúGiven a *monoid over* ‚Ñï, ‚Ä¶‚Äù
    \vspace{1em}\pause
+ ‚ÄúConsider */the/ monoid* (‚Ñï, +), ‚Ä¶‚Äù
  - (Unique viz proof irrelevance.)
    \vspace{1em}\pause
+ ‚ÄúConsider */the/ monoid* (‚Ñï, +, 0), ‚Ä¶‚Äù

 #+begin_src agda :tangle yes :exports none
open import Relation.Binary.PropositionalEquality
#+end_src

** ‚ÄúA monoid consists of a collection ~Carrier~, an operation, ‚Ä¶‚Äù?
   :PROPERTIES:
   :BEAMER_OPT: fragile
   :END:

#+begin_src agda :tangle yes
record Monoid‚ÇÄ  : Set‚ÇÅ  where
  field  Carrier : Set
         _‚®æ_     :  Carrier ‚Üí Carrier ‚Üí Carrier
         Id      :  Carrier
         lid     : ‚àÄ {x} ‚Üí   Id ‚®æ x  ‚â°  x
         rid     : ‚àÄ {x} ‚Üí   x ‚®æ Id  ‚â°  x
         assoc   : ‚àÄ {x y z} ‚Üí  (x ‚®æ y) ‚®æ z  ‚â°  x ‚®æ (y ‚®æ z)
#+end_src

| Use-case: The category of monoids. |

** ‚ÄúA monoid over a given collection ~Carrier~ and operation ~_‚®æ_~ is given by ensuring there is a selected point ...‚Äù?
   :PROPERTIES:
   :BEAMER_OPT: fragile
   :END:

#+begin_src agda :tangle yes
record Monoid‚ÇÅ
         (Carrier : Set)   : Set  where
  field
         _‚®æ_     :  Carrier ‚Üí Carrier ‚Üí Carrier
         Id      :  Carrier
         lid     : ‚àÄ {x} ‚Üí   Id ‚®æ x  ‚â°  x
         rid     : ‚àÄ {x} ‚Üí   x ‚®æ Id  ‚â°  x
         assoc   : ‚àÄ {x y z} ‚Üí  (x ‚®æ y) ‚®æ z  ‚â°  x ‚®æ (y ‚®æ z)
#+end_src

| Use-case: Sharing the carrier type |

** Or ‚Ä¶ ?

#+begin_src agda :tangle yes
record Monoid‚ÇÇ
         (Carrier : Set)
         (_‚®æ_     :  Carrier ‚Üí Carrier ‚Üí Carrier) : Set where
  field
         Id      :  Carrier
         lid     : ‚àÄ {x} ‚Üí   Id ‚®æ x  ‚â°  x
         rid     : ‚àÄ {x} ‚Üí   x ‚®æ Id  ‚â°  x
         assoc   : ‚àÄ {x y z} ‚Üí  (x ‚®æ y) ‚®æ z  ‚â°  x ‚®æ (y ‚®æ z)
#+end_src

| Use-case: The additive monoid on the ‚Ñïatural numbers |

** Or ‚Ä¶ ?

#+begin_src agda :tangle yes
record Monoid‚ÇÉ
         (Carrier : Set)
         (_‚®æ_     :  Carrier ‚Üí Carrier ‚Üí Carrier)
         (Id      :  Carrier)      : Set  where
  field
         lid     : ‚àÄ {x} ‚Üí   Id ‚®æ x  ‚â°  x
         rid     : ‚àÄ {x} ‚Üí   x ‚®æ Id  ‚â°  x
         assoc   : ‚àÄ {x y z} ‚Üí  (x ‚®æ y) ‚®æ z  ‚â°  x ‚®æ (y ‚®æ z)
 #+end_src

\vspace{1em}
/Notice that the keyword src_emacs-lisp[:exports code]{field} is ‚Äúgoing down‚Äù
the *waist* each time./

** Tom Hales ---Kepler Conjecture / Flyspeck

 #+begin_quote
 Structures are meaninglessly parameterized from a mathematical perspective.
 [‚Ä¶]  That is, what is bundled cannot be later opened up as a parameter. [...]
 This means that library designers are forced to take a conservative approach
 and expose as a parameter anything that any user might reasonably want exposed,
 because once it is bundled, it is not coming back.

     \hfill ---[[https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/][A Review of the Lean Theorem Prover]], *2018-09-18*
 #+end_quote

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(2,5){\colorbox{yellow}{\Large ‚áí This is a problem we are solving!}}

\pause
\put(2,4.4){\colorbox{yellow}{\Large ‚áí A \emph{recent} problem}}

\pause
\put(2,3.8){\colorbox{yellow}{\Large ‚áí \emph{\textbf{\alert{‚ÄúThe Unbundling Problem‚Äù}}}}}

\end{picture}
#+end_export

** Does this /actually/ happen?

\pause
#+latex: \centerline{\alert{\large Yes!}}

\pause
Examples:
+ Agda's Standard Library,
+ RATH-Agda,
+ agda-categories

It's not just dependently-typed languages...
\pause
+ Arend
+ Haskell's Standard Library

** What are the adjacent problems?

\alert{Maintence of relationships} when we ‚Äúbring down the waist‚Äù ---the
position of the src_emacs-lisp[:exports code]{field} keyword.

\pause

#+begin_src haskell
                       Monoid‚ÇÄ  ‚âÖ  Œ£ C : Set ‚Ä¢ Monoid‚ÇÅ C
#+end_src
\pause
#+begin_src haskell
              Monoid‚ÇÅ C  ‚âÖ  Œ£ ùë¥ : Monoid‚ÇÄ ‚Ä¢ Monoid‚ÇÄ.Carrier ùë¥ ‚â° C
#+end_src
\pause
#+latex: \centerline{These coercions can be derived \textbf{mechanically}}

\pause What about other /natural constructions/ on mathematical theories (and the
associated relationships)?
+ Extensions? ---‚ÄúA group is a monoid with an extra‚Ä¶‚Äù \pause
+ Exclusions? ---‚ÄúA semigroup is a non-unital monoid.‚Äù  \pause
+ Termtypes?  ---‚ÄúLists are just the free /monoid over/ a given type.‚Äù \pause
+ Pushouts: Name-relevant unions? ---‚ÄúA monoid is a pointed set along with a
  semigroup *such that* they share the same carrier.‚Äù \pause
+ Numerous other constructions from Category Theory

** Which items should be fields, which parameters?

 + The src_haskell[:exports code]{Monoid·µ¢} family showed some
   combinations of items selected as parameters.  \pause

 + There are other combinations of what is to be exposed and hidden, for
   applications that we might never think of. \pause

 + Providing always the most-general parameterisation produces *awkward* library
   interfaces!

\pause

_Proposed Solution_:

 + Commit to no particular formulation and allow on-the-fly ``unbundling''
   - This is the /converse/ of instantiation

     \pause
 + The ‚ÄúEmacs editor tactic‚Äù src_emacs-lisp[:exports code]{PackageFormer}
 + The ‚ÄúAgda library‚Äù src_haskell[:exports code]{Context}

** TODO COMMENT Roadmap
   There are 3 ways to see the problem....
* The src_emacs-lisp[:exports code]{PackageFormer} Prototype: A useful experimentation tool

** Evidence that the theory ‚Äòactually works‚Äô

#+begin_center
*Prototype* with an editor extension /then/ incorporate *lessons learned* into a DTL
library!
#+end_center

#+begin_export latex
\begin{figure}
\centering
 \makebox[\textwidth]{\includegraphics[width=.5\paperwidth, height=.4\paperheight]{~/thesis-proposal/images/Paper0_MousingOverLarge.png}}
\end{figure}
#+end_export

|Generated code displayed on hover|

** /A Language Feature to Unbundle Data at Will/ (GPCE '19)

 #+ATTR_LATEX: :width 0.75\paperwidth :height 0.75\paperheight
 [[file:~/thesis-proposal/images/gpce19.png]]

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(2,4){\colorbox{yellow}{\Large ‚áí Influenced Agda's Standard Library}}

\end{picture}
#+end_export

** COMMENT Prototype ‚áí *Lisp Metaprogramming*, ASTs, Untyped, String Manipulation, Agda Generation, Macro DSL
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

# +ATTR_LATEX: :height 0.75\paperheight
# [[file:~/thesis-proposal/lisp.png]]
#+latex: \centering
#+LaTeX: \setminted[common-lisp]{fontsize=\tiny, breaklines}
#+latex: \begin{minipage}[t]{0.95\linewidth}
#+BEGIN_SRC emacs-lisp
{-lisp
(ùí± record‚ÇÅ (discard-equations nil)
 = "Reify a variational as an Agda ‚Äúrecord‚Äù.
    Elements with equations are construed as
    derivatives of fields  ---the elements
    without any equations--- by default, unless
    DISCARD-EQUATIONS is provided with a non-nil value."
  :kind record
  :alter-elements
    (Œª es ‚Üí
      (thread-last es
      ;; Keep or drop eqns depending on ‚Äúdiscard-equations‚Äù
      (--map
        (if discard-equations
            (map-equations (Œª _ ‚Üí nil) it)
            it))
      ;; Unless there's equations, mark elements as fields.
      (--map (map-qualifier
        (Œª _ ‚Üí (unless (element-equations it)
               "field")) it)))))
-}

{-700
Monoid-record-with-definitional-extensions  =  MonoidP record‚ÇÅ
Monoid-record-with-extensions-as-fields     =  MonoidP record‚ÇÅ :discard-equations t
-}
#+END_SRC
#+LaTeX: \setminted[common-lisp]{fontsize=\footnotesize, breaklines}
#+latex:   \end{minipage}

** *The* Definition of a Monoid

#+begin_src haskell
  PackageFormer MonoidP : Set‚ÇÅ where
    Carrier : Set
    _‚®æ_       : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí   (x ‚®æ y) ‚®æ z  ‚â°  x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x} ‚Üí   Id ‚®æ x  ‚â°  x
    rightId : ‚àÄ {x} ‚Üí   x ‚®æ Id  ‚â°  x
#+end_src

\pause

| We regain the different candidates by applying *variationals*. |

#+begin_parallel :bar t

 #+ATTR_LATEX: :options fontsize=\tiny
#+begin_src haskell
  Monoid‚ÇÄ  =  MonoidP record
  Monoid‚ÇÅ  =  MonoidP record ‚ü¥ unbundled 1
  Monoid‚ÇÇ  =  MonoidP record ‚ü¥ unbundled 2
  Monoid‚ÇÉ  =  Monoid‚ÇÄ‚Ä≤ exposing "Carrier; _‚®æ_; Id"
#+end_src

\ldots and we can do more

#+columnbreak:

\pause Monoid syntax!
 #+ATTR_LATEX: :options fontsize=\tiny
#+begin_src haskell
  Tree = MonoidP termtype-with-variables "Carrier"
‚âÖ
  data Tree (Var : Set) : Set where
    inj : Var ‚Üí Tree Var
    _‚®æ_   : Tree Var ‚Üí Tree Var ‚Üí Tree Var
    Id  : Tree Var
#+end_src

#+end_parallel

\pause
| *_Linear_* effort in number of variations                      |

** *Pushout* unions, intersections, extensions, views, ‚Ä¶

# +ATTR_LATEX: :height 0.75\paperheight
# [[file:~/thesis-proposal/pushouts.png]]

#+LaTeX: \setminted[common-lisp]{fontsize=\tiny, breaklines}
#+BEGIN_SRC emacs-lisp
(ùí± union pf (renaming‚ÇÅ "") (renaming‚ÇÇ "") (adjoin-retract‚ÇÅ t) (adjoin-retract‚ÇÇ t)
 = "Union the elements of the parent PackageFormer with those of
    the provided PF symbolic name, then adorn the result with two views:
    One to the parent and one to the provided PF.

    If an identifer is shared but has different types, then crash."
   :alter-elements (Œª es ‚Üí
     (let* ((p (symbol-name 'pf))
            (es‚ÇÅ (alter-elements es renaming renaming‚ÇÅ :adjoin-retract nil))
            (es‚ÇÇ (alter-elements ($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì p) renaming renaming‚ÇÇ :adjoin-retract nil))
            (es‚Ä≤ (-concat es‚ÇÅ es‚ÇÇ)))

      ;; Ensure no name clashes!
      (loop for n in (find-duplicates (mapcar #'element-name es‚Ä≤))
            for e = (--filter (equal n (element-name it)) es‚Ä≤)
            unless (--all-p (equal (car e) it) e)
            do (-let [debug-on-error nil]
              (error "%s = %s union %s \n\n\t\t ‚û© Error: Elements ‚Äú%s‚Äù conflict!\n\n\t\t\t%s"
                     $ùëõùëéùëöùëí $ùëùùëéùëüùëíùëõùë° p (element-name (car e)) (s-join "\n\t\t\t" (mapcar #'show-element e)))))

   ;; return value
   (-concat
       es‚Ä≤
       (when adjoin-retract‚ÇÅ (list (element-retract $ùëùùëéùëüùëíùëõùë° es :new es‚ÇÅ :name adjoin-retract‚ÇÅ)))
       (when adjoin-retract‚ÇÇ (list (element-retract p     ($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì p) :new es‚ÇÇ :name adjoin-retract‚ÇÇ)))))))
#+END_SRC
#+LaTeX: \setminted[common-lisp]{fontsize=\footnotesize, breaklines}

#+latex: \centerline{\alert{Combinators are motivated from existing, real-world, DTL libraries!}}

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(.5,6){\colorbox{yellow}{\Large Framework built around \textbf{5 metaprimitives}}}
\put(.5,5.4){\colorbox{yellow}{\Large ‚Ü¶ Lisp Metaprogramming, untyped string manipulation, }}
\put(.5,4.8){\colorbox{yellow}{\Large ‚Ü¶ Macro DSL, Agda generation }}

\pause
\put(.5,2.8){\colorbox{yellow}{\Large ‚áí The rest are ‚Äúuser-defined‚Äù with a bit of Lisp}}
\end{picture}
#+end_export

** Generated 200+ theories using the Lisp metaprogramming framework ---the MathScheme library

# +ATTR_LATEX: :width 0.75\paperwidth :height 0.75\paperheight
# [[file:~/thesis-proposal/200+specs.png]]

#+LaTeX: \setminted[haskell]{fontsize=\tiny, breaklines}
#+BEGIN_SRC haskell
AdditiveMagma            = Magma renaming‚Ä≤ "_*_ to _+_"
LeftDivisionMagma        = Magma renaming‚Ä≤ "_*_ to _‚ï≤_"
RightDivisionMagma       = Magma renaming‚Ä≤ "_*_ to _‚ï±_"
LeftOperation            = MultiCarrier extended-by‚Ä≤ "_‚ü´_ : U ‚Üí S ‚Üí S"
RightOperation           = MultiCarrier extended-by‚Ä≤ "_‚ü™_ : S ‚Üí U ‚Üí S"
IdempotentMagma          = Magma extended-by‚Ä≤ "*-idempotent : ‚àÄ (x : U) ‚Üí (x * x) ‚â° x"
IdempotentAdditiveMagma  = IdempotentMagma renaming‚Ä≤ "_*_ to _+_"
SelectiveMagma           = Magma extended-by‚Ä≤ "*-selective : ‚àÄ (x y : U) ‚Üí (x * y ‚â° x) ‚äé (x * y ‚â° y)"
SelectiveAdditiveMagma   = SelectiveMagma renaming‚Ä≤ "_*_ to _+_"
PointedMagma             = Magma union‚Ä≤ PointedCarrier
PointedùüòMagma            = PointedMagma renaming‚Ä≤ "e to ùüò"
AdditivePointed1Magma    = PointedMagma renaming‚Ä≤ "_*_ to _+_; e to ùüô"
LeftPointAction          = PointedMagma extended-by "pointactLeft  :  U ‚Üí U; pointactLeft x = e * x"
RightPointAction         = PointedMagma extended-by "pointactRight  :  U ‚Üí U; pointactRight x = x * e"
CommutativeMagma         = Magma extended-by‚Ä≤ "*-commutative  :  ‚àÄ (x y : U) ‚Üí  (x * y) ‚â° (y * x)"
CommutativeAdditiveMagma = CommutativeMagma renaming‚Ä≤ "_*_ to _+_"
PointedCommutativeMagma  = PointedMagma union‚Ä≤ CommutativeMagma ‚ü¥ :remark "over Magma"
AntiAbsorbent            = Magma extended-by‚Ä≤ "*-anti-self-absorbent  : ‚àÄ (x y : U) ‚Üí (x * (x * y)) ‚â° y"
SteinerMagma             = CommutativeMagma union‚Ä≤ AntiAbsorbent ‚ü¥ :remark "over Magma"
Squag                    = SteinerMagma union‚Ä≤ IdempotentMagma ‚ü¥ :remark "over Magma"
PointedSteinerMagma      = PointedMagma union‚Ä≤ SteinerMagma ‚ü¥ :remark "over Magma"
UnipotentPointedMagma    = PointedMagma extended-by‚Ä≤ "unipotent  : ‚àÄ (x : U) ‚Üí  (x * x) ‚â° e"
Sloop                    = PointedSteinerMagma union‚Ä≤ UnipotentPointedMagma
#+END_SRC
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(2,6){\colorbox{yellow}{\Large Terse, readable, specifications}}
\put(2,5.4){\colorbox{yellow}{\Large ‚Ü¶ Useful, typecheckable, dauntingly large code }}

\pause
\put(2,4){\colorbox{yellow}{\Large 200+ \textbf{one-line} specs}}
\put(2,3.4){\colorbox{yellow}{\Large \hspace{1em} ‚Ü¶ 1500+ lines of typechecked Agda}}
\pause
\put(2,2.8){\colorbox{yellow}{\Large ‚áí 750\% efficiency savings}}

\put(2,1.4){\colorbox{yellow}{\Large Useful engineering result}}
\end{picture}
#+end_export

** Primary Lessons Learned


\pause
+ Waist :: The difference between *field* and *parameter* is an illusion ---as is that of *input*
  and *output* when one considers relations rather than deterministic functions.
  \pause \vspace{1em}

+ Termtypes :: Record types (Œ£), type classes (Œ†¬πŒ£), and algebraic data types
  (ùí≤) are all valid *semantics of contexts* ---which are ‚Äúname : type =
  optional-definition‚Äù tuples.
  \pause \vspace{1em}

+ Pragmatic :: We have an extendable, \pause expressive, \pause and efficient
  interface based on a small kernel, \pause that is immediately usable, \pause
  as an editor extension; \pause what about an in-language (DTL) library?

:ignore:

-----

User-defined variational: /Drop definitions when lifting fields into parameters./
# [[file:~/thesis-proposal/waist.png]]
#+LaTeX: \setminted[common-lisp]{fontsize=\tiny, breaklines}
#+BEGIN_SRC emacs-lisp
(ùí± unbundling n
 = "Turn the first N elements into parameters to the PackageFormer.

    Any elements above the waist line have their equations dropped."
   :waist n
   :alter-elements (Œª es ‚Üí
     (-let [i 0]
       (--graph-map (progn (incf i) (<= i n))
                    (map-equations (-const nil) it)
                    es))))
#+END_SRC
#+LaTeX: \setminted[common-lisp]{fontsize=\footnotesize, breaklines}
:end:

** COMMENT How Does This Work?

 + Currently implemented  as an ‚Äúeditor tactic‚Äù meta-program
 + Using the ‚Äúdefault IDE‚Äù of Agda Emacs
 + Implementation is an *extensible* library built on top of 5 meta-primitives
 + Generated Agda file is automatically imported into the current file
 + Special-purpose IDE support
 +  Menus, highlighting new syntax, fold away 700-blocks, discard annotations.

** COMMENT The Language of Variationals

   $$\mathsf{Variational} \quad ‚âÖ \quad (\mathsf{PackageFormer} ‚Üí \mathsf{PackageFormer})$$

 \begin{code}
   id                       :  Variational
   _‚ü¥_                      :  Variational ‚Üí Variational ‚Üí Variational
   record                   :  Variational
   termtype                 :  String ‚Üí Variational
   termtype-with-variables  :  String ‚Üí Variational
   unbundled                :  ‚Ñï ‚Üí Variational
   exposing                 :  List Name ‚Üí Variational
 \end{code}

** COMMENT Library Design

 + Goals:
   + Reusability
   + Generality
   + (Mathematical) ‚ÄúNaturality‚Äù

 + Result: *Conflict of Interests:*

    For a record type bundling up items that ‚Äúnaturally‚Äù belong together:
    + Which parts of that record should be red:parameters?
    + Which parts should be green:fields?

* The Unbundling Problem ---in Agda

# The *Context* Library: Solving the unbundling problem
** COMMENT Monoid ---‚ÄúUntyped Composition‚Äù

- We have things, called src_haskell[:exports code]{Carrier},
- ‚Ä¶ and we want to ‚Äòcombine‚Äô them via some operation src_haskell[:exports code]{_‚®æ_}
- ‚Ä¶ which has a ‚Äòdo nothing‚Äô value src_haskell[:exports code]{Id}.

** COMMENT Typeclass approach, as in Haskell

#+begin_src haskell
record MonoidOn (Carrier : Set) : Set
 where
  field
    _‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier
    Id  : Carrier
    leftId : ‚àÄ x ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ x ‚Üí x ‚®æ Id ‚â° x
    assoc   : ‚àÄ x y z ‚Üí  (x ‚®æ y) ‚®æ z
                       ‚â°  x ‚®æ (y ‚®æ z)
#+end_src

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
open MonoidOn {{...}}
#+end_src

** COMMENT Examples
#+ATTR_REVEAL: :frag (appear)
- Programs and sequential (or parallel) composition
- *Numbers and addition (or multiplication)*
- Writing words on a page ---i.e., lists and catenation

** What is ‚Äúthe‚Äù monoid on the natural numbers?

Haskell's solution is to make *two isomorphic copies* of numbers since typeclass
instance search relies on /unique/ instances for the typeclass parameters.

#+begin_quote
Some types can be viewed as a monoid in more than one way, e.g. both addition
and multiplication on numbers. In such cases we often define newtypes and make
those instances of Monoid, e.g. Sum and Product.
---[[https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Monoid.html#t:Monoid][Hackage Data.Monoid]]
#+end_quote

#+begin_center
#+begin_src haskell
                       Sum Œ± ‚âÖ Œ±  {- and -} Product Œ± ‚âÖ Œ±
#+end_src
For src_haskell[:exports code]{Num Œ±} they have different monoid instances.
#+end_center

** COMMENT Additive?
#+begin_src haskell
instance
  ‚Ñï‚Çä : MonoidOn ‚Ñï
  ‚Ñï‚Çä = record { _‚®æ_     = _+_
              ; Id      = 0
              ; leftId  = +-identityÀ°
              ; rightId = +-identity ≥
              ;  assoc  = +-assoc }
#+end_src

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
ex : ‚àÄ (m n : ‚Ñï) ‚Üí m ‚®æ n  ‚â°  n ‚®æ m
ex = +-comm
#+end_src

#+ATTR_REVEAL: :frag (appear)
 src_haskell[:exports code]{__‚®æ__} is determined to be src_haskell[:exports
code]{_+_}by *instance search* $\star$

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
likewise : ‚àÄ (m : ‚Ñï) ‚Üí m ‚®æ Id ‚â° m
likewise = rightId
#+end_src

** COMMENT ‚Ä¶ or Multiplicative?
#+begin_src haskell
instance
  ‚Ñï‚Çì : MonoidOn ‚Ñï
  ‚Ñï‚Çì = record { _‚®æ_     = _*_
              ; Id      = 1
              ; leftId  = *-identityÀ°
              ; rightId = *-identity ≥
              ; assoc   = *-assoc }
#+end_src


#+begin_src haskell
whoops : ‚àÄ {m : ‚Ñï} ‚Üí m ‚®æ Id ‚â° m
whoops = {!!}
#+end_src


$\star$ ‚Ñï‚Çä and ‚Ñï‚Çì are both candidates! *No unique solution!* $\star$

** Alternate Solution to Multiple Monoid Instance Problem

\pause
*Start* with /fully bundled/ src_haskell[:exports code]{Monoid}
\pause
*then* /expose fields as parameters/ *on the fly*.

\pause
#+begin_center
#+latex: {\Large How?}

\pause
*Reflection!*
#+end_center
\pause
- Unfortunately, current mechanism cannot touch
  src_haskell[:exports code]{record}-s /directly/.
- But every record is a Œ£-type...

** Records as Œ† ∑Œ£-types  ---Partitioned Contexts

- Instead of the nice /syntactic sugar/
  #+begin_src haskell :tangle no
record R (Œµ¬π : œÑ¬π) ‚ãØ (Œµ ∑ : œÑ ∑) : Set
  where
    field
      Œµ ∑‚Å∫¬π : œÑ ∑‚Å∫¬π
      ‚ãÆ
      Œµ ∑‚Å∫·µè : œÑ ∑‚Å∫·µè
#+end_src

\pause
- Use a more raw form  ---/eek!/
  #+begin_src haskell :tangle no
R  : Œ† Œµ¬π   : œÑ¬π  ‚Ä¢ ‚ãØ ‚Ä¢ Œ† Œµ ∑   : œÑ ∑ ‚Ä¢ Set
R  ‚âÖ  Œª Œµ¬π  : œÑ¬π  ‚Ä¢ ‚ãØ ‚Ä¢ Œª Œµ ∑   : œÑ ∑
    ‚Ä¢ Œ£ Œµ ∑‚Å∫¬π : œÑ ∑‚Å∫¬π ‚Ä¢ ‚ãØ ‚Ä¢ Œ£ Œµ ∑‚Å∫·µè : œÑ ∑‚Å∫·µè
    ‚Ä¢ ùüô
#+end_src

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)
\pause
\put(8.3,1.8){\colorbox{yellow}{\Large ‚áê ‚Äúparameters‚Äù}}
\pause
\put(8.3,1.3){\colorbox{yellow}{\Large ‚áê ‚Äúfields‚Äù}}
\pause
\put(2.5,0){\colorbox{yellow}{\Large We say $w$ is the \textbf{‚Äúwaist‚Äù}}}
\end{picture}
#+end_export

# E.g., src_haskell[:exports code]{MonoidOn} is a Œ†¬πŒ£ type

** COMMENT Shucks, the Unbundling Problem Strikes Again

If we encode a record as a Œ† ∑Œ£ type, what if we want
to /instantiate, fix,/ a field ---instead of a parameter?

#+ATTR_REVEAL: :frag (appear)
We thus need a way to *lift parameters to fields*!
#+ATTR_REVEAL: :frag (appear)
( Teaser: src_haskell[:exports code]{Œ†‚ÜíŒª} ! )

** A *Pragmatic* Notation ---Contexts

#+begin_src haskell :exports none
open import Level renaming (_‚äî_ to _‚äç_; suc to ‚Ñìsuc; zero to ‚Ñì‚ÇÄ)
open import Data.Product
open import Context -- Gives us Œ£‚à∂‚Ä¢, Œ†‚à∂‚Ä¢, >>=, ‚ü®‚ãØ‚ü©
#+end_src

#+ATTR_REVEAL: :frag (appear)
0. ‚ÄúContexts‚Äù are exposure-indexed types
   #+begin_src haskell :tangle no
Context = Œª ‚Ñì ‚Üí (waist : ‚Ñï) ‚Üí Set ‚Ñì
#+end_src
   \pause
1. The ‚Äúempty context‚Äù is the unit type
   #+begin_src haskell :tangle no
End : ‚àÄ {‚Ñì} ‚Üí Context ‚Ñì
End {‚Ñì} = Œª _ ‚Üí ùüô {‚Ñì}
#+end_src

   \pause
2. src_haskell[:exports code]{do}-notation!
   #+begin_src haskell :tangle no
_>>=_ : ‚àÄ {a b}
      ‚Üí (Œì : Context a)
      ‚Üí (‚àÄ {n} ‚Üí Œì n ‚Üí Context b)
      ‚Üí Context (a ‚äç b)
(Œì >>= f) zero    = Œ£ Œ≥ ‚à∂ Œì 0 ‚Ä¢ f Œ≥ 0
(Œì >>= f) (suc n) = Œ† Œ≥ ‚à∂ Œì n ‚Ä¢ f Œ≥ n
#+end_src

\pause
#+begin_center
The *‚ÄúDIY‚Äù* lies at ~>>=~, permitting Œ£, Œ†, ùí≤, ~let~, ‚Ä¶ !
#+end_center

** Example Context ---Monoids

 #+begin_src haskell
Monoid : Context ‚Ñì‚ÇÅ
Monoid = do Carrier ‚Üê Set
            _‚®æ_     ‚Üê (Carrier ‚Üí Carrier ‚Üí Carrier)
            Id      ‚Üê Carrier
            leftId  ‚Üê ‚àÄ (x : Carrier) ‚Üí x ‚®æ Id ‚â° x
            rightId ‚Üê ‚àÄ (x : Carrier) ‚Üí Id ‚®æ x ‚â° x
            assoc   ‚Üê ‚àÄ (x y z) ‚Üí (x ‚®æ y) ‚®æ z  ‚â°  x ‚®æ (y ‚®æ z)
            End {‚Ñì}
#+end_src

** COMMENT =Context= Agda Library ‚áí *Pragmatic Interface*

   # [[file:~/thesis-proposal/pragmattic.png]]

#+latex: \centering
#+latex: \begin{minipage}[t]{0.95\linewidth}
#+begin_src haskell
Monoid : ‚àÄ ‚Ñì ‚Üí Context (‚Ñìsuc ‚Ñì)
Monoid ‚Ñì = do Carrier ‚Üê Set ‚Ñì
              _‚äï_    ‚Üê (Carrier ‚Üí Carrier ‚Üí Carrier)
              Id      ‚Üê Carrier
              leftId  ‚Üê ‚àÄ {x : Carrier} ‚Üí x ‚äï Id ‚â° x
              rightId ‚Üê ‚àÄ {x : Carrier} ‚Üí Id ‚äï x ‚â° x
              assoc   ‚Üê ‚àÄ {x y z} ‚Üí (x ‚äï y) ‚äï z  ‚â°  x ‚äï (y ‚äï z)
              End {‚Ñì}
#+end_src
#+latex:   \end{minipage}

\pause \vspace{1em}
- Ideas: /Weak/ *Agda Reflection*, No fresh names, Monads, Termination,
  ‚ÄòReification‚Äô Œ†‚ÜíŒª

#  \pause  \vspace{1em}

** *Using* Contexts ---@@latex:\emph{re\"{\i}fication}@@

+ If src_haskell[:exports code]{C : Context ‚Ñì‚ÇÄ} then src_haskell[:exports
  code]{C w} has the type ~Œ† ∑ x ‚Ä¢ œÑ~ ---consisting of /w/-many Œ†'s---
  \pause but we want to *apply* src_haskell[:exports code]{C w} to /w/-many /parameters/...

   \vspace{1em} \pause
+ So we need a combinator...
  #+begin_center
    #+begin_src haskell
 Œ†‚ÜíŒª  ‚ÄúŒ† ∑ x ‚Ä¢ œÑ‚Äù   =   ‚ÄúŒª ∑ x ‚Ä¢ œÑ‚Äù
#+end_src
  #+end_center

\vspace{1em}\pause
+ with an infix form for contexts in particular ...
  #+begin_center
  #+begin_src haskell
C :waist w   =   Œ†‚ÜíŒª (C w)
#+end_src
  #+end_center
** Characterising =:waist= as Œ†‚ÜíŒª :Maybe_delete:

 #+BEGIN_SRC haskell
                      Œ†‚ÜíŒª (Œ† a : A ‚Ä¢ œÑ)  =  (Œª a : A ‚Ä¢ œÑ)
                           C :waist w    =   Œ†‚ÜíŒª (C w)
 #+END_SRC

 \pause
 -----
 \vspace{0.5em}

 #+begin_parallel 2
 #+begin_src haskell
id‚ÇÄ : Set‚ÇÅ
id‚ÇÄ = Œ† X ‚à∂ Set ‚Ä¢ Œ† e ‚à∂ X ‚Ä¢ X
 #+end_src

 \pause\vspace{.5em}

 #+begin_src haskell
id‚ÇÅ : Œ† X ‚à∂ Set ‚Ä¢ Set
id‚ÇÅ = Œª (X : Set) ‚Üí Œ† e ‚à∂ X ‚Ä¢ X

  #+end_src

 \pause\vspace{.5em}
 #+begin_src haskell
id‚ÇÇ : Œ† X ‚à∂ Set ‚Ä¢ Œ† e ‚à∂ X ‚Ä¢ Set
id‚ÇÇ = Œª (X : Set) (e : X) ‚Üí X
 #+end_src

 #+latex: \columnbreak

 \pause
 + ~id·µ¢‚Çä‚ÇÅ ‚âà Œ†‚ÜíŒª id·µ¢~
 + ~id‚ÇÄ~ is a /type of functions/
 + ~id‚ÇÅ~ is a /function on types/

 #+end_parallel

 :Details:
 We shall refer to the latter change
 as @@latex: \emph{re\"{\i}fication}@@ since the result is more concrete: It can
 be applied. This transformation will be
 denoted by ~Œ†‚ÜíŒª~. To clarify this subtlety, consider the following forms of the
 polymorphic identity function. Notice that $\mathsf{id}·µ¢$ /exposes/ =i=-many details at the
 type level to indicate the sort of data it consists of. However, notice that ~id‚ÇÄ~ is
 a type of functions whereas $\mathsf{id}‚ÇÅ$ is a function on types. Indeed, the latter
 :End:

** Monoid·µ¢

#+begin_src haskell :tangle no
Monoid : Context
Monoid = do C ‚Üê Set; _‚®æ_ : C ‚Üí C ‚Üí C; Id ‚Üê C; ‚Ä¶
#+end_src

\pause
With no parameters, we have a Œ†‚Å∞Œ£-type (a *record*)
#+begin_src haskell :tangle no
Monoid :waist 0  : Set‚ÇÅ
Monoid :waist 0  ‚â°  Œ£ C : Set ‚Ä¢ Œ£ _‚®æ_ : C ‚Üí C ‚Üí C ‚Ä¢ Œ£ Id : C ‚Ä¢ ‚Ä¶
#+end_src

\pause
With *one* parameter, we have a *typeclass*
#+begin_src haskell :tangle no
Monoid :waist 1  :  Œ† C : Set ‚Ä¢ Set
Monoid :waist 1  =  Œª C : Set ‚Ä¢ Œ£ _‚®æ_ : C ‚Üí C ‚Üí C ‚Ä¢ Œ£ Id : C ‚Ä¢ ‚Ä¶
#+end_src

\pause
With *two* parameters, we have a /‚Äòsolution‚Äô/ to the
additive-or-multiplicative-monoid-problem!
   #+begin_src haskell :tangle no
Monoid :waist 2  :  Œ† C : Set) ‚Ä¢ Œ† _‚®æ_ : C ‚Üí C ‚Üí C ‚Ä¢ Set
Monoid :waist 2  =  Œª C : Set ‚Ä¢ Œª _‚®æ_ : C ‚Üí C ‚Üí C ‚Ä¢ Œ£ Id : C ‚Ä¢ ‚Ä¶
#+end_src

** Example Instance ---Additive Naturals
#+begin_src haskell
                          ‚Ñï‚Çä  : (Monoid ‚Ñì‚ÇÄ :waist 1) ‚Ñï
                          ‚Ñï‚Çä  = ‚ü® _+_           -- _‚®æ_
                                , 0             -- Id
                                , +-identityÀ°
                                , +-identity ≥
                                , +-assoc
                                ‚ü©
#+end_src

** COMMENT Relationships between various forms

#+begin_src haskell :tangle no
Monoid : Context -- i.e., (w : ‚Ñï) ‚Üí Set

Monoid :waist ùìå   :  Œ† ∑ ‚ãØ ‚Ä¢ Set
Monoid :waist ùìå   =  Œª ∑ ‚Äúparameters‚Äù ‚Ä¢ ‚Äúfields‚Äù
#+end_src

** COMMENT 11 Line Implementation ---thanks Ulf!

*** The Core _Syntactic_ Transformation

 #+begin_src haskell :tangle no
--  Œ† a : A ‚Ä¢ B a   ‚Ü¶   Œª a : A ‚Ä¢ B a

Œ†‚ÜíŒª-helper : Term ‚Üí Term

Œ†‚ÜíŒª-helper (pi a (abs x b))
  = lam visible (abs x (Œ†‚ÜíŒª-helper b))

Œ†‚ÜíŒª-helper x
  = x
 #+end_src

*** Keeping Track of Types

 src_haskell[:exports code]{Term} denotes untyped Œª-terms,
 so let's keep track of the types when we convert Œ†s to Œªs.

 #+begin_src haskell :tangle no
Œ†‚ÜíŒª-type : Term ‚Üí Term

Œ†‚ÜíŒª-type (pi a (abs x b))
 = pi a  (abs x (Œ†‚ÜíŒª-type b))

Œ†‚ÜíŒª-type x
 = unknown
 #+end_src

*** Putting them together

 #+html:<small>
 #+begin_src haskell :tangle no
macro
  Œ†‚ÜíŒª : Term ‚Üí Term ‚Üí TC Unit.‚ä§
  Œ†‚ÜíŒª œÑ goal
   =  normalise œÑ
       >>=‚Çú‚Çë·µ£‚Çò Œª œÑ‚Ä≤ ‚Üí checkType goal (Œ†‚ÜíŒª-type œÑ‚Ä≤)
       >>=‚Çú‚Çë·µ£‚Çò Œª _ ‚Üí  unify goal (Œ†‚ÜíŒª-helper œÑ‚Ä≤)
 #+end_src
 #+html:</small>

** Lessons Learned

On-the-fly unbundling can be implemented as an in-language library in a
dependently-typed language with sufficient reflection capabilities :-)

\[\star\; \star\; \star\]

The src_haskell[:exports code]{Context} approach /inherits/ the strengths and
limitations of the host language.

** Comparing =PackageFormer= and =Context=
   # [[file:~/thesis-proposal/PF-Context-comparision.png]]

  |                          | PackageFormer      | Contexts             |
  |--------------------------+--------------------+----------------------|
  | Type of Entity           | Preprocessing Tool | Language Library     |
  | Specification Language   | Lisp + Agda        | Agda                 |
  | Well-formedness Checking | ‚ùå               | ‚úì                    |
  | Termination Checking     | ‚úì                  | ‚úì                    |
  | Elaboration Tooltips     | ‚úì                  | ‚ùå                 |
  | Rapid Prototyping        | ‚úì                  | ‚úì (Slower)           |
  | Usability Barrier        | None               | None                 |
  | Extensibility Barrier    | Lisp               | Weak Metaprogramming |
** COMMENT Related Problem: Control over Parameter Instantiation

 Instances of Haskell typeclasses
 + are indexed by \textbf{types} only
 + so that there can be only one ~Monoid~ instance for ~Bool~

 Crude solution: Isomorphic copies with different type \textbf{name}:
 \begin{code}
 data Bool   = False | True
 \end{code}

 \begin{code}
 newtype All = All { getAll :: Bool } -- for ~Monoid~ instance based on conjunction
 \end{code}

 \begin{code}
 newtype Any = Any { getAny :: Bool } -- for ~Monoid~ instance based on disjunction
 \end{code}

* GADTs are Contexts too!

** From Contexts to GADTS

src_haskell[:exports code]{Monoid}
   # \pause@@html: <small>@@ definition@@html: </small>@@

#+latex: \pause ‚üø % \hfill {\small (definition)}
#+begin_src haskell
do C ‚Üê Set; _‚®æ_ : C ‚Üí C ‚Üí C; Id : C; ‚Ä¶
#+end_src
   # \pause@@html: <small>@@ go to waist 1 to get a parameterised record@@html:
   # </small>@@

#+latex: \pause ‚üø % \hfill {\small (:waist 1)}
#+begin_src haskell
Œª C : Set ‚Ä¢ Œ£ _‚®æ_ : C ‚Üí C ‚Üí C ‚Ä¢ Œ£ Id : C ‚Ä¢ ‚Ä¶
#+end_src

   # \pause@@html: <small>@@ Termtype constructors all target the same type, say ~C~, so drop all others@@html: </small>@@

#+latex: \pause ‚üø % \hfill {\small (Drop all non-C valued ops)}
#+begin_src haskell
Œª C : Set ‚Ä¢ Œ£ _‚®æ_ : C ‚Üí C ‚Üí C ‚Ä¢ Œ£ Id : C ‚Ä¢ ùüô
#+end_src
   # \pause@@html: <small>@@ Termtype are sums of products@@html: </small>@@

#+latex: \pause ‚üø % \hfill {\small (Sums of products)}
#+begin_src haskell
Œª C : Set ‚Ä¢       C √ó C    ‚äç         C ‚äç ùüô
#+end_src
   # \pause@@html: <small>@@ Termtypes are fixpoints of type constructors@@html: </small>@@

#+latex: \pause ‚üø % \hfill {\small (Fixpoints)}
#+begin_src haskell
Œº C : Set ‚Ä¢       C √ó C    ‚äç         C ‚äç ùüô
#+end_src

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

% \pause
% \put(2,5){\colorbox{yellow}{\Large As a macro...}}
% \pause
\put(2,4){\colorbox{yellow}{\Large \texttt{termtype : UnaryFunctor ‚Üí Type}}}
\put(2,3.4){\colorbox{yellow}{\Large \texttt{termtype œÑ = Fix (Œ£‚Üí‚äé (sources œÑ))}}}
\end{picture}
#+end_export

** Monoids give rise to tree skeletons / Context
#+begin_src haskell :tangle no
Monoid : ‚àÄ ‚Ñì ‚Üí Context (‚Ñìsuc ‚Ñì)
Monoid ‚Ñì = do Carrier ‚Üê Set ‚Ñì
              _‚®æ_     ‚Üê (Carrier ‚Üí Carrier ‚Üí Carrier)
              Id      ‚Üê Carrier
              leftId  ‚Üê ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
              rightId ‚Üê ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
              assoc   ‚Üê ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z  ‚â°  x ‚®æ (y ‚®æ z)
              End {‚Ñì}
#+end_src

** Monoids give rise to tree skeletons / Termtype

#+begin_src haskell
  ùïÑ : Set
  ùïÑ = termtype (Monoid ‚Ñì‚ÇÄ :waist 1)
#+end_src

#+begin_src haskell
  that-is : ùïÑ
          ‚â° Fix (Œª X ‚Üí
                -- _‚äï_, branch
                X √ó X √ó ùüô
                -- Id, nil leaf
              ‚äé ùüô
                -- invariant leftId
              ‚äé ùüò
                -- invariant rightId
              ‚äé ùüò
                -- invariant assoc
              ‚äé ùüò
                --  the ‚ÄúEnd {‚Ñì}‚Äù
              ‚äé ùüò)
  that-is = refl
            #+end_src

** Monoids give rise to tree skeletons / Readability
# Pattern synonyms for more compact presentation
            #+begin_src haskell
-- : ùïÑ
pattern emptyM
    = Œº (inj‚ÇÇ (inj‚ÇÅ tt))
#+end_src

#+begin_src haskell
-- : ùïÑ ‚Üí ùïÑ ‚Üí ùïÑ
pattern branchM l r
    = Œº (inj‚ÇÅ (l , r , tt))
#+end_src

#+begin_src haskell
-- absurd ùüò-values
pattern absurdM a
    = Œº (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÇ a))))
#+end_src

** Monoids give rise to tree skeletons / ~termtype Monoid ‚âÖ TreeSkeleton~

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
  data TreeSkeleton : Set where
    empty  : TreeSkeleton
    branch : TreeSkeleton ‚Üí TreeSkeleton ‚Üí TreeSkeleton
#+end_src


#+ATTR_REVEAL: :frag (appear)
- ‚Äúdoing nothing‚Äù
   #+begin_src haskell
  to : ùïÑ ‚Üí TreeSkeleton
  to emptyM        = empty
  to (branchM l r) = branch (to l) (to r)
  to (absurdM (inj‚ÇÅ ()))
  to (absurdM (inj‚ÇÇ ()))
#+end_src


#+ATTR_REVEAL: :frag (appear)
- ‚Äúdoing nothing‚Äù
   #+begin_src haskell
  from : TreeSkeleton ‚Üí ùïÑ
  from empty        = emptyM
  from (branch l r) = branchM (from l) (from r)
#+end_src

** COMMENT Dynamical Systems give rise to ‚Ñï
** COMMENT Context

#+begin_src haskell
DynamicSystem : Context ‚Ñì‚ÇÅ
DynamicSystem = do State ‚Üê Set
                   start ‚Üê State
                   next  ‚Üê (State ‚Üí State)
                   End {‚Ñì‚ÇÄ}
                       #+end_src

** COMMENT Termtype
                           #+begin_src haskell
ùîª = termtype (DynamicSystem :waist 1)
#+end_src
Pattern synonyms for more compact presentation
#+begin_src haskell
-- : ùîª
pattern startD
    = Œº (inj‚ÇÅ tt)

-- : ùîª ‚Üí ùîª
pattern nextD e = Œº (inj‚ÇÇ (inj‚ÇÅ e))
#+end_src

** COMMENT ~termtype ùîª ‚âÖ ‚Ñï~
#+begin_src haskell
    to : ùîª ‚Üí ‚Ñï
    to startD    = 0
    to (nextD x) = suc (to x)

    from : ‚Ñï ‚Üí ùîª
    from zero    = startD
    from (suc n) = nextD (from n)
#+end_src

** COMMENT Pointed Sets give rise to terminal types

#+begin_src haskell
PSet  : Context (‚Ñìsuc ‚Ñì‚ÇÄ)
PSet  = do Carrier ‚Üê Set ‚Ñì‚ÇÄ
           point  ‚Üê Carrier
           End {‚Ñì‚ÇÄ}
#+end_src

#+ATTR_REVEAL: :frag appear
#+begin_src haskell
‚Ñôùïäùïñùï• : Set
‚Ñôùïäùïñùï• = termtype (PSet :waist 1)
#+end_src

#+ATTR_REVEAL: :frag appear
#+begin_src haskell
to : ‚Ñôùïäùïñùï• ‚Üí ùüô {‚Ñì‚ÇÄ}
to emptyM = tt

from : ùüô {‚Ñì‚ÇÄ} ‚Üí ‚Ñôùïäùïñùï•
from _ = Œº (inj‚ÇÅ tt)
#+end_src

** COMMENT (Simple) Graphs give rise to pairs


#+begin_src haskell
Graph  : Context (‚Ñìsuc ‚Ñì‚ÇÄ)
Graph = do Node ‚Üê Set
           Edge ‚Üê Set
           adjacency ‚Üê (Node ‚Üí Node ‚Üí Edge)
           End {‚Ñì‚ÇÄ}
#+end_src

#+ATTR_REVEAL: :frag appear
#+begin_src haskell
ùîæùï£ùïíùï°ùïô : Set ‚Üí Set
ùîæùï£ùïíùï°ùïô X = termtype ((Graph :waist 2) X)
#+end_src

#+ATTR_REVEAL: :frag appear
#+begin_src haskell
pattern _‚áå_ x y = Œº (inj‚ÇÅ (x , y , tt))

view : ‚àÄ {X} ‚Üí ùîæùï£ùïíùï°ùïô X ‚Üí X √ó X
view (x ‚áå y) = x , y
#+end_src

** COMMENT Indexed unary algebras (‚Äúactions‚Äù) give rise to streams

** COMMENT Context
#+begin_src haskell
Action  : Context ‚Ñì‚ÇÅ
Action  = do Value    ‚Üê Set
             Program  ‚Üê Set
             run      ‚Üê (Program ‚Üí Value ‚Üí Value)
             End {‚Ñì‚ÇÄ}
#+end_src
** COMMENT Termtype
#+begin_src haskell
ùî∏ùïîùï•ùïöùï†ùïü : Set ‚Üí Set
ùî∏ùïîùï•ùïöùï†ùïü X = termtype ((Action :waist 2) X)
#+end_src

#+begin_src haskell
-- : X ‚Üí ùî∏ùïîùï•ùïöùï†ùïü X ‚Üí ùî∏ùïîùï•ùïöùï†ùïü X
pattern _‚à∑_ head tail
         = Œº (inj‚ÇÅ (tail , head , tt))
#+end_src

** COMMENT ‚Ä¶ to stream
#+begin_src haskell
record Stream (X : Set) : Set   where
  coinductive
  field
    hd : X
    tl : Stream X

open Stream
#+end_src
#+ATTR_REVEAL: :frag appear
#+begin_src haskell
view : ‚àÄ {I} ‚Üí ùî∏ùïîùï•ùïöùï†ùïü I ‚Üí Stream I
hd (view (h ‚à∑ t)) = h
tl (view (h ‚à∑ t)) = view t
#+end_src

** COMMENT Collection theories give rise to lists

#+begin_src haskell
Collection : ‚àÄ ‚Ñì ‚Üí Context (‚Ñìsuc ‚Ñì)
Collection ‚Ñì = do Elem      ‚Üê Set ‚Ñì
                  Container ‚Üê Set ‚Ñì
                  insert    ‚Üê (Elem ‚Üí Container ‚Üí Container)
                  ‚àÖ         ‚Üê Container
                  End {‚Ñì}
#+end_src

#+ATTR_REVEAL: :frag appear
#+begin_src haskell
‚ÑÇ : Set ‚Üí Set
‚ÑÇ Elem = termtype ((Collection ‚Ñì‚ÇÄ :waist 2) Elem)
#+end_src
#+ATTR_REVEAL: :frag appear
#+begin_src haskell
-- : X ‚Üí ‚ÑÇ X ‚Üí ‚ÑÇ X
pattern _::_ x xs
         = Œº (inj‚ÇÅ (x , xs , tt))

-- : ‚ÑÇ X
pattern  ‚àÖ
    = Œº (inj‚ÇÇ (inj‚ÇÅ tt))
#+end_src

** Summary

| ‚Äòtheory‚Äô œÑ     | ‚Äòdata structure‚Äô ~termtype œÑ~ |
|----------------+-----------------------------|
| pointed set    | ùüô                           |
| dynamic system | ‚Ñï                           |
| monoid         | tree skeletons              |
| collections    | lists                       |
| graphs         | (homogeneous) pairs         |
| actions        | infinite streams            |

#+begin_quote
/Many more theories œÑ to explore and see what data structures arise!/
#+end_quote
* Contributions

** Module Systems for DTLs

0. [@0] Identify the \alert{module design patterns} used by DTL practitioners

   \pause
1. The ability to /implement/ module systems \alert{for DTLs within DTLs}

   #+latex: \vspace{1em} \pause
2. The ability to arbitrarily \alert{extend} such systems by users at a high-level

      #+latex: \vspace{1em} \pause
3. Demonstrate that there is an expressive yet minimal set of
   \alert{module meta-primitives} which allow common module constructions to be defined

   # **Unifying Seemingly Disparate Notions of Modules
      #+latex: \vspace{1em} \pause
4. Demonstrate that relationships between modules can also be \alert{mechanically}
   generated.
   # - In particular, if module ‚Ñ¨ is obtained by applying a user-defined
   #   ‚Äòvariational‚Äô to module ùíú, then the user could also enrich the child module
   #   ‚Ñ¨ with morphisms that describe its relationships to the parent module ùíú.
   # - E.g., if ‚Ñ¨ is an extension of ùíú, then we may have a ‚Äúforgetful mapping‚Äù
   #   that drops the new components; or if ‚Ñ¨ is a ‚Äòminimal‚Äô rendition of the
   #   theory ùíú, then we have a ‚Äúsmart constructor‚Äù that forms the rich ùíú by only
   #   asking the few ‚Ñ¨ components of the user.

** Termtypes as Modules

#+latex: \centering

5. [@5] Bring \alert{algebraic data types} under the umbrella of grouping mechanisms:
   An ADT is just a context whose symbols target the ADT ‚Äòcarrier‚Äô and
   are not otherwise interpreted.
   - In particular, both an ADT and a record can be obtained *practically* from
     a *single* context declaration.

\pause

\vspace{-0.5em}
#+begin_parallel 2

# +ATTR_LATEX: :width 0.45\paperwidth :height 0.35\paperheight
#+begin_src haskell
DynamicSystem : Context ‚Ñì‚ÇÅ
DynamicSystem
    = do State ‚Üê Set
         start ‚Üê State
         next  ‚Üê (State ‚Üí State)
         End
#+end_src
# [[file:~/thesis-proposal/unbundling-DS-0.png]]

#+latex: \columnbreak

\pause
# +ATTR_LATEX: :width 0.2\paperwidth :height 0.2\paperheight
# [[file:~/thesis-proposal/DS-data.png]]

#+begin_src haskell
data ùîª : Set where
    startD : ùîª
    nextD  : ùîª ‚Üí ùîª
#+end_src

#+end_parallel

\pause
\vspace{-1.3em}
-----
\vspace{-2em}
#+latex: \begin{minipage}[t]{0.85\linewidth}
#+begin_src haskell
ùîª = termtype (DynamicSystem :waist 1)

-- Pattern synonyms for more compact presentation
pattern startD  = Œº (inj‚ÇÅ tt)       -- : ùîª
pattern nextD e = Œº (inj‚ÇÇ (inj‚ÇÅ e)) -- : ùîª ‚Üí ùîª
trivial : ùîª ‚âÖ ‚Ñï
#+end_src
#+latex: \end{minipage}

# +latex: \setlength{\unitlength}{1cm} \begin{picture}(0,0)(0,0)
# +latex: \put(6,-1.55){
# +ATTR_LATEX: :width 0.45\paperwidth :height 0.4\paperheight
# [[file:~/thesis-proposal/DS-termtype.png]]
# +latex: }
# +latex: \end{picture}

** Common data-structures as *free* termtypes
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

6. [@6] Show that common data-structures are \alert{mechanically the (free) termtypes} of
   common modules.

\centering
\vspace{-1em}
\pause

   | Module System         | Termtype |
   |-----------------------+----------|
   | Dynamical Structures  | Naturals |
   | Collection Structures | Lists    |
   | Pointed Structures    | Maybe    |

\vspace{-1em}
\pause

# +ATTR_LATEX: :width 0.45\paperwidth :height 0.5\paperheight
# [[file:~/thesis-proposal/lists-as-free-collections.png]]

#+LaTeX: \setminted[haskell]{fontsize=\scriptsize, breaklines}
#+begin_src haskell
Collection : ‚àÄ ‚Ñì ‚Üí Context (‚Ñìsuc ‚Ñì)
Collection ‚Ñì = do Elem    ‚Üê Set ‚Ñì
                  Carrier ‚Üê Set ‚Ñì
                  insert  ‚Üê (Elem ‚Üí Carrier ‚Üí Carrier)
                  ‚àÖ       ‚Üê Carrier
                  End {‚Ñì}

List : Set ‚Üí Set
List ElemType = termtype ((Collection ‚Ñì‚ÇÄ :waist 2) ElemType)

pattern _::_ x xs = Œº (inj‚ÇÅ (x , xs , tt))
pattern  ‚àÖ        = Œº (inj‚ÇÇ (inj‚ÇÅ tt))
#+end_src
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "committee.pdf"))

** Solve the unbundling problem ---all in Agda!

7. [@7] The ability to ‚Äòunbundle‚Äô module fields as if they were parameters ‚Äòon
   the fly‚Äô

\pause
\vspace{-1.2em}
-----
#+begin_parallel 2
# +ATTR_LATEX: :width 0.45\paperwidth :height 0.5\paperheight
#+begin_src haskell
DynamicSystem : Context ‚Ñì‚ÇÅ
DynamicSystem
    = do State ‚Üê Set
         start ‚Üê State
         next  ‚Üê (State ‚Üí State)
         End
#+end_src
# [[file:~/thesis-proposal/unbundling-DS-0.png]]

\pause
# \columnbreak
# +ATTR_LATEX: :width 0.45\paperwidth :height 0.5\paperheight
# [[file:~/thesis-proposal/unbundling-DS-1.png]]

#+BEGIN_SRC haskell
ùí©‚Å∞ : DynamicSystem :waist 0
ùí©‚Å∞ = ‚ü® ‚Ñï , 0 , suc ‚ü©

ùí©¬π : (DynamicSystem :waist 1) ‚Ñï
ùí©¬π = ‚ü® 0 , suc ‚ü©

ùí©¬≤ : (DynamicSystem :waist 2) ‚Ñï 0
ùí©¬≤ = ‚ü® suc ‚ü©

ùí©¬≥ : (DynamicSystem :waist 3) ‚Ñï 0 suc
ùí©¬≥ = ‚ü®‚ü©
#+END_SRC
#+end_parallel

*Without redefining src_haskell[:exports code]{DynamicSystem}*, we are able to *fix*
some of its /fields/ by making them into /parameters/!

*** COMMENT more
\pause
#+begin_export latex
  % X-axis to the right and Y-axis upwards
  \setlength{\unitlength}{1cm}
  \begin{picture}(0,0)(0,0)
   \put(0,2.5){\textbf{Without redefining \texttt{DynamicSystem}},}
   \put(0,2.0){we are able to \textbf{fix} some of its fields}
   \put(0,1.5){by making them into parameters!}
\end{picture}
#+end_export

\pause
\vspace{-3em}
-----
\vspace{-0.5em}
#+begin_footnotesize org
# Using ~:waist ùíæ~ we may fix the first ~ùíæ~-parameters ahead of time.
# \vspace{-1em}
# + =(DynamicSystem :waist 1) ‚Ñï= is /the type of dynamic systems over carrier ‚Ñï/
# \vspace{-1em}

The type of dynamic systems *over* carrier ‚Ñï and start state 0
\newline is =(DynamicSystem :waist 2) ‚Ñï 0=.
#+end_footnotesize

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "committee.pdf"))

:Examples_in_the_wild:

Examples of the need for such on-the-fly unbundling can be found in numerous
places in the Haskell standard library. For instance, the standard libraries cite:data_monoid
have two isomorphic copies of the integers, called ~Sum~ and ~Product~, whose reason
for being is to distinguish two common monoids: The former is for /integers with
addition/ whereas the latter is for /integers with multiplication/.

:End:

** Theory & Implementation

8. [@8] Demonstrate that there is a \alert{practical implementation} of such a framework

   - [X] The =Context= framework is implemented in Agda and we've seen practical examples of
     its use.

      #+latex: \vspace{2em} \pause
9. Finally, the resulting framework is /mostly/ \alert{type-theory agnostic}: The target
   setting is DTLs but we only assume the barebones; if users drop parts of that
   theory, then /only/ some parts of the framework will no longer apply.

   - [X] There are various forms of semantics presented in the thesis: Abstract
     semantics via signatures, concrete semantics via Agda functions,
     denotational semantics via Œ†Œ£ùí≤, as well as a guide for forming the
     src_haskell[:exports code]{Context} library in other languages.

# - For instance, in DTLs without a fixed-point functor the framework still
#   ‚Äòapplies‚Äô, but can no longer be used to provide arbitrary algebraic data
#   types from contexts.
#

** COMMENT Future Work

 + Explicit (elaboration) semantics for \textsf{PackageFormer}s and
   \textsf{Variational}s within a minimal type theory

   - Refactor meta-primitives from LISP flavour to Agda flavour
   - Integrate with a reflection interface for Agda

 + Explore multiple default definitions

 + Explore inheritance, coercion, and transport along canonical isomorphisms

 + Generate mutually-recursive definitions for certain instances of
   many-sorted \textsf{PackageFormer}s?

** COMMENT Conclusion ---Prototype
+ Naming, terminology, concrete syntax, combinator interfaces
  are all still in flux!

+ The present system already allows to replace hand-written
  instances of structuring schemes
  with invocations of (generative) library methods

+ Our resulting system has turned hand-written instances of structuring schemes from a design
  pattern into full-fledged library methods

+ We already influenced the naming conventions of the Agda ``standard library''

+ Our approach based on \textsf{PackageFormer}s and
  \textsf{Variational}s makes it possible
  - \large to codify, name, and document ``design patterns'' of
       uses of structuring mechanisms
  - \large to enable and encourage re-use at a high level of abstraction
  - \large to drastically reduce the interface size of ``interface libraries''

  and therewith has the potential to *drastically* change how we provide and use
  structures via libraries

** *‚ÄúAll‚Äù* module constructions are born from =Context=
# [[file:~/thesis-proposal/everything-is-a-context.png]]

# +begin_scriptsize org
    \pause \vspace{0.5em}
+ Context: ‚Äúname-type pairs‚Äù
  #+BEGIN_SRC haskell
do S ‚Üê Set; s ‚Üê S; n ‚Üê (S ‚Üí S); End
#+END_SRC
    \pause \vspace{0.5em}

+ Record Type: ‚Äúbundled-up data‚Äù
   #+BEGIN_SRC haskell
Œ£ S ‚à∂ Set ‚Ä¢ Œ£ s ‚à∂ S ‚Ä¢ Œ£ n ‚à∂ S ‚Üí S ‚Ä¢ ùüô
#+END_SRC
    \pause \vspace{0.5em}

+ Function Type: ‚Äúa type of functions‚Äù
   #+BEGIN_SRC haskell
Œ† S ‚Ä¢ Œ£ s ‚à∂ S ‚Ä¢ Œ£ n ‚à∂ S ‚Üí S ‚Ä¢ ùüô
#+END_SRC
    \pause \vspace{0.5em}

+ Type constructor: ‚Äúa function on types‚Äù
   #+BEGIN_SRC haskell
Œª S ‚Ä¢ Œ£ s ‚à∂ S ‚Ä¢ Œ£ n ‚à∂ S ‚Üí S ‚Ä¢ ùüô
#+END_SRC
    \pause \vspace{0.5em}

+ Algebraic datatype: ‚Äúa descriptive syntax‚Äù
   #+BEGIN_SRC haskell
data ùîª : Set where s : ùîª; n : ùîª ‚Üí ùîª
#+END_SRC

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(8,4){\colorbox{yellow}{\Large ‚áí Thank-you}}
\put(8,3.4){\colorbox{yellow}{\Large \hspace{1.7em} for \hspace{2.4em}{\color{yellow}.}}}
\put(8,2.8){\colorbox{yellow}{\Large your time! ‚áê}}
\end{picture}
#+end_export


# +end_scriptsize
** COMMENT /Thank-you for your time!/

 # \pause
 # \vspace{1em}
 # /Thank-you for your time!/

 \vspace{1em}
 \centerline{Questions?}
* COMMENT Misc Summary

  Common, mechanical, patterns for module construction are just out
  of reach of the module systems of dependently-typed languages.
  Such languages permit a rich number of possible formulations for
  a module, such as by having some of its constituents exposed
  at the type level as parameters, others as fields, and others
  as definitional extensions.

  Library designers are generally conservative; they provide a predicate
  formulation consisting of a set of proof obligations that constrain the
  functional symbols provided as parameters in the type level. This formulation
  is then usually accompanied by a fully ‚Äúbundled up‚Äù variation that has no
  parameters and all relevant data is rendered as fields.

  However, trouble arises when library users wish to fix only one field ahead of
  time ---this is the ‚Äúunbundling problem‚Äù and it is akin to function uncurrying
  but for modules.

  Moreover, library designers for dependently-typed languages generally only
  provide a handful of formulations for a single module. Other formulations
  must be written out by hand by users, which must then form coercions
  between the new forms and those used in the library, so as to make use
  of the library's utilities.

  I have produced an editor extension for Agda's de-facto IDE, Emacs,
  which reduces the boilerplate for new formulations of modules to
  simple, usually one-line, specifications. The tool is run in the background
  and works on ordinary Agda files by looking at special comments.
  The specifications are expanded into typechecked Agda code.

  Moreover, using the lessons learned from the editor extension, an Agda library
  has been implemented to achieve similar goals within Agda itself.  Due to
  Agda's current metaprogramming limitations, such as the inability to produce
  fresh names, development with the library is slower than with the editor
  extension.
