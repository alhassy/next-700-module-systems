# C-c C- e l O

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "phd-defense.pdf"))
# M-x org-beamer-export-to-pdf
#+TITLE: Do-it-yourself Module Systems
#+subtitle: Extending Dependently-Typed Languages to Implement \\ Module System Features In The Core Language
#+AUTHOR: Musa Al-hassy
#+date: April 28, 2021
#+OPTIONS: H:2 toc:nil d:nil
# +ATTR_LATEX: :width 0.9\paperwidth :height 0.85\paperheight
#

# ("" "titletoc" nil) â‡’ causes problems!
# (pop org-latex-default-packages-alist)

* Beamer Setup :ignore:
# +BEAMER_THEME: Rochester
# +BEAMER_THEME: Copenhagen
# +BEAMER_THEME: default
# +BEAMER_THEME: metropolis [numbering=fraction, progressbar=frametitle, titleformat=smallcaps]
#+BEAMER_THEME: metropolis

#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col)


#+latex_header: \institute{\vspace{2em}McMaster University,
#+latex_header: %1280 Main St. West,
#+latex_header: Hamilton, Ontario, Canada
#+latex_header: % L8S 4K1,
#+latex_header: \\
#+latex_header: \textsf{alhassy@gmail.com}
#+latex_header: }
#+latex_header:

#+BEAMER_COLOR_THEME: structure[RGB={87,83,170}]
#+LATEX_HEADER: \hypersetup{colorlinks, linkcolor=black, urlcolor=blue}
#+LATEX: \AtBeginSection{\frame{\sectionpage}}
#+LATEX_HEADER: \setbeamersize{text margin left=3mm,text margin right=3mm}
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}
#+latex_header: \usepackage{picture,xcolor,multicol}

# Needs to be before \begin{document}, hence in a latex-header.  Add numbers to
# slides.
#
#+LATEX_HEADER: \setbeamertemplate {footline}{\color{gray}\hspace{49.7em}\insertframenumber\strut\quad}
# LATEX_HEADER: \setbeamertemplate{footline}[frame number]

# HACK: minted, like other verbatim, environments is ``fragile'' wrt to beamer.
# Hence all frames with code may behave erracticly if not marked fragile.
#
# \begin{frame}[fragile]{titleHere}
#
#+LATEX_HEADER: \usepackage{minted}
# https://armkeh.github.io/unicode-sty/
#+LATEX_HEADER: \usepackage{\string~"/unicode-sty/unicode"}
#+latex_header: \usepackage{newunicodechar}
#+latex_header: \newunicodechar{â€²}{'}
#+latex_header: \newunicodechar{â¨¾}{\ensuremath{\fatsemi}}
#+latex_header: \newunicodechar{â‡Œ}{\ensuremath{\rightleftharpoons}}

# Removing the red box that appears in "minted" when using unicode.
# Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+LATEX_HEADER: \makeatother

# to use super tiny fonts, or large ones; e.g., \scalebox{.2}{supertiny}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{lipsum}
#+BEGIN_EXPORT latex
\newcommand\Wider[2][3em]{%
\makebox[\linewidth][c]{%
  \begin{minipage}{\dimexpr\textwidth+#1\relax}
  \raggedright#2
  \end{minipage}%
  }%
}
#+END_EXPORT


#+latex_header: \usepackage{color}
#+latex_header: \definecolor{DarkGreen}{rgb}{0,0.6,0}
#+latex_header: \definecolor{DarkRed}{rgb}{0.6,0,0}
#+latex_header: \definecolor{DarkBlue}{rgb}{0,0,0.6}
#+latex_header: \definecolor{grey}{rgb}{0.5,0.5,0.5}
#+latex_header: \definecolor{DarkGrey}{rgb}{0.4,0.4,0.4}
#+latex_header: \definecolor{DGreen}{rgb}{0,0.4,0.2}


#+latex_header: \newunicodechar{âŸ´}{\ensuremath{\kern0.28em\oplus\kern-1.53em\longrightarrow}}
#+latex_header: % U+27F4: RIGHT ARROW WITH CIRCLED PLUS

* What is the problem?
** Overview

With a bit of reflection, we can obtain

#+ATTR_REVEAL: :frag (appear)
1. a uniform, and *practical*, syntax for both /records/ (semantics) and /termtypes/ (syntax)
2. on-the-fly unbundling; and,
3. *mechanically* obtain data structures from theories
   \pause
   #+latex: \begin{small}
   | â€˜theoryâ€™ Ï„     | â€˜data structureâ€™ ~termtype Ï„~ |
   |----------------+-----------------------------|
   | pointed set    | ğŸ™                           |
   | dynamic system | â„•                           |
   | monoid         | tree skeletons              |
   | collections    | lists                       |
   | graphs         | (homogeneous) pairs         |
   | actions        | infinite streams            |
   #+latex: \end{small}

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(.5,5){\colorbox{yellow}{\Large The combinators presented in the thesis were guided}}
\put(.5,4.4){\colorbox{yellow}{\Large \emph{not} by theortetial concerns on the algebraic nature}}
\put(.5,3.8){\colorbox{yellow}{\Large of containers but rather on the}}
\put(.5,3.2){\colorbox{yellow}{\Large \textbf{practical needs of actual users working in DTLs}}}
\end{picture}
#+end_export

** COMMENT Research Question
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

#+begin_center
*Use a dependently-typed language (DTL) to implement the â€˜missingâ€™ module system
features directly inside the language*
#+end_center

\pause
-----
#+LaTeX: \setminted[haskell]{fontsize=\scriptsize, breaklines}
#+begin_src haskell +n 0
-- Terms: Expressions and Types
e, Ï„ ::= Î±          -- base types and constants
    | Typeáµ¢       -- â€œtype of typesâ€; Universe of types at level i : â„•
    | â„•             -- â€œLevelsâ€ for the type hierarchy
    | Î  x : Ï„ â€¢ Ï„   -- â€œPiâ€, dependent-function type
    | Î£ x : Ï„ â€¢ Ï„   -- â€œSigmaâ€, dependent-sum type
    | x             -- Variable
    | e e           -- Application; Î -elimination
    | Î» x : Ï„ â€¢ e   -- Abstraction; Î -introduction
    | (e , e)       -- Pairing; Î£-introduction
    | fst e | snd e -- Projections; Î£-elimination
    | Fix ğ‘­         -- Fixpoints for ğ‘­ : Typeáµ¢ â†’ Typeáµ¢

-- Abbreviation: Provided Î² does not refer to variable â€˜_â€™,
(Î± â†’ Î²) :=  (Î  _ : Î± â€¢ Î²)
 #+end_src
#+latex: \vspace{-1em}
| DTL Syntax   |
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}
** COMMENT Ubiquitous *mechanical* module constructions are *out of reach* of DTL module systems...

   # [[file:~/thesis-proposal/patterns.png]]

#+latex_header: \usepackage{smartdiagram}
#+latex: \vspace{-2em}
#+begin_export latex
\begin{center}
\smartdiagram[constellation diagram]{
 {\footnotesize Monoids}
,{\footnotesize Monoids \emph{with} carrier \texttt{C}}
,{\footnotesize Homomorphisms, products, duals}
,{\footnotesize Signature (Tree skeletons)}
,{\footnotesize Pointed Magma} % (â€œExclusionâ€)
,{\footnotesize Terms} %  (Trees with variables)
,{\footnotesize Monoids \emph{over} a setoid}
%,Universal Algebra constructions
,{\scriptsize Monoids \emph{with} carrier \texttt{C} and operation $\oplus$}
% %
% Build a program,Set up,Run,Analyze,Modify~/\\ Add,Check
}

\end{center}
#+end_export

:Hide:

\begin{figure}
\centering
 \makebox[\textwidth]{\includegraphics[width=.9\paperwidth, height=.75\paperheight]{~/thesis-proposal/images/patterns.png}}
\end{figure}

\pause
#+begin_export latex
  % X-axis to the right and Y-axis upwards
  \setlength{\unitlength}{1cm}
  \begin{picture}(0,0)(0,0)
   \put(8.5,8.5){\underline{\textbf{\emph{PL Research is about}}}}
   \put(8.5,8.0){\underline{\textbf{\emph{getting free stuff:}}}}
   \put(8.5,7.5){\underline{\textbf{\emph{We can get a lot!}}}}
\end{picture}
#+end_export

:End:

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "committee.pdf"))
** What is /in a/ monoid?

People work with monoids at various levels of *exposure* â€¦

\pause

+ â€œLet ğ‘´ be a *monoid*, â€¦â€
  \vspace{1em}\pause
+ â€œGiven a *monoid over* â„•, â€¦â€
    \vspace{1em}\pause
+ â€œConsider */the/ monoid* (â„•, +), â€¦â€
  - (Unique viz proof irrelevance.)
    \vspace{1em}\pause
+ â€œConsider */the/ monoid* (â„•, +, 0), â€¦â€

 #+begin_src agda :tangle yes :exports none
open import Relation.Binary.PropositionalEquality
#+end_src

** â€œA monoid consists of a collection ~Carrier~, an operation, â€¦â€?
   :PROPERTIES:
   :BEAMER_OPT: fragile
   :END:

#+begin_src agda :tangle yes
record Monoidâ‚€  : Setâ‚  where
  field  Carrier : Set
         _â¨¾_     :  Carrier â†’ Carrier â†’ Carrier
         Id      :  Carrier
         lid     : âˆ€ {x} â†’   Id â¨¾ x  â‰¡  x
         rid     : âˆ€ {x} â†’   x â¨¾ Id  â‰¡  x
         assoc   : âˆ€ {x y z} â†’  (x â¨¾ y) â¨¾ z  â‰¡  x â¨¾ (y â¨¾ z)
#+end_src

| Use-case: The category of monoids. |

** â€œA monoid over a given collection ~Carrier~ and operation ~_â¨¾_~ is given by ensuring there is a selected point ...â€?
   :PROPERTIES:
   :BEAMER_OPT: fragile
   :END:

#+begin_src agda :tangle yes
record Monoidâ‚
         (Carrier : Set)   : Set  where
  field
         _â¨¾_     :  Carrier â†’ Carrier â†’ Carrier
         Id      :  Carrier
         lid     : âˆ€ {x} â†’   Id â¨¾ x  â‰¡  x
         rid     : âˆ€ {x} â†’   x â¨¾ Id  â‰¡  x
         assoc   : âˆ€ {x y z} â†’  (x â¨¾ y) â¨¾ z  â‰¡  x â¨¾ (y â¨¾ z)
#+end_src

| Use-case: Sharing the carrier type |

** Or â€¦ ?

#+begin_src agda :tangle yes
record Monoidâ‚‚
         (Carrier : Set)
         (_â¨¾_     :  Carrier â†’ Carrier â†’ Carrier) : Set where
  field
         Id      :  Carrier
         lid     : âˆ€ {x} â†’   Id â¨¾ x  â‰¡  x
         rid     : âˆ€ {x} â†’   x â¨¾ Id  â‰¡  x
         assoc   : âˆ€ {x y z} â†’  (x â¨¾ y) â¨¾ z  â‰¡  x â¨¾ (y â¨¾ z)
#+end_src

| Use-case: The additive monoid on the â„•atural numbers |

** Or â€¦ ?

#+begin_src agda :tangle yes
record Monoidâ‚ƒ
         (Carrier : Set)
         (_â¨¾_     :  Carrier â†’ Carrier â†’ Carrier)
         (Id      :  Carrier)      : Set  where
  field
         lid     : âˆ€ {x} â†’   Id â¨¾ x  â‰¡  x
         rid     : âˆ€ {x} â†’   x â¨¾ Id  â‰¡  x
         assoc   : âˆ€ {x y z} â†’  (x â¨¾ y) â¨¾ z  â‰¡  x â¨¾ (y â¨¾ z)
 #+end_src

\vspace{1em}
/Notice that the keyword src_emacs-lisp[:exports code]{field} is â€œgoing downâ€
the *waist* each time./

** Tom Hales ---Kepler Conjecture / Flyspeck

 #+begin_quote
 Structures are meaninglessly parameterized from a mathematical perspective.
 [â€¦]  That is, what is bundled cannot be later opened up as a parameter. [...]
 This means that library designers are forced to take a conservative approach
 and expose as a parameter anything that any user might reasonably want exposed,
 because once it is bundled, it is not coming back.

     \hfill ---[[https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/][A Review of the Lean Theorem Prover]], *2018-09-18*
 #+end_quote

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(2,5){\colorbox{yellow}{\Large â‡’ This is a problem we are solving!}}

\pause
\put(2,4.4){\colorbox{yellow}{\Large â‡’ A \emph{recent} problem}}

\pause
\put(2,3.8){\colorbox{yellow}{\Large â‡’ \emph{\textbf{\alert{â€œThe Unbundling Problemâ€}}}}}

\end{picture}
#+end_export

** Does this /actually/ happen?

\pause
#+latex: \centerline{\alert{\large Yes!}}

\pause
Examples:
+ Agda's Standard Library,
+ RATH-Agda,
+ agda-categories

It's not just dependently-typed languages...
\pause
+ Arend
+ Haskell's Standard Library

** What are the adjacent problems?

\alert{Maintence of relationships} when we â€œbring down the waistâ€ ---the
position of the src_emacs-lisp[:exports code]{field} keyword.

\pause

#+begin_src haskell
                       Monoidâ‚€  â‰…  Î£ C : Set â€¢ Monoidâ‚ C
#+end_src
\pause
#+begin_src haskell
              Monoidâ‚ C  â‰…  Î£ ğ‘´ : Monoidâ‚€ â€¢ Monoidâ‚€.Carrier ğ‘´ â‰¡ C
#+end_src
\pause
#+latex: \centerline{These coercions can be derived \textbf{mechanically}}

\pause What about other /natural constructions/ on mathematical theories (and the
associated relationships)?
+ Extensions? ---â€œA group is a monoid with an extraâ€¦â€ \pause
+ Exclusions? ---â€œA semigroup is a non-unital monoid.â€  \pause
+ Termtypes?  ---â€œLists are just the free /monoid over/ a given type.â€ \pause
+ Pushouts: Name-relevant unions? ---â€œA monoid is a pointed set along with a
  semigroup *such that* they share the same carrier.â€ \pause
+ Numerous other constructions from Category Theory

** Which items should be fields, which parameters?

 + The src_haskell[:exports code]{Monoidáµ¢} family showed some
   combinations of items selected as parameters.  \pause

 + There are other combinations of what is to be exposed and hidden, for
   applications that we might never think of. \pause

 + Providing always the most-general parameterisation produces *awkward* library
   interfaces!

\pause

_Proposed Solution_:

 + Commit to no particular formulation and allow on-the-fly ``unbundling''
   - This is the /converse/ of instantiation

     \pause
 + The â€œEmacs editor tacticâ€ src_emacs-lisp[:exports code]{PackageFormer}
 + The â€œAgda libraryâ€ src_haskell[:exports code]{Context}

** TODO COMMENT Roadmap
   There are 3 ways to see the problem....
* The src_emacs-lisp[:exports code]{PackageFormer} Prototype: A useful experimentation tool

** Evidence that the theory â€˜actually worksâ€™

#+begin_center
*Prototype* with an editor extension /then/ incorporate *lessons learned* into a DTL
library!
#+end_center

#+begin_export latex
\begin{figure}
\centering
 \makebox[\textwidth]{\includegraphics[width=.5\paperwidth, height=.4\paperheight]{~/thesis-proposal/images/Paper0_MousingOverLarge.png}}
\end{figure}
#+end_export

|Generated code displayed on hover|

** /A Language Feature to Unbundle Data at Will/ (GPCE '19)

 #+ATTR_LATEX: :width 0.75\paperwidth :height 0.75\paperheight
 [[file:~/thesis-proposal/images/gpce19.png]]

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(2,4){\colorbox{yellow}{\Large â‡’ Influenced Agda's Standard Library}}

\end{picture}
#+end_export

** COMMENT Prototype â‡’ *Lisp Metaprogramming*, ASTs, Untyped, String Manipulation, Agda Generation, Macro DSL
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

# +ATTR_LATEX: :height 0.75\paperheight
# [[file:~/thesis-proposal/lisp.png]]
#+latex: \centering
#+LaTeX: \setminted[common-lisp]{fontsize=\tiny, breaklines}
#+latex: \begin{minipage}[t]{0.95\linewidth}
#+BEGIN_SRC emacs-lisp
{-lisp
(ğ’± recordâ‚ (discard-equations nil)
 = "Reify a variational as an Agda â€œrecordâ€.
    Elements with equations are construed as
    derivatives of fields  ---the elements
    without any equations--- by default, unless
    DISCARD-EQUATIONS is provided with a non-nil value."
  :kind record
  :alter-elements
    (Î» es â†’
      (thread-last es
      ;; Keep or drop eqns depending on â€œdiscard-equationsâ€
      (--map
        (if discard-equations
            (map-equations (Î» _ â†’ nil) it)
            it))
      ;; Unless there's equations, mark elements as fields.
      (--map (map-qualifier
        (Î» _ â†’ (unless (element-equations it)
               "field")) it)))))
-}

{-700
Monoid-record-with-definitional-extensions  =  MonoidP recordâ‚
Monoid-record-with-extensions-as-fields     =  MonoidP recordâ‚ :discard-equations t
-}
#+END_SRC
#+LaTeX: \setminted[common-lisp]{fontsize=\footnotesize, breaklines}
#+latex:   \end{minipage}

** *The* Definition of a Monoid

#+begin_src haskell
  PackageFormer MonoidP : Setâ‚ where
    Carrier : Set
    _â¨¾_       : Carrier â†’ Carrier â†’ Carrier
    Id      : Carrier
    assoc   : âˆ€ {x y z} â†’   (x â¨¾ y) â¨¾ z  â‰¡  x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x} â†’   Id â¨¾ x  â‰¡  x
    rightId : âˆ€ {x} â†’   x â¨¾ Id  â‰¡  x
#+end_src

\pause

| We regain the different candidates by applying *variationals*. |

#+begin_parallel :bar t

 #+ATTR_LATEX: :options fontsize=\tiny
#+begin_src haskell
  Monoidâ‚€  =  MonoidP record
  Monoidâ‚  =  MonoidP record âŸ´ unbundled 1
  Monoidâ‚‚  =  MonoidP record âŸ´ unbundled 2
  Monoidâ‚ƒ  =  Monoidâ‚€â€² exposing "Carrier; _â¨¾_; Id"
#+end_src

\ldots and we can do more

#+columnbreak:

\pause Monoid syntax!
 #+ATTR_LATEX: :options fontsize=\tiny
#+begin_src haskell
  Tree = MonoidP termtype-with-variables "Carrier"
â‰…
  data Tree (Var : Set) : Set where
    inj : Var â†’ Tree Var
    _â¨¾_   : Tree Var â†’ Tree Var â†’ Tree Var
    Id  : Tree Var
#+end_src

#+end_parallel

\pause
| *_Linear_* effort in number of variations                      |

** *Pushout* unions, intersections, extensions, views, â€¦

# +ATTR_LATEX: :height 0.75\paperheight
# [[file:~/thesis-proposal/pushouts.png]]

#+LaTeX: \setminted[common-lisp]{fontsize=\tiny, breaklines}
#+BEGIN_SRC emacs-lisp
(ğ’± union pf (renamingâ‚ "") (renamingâ‚‚ "") (adjoin-retractâ‚ t) (adjoin-retractâ‚‚ t)
 = "Union the elements of the parent PackageFormer with those of
    the provided PF symbolic name, then adorn the result with two views:
    One to the parent and one to the provided PF.

    If an identifer is shared but has different types, then crash."
   :alter-elements (Î» es â†’
     (let* ((p (symbol-name 'pf))
            (esâ‚ (alter-elements es renaming renamingâ‚ :adjoin-retract nil))
            (esâ‚‚ (alter-elements ($ğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘ -ğ‘œğ‘“ p) renaming renamingâ‚‚ :adjoin-retract nil))
            (esâ€² (-concat esâ‚ esâ‚‚)))

      ;; Ensure no name clashes!
      (loop for n in (find-duplicates (mapcar #'element-name esâ€²))
            for e = (--filter (equal n (element-name it)) esâ€²)
            unless (--all-p (equal (car e) it) e)
            do (-let [debug-on-error nil]
              (error "%s = %s union %s \n\n\t\t â© Error: Elements â€œ%sâ€ conflict!\n\n\t\t\t%s"
                     $ğ‘›ğ‘ğ‘šğ‘’ $ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ p (element-name (car e)) (s-join "\n\t\t\t" (mapcar #'show-element e)))))

   ;; return value
   (-concat
       esâ€²
       (when adjoin-retractâ‚ (list (element-retract $ğ‘ğ‘ğ‘Ÿğ‘’ğ‘›ğ‘¡ es :new esâ‚ :name adjoin-retractâ‚)))
       (when adjoin-retractâ‚‚ (list (element-retract p     ($ğ‘’ğ‘™ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘ -ğ‘œğ‘“ p) :new esâ‚‚ :name adjoin-retractâ‚‚)))))))
#+END_SRC
#+LaTeX: \setminted[common-lisp]{fontsize=\footnotesize, breaklines}

#+latex: \centerline{\alert{Combinators are motivated from existing, real-world, DTL libraries!}}

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(.5,6){\colorbox{yellow}{\Large Framework built around \textbf{5 metaprimitives}}}
\put(.5,5.4){\colorbox{yellow}{\Large â†¦ Lisp Metaprogramming, untyped string manipulation, }}
\put(.5,4.8){\colorbox{yellow}{\Large â†¦ Macro DSL, Agda generation }}

\pause
\put(.5,2.8){\colorbox{yellow}{\Large â‡’ The rest are â€œuser-definedâ€ with a bit of Lisp}}
\end{picture}
#+end_export

** Generated 200+ theories using the Lisp metaprogramming framework ---the MathScheme library

# +ATTR_LATEX: :width 0.75\paperwidth :height 0.75\paperheight
# [[file:~/thesis-proposal/200+specs.png]]

#+LaTeX: \setminted[haskell]{fontsize=\tiny, breaklines}
#+BEGIN_SRC haskell
AdditiveMagma            = Magma renamingâ€² "_*_ to _+_"
LeftDivisionMagma        = Magma renamingâ€² "_*_ to _â•²_"
RightDivisionMagma       = Magma renamingâ€² "_*_ to _â•±_"
LeftOperation            = MultiCarrier extended-byâ€² "_âŸ«_ : U â†’ S â†’ S"
RightOperation           = MultiCarrier extended-byâ€² "_âŸª_ : S â†’ U â†’ S"
IdempotentMagma          = Magma extended-byâ€² "*-idempotent : âˆ€ (x : U) â†’ (x * x) â‰¡ x"
IdempotentAdditiveMagma  = IdempotentMagma renamingâ€² "_*_ to _+_"
SelectiveMagma           = Magma extended-byâ€² "*-selective : âˆ€ (x y : U) â†’ (x * y â‰¡ x) âŠ (x * y â‰¡ y)"
SelectiveAdditiveMagma   = SelectiveMagma renamingâ€² "_*_ to _+_"
PointedMagma             = Magma unionâ€² PointedCarrier
PointedğŸ˜Magma            = PointedMagma renamingâ€² "e to ğŸ˜"
AdditivePointed1Magma    = PointedMagma renamingâ€² "_*_ to _+_; e to ğŸ™"
LeftPointAction          = PointedMagma extended-by "pointactLeft  :  U â†’ U; pointactLeft x = e * x"
RightPointAction         = PointedMagma extended-by "pointactRight  :  U â†’ U; pointactRight x = x * e"
CommutativeMagma         = Magma extended-byâ€² "*-commutative  :  âˆ€ (x y : U) â†’  (x * y) â‰¡ (y * x)"
CommutativeAdditiveMagma = CommutativeMagma renamingâ€² "_*_ to _+_"
PointedCommutativeMagma  = PointedMagma unionâ€² CommutativeMagma âŸ´ :remark "over Magma"
AntiAbsorbent            = Magma extended-byâ€² "*-anti-self-absorbent  : âˆ€ (x y : U) â†’ (x * (x * y)) â‰¡ y"
SteinerMagma             = CommutativeMagma unionâ€² AntiAbsorbent âŸ´ :remark "over Magma"
Squag                    = SteinerMagma unionâ€² IdempotentMagma âŸ´ :remark "over Magma"
PointedSteinerMagma      = PointedMagma unionâ€² SteinerMagma âŸ´ :remark "over Magma"
UnipotentPointedMagma    = PointedMagma extended-byâ€² "unipotent  : âˆ€ (x : U) â†’  (x * x) â‰¡ e"
Sloop                    = PointedSteinerMagma unionâ€² UnipotentPointedMagma
#+END_SRC
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(2,6){\colorbox{yellow}{\Large Terse, readable, specifications}}
\put(2,5.4){\colorbox{yellow}{\Large â†¦ Useful, typecheckable, dauntingly large code }}

\pause
\put(2,4){\colorbox{yellow}{\Large 200+ \textbf{one-line} specs}}
\put(2,3.4){\colorbox{yellow}{\Large \hspace{1em} â†¦ 1500+ lines of typechecked Agda}}
\pause
\put(2,2.8){\colorbox{yellow}{\Large â‡’ 750\% efficiency savings}}

\put(2,1.4){\colorbox{yellow}{\Large Useful engineering result}}
\end{picture}
#+end_export

** Primary Lessons Learned


\pause
+ Waist :: The difference between *field* and *parameter* is an illusion ---as is that of *input*
  and *output* when one considers relations rather than deterministic functions.
  \pause \vspace{1em}

+ Termtypes :: Record types (Î£), type classes (Î Â¹Î£), and algebraic data types
  (ğ’²) are all valid *semantics of contexts* ---which are â€œname : type =
  optional-definitionâ€ tuples.
  \pause \vspace{1em}

+ Pragmatic :: We have an extendable, \pause expressive, \pause and efficient
  interface based on a small kernel, \pause that is immediately usable, \pause
  as an editor extension; \pause what about an in-language (DTL) library?

:ignore:

-----

User-defined variational: /Drop definitions when lifting fields into parameters./
# [[file:~/thesis-proposal/waist.png]]
#+LaTeX: \setminted[common-lisp]{fontsize=\tiny, breaklines}
#+BEGIN_SRC emacs-lisp
(ğ’± unbundling n
 = "Turn the first N elements into parameters to the PackageFormer.

    Any elements above the waist line have their equations dropped."
   :waist n
   :alter-elements (Î» es â†’
     (-let [i 0]
       (--graph-map (progn (incf i) (<= i n))
                    (map-equations (-const nil) it)
                    es))))
#+END_SRC
#+LaTeX: \setminted[common-lisp]{fontsize=\footnotesize, breaklines}
:end:

** COMMENT How Does This Work?

 + Currently implemented  as an â€œeditor tacticâ€ meta-program
 + Using the â€œdefault IDEâ€ of Agda Emacs
 + Implementation is an *extensible* library built on top of 5 meta-primitives
 + Generated Agda file is automatically imported into the current file
 + Special-purpose IDE support
 +  Menus, highlighting new syntax, fold away 700-blocks, discard annotations.

** COMMENT The Language of Variationals

   $$\mathsf{Variational} \quad â‰… \quad (\mathsf{PackageFormer} â†’ \mathsf{PackageFormer})$$

 \begin{code}
   id                       :  Variational
   _âŸ´_                      :  Variational â†’ Variational â†’ Variational
   record                   :  Variational
   termtype                 :  String â†’ Variational
   termtype-with-variables  :  String â†’ Variational
   unbundled                :  â„• â†’ Variational
   exposing                 :  List Name â†’ Variational
 \end{code}

** COMMENT Library Design

 + Goals:
   + Reusability
   + Generality
   + (Mathematical) â€œNaturalityâ€

 + Result: *Conflict of Interests:*

    For a record type bundling up items that â€œnaturallyâ€ belong together:
    + Which parts of that record should be red:parameters?
    + Which parts should be green:fields?

* The Unbundling Problem ---in Agda

# The *Context* Library: Solving the unbundling problem
** COMMENT Monoid ---â€œUntyped Compositionâ€

- We have things, called src_haskell[:exports code]{Carrier},
- â€¦ and we want to â€˜combineâ€™ them via some operation src_haskell[:exports code]{_â¨¾_}
- â€¦ which has a â€˜do nothingâ€™ value src_haskell[:exports code]{Id}.

** COMMENT Typeclass approach, as in Haskell

#+begin_src haskell
record MonoidOn (Carrier : Set) : Set
 where
  field
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    leftId : âˆ€ x â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ x â†’ x â¨¾ Id â‰¡ x
    assoc   : âˆ€ x y z â†’  (x â¨¾ y) â¨¾ z
                       â‰¡  x â¨¾ (y â¨¾ z)
#+end_src

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
open MonoidOn {{...}}
#+end_src

** COMMENT Examples
#+ATTR_REVEAL: :frag (appear)
- Programs and sequential (or parallel) composition
- *Numbers and addition (or multiplication)*
- Writing words on a page ---i.e., lists and catenation

** What is â€œtheâ€ monoid on the natural numbers?

Haskell's solution is to make *two isomorphic copies* of numbers since typeclass
instance search relies on /unique/ instances for the typeclass parameters.

#+begin_quote
Some types can be viewed as a monoid in more than one way, e.g. both addition
and multiplication on numbers. In such cases we often define newtypes and make
those instances of Monoid, e.g. Sum and Product.
---[[https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Monoid.html#t:Monoid][Hackage Data.Monoid]]
#+end_quote

#+begin_center
#+begin_src haskell
                       Sum Î± â‰… Î±  {- and -} Product Î± â‰… Î±
#+end_src
For src_haskell[:exports code]{Num Î±} they have different monoid instances.
#+end_center

** COMMENT Additive?
#+begin_src haskell
instance
  â„•â‚Š : MonoidOn â„•
  â„•â‚Š = record { _â¨¾_     = _+_
              ; Id      = 0
              ; leftId  = +-identityË¡
              ; rightId = +-identityÊ³
              ;  assoc  = +-assoc }
#+end_src

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
ex : âˆ€ (m n : â„•) â†’ m â¨¾ n  â‰¡  n â¨¾ m
ex = +-comm
#+end_src

#+ATTR_REVEAL: :frag (appear)
 src_haskell[:exports code]{__â¨¾__} is determined to be src_haskell[:exports
code]{_+_}by *instance search* $\star$

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
likewise : âˆ€ (m : â„•) â†’ m â¨¾ Id â‰¡ m
likewise = rightId
#+end_src

** COMMENT â€¦ or Multiplicative?
#+begin_src haskell
instance
  â„•â‚“ : MonoidOn â„•
  â„•â‚“ = record { _â¨¾_     = _*_
              ; Id      = 1
              ; leftId  = *-identityË¡
              ; rightId = *-identityÊ³
              ; assoc   = *-assoc }
#+end_src


#+begin_src haskell
whoops : âˆ€ {m : â„•} â†’ m â¨¾ Id â‰¡ m
whoops = {!!}
#+end_src


$\star$ â„•â‚Š and â„•â‚“ are both candidates! *No unique solution!* $\star$

** Alternate Solution to Multiple Monoid Instance Problem

\pause
*Start* with /fully bundled/ src_haskell[:exports code]{Monoid}
\pause
*then* /expose fields as parameters/ *on the fly*.

\pause
#+begin_center
#+latex: {\Large How?}

\pause
*Reflection!*
#+end_center
\pause
- Unfortunately, current mechanism cannot touch
  src_haskell[:exports code]{record}-s /directly/.
- But every record is a Î£-type...

** Records as Î Ê·Î£-types  ---Partitioned Contexts

- Instead of the nice /syntactic sugar/
  #+begin_src haskell :tangle no
record R (ÎµÂ¹ : Ï„Â¹) â‹¯ (ÎµÊ· : Ï„Ê·) : Set
  where
    field
      ÎµÊ·âºÂ¹ : Ï„Ê·âºÂ¹
      â‹®
      ÎµÊ·âºáµ : Ï„Ê·âºáµ
#+end_src

\pause
- Use a more raw form  ---/eek!/
  #+begin_src haskell :tangle no
R  : Î  ÎµÂ¹   : Ï„Â¹  â€¢ â‹¯ â€¢ Î  ÎµÊ·   : Ï„Ê· â€¢ Set
R  â‰…  Î» ÎµÂ¹  : Ï„Â¹  â€¢ â‹¯ â€¢ Î» ÎµÊ·   : Ï„Ê·
    â€¢ Î£ ÎµÊ·âºÂ¹ : Ï„Ê·âºÂ¹ â€¢ â‹¯ â€¢ Î£ ÎµÊ·âºáµ : Ï„Ê·âºáµ
    â€¢ ğŸ™
#+end_src

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)
\pause
\put(8.3,1.8){\colorbox{yellow}{\Large â‡ â€œparametersâ€}}
\pause
\put(8.3,1.3){\colorbox{yellow}{\Large â‡ â€œfieldsâ€}}
\pause
\put(2.5,0){\colorbox{yellow}{\Large We say $w$ is the \textbf{â€œwaistâ€}}}
\end{picture}
#+end_export

# E.g., src_haskell[:exports code]{MonoidOn} is a Î Â¹Î£ type

** COMMENT Shucks, the Unbundling Problem Strikes Again

If we encode a record as a Î Ê·Î£ type, what if we want
to /instantiate, fix,/ a field ---instead of a parameter?

#+ATTR_REVEAL: :frag (appear)
We thus need a way to *lift parameters to fields*!
#+ATTR_REVEAL: :frag (appear)
( Teaser: src_haskell[:exports code]{Î â†’Î»} ! )

** A *Pragmatic* Notation ---Contexts

#+begin_src haskell :exports none
open import Level renaming (_âŠ”_ to _âŠ_; suc to â„“suc; zero to â„“â‚€)
open import Data.Product
open import Context -- Gives us Î£âˆ¶â€¢, Î âˆ¶â€¢, >>=, âŸ¨â‹¯âŸ©
#+end_src

#+ATTR_REVEAL: :frag (appear)
0. â€œContextsâ€ are exposure-indexed types
   #+begin_src haskell :tangle no
Context = Î» â„“ â†’ (waist : â„•) â†’ Set â„“
#+end_src
   \pause
1. The â€œempty contextâ€ is the unit type
   #+begin_src haskell :tangle no
End : âˆ€ {â„“} â†’ Context â„“
End {â„“} = Î» _ â†’ ğŸ™ {â„“}
#+end_src

   \pause
2. src_haskell[:exports code]{do}-notation!
   #+begin_src haskell :tangle no
_>>=_ : âˆ€ {a b}
      â†’ (Î“ : Context a)
      â†’ (âˆ€ {n} â†’ Î“ n â†’ Context b)
      â†’ Context (a âŠ b)
(Î“ >>= f) zero    = Î£ Î³ âˆ¶ Î“ 0 â€¢ f Î³ 0
(Î“ >>= f) (suc n) = Î  Î³ âˆ¶ Î“ n â€¢ f Î³ n
#+end_src

\pause
#+begin_center
The *â€œDIYâ€* lies at ~>>=~, permitting Î£, Î , ğ’², ~let~, â€¦ !
#+end_center

** Example Context ---Monoids

 #+begin_src haskell
Monoid : Context â„“â‚
Monoid = do Carrier â† Set
            _â¨¾_     â† (Carrier â†’ Carrier â†’ Carrier)
            Id      â† Carrier
            leftId  â† âˆ€ (x : Carrier) â†’ x â¨¾ Id â‰¡ x
            rightId â† âˆ€ (x : Carrier) â†’ Id â¨¾ x â‰¡ x
            assoc   â† âˆ€ (x y z) â†’ (x â¨¾ y) â¨¾ z  â‰¡  x â¨¾ (y â¨¾ z)
            End {â„“}
#+end_src

** COMMENT =Context= Agda Library â‡’ *Pragmatic Interface*

   # [[file:~/thesis-proposal/pragmattic.png]]

#+latex: \centering
#+latex: \begin{minipage}[t]{0.95\linewidth}
#+begin_src haskell
Monoid : âˆ€ â„“ â†’ Context (â„“suc â„“)
Monoid â„“ = do Carrier â† Set â„“
              _âŠ•_    â† (Carrier â†’ Carrier â†’ Carrier)
              Id      â† Carrier
              leftId  â† âˆ€ {x : Carrier} â†’ x âŠ• Id â‰¡ x
              rightId â† âˆ€ {x : Carrier} â†’ Id âŠ• x â‰¡ x
              assoc   â† âˆ€ {x y z} â†’ (x âŠ• y) âŠ• z  â‰¡  x âŠ• (y âŠ• z)
              End {â„“}
#+end_src
#+latex:   \end{minipage}

\pause \vspace{1em}
- Ideas: /Weak/ *Agda Reflection*, No fresh names, Monads, Termination,
  â€˜Reificationâ€™ Î â†’Î»

#  \pause  \vspace{1em}

** *Using* Contexts ---@@latex:\emph{re\"{\i}fication}@@

+ If src_haskell[:exports code]{C : Context â„“â‚€} then src_haskell[:exports
  code]{C w} has the type ~Î Ê· x â€¢ Ï„~ ---consisting of /w/-many Î 's---
  \pause but we want to *apply* src_haskell[:exports code]{C w} to /w/-many /parameters/...

   \vspace{1em} \pause
+ So we need a combinator...
  #+begin_center
    #+begin_src haskell
 Î â†’Î»  â€œÎ Ê· x â€¢ Ï„â€   =   â€œÎ»Ê· x â€¢ Ï„â€
#+end_src
  #+end_center

\vspace{1em}\pause
+ with an infix form for contexts in particular ...
  #+begin_center
  #+begin_src haskell
C :waist w   =   Î â†’Î» (C w)
#+end_src
  #+end_center
** Characterising =:waist= as Î â†’Î» :Maybe_delete:

 #+BEGIN_SRC haskell
                      Î â†’Î» (Î  a : A â€¢ Ï„)  =  (Î» a : A â€¢ Ï„)
                           C :waist w    =   Î â†’Î» (C w)
 #+END_SRC

 \pause
 -----
 \vspace{0.5em}

 #+begin_parallel 2
 #+begin_src haskell
idâ‚€ : Setâ‚
idâ‚€ = Î  X âˆ¶ Set â€¢ Î  e âˆ¶ X â€¢ X
 #+end_src

 \pause\vspace{.5em}

 #+begin_src haskell
idâ‚ : Î  X âˆ¶ Set â€¢ Set
idâ‚ = Î» (X : Set) â†’ Î  e âˆ¶ X â€¢ X

  #+end_src

 \pause\vspace{.5em}
 #+begin_src haskell
idâ‚‚ : Î  X âˆ¶ Set â€¢ Î  e âˆ¶ X â€¢ Set
idâ‚‚ = Î» (X : Set) (e : X) â†’ X
 #+end_src

 #+latex: \columnbreak

 \pause
 + ~idáµ¢â‚Šâ‚ â‰ˆ Î â†’Î» idáµ¢~
 + ~idâ‚€~ is a /type of functions/
 + ~idâ‚~ is a /function on types/

 #+end_parallel

 :Details:
 We shall refer to the latter change
 as @@latex: \emph{re\"{\i}fication}@@ since the result is more concrete: It can
 be applied. This transformation will be
 denoted by ~Î â†’Î»~. To clarify this subtlety, consider the following forms of the
 polymorphic identity function. Notice that $\mathsf{id}áµ¢$ /exposes/ =i=-many details at the
 type level to indicate the sort of data it consists of. However, notice that ~idâ‚€~ is
 a type of functions whereas $\mathsf{id}â‚$ is a function on types. Indeed, the latter
 :End:

** Monoidáµ¢

#+begin_src haskell :tangle no
Monoid : Context
Monoid = do C â† Set; _â¨¾_ : C â†’ C â†’ C; Id â† C; â€¦
#+end_src

\pause
With no parameters, we have a Î â°Î£-type (a *record*)
#+begin_src haskell :tangle no
Monoid :waist 0  : Setâ‚
Monoid :waist 0  â‰¡  Î£ C : Set â€¢ Î£ _â¨¾_ : C â†’ C â†’ C â€¢ Î£ Id : C â€¢ â€¦
#+end_src

\pause
With *one* parameter, we have a *typeclass*
#+begin_src haskell :tangle no
Monoid :waist 1  :  Î  C : Set â€¢ Set
Monoid :waist 1  =  Î» C : Set â€¢ Î£ _â¨¾_ : C â†’ C â†’ C â€¢ Î£ Id : C â€¢ â€¦
#+end_src

\pause
With *two* parameters, we have a /â€˜solutionâ€™/ to the
additive-or-multiplicative-monoid-problem!
   #+begin_src haskell :tangle no
Monoid :waist 2  :  Î  C : Set) â€¢ Î  _â¨¾_ : C â†’ C â†’ C â€¢ Set
Monoid :waist 2  =  Î» C : Set â€¢ Î» _â¨¾_ : C â†’ C â†’ C â€¢ Î£ Id : C â€¢ â€¦
#+end_src

** Example Instance ---Additive Naturals
#+begin_src haskell
                          â„•â‚Š  : (Monoid â„“â‚€ :waist 1) â„•
                          â„•â‚Š  = âŸ¨ _+_           -- _â¨¾_
                                , 0             -- Id
                                , +-identityË¡
                                , +-identityÊ³
                                , +-assoc
                                âŸ©
#+end_src

** COMMENT Relationships between various forms

#+begin_src haskell :tangle no
Monoid : Context -- i.e., (w : â„•) â†’ Set

Monoid :waist ğ“Œ   :  Î Ê· â‹¯ â€¢ Set
Monoid :waist ğ“Œ   =  Î»Ê· â€œparametersâ€ â€¢ â€œfieldsâ€
#+end_src

** COMMENT 11 Line Implementation ---thanks Ulf!

*** The Core _Syntactic_ Transformation

 #+begin_src haskell :tangle no
--  Î  a : A â€¢ B a   â†¦   Î» a : A â€¢ B a

Î â†’Î»-helper : Term â†’ Term

Î â†’Î»-helper (pi a (abs x b))
  = lam visible (abs x (Î â†’Î»-helper b))

Î â†’Î»-helper x
  = x
 #+end_src

*** Keeping Track of Types

 src_haskell[:exports code]{Term} denotes untyped Î»-terms,
 so let's keep track of the types when we convert Î s to Î»s.

 #+begin_src haskell :tangle no
Î â†’Î»-type : Term â†’ Term

Î â†’Î»-type (pi a (abs x b))
 = pi a  (abs x (Î â†’Î»-type b))

Î â†’Î»-type x
 = unknown
 #+end_src

*** Putting them together

 #+html:<small>
 #+begin_src haskell :tangle no
macro
  Î â†’Î» : Term â†’ Term â†’ TC Unit.âŠ¤
  Î â†’Î» Ï„ goal
   =  normalise Ï„
       >>=â‚œâ‚‘áµ£â‚˜ Î» Ï„â€² â†’ checkType goal (Î â†’Î»-type Ï„â€²)
       >>=â‚œâ‚‘áµ£â‚˜ Î» _ â†’  unify goal (Î â†’Î»-helper Ï„â€²)
 #+end_src
 #+html:</small>

** Lessons Learned

On-the-fly unbundling can be implemented as an in-language library in a
dependently-typed language with sufficient reflection capabilities :-)

\[\star\; \star\; \star\]

The src_haskell[:exports code]{Context} approach /inherits/ the strengths and
limitations of the host language.

** Comparing =PackageFormer= and =Context=
   # [[file:~/thesis-proposal/PF-Context-comparision.png]]

  |                          | PackageFormer      | Contexts             |
  |--------------------------+--------------------+----------------------|
  | Type of Entity           | Preprocessing Tool | Language Library     |
  | Specification Language   | Lisp + Agda        | Agda                 |
  | Well-formedness Checking | âŒ               | âœ“                    |
  | Termination Checking     | âœ“                  | âœ“                    |
  | Elaboration Tooltips     | âœ“                  | âŒ                 |
  | Rapid Prototyping        | âœ“                  | âœ“ (Slower)           |
  | Usability Barrier        | None               | None                 |
  | Extensibility Barrier    | Lisp               | Weak Metaprogramming |
** COMMENT Related Problem: Control over Parameter Instantiation

 Instances of Haskell typeclasses
 + are indexed by \textbf{types} only
 + so that there can be only one ~Monoid~ instance for ~Bool~

 Crude solution: Isomorphic copies with different type \textbf{name}:
 \begin{code}
 data Bool   = False | True
 \end{code}

 \begin{code}
 newtype All = All { getAll :: Bool } -- for ~Monoid~ instance based on conjunction
 \end{code}

 \begin{code}
 newtype Any = Any { getAny :: Bool } -- for ~Monoid~ instance based on disjunction
 \end{code}

* GADTs are Contexts too!

** From Contexts to GADTS

src_haskell[:exports code]{Monoid}
   # \pause@@html: <small>@@ definition@@html: </small>@@

#+latex: \pause âŸ¿ % \hfill {\small (definition)}
#+begin_src haskell
do C â† Set; _â¨¾_ : C â†’ C â†’ C; Id : C; â€¦
#+end_src
   # \pause@@html: <small>@@ go to waist 1 to get a parameterised record@@html:
   # </small>@@

#+latex: \pause âŸ¿ % \hfill {\small (:waist 1)}
#+begin_src haskell
Î» C : Set â€¢ Î£ _â¨¾_ : C â†’ C â†’ C â€¢ Î£ Id : C â€¢ â€¦
#+end_src

   # \pause@@html: <small>@@ Termtype constructors all target the same type, say ~C~, so drop all others@@html: </small>@@

#+latex: \pause âŸ¿ % \hfill {\small (Drop all non-C valued ops)}
#+begin_src haskell
Î» C : Set â€¢ Î£ _â¨¾_ : C â†’ C â†’ C â€¢ Î£ Id : C â€¢ ğŸ™
#+end_src
   # \pause@@html: <small>@@ Termtype are sums of products@@html: </small>@@

#+latex: \pause âŸ¿ % \hfill {\small (Sums of products)}
#+begin_src haskell
Î» C : Set â€¢       C Ã— C    âŠ         C âŠ ğŸ™
#+end_src
   # \pause@@html: <small>@@ Termtypes are fixpoints of type constructors@@html: </small>@@

#+latex: \pause âŸ¿ % \hfill {\small (Fixpoints)}
#+begin_src haskell
Î¼ C : Set â€¢       C Ã— C    âŠ         C âŠ ğŸ™
#+end_src

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

% \pause
% \put(2,5){\colorbox{yellow}{\Large As a macro...}}
% \pause
\put(2,4){\colorbox{yellow}{\Large \texttt{termtype : UnaryFunctor â†’ Type}}}
\put(2,3.4){\colorbox{yellow}{\Large \texttt{termtype Ï„ = Fix (Î£â†’âŠ (sources Ï„))}}}
\end{picture}
#+end_export

** Monoids give rise to tree skeletons / Context
#+begin_src haskell :tangle no
Monoid : âˆ€ â„“ â†’ Context (â„“suc â„“)
Monoid â„“ = do Carrier â† Set â„“
              _â¨¾_     â† (Carrier â†’ Carrier â†’ Carrier)
              Id      â† Carrier
              leftId  â† âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
              rightId â† âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x
              assoc   â† âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z  â‰¡  x â¨¾ (y â¨¾ z)
              End {â„“}
#+end_src

** Monoids give rise to tree skeletons / Termtype

#+begin_src haskell
  ğ•„ : Set
  ğ•„ = termtype (Monoid â„“â‚€ :waist 1)
#+end_src

#+begin_src haskell
  that-is : ğ•„
          â‰¡ Fix (Î» X â†’
                -- _âŠ•_, branch
                X Ã— X Ã— ğŸ™
                -- Id, nil leaf
              âŠ ğŸ™
                -- invariant leftId
              âŠ ğŸ˜
                -- invariant rightId
              âŠ ğŸ˜
                -- invariant assoc
              âŠ ğŸ˜
                --  the â€œEnd {â„“}â€
              âŠ ğŸ˜)
  that-is = refl
            #+end_src

** Monoids give rise to tree skeletons / Readability
# Pattern synonyms for more compact presentation
            #+begin_src haskell
-- : ğ•„
pattern emptyM
    = Î¼ (injâ‚‚ (injâ‚ tt))
#+end_src

#+begin_src haskell
-- : ğ•„ â†’ ğ•„ â†’ ğ•„
pattern branchM l r
    = Î¼ (injâ‚ (l , r , tt))
#+end_src

#+begin_src haskell
-- absurd ğŸ˜-values
pattern absurdM a
    = Î¼ (injâ‚‚ (injâ‚‚ (injâ‚‚ (injâ‚‚ a))))
#+end_src

** Monoids give rise to tree skeletons / ~termtype Monoid â‰… TreeSkeleton~

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
  data TreeSkeleton : Set where
    empty  : TreeSkeleton
    branch : TreeSkeleton â†’ TreeSkeleton â†’ TreeSkeleton
#+end_src


#+ATTR_REVEAL: :frag (appear)
- â€œdoing nothingâ€
   #+begin_src haskell
  to : ğ•„ â†’ TreeSkeleton
  to emptyM        = empty
  to (branchM l r) = branch (to l) (to r)
  to (absurdM (injâ‚ ()))
  to (absurdM (injâ‚‚ ()))
#+end_src


#+ATTR_REVEAL: :frag (appear)
- â€œdoing nothingâ€
   #+begin_src haskell
  from : TreeSkeleton â†’ ğ•„
  from empty        = emptyM
  from (branch l r) = branchM (from l) (from r)
#+end_src

** COMMENT Dynamical Systems give rise to â„•
** COMMENT Context

#+begin_src haskell
DynamicSystem : Context â„“â‚
DynamicSystem = do State â† Set
                   start â† State
                   next  â† (State â†’ State)
                   End {â„“â‚€}
                       #+end_src

** COMMENT Termtype
                           #+begin_src haskell
ğ”» = termtype (DynamicSystem :waist 1)
#+end_src
Pattern synonyms for more compact presentation
#+begin_src haskell
-- : ğ”»
pattern startD
    = Î¼ (injâ‚ tt)

-- : ğ”» â†’ ğ”»
pattern nextD e = Î¼ (injâ‚‚ (injâ‚ e))
#+end_src

** COMMENT ~termtype ğ”» â‰… â„•~
#+begin_src haskell
    to : ğ”» â†’ â„•
    to startD    = 0
    to (nextD x) = suc (to x)

    from : â„• â†’ ğ”»
    from zero    = startD
    from (suc n) = nextD (from n)
#+end_src

** COMMENT Pointed Sets give rise to terminal types

#+begin_src haskell
PSet  : Context (â„“suc â„“â‚€)
PSet  = do Carrier â† Set â„“â‚€
           point  â† Carrier
           End {â„“â‚€}
#+end_src

#+ATTR_REVEAL: :frag appear
#+begin_src haskell
â„™ğ•Šğ•–ğ•¥ : Set
â„™ğ•Šğ•–ğ•¥ = termtype (PSet :waist 1)
#+end_src

#+ATTR_REVEAL: :frag appear
#+begin_src haskell
to : â„™ğ•Šğ•–ğ•¥ â†’ ğŸ™ {â„“â‚€}
to emptyM = tt

from : ğŸ™ {â„“â‚€} â†’ â„™ğ•Šğ•–ğ•¥
from _ = Î¼ (injâ‚ tt)
#+end_src

** COMMENT (Simple) Graphs give rise to pairs


#+begin_src haskell
Graph  : Context (â„“suc â„“â‚€)
Graph = do Node â† Set
           Edge â† Set
           adjacency â† (Node â†’ Node â†’ Edge)
           End {â„“â‚€}
#+end_src

#+ATTR_REVEAL: :frag appear
#+begin_src haskell
ğ”¾ğ•£ğ•’ğ•¡ğ•™ : Set â†’ Set
ğ”¾ğ•£ğ•’ğ•¡ğ•™ X = termtype ((Graph :waist 2) X)
#+end_src

#+ATTR_REVEAL: :frag appear
#+begin_src haskell
pattern _â‡Œ_ x y = Î¼ (injâ‚ (x , y , tt))

view : âˆ€ {X} â†’ ğ”¾ğ•£ğ•’ğ•¡ğ•™ X â†’ X Ã— X
view (x â‡Œ y) = x , y
#+end_src

** COMMENT Indexed unary algebras (â€œactionsâ€) give rise to streams

** COMMENT Context
#+begin_src haskell
Action  : Context â„“â‚
Action  = do Value    â† Set
             Program  â† Set
             run      â† (Program â†’ Value â†’ Value)
             End {â„“â‚€}
#+end_src
** COMMENT Termtype
#+begin_src haskell
ğ”¸ğ•”ğ•¥ğ•šğ• ğ•Ÿ : Set â†’ Set
ğ”¸ğ•”ğ•¥ğ•šğ• ğ•Ÿ X = termtype ((Action :waist 2) X)
#+end_src

#+begin_src haskell
-- : X â†’ ğ”¸ğ•”ğ•¥ğ•šğ• ğ•Ÿ X â†’ ğ”¸ğ•”ğ•¥ğ•šğ• ğ•Ÿ X
pattern _âˆ·_ head tail
         = Î¼ (injâ‚ (tail , head , tt))
#+end_src

** COMMENT â€¦ to stream
#+begin_src haskell
record Stream (X : Set) : Set   where
  coinductive
  field
    hd : X
    tl : Stream X

open Stream
#+end_src
#+ATTR_REVEAL: :frag appear
#+begin_src haskell
view : âˆ€ {I} â†’ ğ”¸ğ•”ğ•¥ğ•šğ• ğ•Ÿ I â†’ Stream I
hd (view (h âˆ· t)) = h
tl (view (h âˆ· t)) = view t
#+end_src

** COMMENT Collection theories give rise to lists

#+begin_src haskell
Collection : âˆ€ â„“ â†’ Context (â„“suc â„“)
Collection â„“ = do Elem      â† Set â„“
                  Container â† Set â„“
                  insert    â† (Elem â†’ Container â†’ Container)
                  âˆ…         â† Container
                  End {â„“}
#+end_src

#+ATTR_REVEAL: :frag appear
#+begin_src haskell
â„‚ : Set â†’ Set
â„‚ Elem = termtype ((Collection â„“â‚€ :waist 2) Elem)
#+end_src
#+ATTR_REVEAL: :frag appear
#+begin_src haskell
-- : X â†’ â„‚ X â†’ â„‚ X
pattern _::_ x xs
         = Î¼ (injâ‚ (x , xs , tt))

-- : â„‚ X
pattern  âˆ…
    = Î¼ (injâ‚‚ (injâ‚ tt))
#+end_src

** Summary

| â€˜theoryâ€™ Ï„     | â€˜data structureâ€™ ~termtype Ï„~ |
|----------------+-----------------------------|
| pointed set    | ğŸ™                           |
| dynamic system | â„•                           |
| monoid         | tree skeletons              |
| collections    | lists                       |
| graphs         | (homogeneous) pairs         |
| actions        | infinite streams            |

#+begin_quote
/Many more theories Ï„ to explore and see what data structures arise!/
#+end_quote
* Contributions

** Module Systems for DTLs

0. [@0] Identify the \alert{module design patterns} used by DTL practitioners

   \pause
1. The ability to /implement/ module systems \alert{for DTLs within DTLs}

   #+latex: \vspace{1em} \pause
2. The ability to arbitrarily \alert{extend} such systems by users at a high-level

      #+latex: \vspace{1em} \pause
3. Demonstrate that there is an expressive yet minimal set of
   \alert{module meta-primitives} which allow common module constructions to be defined

   # **Unifying Seemingly Disparate Notions of Modules
      #+latex: \vspace{1em} \pause
4. Demonstrate that relationships between modules can also be \alert{mechanically}
   generated.
   # - In particular, if module â„¬ is obtained by applying a user-defined
   #   â€˜variationalâ€™ to module ğ’œ, then the user could also enrich the child module
   #   â„¬ with morphisms that describe its relationships to the parent module ğ’œ.
   # - E.g., if â„¬ is an extension of ğ’œ, then we may have a â€œforgetful mappingâ€
   #   that drops the new components; or if â„¬ is a â€˜minimalâ€™ rendition of the
   #   theory ğ’œ, then we have a â€œsmart constructorâ€ that forms the rich ğ’œ by only
   #   asking the few â„¬ components of the user.

** Termtypes as Modules

#+latex: \centering

5. [@5] Bring \alert{algebraic data types} under the umbrella of grouping mechanisms:
   An ADT is just a context whose symbols target the ADT â€˜carrierâ€™ and
   are not otherwise interpreted.
   - In particular, both an ADT and a record can be obtained *practically* from
     a *single* context declaration.

\pause

\vspace{-0.5em}
#+begin_parallel 2

# +ATTR_LATEX: :width 0.45\paperwidth :height 0.35\paperheight
#+begin_src haskell
DynamicSystem : Context â„“â‚
DynamicSystem
    = do State â† Set
         start â† State
         next  â† (State â†’ State)
         End
#+end_src
# [[file:~/thesis-proposal/unbundling-DS-0.png]]

#+latex: \columnbreak

\pause
# +ATTR_LATEX: :width 0.2\paperwidth :height 0.2\paperheight
# [[file:~/thesis-proposal/DS-data.png]]

#+begin_src haskell
data ğ”» : Set where
    startD : ğ”»
    nextD  : ğ”» â†’ ğ”»
#+end_src

#+end_parallel

\pause
\vspace{-1.3em}
-----
\vspace{-2em}
#+latex: \begin{minipage}[t]{0.85\linewidth}
#+begin_src haskell
ğ”» = termtype (DynamicSystem :waist 1)

-- Pattern synonyms for more compact presentation
pattern startD  = Î¼ (injâ‚ tt)       -- : ğ”»
pattern nextD e = Î¼ (injâ‚‚ (injâ‚ e)) -- : ğ”» â†’ ğ”»
trivial : ğ”» â‰… â„•
#+end_src
#+latex: \end{minipage}

# +latex: \setlength{\unitlength}{1cm} \begin{picture}(0,0)(0,0)
# +latex: \put(6,-1.55){
# +ATTR_LATEX: :width 0.45\paperwidth :height 0.4\paperheight
# [[file:~/thesis-proposal/DS-termtype.png]]
# +latex: }
# +latex: \end{picture}

** Common data-structures as *free* termtypes
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

6. [@6] Show that common data-structures are \alert{mechanically the (free) termtypes} of
   common modules.

\centering
\vspace{-1em}
\pause

   | Module System         | Termtype |
   |-----------------------+----------|
   | Dynamical Structures  | Naturals |
   | Collection Structures | Lists    |
   | Pointed Structures    | Maybe    |

\vspace{-1em}
\pause

# +ATTR_LATEX: :width 0.45\paperwidth :height 0.5\paperheight
# [[file:~/thesis-proposal/lists-as-free-collections.png]]

#+LaTeX: \setminted[haskell]{fontsize=\scriptsize, breaklines}
#+begin_src haskell
Collection : âˆ€ â„“ â†’ Context (â„“suc â„“)
Collection â„“ = do Elem    â† Set â„“
                  Carrier â† Set â„“
                  insert  â† (Elem â†’ Carrier â†’ Carrier)
                  âˆ…       â† Carrier
                  End {â„“}

List : Set â†’ Set
List ElemType = termtype ((Collection â„“â‚€ :waist 2) ElemType)

pattern _::_ x xs = Î¼ (injâ‚ (x , xs , tt))
pattern  âˆ…        = Î¼ (injâ‚‚ (injâ‚ tt))
#+end_src
#+LaTeX: \setminted[haskell]{fontsize=\footnotesize, breaklines}

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "committee.pdf"))

** Solve the unbundling problem ---all in Agda!

7. [@7] The ability to â€˜unbundleâ€™ module fields as if they were parameters â€˜on
   the flyâ€™

\pause
\vspace{-1.2em}
-----
#+begin_parallel 2
# +ATTR_LATEX: :width 0.45\paperwidth :height 0.5\paperheight
#+begin_src haskell
DynamicSystem : Context â„“â‚
DynamicSystem
    = do State â† Set
         start â† State
         next  â† (State â†’ State)
         End
#+end_src
# [[file:~/thesis-proposal/unbundling-DS-0.png]]

\pause
# \columnbreak
# +ATTR_LATEX: :width 0.45\paperwidth :height 0.5\paperheight
# [[file:~/thesis-proposal/unbundling-DS-1.png]]

#+BEGIN_SRC haskell
ğ’©â° : DynamicSystem :waist 0
ğ’©â° = âŸ¨ â„• , 0 , suc âŸ©

ğ’©Â¹ : (DynamicSystem :waist 1) â„•
ğ’©Â¹ = âŸ¨ 0 , suc âŸ©

ğ’©Â² : (DynamicSystem :waist 2) â„• 0
ğ’©Â² = âŸ¨ suc âŸ©

ğ’©Â³ : (DynamicSystem :waist 3) â„• 0 suc
ğ’©Â³ = âŸ¨âŸ©
#+END_SRC
#+end_parallel

*Without redefining src_haskell[:exports code]{DynamicSystem}*, we are able to *fix*
some of its /fields/ by making them into /parameters/!

*** COMMENT more
\pause
#+begin_export latex
  % X-axis to the right and Y-axis upwards
  \setlength{\unitlength}{1cm}
  \begin{picture}(0,0)(0,0)
   \put(0,2.5){\textbf{Without redefining \texttt{DynamicSystem}},}
   \put(0,2.0){we are able to \textbf{fix} some of its fields}
   \put(0,1.5){by making them into parameters!}
\end{picture}
#+end_export

\pause
\vspace{-3em}
-----
\vspace{-0.5em}
#+begin_footnotesize org
# Using ~:waist ğ’¾~ we may fix the first ~ğ’¾~-parameters ahead of time.
# \vspace{-1em}
# + =(DynamicSystem :waist 1) â„•= is /the type of dynamic systems over carrier â„•/
# \vspace{-1em}

The type of dynamic systems *over* carrier â„• and start state 0
\newline is =(DynamicSystem :waist 2) â„• 0=.
#+end_footnotesize

# (progn (org-beamer-export-to-pdf) (switch-to-buffer "committee.pdf"))

:Examples_in_the_wild:

Examples of the need for such on-the-fly unbundling can be found in numerous
places in the Haskell standard library. For instance, the standard libraries cite:data_monoid
have two isomorphic copies of the integers, called ~Sum~ and ~Product~, whose reason
for being is to distinguish two common monoids: The former is for /integers with
addition/ whereas the latter is for /integers with multiplication/.

:End:

** Theory & Implementation

8. [@8] Demonstrate that there is a \alert{practical implementation} of such a framework

   - [X] The =Context= framework is implemented in Agda and we've seen practical examples of
     its use.

      #+latex: \vspace{2em} \pause
9. Finally, the resulting framework is /mostly/ \alert{type-theory agnostic}: The target
   setting is DTLs but we only assume the barebones; if users drop parts of that
   theory, then /only/ some parts of the framework will no longer apply.

   - [X] There are various forms of semantics presented in the thesis: Abstract
     semantics via signatures, concrete semantics via Agda functions,
     denotational semantics via Î Î£ğ’², as well as a guide for forming the
     src_haskell[:exports code]{Context} library in other languages.

# - For instance, in DTLs without a fixed-point functor the framework still
#   â€˜appliesâ€™, but can no longer be used to provide arbitrary algebraic data
#   types from contexts.
#

** COMMENT Future Work

 + Explicit (elaboration) semantics for \textsf{PackageFormer}s and
   \textsf{Variational}s within a minimal type theory

   - Refactor meta-primitives from LISP flavour to Agda flavour
   - Integrate with a reflection interface for Agda

 + Explore multiple default definitions

 + Explore inheritance, coercion, and transport along canonical isomorphisms

 + Generate mutually-recursive definitions for certain instances of
   many-sorted \textsf{PackageFormer}s?

** COMMENT Conclusion ---Prototype
+ Naming, terminology, concrete syntax, combinator interfaces
  are all still in flux!

+ The present system already allows to replace hand-written
  instances of structuring schemes
  with invocations of (generative) library methods

+ Our resulting system has turned hand-written instances of structuring schemes from a design
  pattern into full-fledged library methods

+ We already influenced the naming conventions of the Agda ``standard library''

+ Our approach based on \textsf{PackageFormer}s and
  \textsf{Variational}s makes it possible
  - \large to codify, name, and document ``design patterns'' of
       uses of structuring mechanisms
  - \large to enable and encourage re-use at a high level of abstraction
  - \large to drastically reduce the interface size of ``interface libraries''

  and therewith has the potential to *drastically* change how we provide and use
  structures via libraries

** *â€œAllâ€* module constructions are born from =Context=
# [[file:~/thesis-proposal/everything-is-a-context.png]]

# +begin_scriptsize org
    \pause \vspace{0.5em}
+ Context: â€œname-type pairsâ€
  #+BEGIN_SRC haskell
do S â† Set; s â† S; n â† (S â†’ S); End
#+END_SRC
    \pause \vspace{0.5em}

+ Record Type: â€œbundled-up dataâ€
   #+BEGIN_SRC haskell
Î£ S âˆ¶ Set â€¢ Î£ s âˆ¶ S â€¢ Î£ n âˆ¶ S â†’ S â€¢ ğŸ™
#+END_SRC
    \pause \vspace{0.5em}

+ Function Type: â€œa type of functionsâ€
   #+BEGIN_SRC haskell
Î  S â€¢ Î£ s âˆ¶ S â€¢ Î£ n âˆ¶ S â†’ S â€¢ ğŸ™
#+END_SRC
    \pause \vspace{0.5em}

+ Type constructor: â€œa function on typesâ€
   #+BEGIN_SRC haskell
Î» S â€¢ Î£ s âˆ¶ S â€¢ Î£ n âˆ¶ S â†’ S â€¢ ğŸ™
#+END_SRC
    \pause \vspace{0.5em}

+ Algebraic datatype: â€œa descriptive syntaxâ€
   #+BEGIN_SRC haskell
data ğ”» : Set where s : ğ”»; n : ğ”» â†’ ğ”»
#+END_SRC

#+begin_export latex
\setlength{\unitlength}{1cm}
\begin{picture}(0,0)(0,0)

\pause
\put(8,4){\colorbox{yellow}{\Large â‡’ Thank-you}}
\put(8,3.4){\colorbox{yellow}{\Large \hspace{1.7em} for \hspace{2.4em}{\color{yellow}.}}}
\put(8,2.8){\colorbox{yellow}{\Large your time! â‡}}
\end{picture}
#+end_export


# +end_scriptsize
** COMMENT /Thank-you for your time!/

 # \pause
 # \vspace{1em}
 # /Thank-you for your time!/

 \vspace{1em}
 \centerline{Questions?}
* COMMENT Misc Summary

  Common, mechanical, patterns for module construction are just out
  of reach of the module systems of dependently-typed languages.
  Such languages permit a rich number of possible formulations for
  a module, such as by having some of its constituents exposed
  at the type level as parameters, others as fields, and others
  as definitional extensions.

  Library designers are generally conservative; they provide a predicate
  formulation consisting of a set of proof obligations that constrain the
  functional symbols provided as parameters in the type level. This formulation
  is then usually accompanied by a fully â€œbundled upâ€ variation that has no
  parameters and all relevant data is rendered as fields.

  However, trouble arises when library users wish to fix only one field ahead of
  time ---this is the â€œunbundling problemâ€ and it is akin to function uncurrying
  but for modules.

  Moreover, library designers for dependently-typed languages generally only
  provide a handful of formulations for a single module. Other formulations
  must be written out by hand by users, which must then form coercions
  between the new forms and those used in the library, so as to make use
  of the library's utilities.

  I have produced an editor extension for Agda's de-facto IDE, Emacs,
  which reduces the boilerplate for new formulations of modules to
  simple, usually one-line, specifications. The tool is run in the background
  and works on ordinary Agda files by looking at special comments.
  The specifications are expanded into typechecked Agda code.

  Moreover, using the lessons learned from the editor extension, an Agda library
  has been implemented to achieve similar goals within Agda itself.  Due to
  Agda's current metaprogramming limitations, such as the inability to produce
  fresh names, development with the library is slower than with the editor
  extension.
