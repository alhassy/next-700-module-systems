<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-08-20 Tue 07:51 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Next 700 Module Systems</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Musa Al-hassy" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>

<script type="text/javascript" src="https://orgmode.org/org-info.js">
/**
 *
 * @source: https://orgmode.org/org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in https://orgmode.org/org-info.js.
 *
 * Copyright (C) 2012-2019 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in https://orgmode.org/org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "1");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">The Next 700 Module Systems
<br />
<span class="subtitle">Extending Dependently-Typed Languages to Implement Module System Features In The Core Language</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#introduction">1. Introduction &#x2014;The Proposal's “Story”</a>
<ul>
<li><a href="#orgee7102e">1.1. A Language Has Many Tongues</a></li>
<li><a href="#org9c23220">1.2. Needless Distinctions for Containers</a></li>
<li><a href="#org2dc0ee4">1.3. Proposed Contributions</a></li>
<li><a href="#org738d3e2">1.4. Overview of the Remaining Chapters</a></li>
</ul>
</li>
<li><a href="#current_approaches">2. Current Approaches</a>
<ul>
<li><a href="#orgba88b50">2.1. Expectations of Module Systems</a></li>
<li><a href="#org292fa11">2.2. Ad hoc Grouping Mechanisms</a></li>
<li><a href="#org69e5635">2.3. Existing Systems</a></li>
<li><a href="#orgc7d32fc">2.4. Facets of Structuring Mechanisms: An Agda Rendition</a></li>
<li><a href="#org6a2de21">2.5. Theory Presentations: A Structuring Mechanism</a></li>
</ul>
</li>
<li><a href="#solution_requirements">3. Solution Requirements</a>
<ul>
<li><a href="#orga008de9">3.1. Missing Features</a></li>
<li><a href="#org0517160">3.2. Desirable Features</a></li>
<li><a href="#orgdc946aa">3.3. One-Item Checklist for a Candidate Solution</a></li>
<li><a href="#org59b062f">3.4. Preliminary Research</a>
<ul>
<li><a href="#org3f2710b">3.4.1. First Observation: Syntactic Similarity for Containers</a></li>
<li><a href="#org8fd714c">3.4.2. Second Observation: Computing Similarity for Containers</a></li>
<li><a href="#org3d88793">3.4.3. Next Steps</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#approach_and_timeline">4. Approach and Timeline</a>
<ul>
<li><a href="#org714c72e">4.1. Implementation Matter</a></li>
<li><a href="#org71ce4c8">4.2. Next Steps</a></li>
<li><a href="#orga5744ee">4.3. Timeline</a>
<ul>
<li><a href="#org8ab14fb">4.3.1. The First Pass: May-October 2019</a></li>
<li><a href="#org8db9a3b">4.3.2. The Middle Pass: November 2019 - February 2020</a></li>
<li><a href="#org86aa35f">4.3.3. The Final Pass: March - April 2020</a></li>
<li><a href="#orgae7bf04">4.3.4. Concluding Phase</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#conclusion">5. Conclusion</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgb2bff6f" class="outline-2">
<h2 id="introduction"><span class="section-number-2">1</span> Introduction &#x2014;The Proposal's “Story”</h2>
<div class="outline-text-2" id="text-introduction">
<p>
In this chapter we aim to present the narrative that demonstrates the distinction between
what can currently be accomplished and what is desired when working with composition of software
units. We arrive at the observation that packaging concepts differ only in their use &#x2013;for example,
a typeclass and a record are both sequences of declarations that only differ in the former used
for polymorphism with instance search whereas the latter is used as a structure grouping related items together.
In turn, we are led to propose that the various packaging concepts ought to have a uniform syntax.
Moreover, since records are a particular notion of packaging, the commitment to syntactic similarity
gives rise to a <a href="https://en.wikipedia.org/wiki/Homoiconicity">homoiconic</a> nature to the host language.
</p>

<p>
Within this work we refer to a <i>simple type theory</i> as a language that contains typed lambda terms
for terms and formuale; if in addition it contains typed lambda terms for ‘proofs’
&#x2014;which are members of types that could be interpreted as propositions&#x2014;
then we say it is
a <i>dependently-typed language</i>, or ‘DTL’ for short. More precisely, if type formation is indexed,
i.e., types may depend on a context, then we have a DTL.
With the exception of declarations and ephemeral
notions, nearly everything in a DTL is a typed  lambda term.
Just as Lisp's homoiconic nature blurs data and code leaving it not as a language with primitives
but rather a language with meta-primitives,
so too the lack of distinction between term and type lends itself to generic and uniform concepts in DTLs
thereby leaving no syntactic distinction between a constructive proof and an algorithm.
</p>

<p>
Proofs are not a necessary ingredient for dependent types
(and are anyways only a matter of intent, as you yourself also
 emphasised in the last meeting).
</p>

<p>
The sections below explore our primary observation, which is discussed further
later on in chapter 3 as preliminary research.
Section 1 demonstrates the variety of languages present in a single system
which are conflated in a DTL,
section 2 discusses that such conflation should by necessity apply to notions of packaging,
and section 3 concludes with proposed work to ensure that happens.
</p>

<ul class="org-ul">
<li>In the introduction to section 1, you discuss "the variety of languages present in a single system". I feel this makes sense after reading "A coding language is actually many languages working together" below, but I found it confusing on first read. Maybe put languages in quotes and change system to language?</li>
</ul>
</div>

<div id="outline-container-orgee7102e" class="outline-3">
<h3 id="orgee7102e"><span class="section-number-3">1.1</span> A Language Has Many Tongues</h3>
<div class="outline-text-3" id="text-1-1">
<p>
A programming language is actually many languages working together.
</p>

<p>
The most basic of imperative languages comes with a notion of ‘statement’ that is executed
by the computer to alter ‘state’ and a notion of ‘value’ that can be assigned to memory locations.
Statements may be sequenced or looped, whereas values may be added or multiplied, for example.
In general, the operations on one linguistic category cannot be applied to the other.
Unfortunately, a rigid separation between the two sub-languages means that binary choice, for example,
conventionally invites two notations with identical semantics &#x2014;e.g.; in <code>C</code> one writes <code>if (cond) clause₁ else clause₂</code>
for statements but must use the notation <code>cond?term₁:term₂</code> for values.
Hence, there are value and statement languages.
</p>

<p>
Let us continue using the <code>C</code> language for our examples since it is so ubiquitous
and has influenced many languages. Such a choice has the benefit of referring to
a concrete language, rather than speaking in vague generalities.
Besides Agda &#x2013;a language mentioned throughout the proposal&#x2013;
we shall also refer to Haskell as a representative of the functional
side of programming. For example, in Haskell there is no distinction between values and statements
&#x2014;the latter being a particular instance of the former&#x2014; and so it uses the same notation <code>if_then_else_</code> for both.
However, in practice, statements in Haskell are more pragmatically used as a body of a <code>do</code> block for which
the rules of conditionals and local variables change &#x2013;hence, Haskell is not as uniform as it initially appears.
</p>

<p>
In <code>C</code>, one declares an integer value by <code>int x;</code> but a value of a user-defined type <code>T</code>
is declared <code>struct T x;</code> since, for simplicity, one may think of <code>C</code> having an array named <code>struct</code>
that contains the definitions of user-defined types <code>T</code> and the notation <code>struct T</code> acts as an array access.
Since this is a clunky notation, we can provide an alias using the declaration <code>typedef existing-name new-name;</code>.
Unfortunately, the existing name must necessarily be a type, such as <code>struct T</code> or <code>int</code>, and cannot be an arbitrary
term. One must use <code>#define</code> to produce term aliases, which are handled by the <code>C</code> preprocessor,
which also provides <code>#include</code> to import existing libraries.
Hence, the type language is distinct from the libraries language, which is part of the preprocessor language.
</p>

<p>
In contrast, Haskell has a pragma language for enabling certain features of the compiler. Unlike <code>C</code>, it
has an interface language using <code>typeclass</code>-es which differs from its <code>module</code> language
\parencite{haskell_modules_formally, haskell_in_haskell, classic_haskell_genericity}
since the former's names
may be qualified by the names of the latter but not the other way around. In turn, <code>typeclass</code> names may be used
as constraints on types, but not so with <code>module</code> names. It may be argued that this interface language is part
of the type language, but it is sufficiently different that it could be thought of as its own language \parencite{modular_modules}
&#x2014;for example, it comes with keywords <code>class, instance, =&gt;</code> that can only appear in special phrases.
In addition, by default, variable declarations are the same for built-in and user-defined types &#x2013;whereas <code>C</code> requires using <code>typedef</code> to mimic such behaviour.
However, Haskell distinguishes between term and type aliases.
In contrast, Agda treats aliasing as nothing more than a normal definition.
</p>

<p>
Certain application domains require high degrees of confidence in the correctness of software.
Such program verification settings may thus have an additional specification language.
For <code>C</code>, perhaps the most popular is the ANSI C Specification Language, ACSL \parencite{acsl}.
Besides the <code>C</code> types, ACSL provides a type <code>integer</code> for specifications referring to unbounded integers
as well as numerous other notions and notations not part of the <code>C</code> language. Hence, the specification language
generally differs from the implementation language. In contrast, Haskell's specification are generally \parencite{programatica} in comments
but its relative Agda allows specifications to occur at the type level.
</p>

<p>
Whether programs actually meet their specifications ultimately requires a proof language.
For example, using the Frama-C tool \parencite{frama_c}, ACSL specifications can be supported
by Isabelle or Coq proofs. In contrast, being dependently-typed, Agda allows us to use the implementation
language also as a proof language ---<i>the only distinction is a shift in our perspective; the syntax is the same.</i>
Tools such as Idris and Coq come with ‘tactics’ &#x2014;algorithms which one may invoke to produce proofs&#x2014;
and may combine them using specific operations that only act on tactics, whence yet another tongue.
</p>

<p>
Hence, even the simplest of programming languages contain the first three of the following
sub-languages &#x2013;types may be treated at runtime.
</p>

<ol class="org-ol">
<li>Expression language;</li>
<li>Statement, or control flow, language;</li>
<li>Type language;</li>
<li>Specification language;</li>
<li>Proof language;</li>
<li>Module language;</li>
<li>Meta-programming languages &#x2014;including Coq tactics, C preprocessor, Haskell pragmas, Template Haskell's various quotation brackets <code>[x| ... ]</code>, Idris directives, etc.</li>
</ol>

<p>
As briefly discussed, the first five languages telescope down into one uniform language
within the dependently-typed language Agda. So why not the module language?
</p>
</div>
</div>

<div id="outline-container-org9c23220" class="outline-3">
<h3 id="org9c23220"><span class="section-number-3">1.2</span> Needless Distinctions for Containers</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Computing is compositionality.
Large mind-bending software developments are formed by composing smaller,
much more manageable, pieces together.
How? In the previous section we outlined a number of languages
equipped with term constructors, yet we did not indicate which were
more primitive and which could be derived.
</p>

<p>
The methods currently utilised are ‘ad hoc’,
e.g., “dump the contents of packages into a new \"uber package”.
What about when the packages contain conflicting names?
“Make an uber package with field names for each package's contents”.
What about viewing the new uber package as a hierarchy of its packages?
“Make conversion methods between the two representations.”
─This <i>should be</i> mechanically derivable.
</p>

<p>
In general, there are special-purpose constructs specifically for working
with packages of “usual”, or “day-to-day” expression- or statement-level code.
That is, a language for working with containers whose contents live in another language.
This forces the users to think of these constructs as rare notions that
are rarely needed &#x2014;since they belong to an ephemeral language.
They are only useful when connecting packages together
and otherwise need not be learned.
</p>

<p>
When working with mutually dependent modules, a simple workaround to cyclic
typechecking and loading is to create an interface file containing the
declarations that dependents require. To mitigate such error-prone duplication of
declarations, one may utilise literate programming to tangle the declarations to
multiple files &#x2014;the actual parent module and the interface module.
This was the situation with Haskell before its recent module signature
mechanism \parencite{haskell_backpack}.
Being a purely functional language, it is unsurprising that Haskell treats
nested record field updates awkwardly: Where a C-like language may have \newline
<code>a.b.c := d</code>, Haskell requires <code>a { b = b a {c = d}}</code> which necessarily has
field names <code>b, c</code> polluting the global function namespace as field projections.
Since a record is a possibly deeply nested list of declarations,
it is trivial to flatten such a list to mechanically generate the names
<code>“a-b-c”</code> &#x2014;since the dot is reserved&#x2014; unfortunately this is not possible
in the core language thereby forcing users to employ ‘lenses’ to generate such
accessors by compile-time meta-programming.
In the setting of DTLs, records in the form of nested Σ-types
tend to have tremendously poor performance
&#x2014;in existing implementations of Coq \parencite{coq_cat_experiences} and Agda \parencite{perna},
the culprit generally being projections.
More generally,
what if we wanted to do something with packages that the host language does not
support? “Use a pre-processor, approximate packaging at a different language level,
or simply settle with what you have.”
</p>

<p>
<b>Main Observation</b> Packages, modules, theories, contexts, traits, typeclasses, interfaces, what have you
   all boil down to dependent records at the end of the day and <i>really differ</i> in <i>how</i>
   they are used or implemented. At the end of section 3 we demonstrate various distinct
   presentations of such notions of packaging arising from a single package declaration.
</p>
</div>
</div>

<div id="outline-container-org2dc0ee4" class="outline-3">
<h3 id="org2dc0ee4"><span class="section-number-3">1.3</span> Proposed Contributions</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The proposed thesis investigates the current state of the art of grouping
mechanisms \newline &#x2014;sometimes referred to as modules or packages&#x2014;,
their shortcomings, and a route to implementing candidate solutions
based upon a dependently-typed language.
</p>

<p>
The introduction of first-class structuring mechanisms drastically changes the situation
by allowing the composition and manipulation of structuring mechanisms within the language itself.
Granted, languages providing combinators for structuring mechanisms are not new;
e.g., such notions already exist for Full Maude \parencite{maude_module_algebra}
and B \parencite{B_reuse}. The former is closer in spirit to our work, but
it differs from ours in that it is based on a <i>reflective logic</i>: A logic where
certain aspects of its metatheory can be faithfully represented within the logic itself.
It may well be that the meta-theory of our effort may involve reflection,
yet our distinction is that our aim is to form powerful module system features
for Dependently-Typed Languages (DTLs).
</p>

<p>
To the uninitiated, the shift to DTLs may not appear useful, or at least would
not differ much from existing approaches. We believe otherwise; indeed,
in programming and, more generally, in mathematics,  there are three
&#x2014;below: 1, 2a, 2b&#x2014; essentially
equivalent perspectives to understanding a concept. Even though they
are equivalent, each
perspective has prompted numerous programming languages; as such, the equivalence
does not make the selection of a perspective irrelevant. The perspectives are
as follows:
</p>

<ol class="org-ol">
<li><p>
“Point-wise” or “Constituent-Based”:
A concept is understood by studying the concepts it is “made out of”.
Common examples include:
</p>
<ul class="org-ul">
<li>A mathematical set is determined by the elements it contains.</li>
<li>A method is determined by the sequence
of statements or expressions it is composed from.</li>
<li>A package &#x2014;such as a record or data declaration&#x2014; is determined by
its components, which may be <i>thought of</i> as fields or constructors.</li>
</ul>

<p>
Object-oriented programming is based on the notion of inheritance
  which informs us of “has a” and “is a” relationships.
</p></li>

<li><p>
“Point-free” or Relationship Based:
A concept is understood by its relationship to other concepts in the domain
of discourse. This approach comes into two sub-classifications:
</p>
<ol class="org-ol">
<li><p>
“First Class Citizen” or “Concept as Data”:
The concept is treated as a static entity and is
identified by applying operations <i>onto it</i> in order to observe its nature.
Common examples include:
</p>
<ul class="org-ul">
<li>A singleton set is a set whose cardinality is 1.</li>
<li>A method, in any coding language, is a value with the ability</li>
</ul>
<p>
to act on other values of a particular type.
</p>
<ul class="org-ul">
<li>A renaming scheme to provide different names for a given package;</li>
</ul>
<p>
more generally, applicative modules.
</p></li>

<li><p>
“Second Class Citizen” or “Concept as Method”:
The concept is treated as a dynamic entity that
is fed input stimuli and is understood by its emitted observational output.
Common examples include:
</p>
<ul class="org-ul">
<li>A singleton set is a set for which there is a unique mapping to it</li>
</ul>
<p>
from any other set. Input any set, obtain a map from it to the singleton set.
</p>
<ul class="org-ul">
<li>A method, in any coding language, is unique up to observational equality:</li>
</ul>
<p>
Feed it arguments, check its behaviour. Realistically, one may want to
also consider efficiency matters.
</p>
<ul class="org-ul">
<li>Generative modules as in the <code>new</code> keyword from Object oriented programming:</li>
</ul>
<p>
Basic construction arguments are provided and a container object is produced.
</p></li>
</ol>

<p>
Observing such a sub-classification as distinct led to traditional structural
programming languages, whereas blurring the distinction somewhat led to functional programming.
</p></li>
</ol>

<p>
A simple selection of equivalent perspectives leads to wholly distinct paradigms
of thought. It is with this idea that we propose an implementation of
first-class grouping mechanisms in a dependently typed language
&#x2014;theories have been proposed, on paper, but as just discussed
actual design decisions may have challenging impacts on the overall
system. Most importantly, this is a
<i>requirements driven</i> approach to coherent modularisation constructs in
dependently typed languages.
</p>

<p>
Later on,
we shall demonstrate that
with a sufficiently expressive type system, a number of
traditional programming notions regarding ‘packaging up data’ become conflated
&#x2014;in particular: Records and modules; which for the most
part can all be thought of as ``dependent products with named components''.
Languages without such expressive type systems necessitate certain constraints
on these concepts according to their intended usage
&#x2014;e.g., no multiple inheritance for Java's classes and only one instance for
Haskell's typeclasses.
It is not clear whether such constraints have been brought to more expressive
languages out of necessity, convention, or convenience.
Hence we propose a systematic exploration of the structuring-mechanism
design space for DTLs as a starting point for the design of an appropriate
dependently-typed module system. Along the way, we intend to provide a set
of atomic combinators that suffice as building blocks for generally desirable
features of grouping mechanisms, and moreover we intend to provide an analyses
of their interactions.
</p>

<p>
That is, we want to look at the edge cases of the design space for structuring-mechanism
<i>systems</i>, not only what is considered `convenient' or `conventional'.
Along the way, we will undoubtedly encounter `useless' or non-feasible approaches.
The systems we intend to consider would account for, say, module structures with intrinsic types
&#x2014;hence treating them as first class concepts&#x2014; so that
our examination is based on sound principles.
</p>

<p>
Understandably, some of the traditional constraints have to do with
implementations. For example, a Haskell typeclass is generally implemented as a dictionary
that can, for the most part, be inlined whereas a record is, in some languages, a contiguous memory
block: They can be identified in a DTL, but their uses force different implementation
methodologies and consequently they are segregated under different names.
</p>

<p>
In summary,
the proposed research is to build upon the existing state of module
systems \parencite{types_for_modules} in a dependently-typed setting \parencite{dtls_give_modules} which is substantiated by developing
an extension to a compiler.
The intended outcomes include:
</p>
<ol class="org-ol">
<li>A clean module system for DTLs that treats modules uniformly as any other value type.</li>
<li>A variety of use-cases contrasting the resulting system with previous
approaches.</li>
<li>A module system that enables rather than inhibits efficiency.</li>
<li>Demonstrate that module features traditionally handled using meta-programming can be brought
to the data-value level; thereby not actually requiring the
immense power and complexity of meta-programming.</li>
</ol>

<p>
Most importantly, we intend to implement our theory to obtain
validation that it ‘works’.
</p>
</div>
</div>
<div id="outline-container-org738d3e2" class="outline-3">
<h3 id="org738d3e2"><span class="section-number-3">1.4</span> Overview of the Remaining Chapters</h3>
<div class="outline-text-3" id="text-1-4">
<p>
When a programming languages does not provide sufficiently expressive
primitives for a concept &#x2014;such as typeclass derivation \parencite{deriving_via}&#x2014;
users use some form of pre-processing to accomplish their tasks.
In our case, the insufficient primitives are regarding the creation and manipulation
of theories &#x2014;i.e., records, classes, packages, modules. In section 3, we will demonstrate
an undisciplined prototype that clarified the requirements of our envisioned system.
Even though the prototype appears to be metaprogramming, the aim is not to force users
interested in manipulating packages to worry about the intricacies of representations;
that is, the end goal is to avoid metaprogramming &#x2014;which is an over-glorified form
of preprocessing. The goal is to <i>use a dependently-typed language to implement</i>
<i>the ‘missing’ module system features directly inside the language.</i>
</p>

<p>
The remainder of the thesis proposal is organised as follows.
</p>

<ul class="org-ul">
<li>Chapter II discusses what is expected of modularisation mechanisms,
how they could be simulated, their interdefinability in Agda, and
discuss a theoretical basis for modularisation.</li>

<li>Chapter III outlines missing features from current modularisation systems,
their use cases, and provides a checklist for a candidate module
system for DTLs.</li>

<li>Chapter IV discusses issues regarding implementation matter and the next steps
in this research, along with a proposed timeline.</li>

<li>Chapter V outlines the intended outcomes of this research effort.</li>
</ul>

<p>
An important design decision is whether the resulting development is intended
to be reasoned about or not. If reasoning is important, then a language that
better supports it is ideal. That is why we are using Agda
&#x2013;using a simpler language and maintaining data invariants eventually becomes
much harder \parencite{hasochism}.
</p>

<p>
Let us conclude by attempting to justify the title of this thesis proposal.
</p>

<p>
Landin's <i>The Next 700 Programming Languages</i> \parencite{seven_hundred_langs}
inspired a number of works, including
\parencite{seven_hundred_tt_models,seven_hundred_provers, seven_hundred_hoas,seven_hundred_libraries, seven_hundred_data}
and more.
The intended aim of the thesis is a requirements driven approach to coherent
modularisation constructs in DTLs. In particular, we wish to extend Agda
to be powerful enough to implement the module system features, in the core language,
that people actually want and currently mimic by-hand or using third-party preprocessors.
An eager fix would be to provide metaprogramming features,
but unless one is altering the syntax or producing efficient code, this is
glorified pre-processing &#x2014;it is a means to fake missing abstraction features.
Moreover, metaprogramming would be a hammer too big for the nail we are interested in;
so big that its introduction might ruin the soundness of the DTLs
&#x2014;e.g., two terms may be ill-typed and ill-formed, such as <code>x +</code> and <code>5 = 3</code>, but
are meaningful when joined together, as in <code>x + 5 = 3</code>.
Our aim is to provide just the right level of abstraction so that, if anything,
users can write a type of container or method upon it then derive ‘700’ simple
alternate views of the same container and method.
</p>

<p>
To be clear, consider a semi-ring &#x2014;or any simple record of 17 different kinds of
data.
A semi-ring consists of two monoids &#x2014;each consisting of a total of 7 items
of data and proof matter&#x2014; where one of them is commutative and there are two
distributivity axioms. Hence, a semi-ring consists of 17 items.
If we wanted to expose, say, 3 such items &#x2014;for example, the shared carrier and the
identities of each monoid&#x2014; then there are a total of \(\binom{17}{3} = 680\) ways,
and if we jump to 4 items we have \(\binom{17}{4} = 2380\) possible forms.
Of course these numbers are only upper bounds when record fields depend on earlier items.
In section 3, we provide explicit examples of different structural presentations of
packages.
</p>

<p>
Usually, library designers provide one or two views, along with conversion functions,
and commit to those; instead we want to liberate them to choose whatever presentation
is convenient for the tasks at hand and to work comfortably with the guarantee that
all the presentations are isomorphic. Humans should be left to tackle difficult and
interesting problems; machines should derive the tedious and uninteresting
&#x2014;even if it's simple, it saves time, is less error-prone, and clearly communicates
the underlying principle.
</p>

<p>
If anything, our aim is practical &#x2014;to save developers from ad hoc copy-paste
preprocessing hacks.
</p>
</div>
</div>
</div>
<div id="outline-container-org0994771" class="outline-2">
<h2 id="current_approaches"><span class="section-number-2">2</span> Current Approaches</h2>
<div class="outline-text-2" id="text-current_approaches">
<p>
Structuring mechanisms for proof assistants are seen as tools providing
administrative support for large mechanisation developments
\parencite{LF_practical_module_system}, with support for them usually
being conservative: Support for structuring-mechanisms elaborates, or rewrites,
into the language of the ambient system's logic. Conservative extensions
are reasonable to avoid bootstrapping new foundations altogether but they
come at the cost of limiting expressiveness to the existing foundations;
thereby possibly producing awkward or unusual uses of linguistic phrases
of the ambient language.
</p>

<p>
We may use the term ‘module’ below due to its familiarity, however some of the
issues addressed also apply to other instances of grouping mechanisms
&#x2014;such as records, code blocks, methods, files, families of files, and namespaces.
</p>

<p>
In section 2.1 we define modularisation; in section 2.2 we discuss how to
simulate it, and in section 2.3 we review what current systems can and cannot do;
then in section 2.4 we provide legitimate examples of the interdefinability of
different grouping mechanisms within Agda. We conclude in section 2.5 by
taking a look at an implementation-agnostic representation of grouping mechanisms
that is sufficiently abstract to ignore any differences between a record and
an interface but is otherwise sufficiently useful to encapsulate what is expected of
module systems.
Moreover, besides looking at the current solutions, we also briefly discuss their flaws.
</p>
</div>


<div id="outline-container-orgba88b50" class="outline-3">
<h3 id="orgba88b50"><span class="section-number-3">2.1</span> Expectations of Module Systems</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Packaging systems are not so esoteric that we need to dwell on their uses;
yet we recall primary use cases to set the stage for the rest of our discussions.
</p>

<dl class="org-dl">
<dt>Namespacing</dt><dd><p>
Modules provide new unique local scopes for identifiers thereby permitting de-coupling.
</p>

<p>
The ability to have multiple files contribute to the same namespace is also desirable
for de-coupled developments. This necessitates an independence of module names from
the names of physical files &#x2014;such de-conflation permits recursive modules.
</p></dd>

<dt>Information Hiding</dt><dd>Modules ought to provide the ability to enforce content <i>not</i> to be accessible,
or alterable, from outside of the module to enforce that users cannot depend on implementation design decisions.</dd>

<dt>Citizenship</dt><dd><p>
Grouping mechanisms need not be treated any more special than record types.
As such, one ought to be able to operate on them and manipulate them
like any first-class citizen.
</p>

<p>
In particular, packages themselves have types which happen to be packages.
This is the case with universal algebra, and OCaml, where
‘structures’ are typed by ‘signatures’
&#x2014;note that OCaml's approach is within the same language, whereas, for example,
Haskell's recent retrofitting \parencite{haskell_backpack},
of its weak module system to allow such interfacing, is not
entirely in the core language since, for example, instantiating happens
by the package manager rather than by a core language declaration.
</p></dd>

<dt>Polymorphism</dt><dd><p>
Grouping mechanisms should group all kinds of things without prejudice.
</p>

<p>
This includes ‘nested datatypes’: Local types introduced for implementation
purposes, where only certain functionality is exposed. E.g., in an Agda record
declaration, it may be nice to declare a local type where the record fields refer to it.
This approach naturally leads into hierarchical modules as well.
</p>

<p>
Interestingly, such nesting is expressible in <a href="http://fsl.cs.illinois.edu/images/5/5e/Cayenne.pdf">Cayenne</a>, a long-gone predecessor
of Agda. The language lived for about 7 years and it is unclear why it is no longer
maintained. Speculation would be that dependent types were poorly understood by
the academics let alone the coders &#x2014;moreover, it had essentially one maintainer
who has since moved on to other projects.
</p>

<p>
With the metaprogramming inspired approach we are proposing, it is only reasonable that, for example,
one be able to mechanically transform a package with a local type declaration into
a package with the local declaration removed and a new component added to abstract it.
That is, a particular implementation is no longer static, but dynamic.
</p></dd>
</dl>

<p>
It would not be unreasonable to consider adding to this enumeration:
</p>
<dl class="org-dl">
<dt>Sharing</dt><dd>The computation performed for a module parameter should be
shared across its constituents, rather than inefficiently being recomputed
for each constituent &#x2014;as is the case in the current implementation of Agda.</dd>
</dl>

<p>
It is however debatable whether the following is the ‘right’ way to incorporate
object-oriented notions of encapsulation.
</p>
<dl class="org-dl">
<dt>Generative modules</dt><dd><p>
A module, rather than being pure like a function, may have
some local state or initial setup that is unique to each ‘instantiation’ of
the module &#x2014;rather than being purely applying a module to parameters.
</p>

<p>
SML supports such features.
Whereas Haskell, for example,
has its typeclass system essentially behave like an implicitly type-indexed record
for the ‘unnamed instance record’ declarations; thereby rendering useless
the interfaces supporting, say, only an integer constant.
</p></dd>
<dt>Subtyping</dt><dd><p>
This gives rise to ‘heterogeneous equality’ where altering type annotations can suddenly
make a well-typed expression ill-typed. E.g., any two record values are equal <i>at</i> the
subtype of the empty record, but may be unequal at any other type annotation.
</p>

<p>
Since a package could contain anything, such as notational declarations,
it is unclear how even homogeneous equality should be defined
&#x2014;assuming notations are not part of a package's type.
</p></dd>
</dl>

<p>
There are many other concerns regarding packages &#x2014;such as deriving excerpts, decoration with
higher-order utilities, literate programming support, and matters of compilation along altered constituents&#x2014;
but they serve to distract from our core discussions and are thus omitted.
</p>
</div>
</div>

<div id="outline-container-org292fa11" class="outline-3">
<h3 id="org292fa11"><span class="section-number-3">2.2</span> Ad hoc Grouping Mechanisms</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Many popular coding languages do not provide top-level modularisation mechanisms,
yet users have found ways to emulate some or all of their <i>requirements</i>.
We shall emphasise a record-like embedding in this section, then illustrate it in
Agda in the next section.
</p>

<p>
<b>Namespacing:</b> Ubiquitous languages, such as C, Shell, and JavaScript, that do not
have built-in support for namespaces mimic it by a consistent naming
discipline as in \newline <code>theModule_theComponent</code>. This way, it is clear where <code>theComponent</code>
comes from; namely, the `module' <code>theModule</code> which may have its interface expressed as a
C header file or as a JSON literal. This is a variation of
Hungarian Notation \cite{hungarian_notation}.
</p>

<p>
Incidentally, a Racket source file, module, and `language' declaration
are precisely the same.
Consequently, Racket modules, like OCaml's, may contain top-level
effectful expressions.
In a similar fashion, Python packages
are directories containing an  <code>__init__.py</code> file which is used for the the same
purpose as Scala's <code>package object</code>'s &#x2014;for package-wide definitions.
</p>

<p>
<b>Objects:</b> An object can be simulated by having a record structure
contain the properties of the class which are then instantiated
by record instances. Public class methods are then normal
methods whose first argument is a reference to the structure
that contains the properties.
</p>

<div class="org-center">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><b>Template</b></td>
<td class="org-left">\(\qquad\text{has a}\qquad\)</td>
<td class="org-left"><b>Instance</b></td>
</tr>

<tr>
<td class="org-left">≈ class</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">≈ object</td>
</tr>

<tr>
<td class="org-left">≈ type</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">≈ value</td>
</tr>

<tr>
<td class="org-left">≈ theorem statement</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">≈ witnessing proof</td>
</tr>

<tr>
<td class="org-left">≈ specification</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">≈ implementation</td>
</tr>

<tr>
<td class="org-left">≈ interface</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">≈ implementation</td>
</tr>

<tr>
<td class="org-left">≈ signature</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">≈ algebra</td>
</tr>

<tr>
<td class="org-left">≈ logic</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">≈ theory</td>
</tr>
</tbody>
</table>
</div>
<p>
<b>Modules:</b> Languages that do not support a module may mimic it
by placing ``module contents'' within a record.
Keeping all contents within one massive record also solves the
namespacing issue.
</p>

<p>
In JavaScript, for example, a module is a JSON literal
&#x2014;i.e., a comma separated list of key-value pairs.
Moreover, encapsulation is simulated by having the module be encoded
as a function that yields a record which acts as the public contents
of the module, while the non-returned matter is considered private.
Due to JavaScript's dynamic nature we can easily adjoin functionality to such `modules'
at any later point; however, we cannot access any private members of the module.
This inflexibility of private data is a heavy burden in an Object Oriented
Paradigm.
</p>

<p>
<b>Sub-Modules:</b> If a module is encoded as a record, then a sub-module is a
field in the record which itself happens to be a module encoding.
</p>

<p>
<b>Parameterised Modules:</b> If a module can be considered as encoded as the returned record from
a function, then the arguments to such a function are the parameters to the module.
</p>

<p>
<b>Mixins:</b> A <i>mixin</i> is the ability to extend a datatype <i>X</i> with functionality <i>Y</i>
long after, and far from, its definition.
Mixins ‘mix in’ new functionality by permitting <i>X obtains traits Y</i>
&#x2014;unlike inheritance which declares <i>X is a Y</i>. Examples of this
include Scala's traits, Java's inheritance, Haskell's typeclasses, and C#'s extension methods.
</p>

<p>
Typescript \parencite{understanding_typescript}
occupies an interesting position with regards to mixins: It is one of the few
languages to provide union and intersection combinators for its <code>interface</code> grouping mechanism,
thereby most easily supporting the little theories \parencite{little_theories}
method and making theories a true lattice. Interestingly intersection of interfaces
results in a type that contains the declarations of its arguments and if a field
name has conflicting types then it is, recursively, assigned the intersection of the distinct types
&#x2014;the base cases of this recursive definition are primitive types, for which distinct types yield an empty intersection.
In contrast, its union types are disjoint sums.
</p>

<p>
In the dependently-typed setting, one also obtains so-called ‘canonical structures’ \parencite{coq_canonical},
which not only generalise the previously mentioned mixins but also facilitate a flexible
style of logic programming by having user-defined algorithms executed during unification;
thereby permitting one to omit many details \parencite{coq_canonical_tutorial} and have them inferred.
As mentioned earlier regarding objects, we could simulate mixins by encoding a class
as a record and a mixin as a record-consuming method.
Incidentally languages admitting mixins give rise to an alternate method
of module encoding:
A ‘module <i>of type M’ is encoded as an instantiation
of the mixin trait M.</i>
</p>

<p>
These natural encodings only reinforce our idea that there is no real essential difference
between grouping mechanisms: Whether one uses a closure, record, or module
is a matter of preference the usage of which communicates particular intent.
</p>
</div>
</div>

<div id="outline-container-org69e5635" class="outline-3">
<h3 id="org69e5635"><span class="section-number-3">2.3</span> Existing Systems</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Is there any actual <i>need</i> for the proposed research?
Are the goals easily adaptable from the simply-typed settings?
Is the declared arena of dependently-typed languages
sufficiently intricate to warrant this much attention?
</p>

<p>
In this section, we shall outline that DTLs constitute a difficult
and poorly understood domain in comparison to conventional programming
languages, such as the purely functional Haskell or the imperative Java.
Then we outline the merits of including dependent types.
Finally, we close with a comparison of some of the most popular DTLs.
</p>

<p>
We want to implement solutions in a dependently typed
language. Let us discuss which are active and their capabilities.
</p>

<p>
Dependent-types provide an immense level of expressivity thereby
allowing varying degrees of precision to be embedded, or omitted,
from the type of a declaration. This overwhelming degree of freedom
comes at the cost of common albeit non-orthogonal styles of coding
and compilation, which remain as open problems that are only mitigated
by awkward workarounds such as Coq's distinction of types and
propositions for compilation efficiency.
The difficulties presented by DTLs are outweighed by
the opportunities they provide \cite{dtl_why} &#x2014;of central importance is that they blur distinctions between
usual programming constructs, which is in alignment with our thesis.
</p>

<p>
To the best of our knowledge, as confirmed by Wikipedia in \parencite{wiki_proof_assistants, wiki_proof_assistants_dependent}, there are currently less than 15 <i>actively
developed</i> dependently-typed languages in-use <i>that are also used</i> as
proof-assistants &#x2014;which are intersting to us since we aim to
mechanise all of our results: Algorithms as well as theorems.
</p>

<p>
<b>Agda \parencite{agda_overview, agda_thesis}</b>: One of the more popular proof assistants around; possibly due to its syntactic
inheritance from Haskell &#x2014;as is the case with Idris. Its Unicode mixfix
lexemes permit somewhat faithful renditions of informal mathematics; e.g.,
calculational proofs can be encoded to be read by those unfamiliar with the system.
It also allows traditional functional programming with the ability to
`escape under the hood' and write Haskell code. The language has not been
designed solely with theorem proving in mind, as is the case for Coq, but rather
has been designed with dependently-typed programming in mind
\parencite{agda_web, agda_plf}.
</p>

<p>
The current implementation of the Agda language has a notion of second-class modules which
may contain sub-modules along with declarations and definitions of first-class citizens.
The intimate relationship between records and modules is perhaps best exemplified here
since the current implementation provides a declaration to construe a record as if it were
a module. This change in perspective allows Agda records to act as Haskell typeclasses.
However, the relationship with Haskell is only superficial: Agda's current implementation does
not support sharing. In particular, a parameterised module is only syntactic sugar such that
each member of the module actually obtains a new functional parameter; as such, a computationally
expensive parameter provided to a module invocation may be intended to be computed only once,
but is actually computed at each call site.
</p>

<p>
<b>Coq \parencite{coq_implementation, coq_cat_experiences}:</b> Unquestionably one of, if not, the most popular proof assistant around.
It has been used to produce mechanised proofs of the infamous Four Colour Theorem
\parencite{coq_four_colour}, the Feit-Thompson Theorem \parencite{coq_feit},
and an optimising compiler for the C language: CompCert \parencite{coq_compcert, compcert_paper}.
</p>

<p>
Unlike Agda, Coq supports tactics \parencite{tacticstype} -a brute force approach
that renders (hundredfold) case analysis as child's play:
Just refine your tactics till all the subgoals are achieved.
Ultimately the cost of utilising tactics is that a tactical proof
can only be understood with the aid of the system, and may otherwise be
un-insightful and so failing to meet most of the purposes of proof \parencite{purposes_of_proof}
&#x2014;which may well be a large barrier for mathematicians who value insightful proofs.
</p>

<p>
The current implementation of Coq provides the base features expected of any module system.
A notable difference from Agda is that it allows “copy and paste”
contents of modules using the include keyword. Consequently it provides a number
of module combinators, such as <code>&lt;+</code> which is the infix form of module inclusion
\parencite{coq_manual}. Since Coq module types are essentially contexts,
the module type <code>X &lt;+ Y &lt;+ Z</code> is really the catenation of contexts, where later
items may depend on former items. The Maude \parencite{maude, maude_module_algebra} framework
contains a similar yet more comprehensive algebra of modules and how they
work with Maude theories. An important aspect of the thesis work will be to
actually investigate Maude further and attempt to reproduce and generalise
some of the use cases in ‘the Maude book’ \parencite{maude} using a core
set of packaging primitives for DTLs &#x2014;we will return to what such primitives may be
in a later section, on preliminary research.
The Common Algebraic Specification Language
\parencite{casl_overview, casl_user_manual, casl_reference_manual}
will also be investigated with the aim of extracting, and generalising, useful module combinators
and their properties.
</p>

<p>
Maude is based on rewriting logic,
which uses term rewrite rules in two roles:
</p>
<ul class="org-ul">
<li>as equations, for algebraic specification</li>
<li>as (labelled) transitions.</li>
</ul>

<p>
In the resulting transition systems,
a ``state'' is an equivalence class of value terms
modulo the associated set of equations,
and transitions are rewrites using the second class of rules.
</p>

<p>
Theories (and functional modules fmod) can only
contain equations.
</p>

<p>
Incidentally, Coq modules are essentially
Agda records &#x2014;which is unsurprising since our thesis states packaging containers
are all essentially the same. In more detail, both notions coincide with
that of a signature &#x2014;a sequence of pairs of name-type declarations.
Where Agda users would speak of a record instance, Coq users would speak of
a module implementation. To make matters worse, Coq has a notion of records
which are far weaker than Agda's; e.g., by default all record
field names are globally exposed and records are non-recursive.
</p>

<p>
Coq's module system extends that of OCaml; a notable divergence is that Coq
permits parameterised module types &#x2014;i.e., parameterised record types, in Agda
parlance. Such module types are also known as ‘functors’ by Coq and OCaml users; which
are “generative”: Invocations generate new datatypes. Perhaps an example will
make this rather strange concept more apparent.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Coq                        -- Corresponding Agda</span>

<span style="color: #b58900; font-style: italic;">Module</span> <span style="color: #b58900; font-style: italic;">Type</span> Unit. <span style="color: #b58900; font-style: italic;">End</span> Unit.   <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">record Unit : Set where</span>
<span style="color: #b58900; font-style: italic;">Module</span> <span style="color: #b58900; font-style: italic;">TT</span> <span style="color: #268bd2;">&lt;:</span> Unit. <span style="color: #b58900; font-style: italic;">End</span> TT.    <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">tt : Unit; tt = record {}</span>

<span style="color: #b58900; font-style: italic;">Module</span> <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Unit</span><span style="color: #268bd2;">)</span><span style="color: #268bd2;">.</span>          <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">module F (X : Unit) where</span>
  <span style="color: #b58900; font-style: italic;">End</span> F.                      <span style="color: #93a1a1;">--     </span><span style="color: #96A7A9; font-style: italic;">data t : Set where C : t</span>

<span style="color: #b58900; font-style: italic;">Module</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:=</span> <span style="color: #b58900; font-style: italic;">F</span> TT.             <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">module A = F tt</span>
<span style="color: #b58900; font-style: italic;">Module</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:=</span> <span style="color: #b58900; font-style: italic;">F</span> TT.             <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">module B = F tt</span>

<span style="color: #b58900; font-style: italic;">Fail</span> <span style="color: #b58900; font-style: italic;">Check</span> eq_refl <span style="color: #b58900; font-style: italic;">:</span> A.t <span style="color: #268bd2;">=</span> B.t<span style="color: #268bd2;">.</span> <span style="color: #93a1a1;">--  </span><span style="color: #96A7A9; font-style: italic;">&#8800;   eq : A.t &#8801; B.t ; eq = refl</span>
</pre>
</div>
<p>
As seen, in Coq the inductive types are different yet in Agda they are the same.
This is because Agda treats such parameterised records, or functors, as
‘applicative’: They can only be applied, like functions.
</p>

<p>
record Unit : Set where
</p>

<p>
tt : Unit
tt = record {}
</p>

<p>
module F (X : Unit) where
  data t : Set where C : t
</p>

<p>
module A = F tt
</p>

<p>
module B = F tt
</p>

<p>
open import Relation.Binary.PropositionalEquality
</p>

<p>
it : A.t ≡ B.t
it = refl
</p>

<p>
For simplicity, we may think of generative functor applications <code>F X</code> as actually
<code>F X t</code> where <code>t</code> is an implicit tag such as textual position or clock time.
From an object-oriented programming perspective,
<code>F X</code> for a generative functor <code>F</code> is like the
<code>new</code> keyword in Java/C#: A new instance is created
which is distinct from all other instances even though
the same class is utilised. So much for the esotericity of generative functors.
</p>

<p>
Unlike Agda, which uses records to provide traditional record types, Haskell-like
typeclasses, and even a module perspective of both, Coq utilises distinct
mechanisms for typeclasses and canonical structures. In contrast, Agda allows
named instances since all instances are named and can be provided where an
implicit failed to be found. Moreover, Coq's approach demands greater familiarity
with the unifer than Agda's approach.
</p>

<p>
<b>Idris \parencite{idris_main}</b>: This is a general purpose, functional, programming language with dependent types; alongside ATS, below,
it is perhaps the only language in this list that can truthfully boast to being
general purpose and to have dependent types. It supports both equational
and tactic based proof styles, like Agda and Coq respectively; unlike these two
however, Idris erases unused proof-terms automatically rather than forcing
the user to declare this far in advance as is the case with Agda and Coq.
The only (negligible) downside, for us, is that the use of tactics creates
a sort of distinction between the activities of proving and programming, which
is mostly fictitious.
</p>

<p>
Moreover, Idris compiles to C whereas Agda compiles
to Haskell thereby opening the possibility to use GHC's many optimisations without
too much translation from the source: In contrast, Idris programs must be first
transformed to their imperative counterparts
\parencite{idris_website, idris_tdd}.
</p>

<p>
Intended to be a more accessible and practical version of Agda, Idris
implements the base module system features and includes interesting new ones.
Until <a href="https://agda.readthedocs.io/en/v2.6.0/language/generalization-of-declared-variables.html">recently</a>, in Agda, one would write <code>module _ (x : ℕ) where ⋯</code> to parameterise every
declaration in the block “⋯” by the name <code>x</code>; whereas in Idris, one writes
<code>parameters (x : ℕ) ⋯</code> to obtain the <a href="http://docs.idris-lang.org/en/latest/tutorial/modules.html">same behaviour</a>
&#x2013;which Agda has since improved upon it via ‘generalisation’:
A declaration's type gets only the variables it actually uses, not
every declared parameter.
</p>

<p>
Other than such pleasantries, Idris does not add anything of note.
However, it does provide new constraints.
As noted earlier, the current implementation of Idris attempts to erase implicits
aggressively therefore providing speedup over Agda.
In particular, Idris modules and records can be parameterised but not indexed
&#x2014;a limitation not in Agda.
</p>

<p>
Unlike Coq, Idris has been designed to “emphasise general purpose programming
rather than theorem proving” \parencite{idris_faq, idris_tdd}.
However, like Coq, Idris provides a Haskell-looking typeclasses mechanism;
but unlike Coq, it allows named instances.
In contrast to Agda's record-instances, typeclasses result in backtracking to
resolve operator overloading thereby having a slower type checker.
</p>

<p>
<b>Lean \parencite{lean_system_desc, lean_formalizing_math}:</b> This is both a theorem prover and programming language; moreover it permits
quotient types and so the usually-desired notion of extensional equality.
It is primarily tactics-based, also permitting a <code>calc</code>-ulational proof format
not too dissimilar with the standard equational proof format utilised in Agda.
</p>

<p>
Lean is based on a version of the Calculus of Inductive Constructions, like
Coq. Lean is heavily aimed at metaprogramming for formal verification,
thereby bridging the gap between interactive and automated theorem proving.
Unfortunately, inspecting the language shows that its rapid development is
not backwards-compatible
&#x2014;Lean 2 standard libraries have yet to be ported to Lean 3&#x2014;,
and unlike, for example, Coq and Isabelle which are backed by other complete
languages, Lean is backed by Lean, which is unfortunately too young to program
various tactics, for example.
</p>

<p>
The lean prover <a href="https://leanprover.github.io/introduction_to_lean/">tutorial</a> is not even complete!
</p>

<p>
It does not seem to be well docmented; only 1 file in the docs!
It's been difficult finding anything superficially; I may need to install and try things out?
</p>

<p>
<b>ATS, Applied Type System</b>: This language combines programming and proving, but is aimed at
unifying programming with formal specification. With the focus being more
on programming than on proving.
\parencite{ats_website, ats_combining}
</p>

<p>
ATS is intended as an approach to practical programming with theorem proving.
Its module system is largely influenced by that of Modula-3, providing what
would today be considered the bare bones of a module system.
Advocating a programmer-centric approach to program verification that
syntactically intertwines programming and theorem proving, ATS is a more
mature relative of Idris &#x2014;whereas Idris is Haskell-based, ATS is OCaml-based.
</p>

<p>
<b>F<sup>*</sup></b>: This language supports dependent types, refinement types,
and a weakest precondition calculus \parencite{fstar_website}.
However it is primarily aimed
at program verification rather than general proof.
Even though this language is roughly 8 years in the making,
it is not mature &#x2014;one encounters great difficult in doing anything
past the initial language tutorial.
</p>

<p>
F<sup>*</sup>'s module system is rather uninteresting, predominately acting as namespace
management. It has very little to offer in comparison to Agda; e.g., within
the last two years, it obtained a typeclass mechanism
&#x2014;regardless, typeclasses can be implemented as dependent records.
</p>

<p>
<b>Beluga</b>: The distinctive feature and sole reason that we mention this language
is its direct support for first-class contexts \parencite{beluga}.
A term <code>t(x)</code> may have free
variables and so whether it is well-formed or what its type could be depend on the
types of its free variables, necessitating one to either declare them before hand
or to write, in Beluga, \newline <code>[ x : T  |-  t(x) ]</code> for example.
As we have mentioned, and will
reiterate a few times, contexts are behaviourally indistinguishable from
dependent sums.
</p>

<p>
A displeasure of Beluga is that, while embracing the Curry-Howard Correspondence,
it insists on two syntactic categories: Data and computation.
This is similar to Coq's distinction of <code>Prop</code> and <code>Type</code>.
Another issue is that to a large degree the terms one uses in their type
declarations are closed and so have an empty context therefore one sees
expressions of the form <code>[ |- t ]</code> since <code>t</code> is a closed term needing only the empty
context. At a first glance, this is only a minor aesthetic concern; yet after
inspection of the language's webpage, tutorials, and publication matter, it is
concerning that nearly all code makes use of empty contexts &#x2014;which are easily
spotted visually. The tremendous amount of empty contexts suggests that the language
is not actually making substantial use of the concept, or it is yet unclear what
pragmatic utility is provided by contexts, and, in either way,
they might as well be relegated to a less intrusive notation.
Finally, the language lacks any substantial standard libraries
thereby rendering it more as a proof of concept rather than a serious system
for considerable work.
</p>

<p>
<b>Mizar</b>: Unlike the rest, it is based on (untyped) Tarski–Grothendieck set theory
which in some-sense has a ‘hierarchy of sets’. Being based on set theory, it is non-constructive. It has a large library of formalised mathematics; like Coq.
\parencite{mizar_website, mizar_overview, mizar_library}.
</p>

<p>
Like Idris, it provide a ‘reservation’ mechanism to name parameters for a block
of code. Mizar <code>environ</code>-ments are generally difficult to work with due to
multiple namespaces for articles and vocabularies.
There is otherwise nothing interesting to say regarding its module system.
</p>

<p>
<b>Notable Mentions</b>: The following are not actively being developed, as far we can
tell from their websites or source repositories,
but are interesting or have made useful contributions.
In contrast to Beluga, Isabelle is a full-featured language and logical framework that also provides
support for named contexts in the form of ‘locales’ \parencite{locales, isabelle_locales};
unfortunately it is not a dependently-typed language &#x2013;though DTLs can be implemented in it.
Mizar, unlike the above, is based on (untyped) Tarski–Grothendieck set theory
which in some-sense has a hierarchy of sets. Like Coq, it has a large library of formalised mathematics
\parencite{mizar_website, mizar_overview, mizar_library}.
Developed in the early 1980s, Nuprl \parencite{prl_site} is constructive with a
refinement-style logic; besides being a mature language, it has been used to provide
proofs of problems related to Girard's Paradox \parencite{girard_paradox}.
PVS, Prototype Verification System \parencite{pvs_prover}, differs from other DTLs
in its support for subset types; however, the language seems to be unmaintained as of 2014.
Twelf \parencite{twelf_site} is a logic programming language
implementing Edinburgh's Logical Framework \parencite{lf_meta_mechanisation, lf_has_isabelle, lf_fast_proof_checking}
and has been used to prove safety properties of ‘real languages’ such as SML.
A notable practical module system \parencite{lf_practical_modules} for Twelf has been implemented using signatures and signature morphisms.
Matita \parencite{matita_main, matita_site} is a Coq-like system that is much lighter \parencite{matita_is_coq_light};
it is been used for the verification of a complexity-preserving C compiler.
</p>

<p>
Dependent types are mostly visible within the functional community, however
   this is a matter of taste and culture as they can also be found in imperative
   settings, \parencite{dtl_imperative}, albeit less prominently.
</p>
</div>
</div>
<div id="outline-container-orgc7d32fc" class="outline-3">
<h3 id="orgc7d32fc"><span class="section-number-3">2.4</span> Facets of Structuring Mechanisms: An Agda Rendition</h3>
<div class="outline-text-3" id="text-2-4">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Relation.Binary.PropositionalEquality</span>
open <span style="color: #b58900;">&#8801;-</span><span style="color: #b58900; font-style: italic;">Reasoning</span>

<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Z-notation for sums</span>
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Level</span>
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Product</span> using <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">&#931;</span> ; proj&#8321; ; proj&#8322; ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#215;</span><span style="color: #859900; font-weight: bold;">_</span> ; <span style="color: #859900; font-weight: bold;">_</span>,<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">)</span>
<span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #b58900;">&#8758;&#8226;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">{</span>a b <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Level</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> a<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> b<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #268bd2;">(</span>a <span style="color: #268bd2;">&#8852;</span> b<span style="color: #268bd2;">)</span>
<span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #b58900;">&#8758;&#8226;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#931;</span>
<span style="color: #859900; font-weight: bold;">infix</span> <span style="color: #b58900;">-</span>666 <span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #268bd2;">&#8758;&#8226;</span>
<span style="color: #b58900;">syntax</span> <span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #268bd2;">&#8758;&#8226;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">(</span>&#955; x <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#931;</span> x <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8226;</span> <span style="color: #b58900; font-style: italic;">B</span>

<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Nat</span>
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Nat.Properties</span>
</pre>
</div>

<p>
In this section we provide a demonstration that with dependent-types we can show records, direct dependent types, and
contexts &#x2014;which in Agda may be thought of as parameters to a module&#x2014;
are interdefinable.
Consequently, we observe that the structuring mechanisms provided by the current
implementation of Agda &#x2013;and other DTLs&#x2013; have no real differences aside from those imposed by the language
and how they are generally utilised.
More importantly, this demonstration indicates our proposed direction of identifying
notions of packages is on the right track.
</p>

<p>
Our example will be implementing a monoidal interface in each format,
then presenting <i>views</i> between each format and that of the <code>record</code> format.
Furthermore, we shall also construe each as a typeclass,
thereby demonstrating that typeclasses are, essentially, not only a
selected record but also a selected <i>value</i> of a dependent type
&#x2014;incidentally this follows from the previous claim that records
and direct dependent types are essentially the same.
</p>

<p>
Recall that the signature of a monoid consists of
a type <code>Carrier</code> with a method <code>_⨾_</code> that composes values
and an <code>Id</code>-entity value.
With Agda's lack of type-proof discrimination, i.e., its support for the
Curry-Howard Correspondence, the “propositions as types” interpretation, we can encode the signature as well as the
axioms of monoids to yield their theory presentation in the following two ways.
Additionally, we have the derived result:
<code>Id</code>-entity can be popped-in and out as desired.
</p>

<p>
The following code blocks contain essentially the same content, but
presented using different notions of packaging. Even though both
use the <code>record</code> keyword, the latter is treated as a typeclass
since the carrier of the monoid is given ‘statically’ and instance
search is used to invoke such instances.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Record</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>&#8321; <span style="color: #859900; font-weight: bold;">where</span>
  <span style="color: #859900; font-weight: bold;">infixl</span> 5 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>
  field
    <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Interface</span>
    <span style="color: #b58900; font-style: italic;">Carrier</span>  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>
    <span style="color: #b58900; font-style: italic;">Id</span>       <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span>
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>      <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span>

    <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Constraints</span>
    lid   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span>x<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">&#10814;</span> x<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8801;</span> x
    rid   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span>x<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span>x <span style="color: #268bd2;">&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8801;</span> x
    assoc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x y z <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span>x <span style="color: #268bd2;">&#10814;</span> y<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#10814;</span> z  <span style="color: #268bd2;">&#8801;</span>  x <span style="color: #268bd2;">&#10814;</span> <span style="color: #268bd2;">(</span>y <span style="color: #268bd2;">&#10814;</span> z<span style="color: #268bd2;">)</span>

  <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">derived result</span>
  pop<span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Id&#7523;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x y  <span style="color: #268bd2;">&#8594;</span>  x <span style="color: #268bd2;">&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">&#10814;</span> y  <span style="color: #268bd2;">&#8801;</span>  x <span style="color: #268bd2;">&#10814;</span> y
  pop<span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Id&#7523;</span> x y <span style="color: #268bd2;">=</span> cong <span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span> y<span style="color: #268bd2;">)</span> rid

<span style="color: #b58900;">open</span> <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Record</span> <span style="color: #268bd2;">{</span><span style="color: #d33682;">{</span><span style="color: #268bd2;">...</span><span style="color: #d33682;">}</span><span style="color: #268bd2;">}</span> using <span style="color: #268bd2;">(</span>pop<span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Id&#7523;</span><span style="color: #268bd2;">)</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">HasMonoid</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>&#8321; <span style="color: #859900; font-weight: bold;">where</span>
  <span style="color: #859900; font-weight: bold;">infixl</span> 5 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>
  field
    <span style="color: #b58900; font-style: italic;">Id</span>    <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span>
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span>
    lid   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span>x<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">&#10814;</span> x<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8801;</span> x
    rid   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span>x<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span>x <span style="color: #268bd2;">&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8801;</span> x
    assoc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x y z <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span>x <span style="color: #268bd2;">&#10814;</span> y<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#10814;</span> z <span style="color: #268bd2;">&#8801;</span> x <span style="color: #268bd2;">&#10814;</span> <span style="color: #268bd2;">(</span>y <span style="color: #268bd2;">&#10814;</span> z<span style="color: #268bd2;">)</span>

  pop<span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Id</span><span style="color: #268bd2;">-</span>tc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x y <span style="color: #268bd2;">&#8594;</span>  x <span style="color: #268bd2;">&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">&#10814;</span> y  <span style="color: #268bd2;">&#8801;</span>  x <span style="color: #268bd2;">&#10814;</span> y
  pop<span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Id</span><span style="color: #268bd2;">-</span>tc x y <span style="color: #268bd2;">=</span> cong <span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span> y<span style="color: #268bd2;">)</span> rid

<span style="color: #b58900;">open</span> <span style="color: #b58900; font-style: italic;">HasMonoid</span> <span style="color: #268bd2;">{</span><span style="color: #d33682;">{</span><span style="color: #268bd2;">...</span><span style="color: #d33682;">}</span><span style="color: #268bd2;">}</span> using <span style="color: #268bd2;">(</span>pop<span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Id</span><span style="color: #268bd2;">-</span>tc<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
The double curly-braces <code>{{...}}</code> serve to indicate that
the given argument is to be found by instance resolution:
The results for <code>Monoid-Record</code> and <code>HasMonoid</code> can be invoked without having to mention a monoid on
a particular carrier, provided there exists one unique record value
having it as carrier &#x2014;otherwise one must use named instances \parencite{named_instances}.
Notice that the carrier argument in the typeclasses approach, “structure on a carrier”, is
an (undeclared) implicit argument to the <code>pop-Id-tc</code> operation.
</p>

<p>
Alternatively, in a DTL we may encode the monoidal interface using dependent products
<b>directly</b> rather than use the syntactic sugar of records.
The notation <code>Σ x ∶ A • B x</code> denotes the type of pairs <code>(x , pf)</code> where <code>x ∶ A</code> and <code>pf ∶ B x</code>
&#x2014;i.e., a record consisting of two fields.
It may be thought of as a constructive analogue to the classical set comprehension \newline <code>{ x ∶ A❙B x}</code>.
</p>


<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Type alias</span>
<span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #b58900;">-</span><span style="color: #b58900; font-style: italic;">&#931;</span>  <span style="color: #b58900; font-style: italic;">:</span>  <span style="color: #b58900; font-style: italic;">Set</span>&#8321;
<span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #b58900;">-</span><span style="color: #b58900; font-style: italic;">&#931;</span>  <span style="color: #268bd2;">=</span>    <span style="color: #b58900; font-style: italic;">&#931;</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">Set</span>
         <span style="color: #268bd2;">&#8226;</span> <span style="color: #b58900; font-style: italic;">&#931;</span> <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">Carrier</span>
         <span style="color: #268bd2;">&#8226;</span> <span style="color: #b58900; font-style: italic;">&#931;</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span><span style="color: #268bd2;">)</span>
         <span style="color: #268bd2;">&#8226;</span> <span style="color: #b58900; font-style: italic;">&#931;</span> lid <span style="color: #268bd2;">&#8758;</span> <span style="color: #268bd2;">(</span><span style="color: #268bd2;">&#8704;</span><span style="color: #d33682;">{</span>x<span style="color: #d33682;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">&#10814;</span> x <span style="color: #268bd2;">&#8801;</span> x<span style="color: #268bd2;">)</span>
         <span style="color: #268bd2;">&#8226;</span> <span style="color: #b58900; font-style: italic;">&#931;</span> rid <span style="color: #268bd2;">&#8758;</span> <span style="color: #268bd2;">(</span><span style="color: #268bd2;">&#8704;</span><span style="color: #d33682;">{</span>x<span style="color: #d33682;">}</span> <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">&#8801;</span> x<span style="color: #268bd2;">)</span>
         <span style="color: #268bd2;">&#8226;</span> <span style="color: #268bd2;">(</span><span style="color: #268bd2;">&#8704;</span> x y z <span style="color: #268bd2;">&#8594;</span> <span style="color: #d33682;">(</span>x <span style="color: #268bd2;">&#10814;</span> y<span style="color: #d33682;">)</span> <span style="color: #268bd2;">&#10814;</span> z <span style="color: #268bd2;">&#8801;</span> x <span style="color: #268bd2;">&#10814;</span> <span style="color: #d33682;">(</span>y <span style="color: #268bd2;">&#10814;</span> z<span style="color: #d33682;">)</span><span style="color: #268bd2;">)</span>

pop<span style="color: #b58900;">-</span><span style="color: #b58900; font-style: italic;">Id</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">&#931;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span><span style="color: #d33682;">{</span><span style="color: #b58900; font-style: italic;">M</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #d33682;">}</span><span style="color: #268bd2;">}</span>
               <span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #b58900; font-style: italic;">Id</span>  <span style="color: #268bd2;">=</span> proj&#8321; <span style="color: #d33682;">(</span>proj&#8322; <span style="color: #b58900; font-style: italic;">M</span><span style="color: #d33682;">)</span><span style="color: #268bd2;">)</span>
               <span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">let</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> proj&#8321; <span style="color: #d33682;">(</span>proj&#8322; <span style="color: #859900;">(</span>proj&#8322; <span style="color: #b58900; font-style: italic;">M</span><span style="color: #859900;">)</span><span style="color: #d33682;">)</span><span style="color: #268bd2;">)</span>
           <span style="color: #268bd2;">&#8594;</span>  <span style="color: #268bd2;">&#8704;</span> <span style="color: #268bd2;">(</span>x y <span style="color: #b58900; font-style: italic;">:</span> proj&#8321; <span style="color: #b58900; font-style: italic;">M</span><span style="color: #268bd2;">)</span>  <span style="color: #268bd2;">&#8594;</span>  <span style="color: #268bd2;">(</span>x <span style="color: #268bd2;">&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#10814;</span> y  <span style="color: #268bd2;">&#8801;</span>  x <span style="color: #268bd2;">&#10814;</span> y
pop<span style="color: #b58900;">-</span><span style="color: #b58900; font-style: italic;">Id</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">&#931;</span> <span style="color: #268bd2;">{</span><span style="color: #d33682;">{</span><span style="color: #b58900; font-style: italic;">M</span><span style="color: #d33682;">}</span><span style="color: #268bd2;">}</span> x y <span style="color: #268bd2;">=</span> cong <span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span> y<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span>rid <span style="color: #d33682;">{</span>x<span style="color: #d33682;">}</span><span style="color: #268bd2;">)</span>
             <span style="color: #859900; font-weight: bold;">where</span>  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>    <span style="color: #268bd2;">=</span> proj&#8321; <span style="color: #268bd2;">(</span>proj&#8322; <span style="color: #d33682;">(</span>proj&#8322; <span style="color: #b58900; font-style: italic;">M</span><span style="color: #d33682;">)</span><span style="color: #268bd2;">)</span>
                rid    <span style="color: #268bd2;">=</span> proj&#8321; <span style="color: #268bd2;">(</span>proj&#8322; <span style="color: #d33682;">(</span>proj&#8322; <span style="color: #859900;">(</span>proj&#8322; <span style="color: #cb4b16;">(</span>proj&#8322; <span style="color: #b58900; font-style: italic;">M</span><span style="color: #cb4b16;">)</span><span style="color: #859900;">)</span><span style="color: #d33682;">)</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
Of the renditions thus far, the <code>Σ</code> rendering makes it clear that a monoid could have
any subpart as a record with the rest being dependent upon said record.
For example, if we had a semigroup type, we could have declared \newline
<code>Monoid-Σ = Σ S ∶ Semigroup • Σ Id ∶ Semigroup.Carrier S</code>.
There are a large number of such hyper-graphs, we have only presented a stratified view
for brevity. In particular, <code>Monoid-Σ</code> is the extreme unbundled version, whereas
<code>Monoid-Record</code> is the other extreme, and there is a large spectrum in between &#x2013;all of which are
somehow isomorphic; e.g., <code>Monoid-Record ≅ Σ C ∶ Set • HasMonoid C</code>.
Our envisioned system would be able to derive any such view at will \parencite{casl_overview}
and so programs may be written according to one view, but easily repurposed for other
view with little human intervention.
</p>

<p>
Like a Java <code>class</code>, within the <code>record</code> we may include derived results
that are then available to all values, `instances', of the record type.
Outside the <code>record</code>, further properties may be added, though they now
require an actual value, instance, to be given.
</p>

<p>
Instances and their use are as follows.
One may realise that <code>pop-0</code> proofs as a form of polymorphism
&#x2014;we will return to package former polymorphism when discussing preliminary research.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">instance</span>
   <span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">-</span>record <span style="color: #268bd2;">=</span> record <span style="color: #268bd2;">{</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> ; <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">=</span> 0 ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">+</span><span style="color: #859900; font-weight: bold;">_</span>
             ; lid <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">+-</span>identity&#737; <span style="color: #859900; font-weight: bold;">_</span>  ; rid <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">+-</span>identity&#691; <span style="color: #859900; font-weight: bold;">_</span> ; assoc <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">+-</span>assoc <span style="color: #268bd2;">}</span>

   <span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">-</span>tc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">HasMonoid</span> <span style="color: #b58900; font-style: italic;">&#8469;</span>
   <span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">-</span>tc <span style="color: #268bd2;">=</span> record <span style="color: #268bd2;">{</span> <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">=</span> 0; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">+</span><span style="color: #859900; font-weight: bold;">_</span>
         ; lid <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">+-</span>identity&#737; <span style="color: #859900; font-weight: bold;">_</span> ; rid <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">+-</span>identity&#691; <span style="color: #859900; font-weight: bold;">_</span> ; assoc <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">+-</span>assoc <span style="color: #268bd2;">}</span>

   <span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">&#931;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">&#931;</span>
   <span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">&#931;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> , 0 , <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">+</span><span style="color: #859900; font-weight: bold;">_</span> , <span style="color: #268bd2;">+-</span>identity&#737; <span style="color: #859900; font-weight: bold;">_</span> , <span style="color: #268bd2;">+-</span>identity&#691; <span style="color: #859900; font-weight: bold;">_</span> , <span style="color: #268bd2;">+-</span>assoc
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">-</span>pop<span style="color: #268bd2;">-</span>0&#7523; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> <span style="color: #268bd2;">(</span>x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">+</span> 0 <span style="color: #268bd2;">+</span> y  <span style="color: #268bd2;">&#8801;</span>  x <span style="color: #268bd2;">+</span> y
<span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">-</span>pop<span style="color: #268bd2;">-</span>0&#7523; <span style="color: #268bd2;">=</span> pop<span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Id&#7523;</span>

<span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">-</span>pop<span style="color: #268bd2;">-</span>0<span style="color: #268bd2;">-</span>tc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> <span style="color: #268bd2;">(</span>x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">+</span> 0 <span style="color: #268bd2;">+</span> y  <span style="color: #268bd2;">&#8801;</span>  x <span style="color: #268bd2;">+</span> y
<span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">-</span>pop<span style="color: #268bd2;">-</span>0<span style="color: #268bd2;">-</span>tc <span style="color: #268bd2;">=</span> pop<span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Id</span><span style="color: #268bd2;">-</span>tc

<span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">-</span>pop<span style="color: #268bd2;">-</span>0&#8348; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> <span style="color: #268bd2;">(</span>x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">+</span> 0 <span style="color: #268bd2;">+</span> y  <span style="color: #268bd2;">&#8801;</span>  x <span style="color: #268bd2;">+</span> y
<span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">-</span>pop<span style="color: #268bd2;">-</span>0&#8348; <span style="color: #268bd2;">=</span> pop<span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Id</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">&#931;</span>
</pre>
</div>

<p>
Interestingly, notice that the grouping in <code>ℕ-Σ</code> is just an unlabelled (dependent) product,
and so when it is used in <code>pop-Id-Σ</code> we project to the desired components.
Whereas in the <code>Monoid-Record</code> case we could have projected the carrier by
<code>Carrier M</code>, now we would write <code>proj₁ M</code>.
</p>

<p>
This is nearly identical to the previous implementation and possibly
simpler due to the lack of the <code>record { ⋯ }</code> clutter required of <i>labelled products</i>.
However, said clutter could have been removed by providing
a <code>constructor</code> declaration in the definition of <code>Monoid-Record</code>
but we have decided not to do so, to make the labelling clear
and distinct from the unlabelled product presentations.
</p>

<p>
Observe the lack of informational
difference between the presentations, yet there is a
<i>Utility Difference: Records give us the power to name our projections <span class="underline"><b>directly</b></span> with possibly meaningful names.</i>
Of course this could be achieved indirectly by declaring extra functions; e.g.,
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">Carrier&#8348;</span> <span style="color: #b58900;">:</span> <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">&#931;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>
<span style="color: #b58900; font-style: italic;">Carrier&#8348;</span> <span style="color: #268bd2;">=</span> proj&#8321;
</pre>
</div>
<p>
We will refrain from creating such boiler plate &#x2014;that is,
<i>records allow us to omit such mechanical boilerplate.</i>
</p>

<p>
Finally, let us exhibit views between this form and the <code>record</code> form.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Following proves: Monoid-Record  &#8773;  &#931; Set HasMonoid.</span>

to<span style="color: #b58900;">-</span>record<span style="color: #268bd2;">-</span>from<span style="color: #268bd2;">-</span>usual<span style="color: #268bd2;">-</span><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">&#931;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Record</span>
to<span style="color: #b58900;">-</span>record<span style="color: #268bd2;">-</span>from<span style="color: #268bd2;">-</span>usual<span style="color: #268bd2;">-</span><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #268bd2;">(</span>c , id , op , lid , rid , assoc<span style="color: #268bd2;">)</span>
  <span style="color: #268bd2;">=</span> record <span style="color: #268bd2;">{</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">=</span> c ; <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">=</span> id ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> op
       ; lid <span style="color: #268bd2;">=</span> lid ; rid <span style="color: #268bd2;">=</span> rid ; assoc <span style="color: #268bd2;">=</span> assoc
       <span style="color: #268bd2;">}</span> <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Term construed by &#8216;Agsy&#8217;,</span>
         <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Agda's mechanical proof search.</span>

from<span style="color: #b58900;">-</span>record<span style="color: #268bd2;">-</span>to<span style="color: #268bd2;">-</span>usual<span style="color: #268bd2;">-</span><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Record</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">&#931;</span>
from<span style="color: #b58900;">-</span>record<span style="color: #268bd2;">-</span>to<span style="color: #268bd2;">-</span>usual<span style="color: #268bd2;">-</span><span style="color: #859900; font-weight: bold;">type</span> <span style="color: #b58900; font-style: italic;">M</span> <span style="color: #268bd2;">=</span>
  <span style="color: #859900; font-weight: bold;">let</span> open <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Record</span> <span style="color: #b58900; font-style: italic;">M</span>
  <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #b58900; font-style: italic;">Carrier</span> , <span style="color: #b58900; font-style: italic;">Id</span> , <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> , lid , rid , assoc

  <span style="color: #93a1a1;">{- </span><span style="color: #96A7A9; font-style: italic;">Essentially moved from record{&#8943;} to product listing -}</span>
</pre>
</div>

<p>
Furthermore, by definition chasing, <code>refl</code>-exivity, these operations are seen to be inverse of
each other. Hence we have two faithful non-lossy protocols for reshaping our grouped data.
</p>

<p>
In our final presentation, we construe the grouping of the monoidal interface
as a sequence of “variable : type” declarations &#x2014;i.e., a ‘context’ or ‘telescope’.
Since these are not top level items by themselves, in Agda, we take a purely syntactic route
by positioning them in a <code>module</code> declaration as follows.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Telescope</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">User</span>
  <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span><span style="color: #268bd2;">)</span>
  <span style="color: #268bd2;">(</span>lid   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #d33682;">{</span>x<span style="color: #d33682;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">&#10814;</span> x <span style="color: #268bd2;">&#8801;</span> x<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span>rid <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #d33682;">{</span>x<span style="color: #d33682;">}</span> <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">&#8801;</span> x<span style="color: #268bd2;">)</span>
  <span style="color: #268bd2;">(</span>assoc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x y z <span style="color: #268bd2;">&#8594;</span> <span style="color: #d33682;">(</span>x <span style="color: #268bd2;">&#10814;</span> y<span style="color: #d33682;">)</span> <span style="color: #268bd2;">&#10814;</span> z <span style="color: #268bd2;">&#8801;</span> x <span style="color: #268bd2;">&#10814;</span> <span style="color: #d33682;">(</span>y <span style="color: #268bd2;">&#10814;</span> z<span style="color: #d33682;">)</span><span style="color: #268bd2;">)</span>
  <span style="color: #859900; font-weight: bold;">where</span>

  pop<span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Id&#8344;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">(</span>x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span><span style="color: #268bd2;">)</span>  <span style="color: #268bd2;">&#8594;</span>  <span style="color: #268bd2;">(</span>x <span style="color: #268bd2;">&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#10814;</span> y  <span style="color: #268bd2;">&#8801;</span>  x <span style="color: #268bd2;">&#10814;</span> y
  pop<span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Id&#8344;</span> x y <span style="color: #268bd2;">=</span> cong <span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span> y<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span>rid <span style="color: #d33682;">{</span>x<span style="color: #d33682;">}</span><span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
Notice that this is nothing more than the named fields of <code>Monoid-Record</code>
squished into six lines. Additionally, if we insert a Σ before each name
we essentially regain the <code>Monoid-Σ</code> formulation.
It seems contexts, at least superficially, are a nice middle ground between
the previous two formulations.
</p>

<p>
As promised earlier, we can regard the above telescope as a record:
</p>
<div class="org-src-container">
<pre class="src src-haskell">  record<span style="color: #268bd2;">-</span>from<span style="color: #268bd2;">-</span>telescope <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Record</span>
  record<span style="color: #268bd2;">-</span>from<span style="color: #268bd2;">-</span>telescope
    <span style="color: #268bd2;">=</span> record <span style="color: #268bd2;">{</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Carrier</span> ; <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Id</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>
         ; lid <span style="color: #268bd2;">=</span> lid ; rid <span style="color: #268bd2;">=</span> rid ; assoc <span style="color: #268bd2;">=</span> assoc <span style="color: #268bd2;">}</span>
</pre>
</div>

<p>
The structuring mechanism <code>module</code> is not a first class citizen in Agda.
As such, to obtain the converse view, we work in a parameterised module.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> record<span style="color: #268bd2;">-</span>to<span style="color: #268bd2;">-</span>telescope <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">M</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Record</span><span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">where</span>

  open <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Record</span> <span style="color: #b58900; font-style: italic;">M</span>
  <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Treat record type as if it were a parameterised module type,</span>
  <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">instantiated with M.</span>

  open <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Telescope</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">User</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> lid rid assoc
</pre>
</div>

<p>
Notice that we just listed the components out &#x2014;rather reminiscent of the formulation
<code>Monoid-Σ</code>. This observation only increases confidence in our thesis that there is no
real distinctions of packaging mechanisms in DTLs.
</p>

<p>
Undeniably instantiating the telescope approach to monoids for the natural number
is nothing more than listing the required components.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">open</span> <span style="color: #b58900; font-style: italic;">Monoid</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Telescope</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">User</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> 0 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">+</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">(</span><span style="color: #268bd2;">+-</span>identity&#737; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span><span style="color: #268bd2;">+-</span>identity&#691; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">+-</span>assoc
</pre>
</div>

<p>
C.f., the definition of <code>ℕ-Σ</code>: This is nearly the same instantiation with the primary
syntactical difference being that this form had its arguments separated by spaces rather than commas!
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">-</span>pop&#8344;  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">(</span>x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">)</span>  <span style="color: #268bd2;">&#8594;</span>  x <span style="color: #268bd2;">+</span> 0 <span style="color: #268bd2;">+</span> y  <span style="color: #268bd2;">&#8801;</span>  x <span style="color: #268bd2;">+</span> y
<span style="color: #b58900; font-style: italic;">&#8469;</span><span style="color: #268bd2;">-</span>pop&#8344;  <span style="color: #268bd2;">=</span>   pop<span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">Id&#8344;</span>
</pre>
</div>

<p>
Notice how this presentation makes it explicitly clear why we cannot have multiple instances:
There would be name clashes. Even if the data we used had distinct names, the derived result
may utilise data having the same name thereby admitting name clashes elsewhere.
&#x2014;This could be avoided in Agda by qualifying names and/or renaming.
</p>

<p>
It is interesting to note that this presentation is akin to that of <code>class</code>-es in C#/Java languages:
The interface is declared in one place, monolithic-ly, as well as all
derived operations there; if we want additional operations, we create
another module that  takes that given module as an argument in the
same way we create a class that inherits from that given class.
</p>

<p>
Demonstrating the interdefinablity of different notions
of packaging cements our thesis that it is essentially utility
that distinguishes packages more than anything else.
In particular, explicit distinctions have lead
to a duplication of work where the same structure is formalised
using different notions of packaging. In chapter 3 we will show how to avoid
duplication by coding against a particular ‘package former’ rather than a
particular variation thereof &#x2013;this is akin to a type former.
</p>
</div>
</div>

<div id="outline-container-org6a2de21" class="outline-3">
<h3 id="org6a2de21"><span class="section-number-3">2.5</span> Theory Presentations: A Structuring Mechanism</h3>
<div class="outline-text-3" id="text-2-5">
<p>
What of the most closely related theoretical work?
</p>

<p>
Our envisioned effort would support a “write one, obtain many” approach to package formation.
We now turn to mentioning how package formers are currently treated
formally under the name of ‘theory presentations’. It is the aim of this section
to attest that the introduction's story is not completely on shaky foundations,
thereby asserting that the aforementioned goals of the introduction are not
unachievable &#x2014;and the problems that will be posed in chapter 3 are not trivial.
</p>

<p>
As discussed, languages are usually designed with a bit more thought given to a first-class
citizen notion of grouping than is given to second-class notions of
packaging up defined content.
Object-oriented languages, for example, comprise features of both views
by treating classes as external structuring mechanisms even though they
are normal types of the type system. This internalising of external grouping
features has not received much attention with the notable mentions being
\parencite{theories_as_types, focalize}.
It is unclear whether there is any real distinction
between these `internal, integrated' and `external, stratified'
forms of grouping, besides intended use.
The two approaches have different advantages.
Both approaches permit separation of concerns: The external point of view
provides a high-level structuring of a development, the internal point of
view provides essentially another type which can be the subject of the
language's operations &#x2014;e.g., quantification or tactics&#x2014; thereby being
more amicable to computing transformations.
Essentially it comes down to whether we want a `module parameter' or a `record field'
&#x2014;why not write it the way you like and get the other form for free.
</p>

<p>
Since external grouping mechanisms tend to allow for intra-language features
&#x2014;e.g., imports, definitions, notation, extra-logical declarations such as pragmas&#x2014;
their systematic internalisation necessitates expressive record types.
As such, a labelled product type or <i>context</i>
&#x2014;being a list of name-type declarations with optional definitions&#x2014;
is a sufficiently generic rendition of what it means to group matter together.
</p>

<p>
Below is a grammar, from \parencite{theories_as_types}, for a simple yet powerful
module system based on theory (presentations) and theory morphisms &#x2013;which are merely named contexts and named substitutions between contexts, respectively.
Both may be formed modularly by using includes to copy over declarations of previously named objects.
Unlike theories which may include arbitrary declarations, theory morphisms \texttt{(V : P → Q) := δ}
are well-defined if for every <code>P</code>-declaration <code>x ∶ T</code>, <code>δ</code> contains a declaration <code>x = t</code> where <code>t</code> may refer to all names declared in <code>Q</code>.
Observe that a context is, up to syntactical differences,
essentially JavaScript object notation literal.
Consequently, the notion of a mixin as described for JSON literals is here
rendered as a theory morphism.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Contexts</span>
<span style="color: #b58900; font-style: italic;">&#915;</span>  <span style="color: #b58900;">::=</span> <span style="color: #268bd2;">&#183;</span>                       <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">empty context</span>
     <span style="color: #268bd2;">|</span> x <span style="color: #b58900; font-style: italic;">:</span> &#964; <span style="color: #268bd2;">[</span><span style="color: #b58900; font-style: italic;">:=</span> &#964;<span style="color: #268bd2;">&#8242;</span><span style="color: #268bd2;">]</span>, <span style="color: #b58900; font-style: italic;">&#915;</span>         <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">context with declaration, optional definition</span>
     <span style="color: #268bd2;">|</span> includes <span style="color: #b58900; font-style: italic;">X</span>, <span style="color: #b58900; font-style: italic;">&#915;</span>           <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">theory inclusion</span>

<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Terms</span>
<span style="color: #b58900;">&#964;</span> <span style="color: #b58900;">::=</span> x <span style="color: #268bd2;">|</span> &#964;&#8321; &#964;&#8322; <span style="color: #268bd2;">|</span> &#955; x <span style="color: #b58900; font-style: italic;">:</span> &#964;<span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">&#8226;</span> &#964; <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">variables, application, lambdas</span>
    <span style="color: #268bd2;">|</span> <span style="color: #b58900; font-style: italic;">&#928;</span> x <span style="color: #b58900; font-style: italic;">:</span> &#964;<span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">&#8226;</span> &#964;             <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">dependent product</span>
    <span style="color: #268bd2;">|</span> <span style="color: #268bd2;">[</span><span style="color: #b58900; font-style: italic;">&#915;</span><span style="color: #268bd2;">]</span> <span style="color: #268bd2;">|</span> <span style="color: #268bd2;">&#10216;</span><span style="color: #b58900; font-style: italic;">&#915;</span><span style="color: #268bd2;">&#10217;</span> <span style="color: #268bd2;">|</span> &#964;<span style="color: #268bd2;">.</span>x          <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">record &#8220;[type]&#8221; and &#8220;&#10216;element&#10217;&#8221; formers, projections</span>
    <span style="color: #268bd2;">|</span> <span style="color: #b58900; font-style: italic;">Mod</span> <span style="color: #b58900; font-style: italic;">X</span>                    <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">contravariant &#8220;theory to record&#8221; internalisation</span>

<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Theory, external grouping, level</span>
<span style="color: #b58900; font-style: italic;">&#920;</span> <span style="color: #b58900;">::=</span> <span style="color: #268bd2;">.</span>                        <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">empty theory</span>
    <span style="color: #268bd2;">|</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:=</span> <span style="color: #b58900; font-style: italic;">&#915;</span>, <span style="color: #b58900; font-style: italic;">&#920;</span>                <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">a theory can contain named contexts</span>
    <span style="color: #268bd2;">|</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #d33682;">(</span><span style="color: #b58900; font-style: italic;">X</span>&#8321; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>&#8322;<span style="color: #d33682;">)</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:=</span> <span style="color: #b58900; font-style: italic;">&#915;</span>     <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">a theory can be a first-class theory morphism</span>

<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Proviso: In record formers, &#915; must be flat; i.e., does not contain includes.</span>

<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Example theory hierarchy of signatures, abbrevating &#8220;(&#928; x : A &#8226; B) = (A &#8594; B)&#8221;.</span>
, <span style="color: #b58900; font-style: italic;">MagmaSig</span> <span style="color: #b58900; font-style: italic;">:=</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>,  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span>, <span style="color: #268bd2;">.</span>
, <span style="color: #b58900; font-style: italic;">MonSig</span>   <span style="color: #b58900; font-style: italic;">:=</span> includes <span style="color: #b58900; font-style: italic;">MagmaSig</span>, <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span>, <span style="color: #268bd2;">.</span>
, <span style="color: #268bd2;">.</span>
</pre>
</div>

<p>
This concept of packaging indeed captures much of what's expected of grouping mechanisms; e.g.,
</p>

<ul class="org-ul">
<li>Grouping mechanism should group all kinds of things and indeed there is no
constraint on what a theory presentation may contain.</li>
<li><p>
Namespacing: Every module context can be construed as a record whose contents
can then be accessed by record field projection.
</p>

<p>
<i>Theories as Types</i> \parencite{theories_as_types} presents the first formal
approach that systematically internalises theories into record types.
Their central idea is to introduce a new operator <code>Mod</code> –read “models of”—
that turns a theory \(T\) into a type \(\Mod T\) which <i>behaves</i> like a record type.
</p></li>

<li>Operations on grouping mechanisms \parencite{tpc}.</li>
</ul>

<p>
As mentioned earlier, a theory morphism, also known as a ‘view’,
is a map between contexts that implements the interface of the source
using utilities of the target; whence results about specific structures can be
constructed by transport along views \parencite{little_theories}:
A view \texttt{V : P → Q} gives rise to a term homomorphism <code>𝒱</code> from <code>P</code>-terms to <code>Q</code>-terms
that is type-preserving in that whenever \texttt{Θ, P ⊢ t : T} then \texttt{Θ, Q ⊢ 𝒱 t : 𝒱 T}.
Thus, views preserve judgements and, via the propositions-as-types representations,
also preserve truth.
</p>

<p>
For example, a view \(\Phi = (U, \beta) : \mathcal{S} \to \mathcal{T}\)
is essentially a predicate \(U\), of the target theory, denoting a <i>universe of discourse</i>
along with an  arity-preserving mapping \(\beta\) of 𝒮-symbols, or declarations, to 𝒯-expressions.
It is lifted to terms as follows
&#x2014; notice translated variable-binders are relativised to the new domain.
</p>
<p>
The <i>Standard Interpretation Theorem</i> \parencite{theory_interpretations_farmer}
provides sufficient conditions for a translation to be an ‘interpretation’
which transports results between formalisations. It states:
A translation is an interpretation provided 𝒮-axioms \(P\) are lifted to
theorems \(\Phi(P)\), the universe of discourse is non-empty
\((\exists x \bullet U\, x)\), and the interpretation of the universe
contains the interpretations of the symbols;
i.e., for each 𝒮-symbol \(f\) of arity \(n\), \newline
\(\Phi(∀ x₁, …, xₙ • ∃ y \,•\, f\, x₁\, …\, x\,ₙ = \,y)\).
</p>

<p>
By virtue of being a validity preserving homomorphism,
a standard interpretation syntactically and semantically
embeds its source theory in its target theory.
The most important consequence of interpretability is the
<i>Standard Relative Satisfiability</i> \parencite{theory_interpretations_farmer}
which says that a theory which is interpretable in a satisfiable theory is itself satisfiable;
in programming terms this amount to: If \(X\) is an implementation of `interface' 𝒯
and 𝒮 is interpretable in 𝒯 then \(X\) can be transformed into an implementation of 𝒮.
Interestingly such ‘subtyping’ can be derived in a mechanical fashion, but it can leave
the subtype relation to be cyclic.
However, it is unclear under which conditions translations automatically
give rise to interpretations: Can the issue be relegated to syntactic
manipulation only?
</p>

<p>
Theory interpretation has been studied for first-order predicate logic
then extended to higher-order logic \cite{theory_interpretations_farmer}.
The advent of dependent-types, in particular the blurring of operations and formulae
\cite{wiki_curry_howard}, means that propositions of a language can be encoded into it as other
sorts, dependent on existing sorts, thereby questioning
<i>what it means to have a validity-preserving morphism</i> when the axioms can be
encoded as operations? As far as we can tell, it seems very little work
regarding theory interpretations has been conducted in dependently-typed
settings \parencite{mlt_partial, higher_order_interpretations, institution_interpretations, dtl_interpretations}.
</p>

<p>
Notice that records play dual roles. They not only serve as an internal form of grouping
mechanisms, but inspired by the previous Agda renditions, also serve the purpose of
forming dependent sum types.
</p>

<p>
What about the presence of non-termination or inheritance
&#x2014;i.e., partial functions and subtypes?
The subject is only beginning to
be seriously explored in higher-order logic and type theory.
\cite{theory_interpretations_farmer}.
Views associating base types with subtypes get complicated since functions must now
deal with restricted domains, consequently necessitating that all predicates on functions
also be relativised.
</p>
</div>
</div>
</div>
<div id="outline-container-org3436221" class="outline-2">
<h2 id="solution_requirements"><span class="section-number-2">3</span> Solution Requirements</h2>
<div class="outline-text-2" id="text-solution_requirements">
<p>
From the outset we have proposed a particular approach to resolving
the needless duplication present in current module systems that are
utilised in non-dependently-typed languages. Up to this point, we have
only discussed how our approach could mitigate certain troubles;
such as a difference of perspectives of modules, or of equivalent
operations acting on different perspectives of modules.
We now turn to discussing, in the following subsections, what it is that
is missing from existing module systems, what one actually wants to
do with modules, and conclude with a checklist of features that our
proposed system should meet in order to be considered usable
and adequate as a thesis-level effort.
</p>
</div>

<div id="outline-container-orga008de9" class="outline-3">
<h3 id="orga008de9"><span class="section-number-3">3.1</span> Missing Features</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Certain mechanically-derivable concepts, such as different perspectives,
are needlessly delegated to the user by pedestrian packaging systems.
Besides being tedious and error-prone, the inexpressibility of derivates
obscures the corresponding general principles underlying them, thus foregoing
any machine assistance in ensuring any correctness or safety-ness guarantees.
The desire to pursue a more economical yet powerful packaging system
follows from our research team's expedited efforts that could have been mechanised .
We will only mention two such use cases.
</p>

<p>
\noindent
<b>Expressivity:</b>
</p>

<p>
\noindent
A common pattern that can be seen, for example, in the Agda standard library,
is of a predicate ensuring desirable properties
OF its inputs, then of a record containing the inputs as fields along
with a proof of said predicate. More concretely, suppose we have a binary predicate
named <code>IsSemi</code> and the record is named <code>Semi</code>; the predicate form allows us to
quantify over inputs as in <code>∀ x y → IsSemi x y → ⋯</code>, in contrast the latter
approach is intrinsic in nature: <code>∀ (s ∶ Semi) → ⋯</code>
&#x2014;contrast this with a mathematician naturally declaring “let <code>s</code> be a semigroup”,
whereas almost never do mathematicians say “let <code>x</code> be a set and <code>y</code> be an operation on it that together constitute a semigroup”.
</p>

<p>
At a first glance, it does not seem too troublesome to produce the record
presentation from the predicate presentation: Simply <i>repeat all</i> the inputs
under a record declaration along with a proof obligation. However, the
word ‘repeat’ already suggests a problem, and ‘all’ suggests another one.
What if one desires to
utilise the record associated to the predicate by only packaging certain
inputs but not others? This is akin to the problem of constructors
in object-oriented languages: In Java, for example, one uses overloading
to provide a number of user-written constructors for only a few resonable
input invocations to construct an object; in contrast, Common Lisp permits
optional named arguments, and so in one fell swoop, with one user-written,
constructor, provides all possible combinations of constructor invocations
&#x2014;we are aiming at this level of power and flexibility.
</p>

<p>
Lest it's unclear, let's elaborate slightly on the idea.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Relation.Binary.PropositionalEquality</span>
open <span style="color: #b58900;">&#8801;-</span><span style="color: #b58900; font-style: italic;">Reasoning</span>

<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Z-notation for sums</span>
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Level</span>
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Product</span> using <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">&#931;</span> ; proj&#8321; ; proj&#8322; ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#215;</span><span style="color: #859900; font-weight: bold;">_</span> ; <span style="color: #859900; font-weight: bold;">_</span>,<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">)</span>
<span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #b58900;">&#8758;&#8226;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">{</span>a b <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Level</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> a<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> b<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #268bd2;">(</span>a <span style="color: #268bd2;">&#8852;</span> b<span style="color: #268bd2;">)</span>
<span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #b58900;">&#8758;&#8226;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#931;</span>
<span style="color: #859900; font-weight: bold;">infix</span> <span style="color: #b58900;">-</span>666 <span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #268bd2;">&#8758;&#8226;</span>
<span style="color: #b58900;">syntax</span> <span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #268bd2;">&#8758;&#8226;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">(</span>&#955; x <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#931;</span> x <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8226;</span> <span style="color: #b58900; font-style: italic;">B</span>
</pre>
</div>

<p>
A semigroup is an algebraic structure that models (untyped) compositionality:
It consists of a collection of objects of interests called the <code>Carrier</code> set,
and an operation <code>_⨾_</code> to compose existing items to produce new items, and the operation
is associative.
Below is a spectrum of ways to bundle up such a structure
&#x2013;starting from being completely bundled up all the way to being
completely exposed.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">One extreme: Completely bundled up</span>
<span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">Semigroup0</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>&#8321; <span style="color: #859900; font-weight: bold;">where</span>
  field
    <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>     <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span>
    assoc   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x y z <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span>x <span style="color: #268bd2;">&#10814;</span> y<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#10814;</span> z <span style="color: #268bd2;">&#8801;</span> x <span style="color: #268bd2;">&#10814;</span> <span style="color: #268bd2;">(</span>y <span style="color: #268bd2;">&#10814;</span> z<span style="color: #268bd2;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8216;Typeclass&#8217; on a given Carrier</span>
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Alternatively: Carrier is known as runtime.</span>
<span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">Semigroup1</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span><span style="color: #268bd2;">)</span><span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>&#8321; <span style="color: #859900; font-weight: bold;">where</span>
  field
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span>
    assoc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x y z <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span>x <span style="color: #268bd2;">&#10814;</span> y<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#10814;</span> z <span style="color: #268bd2;">&#8801;</span> x <span style="color: #268bd2;">&#10814;</span> <span style="color: #268bd2;">(</span>y <span style="color: #268bd2;">&#10814;</span> z<span style="color: #268bd2;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Two items known at run time --c.f., &#8220;IsSemi&#8221; above.</span>
<span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">Semigroup2</span>
 <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span><span style="color: #268bd2;">)</span>
 <span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>     <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
  field
    assoc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x y z <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span>x <span style="color: #268bd2;">&#10814;</span> y<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#10814;</span> z <span style="color: #268bd2;">&#8801;</span> x <span style="color: #268bd2;">&#10814;</span> <span style="color: #268bd2;">(</span>y <span style="color: #268bd2;">&#10814;</span> z<span style="color: #268bd2;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">A value of &#8220;Semigroup3 C op pf&#8221; is trivially the empty record, if any,</span>
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">provided &#8216;pf&#8217; is a proof that &#8216;C&#8217; forms a semigroup with &#8216;op&#8217;.</span>
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">This type is usualy written &#8220;&#931; C &#8758; Set &#8226; &#931; _&#10814;_ &#8758; C &#8594; C &#8594; C &#8226; &#931; assoc &#8758; &#8943;&#8221;.</span>
<span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">Semigroup3</span>
 <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span><span style="color: #268bd2;">)</span>
 <span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span><span style="color: #268bd2;">)</span>
 <span style="color: #268bd2;">(</span>assoc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x y z <span style="color: #268bd2;">&#8594;</span> <span style="color: #d33682;">(</span>x <span style="color: #268bd2;">&#10814;</span> y<span style="color: #d33682;">)</span> <span style="color: #268bd2;">&#10814;</span> z <span style="color: #268bd2;">&#8801;</span> x <span style="color: #268bd2;">&#10814;</span> <span style="color: #d33682;">(</span>y <span style="color: #268bd2;">&#10814;</span> z<span style="color: #d33682;">)</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
  <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">no fields</span>
</pre>
</div>
<p>
Depending on the user's needs, it may be useful to have one form or another.
Unfortunately they are enslaved to the choices of the library designer,
or if they deviate then they must produce tedious conversion methods and use
them to pad all the library methods for the structures.
Even worse, such back and forth conversions will not only be representation
shuffling but also wasteful of resources.
</p>

<p>
For example, every bijective function \(f : A \to B\) furnishes its target \(B\) with a semigroup
structure provided its source \(A\) has the structure to begin with.
Since the statement mentions the carriers of semigroups, it is only natural
to formulate it an prove it using presentation <code>Semigroup1</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">Surjection</span> <span style="color: #b58900;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>
<span style="color: #b58900; font-style: italic;">Surjection</span> <span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">A</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">B</span><span style="color: #268bd2;">}</span> f <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8704;</span> <span style="color: #268bd2;">(</span>b <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">B</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#931;</span> a <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8226;</span> b <span style="color: #268bd2;">&#8801;</span> f a
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">(&#931; a &#8758; A &#8226; P a) &#8776; { (a, proof) &#10073; a &#8712; A &#8743; pf is a proof of P(a) }</span>

<span style="color: #b58900; font-style: italic;">Injection</span> <span style="color: #b58900;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>
<span style="color: #b58900; font-style: italic;">Injection</span> <span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">A</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">B</span><span style="color: #268bd2;">}</span> f <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8704;</span> <span style="color: #268bd2;">{</span>x y<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span>  f x <span style="color: #268bd2;">&#8801;</span> f y <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8801;</span> y
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">translate1 <span style="color: #b58900;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span>f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Surjection</span> f <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Injection</span> f
       <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Semigroup1</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Semigroup1</span> <span style="color: #b58900; font-style: italic;">B</span>
<span style="color: #b58900;">translate1</span> f surj inj <span style="color: #b58900; font-style: italic;">AS</span> <span style="color: #268bd2;">=</span>
  <span style="color: #859900; font-weight: bold;">let</span>
    open <span style="color: #b58900; font-style: italic;">Semigroup1</span> <span style="color: #b58900; font-style: italic;">AS</span>

    <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">x &#10814;&#8242; y is obtained by applying f to the &#10814;-composition of the pre-images of x and y.</span>
    <span style="color: #859900; font-weight: bold;">infix</span> 5 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;&#8242;</span><span style="color: #859900; font-weight: bold;">_</span>
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;&#8242;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> &#955; x y <span style="color: #268bd2;">&#8594;</span> <span style="color: #859900; font-weight: bold;">let</span> a0 <span style="color: #268bd2;">=</span> proj&#8321; <span style="color: #268bd2;">(</span>surj x<span style="color: #268bd2;">)</span>; a1 <span style="color: #268bd2;">=</span> proj&#8321; <span style="color: #268bd2;">(</span>surj y<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">in</span> f <span style="color: #268bd2;">(</span>a0 <span style="color: #268bd2;">&#10814;</span> a1<span style="color: #268bd2;">)</span>

    <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">f distributes over &#10814; turning it into &#10814;&#8242;.</span>
    factor <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> <span style="color: #268bd2;">{</span>a a<span style="color: #268bd2;">&#8242;</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> f a <span style="color: #268bd2;">&#10814;&#8242;</span> f a<span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">&#8801;</span> f <span style="color: #268bd2;">(</span>a <span style="color: #268bd2;">&#10814;</span> a<span style="color: #268bd2;">&#8242;</span><span style="color: #268bd2;">)</span>
    factor <span style="color: #268bd2;">{</span>a<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">{</span>a<span style="color: #268bd2;">&#8242;</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">=</span>
           <span style="color: #859900; font-weight: bold;">let</span> &#119990;  , m  <span style="color: #268bd2;">=</span> surj <span style="color: #268bd2;">(</span>f a<span style="color: #268bd2;">)</span>
           &#119990;<span style="color: #268bd2;">&#8242;</span> , w  <span style="color: #268bd2;">=</span> surj <span style="color: #268bd2;">(</span>f a<span style="color: #268bd2;">&#8242;</span><span style="color: #268bd2;">)</span>
           <span style="color: #859900; font-weight: bold;">in</span>
           begin
         f a <span style="color: #268bd2;">&#10814;&#8242;</span> f a<span style="color: #268bd2;">&#8242;</span>
           <span style="color: #268bd2;">&#8801;</span><span style="color: #268bd2;">&#10216;</span> refl <span style="color: #268bd2;">&#10217;</span>
         f <span style="color: #268bd2;">(</span>&#119990; <span style="color: #268bd2;">&#10814;</span> &#119990;<span style="color: #268bd2;">&#8242;</span><span style="color: #268bd2;">)</span>
           <span style="color: #268bd2;">&#8801;</span><span style="color: #268bd2;">&#10216;</span> cong f <span style="color: #d33682;">(</span>cong&#8322; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900;">(</span>inj <span style="color: #cb4b16;">(</span>sym m<span style="color: #cb4b16;">)</span><span style="color: #859900;">)</span> <span style="color: #859900;">(</span>inj <span style="color: #cb4b16;">(</span>sym w<span style="color: #cb4b16;">)</span><span style="color: #859900;">)</span><span style="color: #d33682;">)</span>  <span style="color: #268bd2;">&#10217;</span>
         f <span style="color: #268bd2;">(</span>a <span style="color: #268bd2;">&#10814;</span> a<span style="color: #268bd2;">&#8242;</span><span style="color: #268bd2;">)</span>
           <span style="color: #268bd2;">&#8718;</span>

    distribute <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> <span style="color: #268bd2;">{</span>a a<span style="color: #268bd2;">&#8242;</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> f <span style="color: #268bd2;">(</span>a <span style="color: #268bd2;">&#10814;</span> a<span style="color: #268bd2;">&#8242;</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8801;</span> f a <span style="color: #268bd2;">&#10814;&#8242;</span> f a<span style="color: #268bd2;">&#8242;</span>
    distribute <span style="color: #268bd2;">{</span>a<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">{</span>a<span style="color: #268bd2;">&#8242;</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">=</span> sym <span style="color: #268bd2;">(</span>factor <span style="color: #d33682;">{</span>a<span style="color: #d33682;">}</span> <span style="color: #d33682;">{</span>a<span style="color: #268bd2;">&#8242;</span><span style="color: #d33682;">}</span><span style="color: #268bd2;">)</span>

  <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Bundle up &#10814;&#8242; along with a proof of associtivity</span>
    record <span style="color: #268bd2;">{</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;&#8242;</span><span style="color: #859900; font-weight: bold;">_</span>; assoc <span style="color: #268bd2;">=</span> &#955; x y z <span style="color: #268bd2;">&#8594;</span>
     <span style="color: #859900; font-weight: bold;">let</span>
    <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Obtain f-pre-images</span>
    a&#8320; , x<span style="color: #268bd2;">&#8776;</span>fa&#8320;  <span style="color: #268bd2;">=</span>  surj x
    a&#8321; , y<span style="color: #268bd2;">&#8776;</span>fa&#8321;  <span style="color: #268bd2;">=</span>  surj y
    a&#8322; , z<span style="color: #268bd2;">&#8776;</span>fa&#8322;  <span style="color: #268bd2;">=</span>  surj z
     <span style="color: #859900; font-weight: bold;">in</span>
      <span style="color: #93a1a1;">{- </span><span style="color: #96A7A9; font-style: italic;">Tersely, we rewrite along the pre-images,</span>
<span style="color: #96A7A9; font-style: italic;">     factor f, perform the associativity of &#10814;,</span>
<span style="color: #96A7A9; font-style: italic;">     then distribute f and rewrite along the pre-images.</span>
<span style="color: #96A7A9; font-style: italic;">      -}</span>
       begin
     <span style="color: #d33682;">(</span>x <span style="color: #268bd2;">&#10814;&#8242;</span> y<span style="color: #d33682;">)</span> <span style="color: #268bd2;">&#10814;&#8242;</span> z
       <span style="color: #268bd2;">&#8801;</span><span style="color: #d33682;">&#10216;</span> cong&#8322; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;&#8242;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900;">(</span>cong&#8322; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;&#8242;</span><span style="color: #859900; font-weight: bold;">_</span> x<span style="color: #268bd2;">&#8776;</span>fa&#8320; y<span style="color: #268bd2;">&#8776;</span>fa&#8321;<span style="color: #859900;">)</span> z<span style="color: #268bd2;">&#8776;</span>fa&#8322; <span style="color: #d33682;">&#10217;</span>
     <span style="color: #d33682;">(</span>f a&#8320; <span style="color: #268bd2;">&#10814;&#8242;</span> f a&#8321;<span style="color: #d33682;">)</span> <span style="color: #268bd2;">&#10814;&#8242;</span> f a&#8322;
       <span style="color: #268bd2;">&#8801;</span><span style="color: #d33682;">&#10216;</span> cong <span style="color: #859900;">(</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;&#8242;</span> f a&#8322;<span style="color: #859900;">)</span> factor <span style="color: #d33682;">&#10217;</span>
     f <span style="color: #d33682;">(</span>a&#8320; <span style="color: #268bd2;">&#10814;</span> a&#8321;<span style="color: #d33682;">)</span> <span style="color: #268bd2;">&#10814;&#8242;</span> f a&#8322;
       <span style="color: #268bd2;">&#8801;</span><span style="color: #d33682;">&#10216;</span> factor <span style="color: #d33682;">&#10217;</span>
     f <span style="color: #d33682;">(</span><span style="color: #859900;">(</span>a&#8320; <span style="color: #268bd2;">&#10814;</span> a&#8321;<span style="color: #859900;">)</span> <span style="color: #268bd2;">&#10814;</span> a&#8322;<span style="color: #d33682;">)</span>
       <span style="color: #268bd2;">&#8801;</span><span style="color: #d33682;">&#10216;</span> cong f <span style="color: #859900;">(</span>assoc <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #859900;">)</span>  <span style="color: #d33682;">&#10217;</span>
     f <span style="color: #d33682;">(</span>a&#8320; <span style="color: #268bd2;">&#10814;</span> <span style="color: #859900;">(</span>a&#8321; <span style="color: #268bd2;">&#10814;</span> a&#8322;<span style="color: #859900;">)</span><span style="color: #d33682;">)</span>
       <span style="color: #268bd2;">&#8801;</span><span style="color: #d33682;">&#10216;</span> distribute <span style="color: #d33682;">&#10217;</span>
     f a&#8320; <span style="color: #268bd2;">&#10814;&#8242;</span> f <span style="color: #d33682;">(</span>a&#8321; <span style="color: #268bd2;">&#10814;</span> a&#8322;<span style="color: #d33682;">)</span>
       <span style="color: #268bd2;">&#8801;</span><span style="color: #d33682;">&#10216;</span> cong <span style="color: #859900;">(</span>f a&#8320; <span style="color: #268bd2;">&#10814;&#8242;</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #859900;">)</span> distribute <span style="color: #d33682;">&#10217;</span>
     f a&#8320; <span style="color: #268bd2;">&#10814;&#8242;</span> <span style="color: #d33682;">(</span>f a&#8321; <span style="color: #268bd2;">&#10814;&#8242;</span> f a&#8322;<span style="color: #d33682;">)</span>
       <span style="color: #268bd2;">&#8801;</span><span style="color: #d33682;">&#10216;</span> sym <span style="color: #859900;">(</span>cong&#8322; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;&#8242;</span><span style="color: #859900; font-weight: bold;">_</span> x<span style="color: #268bd2;">&#8776;</span>fa&#8320; <span style="color: #cb4b16;">(</span>cong&#8322; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;&#8242;</span><span style="color: #859900; font-weight: bold;">_</span> y<span style="color: #268bd2;">&#8776;</span>fa&#8321; z<span style="color: #268bd2;">&#8776;</span>fa&#8322;<span style="color: #cb4b16;">)</span><span style="color: #859900;">)</span>  <span style="color: #d33682;">&#10217;</span>
     x <span style="color: #268bd2;">&#10814;&#8242;</span> <span style="color: #d33682;">(</span>y <span style="color: #268bd2;">&#10814;&#8242;</span> z<span style="color: #d33682;">)</span>
       <span style="color: #268bd2;">&#8718;</span>
  <span style="color: #268bd2;">}</span>
</pre>
</div>
<p>
<code>translate1</code> is a lengthy proof, we could repeat it, or invoke it.
Since duplication with alteration is error-prone and non-generic,
we shall aim for the latter.
</p>

<div class="org-src-container">
<pre class="src src-haskell">translate0 <span style="color: #b58900;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">AS</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Semigroup0</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span>f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Semigroup0.Carrier</span> <span style="color: #b58900; font-style: italic;">AS</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span><span style="color: #268bd2;">)</span>
       <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Surjection</span> f <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Injection</span> f
       <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Semigroup0</span>
<span style="color: #b58900;">translate0</span> <span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">B</span><span style="color: #268bd2;">}</span> <span style="color: #b58900; font-style: italic;">AS</span> f surj inj <span style="color: #268bd2;">=</span> record <span style="color: #268bd2;">{</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">B</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> ; assoc <span style="color: #268bd2;">=</span> assoc <span style="color: #268bd2;">}</span>
  <span style="color: #859900; font-weight: bold;">where</span>

       <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Repackage &#8216;AS&#8217; from a &#8216;Semigroup0&#8217; to a &#8216;Semigroup1&#8217;</span>
       <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">only to immediatley unpack it, so that its contents</span>
       <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">are available to be repacked above as a &#8216;Semigroup0&#8217;.</span>

       pack <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Semigroup1</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Semigroup0.Carrier</span> <span style="color: #b58900; font-style: italic;">AS</span><span style="color: #268bd2;">)</span>
       pack <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">let</span> open <span style="color: #b58900; font-style: italic;">Semigroup0</span> <span style="color: #b58900; font-style: italic;">AS</span>
           <span style="color: #859900; font-weight: bold;">in</span> record <span style="color: #268bd2;">{</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>; assoc <span style="color: #268bd2;">=</span> assoc <span style="color: #268bd2;">}</span>

       open <span style="color: #b58900; font-style: italic;">Semigroup1</span> <span style="color: #268bd2;">(</span>translate1 f surj inj pack<span style="color: #268bd2;">)</span>
</pre>
</div>
<p>
Observe that <code>translate0</code> repackages <code>AS</code> via <code>pack</code>,
then passes that as an argument to <code>translate1</code>, which in turn unpacks it
to form a new <code>Semigroup0</code>, which is then unpacked in the
last line above.
Regardless of any possible wasteful amount of packing and unpacking of records
&#x2013;which may be mitigated via inlining&#x2013;
the way <code>translate0</code> is written is far from ideal;
whereas <code>translate1</code> is the appropriate level of abstraction to pose the problem.
Instead, it would be ideal to write the method at a sufficient level of generality
such that <code>translate0</code> and <code>translate1</code> are, say, polymorphic instances thereof.
This is what we shall propose in a later section.
</p>

<p>
Moreover, as a stylistic decision, implementers may prefer to view
an object in either its predicate form &#x2014;with the constituents varying&#x2014;
or in its record form &#x2014;with the constituents fixed&#x2014;, will all
library utilities tied to a particular form.
</p>

<p>

</p>

<p>
<b>Efficiency:</b>
</p>

<p>
A hallmark of computing is to reduce new problems to ones already considered.
One realisation of this principle is found in the sharing mechanisms of
certain lazy languages: In the expression <code>let y = f(x) in g(y, y)</code>,
the term <code>y</code> is evaluated once and the result is shared among its multiple
call sites. This idea comes under the name of <i>thunks</i>:
When we encounter an instance of <code>y</code> and we need to ‘think’
of its value, we realise we have already ‘thunk’ it.
</p>

<p>
Memory is tremendously difficult to reason about ,
and lazy sharing only compounds to the troubles of garbage collection
and complexity analysis .
</p>

<p>
Dependently-typed languages are usually not only utilised for programming
but generally also for proof; as such, their implementations adhere to
a particular logic.
</p>

<p>
To be completed …
</p>

<p>
<b>Excerption:</b>
</p>

<p>
In order to produce reusable components, theories &#x2014;i.e., packages&#x2014; are formed
from existing theories by adding only one new concept at a time. Such an approach
reduces the possibility of missing a useful structure in the hierarchy, as well
as provides tremendous generality &#x2014;operations can be rendered using the minimal
interface required rather than one that is overly expressive. This is a common
scheme when formalising mathematics \parencite{typeclasses_for_maths,coq_cat_experiences}.
</p>

<p>
Unfortunately, a common scenario is when one wants to <i>instantiate</i> such a deeply
nested theory. More concretely, suppose we have the following fine-grained
hierarchy.
</p>
<div class="org-src-container">
<pre class="src src-plantuml">skinparam defaultTextAlignment center

[*] -&gt; Empty
Empty -&gt; Type
Type -down-&gt; Pointed
Type -&gt; Magma
Magma -&gt; Semigroup
Pointed   -down-&gt; Pointed_Semigroup
Semigroup -down-&gt; Pointed_Semigroup
Pointed_Semigroup -down-&gt; Left_Unital_Semigroup
Pointed_Semigroup -down-&gt; Right_Unital_Semigroup
Left_Unital_Semigroup -down-&gt; Monoid
Right_Unital_Semigroup -down-&gt; Monoid

Type : Carrier
Pointed : Carrier, point
Magma : Carrier, binary_op
Semigroup : Carrier, binary_op, associativity

Pointed_Semigroup : Carrier, point, binary_op, associativity
Left_Unital_Semigroup : &#10218;inherit above&#10219;, left_identity_law
Right_Unital_Semigroup : &#10218;inherit above&#10219;, right_identity_law

Monoid : Carrier, point, binary_op, associativity, identity_laws

center footer  Example Hierarchy
</pre>
</div>

<div class="figure">
<p><img src="example_hierarchy_10.png" alt="example_hierarchy_10.png" />
</p>
</div>

<p>
If we have the ingredients for a monoid in hand, we are unfortunately first
required to produce a left or right unital semigroup, which requires us to produce
a pointed semigroup first, and this regress continues to the base theory, <code>Type</code>.
Building on semigroups, monoids are a ubiquitous model of compositionality,
and so this scenario
happens rather often, in one guise or another. The amount of syntactic noise
required to produce a simple instantiation is unreasonable: One should not be forced
to work through the hierarchy if it provides no immediate benefit.
It is to be noted that this issue does not generally apply to implementations of
object-oriented class supporting multiple interfaces.
</p>

<p>
Even worse, pragmatically speaking, to access a field deep down in a nested structure
results in overtly lengthy and verbose names. Indeed, in the above example, the monoid
operation lives at the bottom-most level, we would need to access all the intermediary
levels to simply refer to it. Such verbose invocations would immediately give way to
helper functions to refer to fields lower in the hierarchy; yet another opportunity
for boilerplate to leak in.
</p>

<p>
It is interesting to note that diamond hierarchies cannot be trivially eliminated
when providing fine-grained hierarchies. As such, we make no rash decisions
regarding limiting them &#x2014;and completely forgoe the unreasonable
possibility of forbidding them.
</p>

<p>
A more common example from programming is that of providing monad instances
in Haskell. Most often users want to avoid tedious case analysis or prefer a
sequential-style approach to producing programs, so they want to furnish a
type constructor with a monad instance in order to utilise Haskell's <code>do</code>-notation.
Unfortunately, this requires an applicative instances, which in turn requires
a functor instance. However, providing the return-and-bind interface for monads
allows us to obtain functor and applicative instances.
Consequently, many users simply provide local names for the return-and-bind
interface then use that to provide the default implementations for the other
interfaces. In this scenario, the standard approach is side-stepped by manually
carrying out a mechanical and tedious set of steps that not only wastes time
but obscures the generic process and could be error-prone.
</p>

<p>
Instead, it would be desirable to ‘flatten’ the hierarchy into a single package,
consisting of the fields throughout the hierarchy, possibly with default
implementations, yet still be able to view
the resulting package at base levels in the hierarchy.
Another benefit of this approach is that it allows users to utilise the package
without consideration of how the hierarchy was formed, thereby providing library
designers with the freedom to alter it in the future.
</p>

<p>
These features are considered ‘missing’ since they are reasonably achievable
in a dependently-typed system &#x2014;e.g., the different forms of dependently-typed
bundling suggest a form of polymorphism.
Their absence may be due to logistic reasons,
such as no effort expedited in their direction, or due to issues surrounding
the logical frameworks of the systems. Which is to blame is an investigation
matter left to the thesis research.
</p>
</div>
</div>
<div id="outline-container-org0517160" class="outline-3">
<h3 id="org0517160"><span class="section-number-3">3.2</span> Desirable Features</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Our preliminary research, and personal use with dependently-typed systems,
has yielded three strongly desirable features of a module system for DTLs.
</p>

<p>
<b>Uniformity:</b>
</p>

<p>
A type alias and a value alias are merely aliases at the end of the day,
so unlike Haskell, for example, which distinguishes the two, Agda, for example,
does not. More generally, type families, simple types, type constructors,
dependent types, etc, collapse into a single category: Dependent types.
</p>

<p>
In particular, recall the canonical definition of ‘term’:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">term</span> <span style="color: #b58900;">::=</span>  x                    <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">variable</span>
      <span style="color: #268bd2;">|</span>   f<span style="color: #268bd2;">(</span>term_0, <span style="color: #268bd2;">&#8230;</span>, term_N<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">function application</span>
</pre>
</div>
<p>
In pedestrian languages, one distinguishes between <i>value</i> terms and <i>type</i> terms,
whence the <code>t_i</code> are constrained to be homogeneously all values or all types.
In contrast, a dependently-typed languages makes no such limitation, thereby allowing
the <code>t_i</code> to be heterogeneous. For example, in a simple type system, <code>Maybe (A × List B)</code>
is a term where all variables, \(t_0, t_1 = A, B\), are of the same kind &#x2014;types.
This is not so with the term \newline <code>Maybe (A × Vec B n)</code> ---<code>A</code> and <code>B</code> are types while <code>n</code> is a number.
Our aim is not to educate the reader on the power and utility of dependent types;
we invite the reader to consult any of the existing material \parencite{dtl_why, agda_overview}.
</p>

<p>
In the same vein, the varying notions of packaging are treated differently
even though they are isomorphic in certain scenarios or interdefinable in others.
As such, it would be useful to reduce the syntactic distinction between them.
</p>

<p>
<b>Genericity:</b>
</p>

<p>
Type polymorphism permits us to produce functions written once with type variables
and have them applied to radically different types. Likewise, it would be desirable
to write once a generic function on a kind of package and have it operate on
the many variations of packaging.
</p>

<p>
An example of this idea is presented at
the end of this section, as part of preliminary research.
In particular, we demonstrate a novel form of generic programming,
<i>package polymorphism</i>: A method is written against a generic notion of container
and is then applied to derived notions
&#x2014;such as the \texttt{Semigroup}\(i\) forms from the previous section.
</p>

<p>
<b>Extensiblity:</b>
</p>

<p>
Systems tend to come with a pre-defined set of operations for built-in constructs;
the user is left to utilise third-party pre-processing tools, for example, to
provide extra-linguistic support for common repetitive scenarios they encounter.
</p>

<p>
More concretely, a large number of proofs can be discharged by merely pattern
matching on variables &#x2014;this works since the case analysis reduces the proof goal
into a trivial reflexitivity obligation, for example. The number of cases can
quickly grow thereby taking up space, which is unfortunate since the proof has
very little to offer besides verifying the claim. In such cases, a pre-process,
perhaps an “editor tactic”, could be utilised to produce the proof in an auxiliary
file, and reference it in the current file.
</p>

<p>
Perhaps more common is the renaming of package contents, by hand.
For example, when a notion of preorder is defined with relation named <code>_≤_</code>,
one may rename it and all references to it by, say, <code>_⊑_</code>. Again, a pre-processor
or editor-tactic could be utilised, but many simply perform the re-write by hand
&#x2014;which is tedious, error prone, and obscures the generic rewriting method.
</p>

<p>
It would be desirable to allow packages to be treated as first-class concepts
that could be acted upon, in order to avoid third-party tools that obscure
generic operations and leave them out of reach for the powerful typechecker of
a dependently typed system.
</p>

<p>
These features are desirable for working with modules, yet raise a number of
immediate concerns. For example, uniformity may lead to ambiguous parsing,
genericity may lead to inefficient execution, and extensibility borders on
meta-programming thereby leaving the realm of types altogether.
Possible limitations on these features may result in the thesis efforts
to implement them in a dependently-typed system, such as Agda.
</p>
</div>
</div>

<div id="outline-container-orgdc946aa" class="outline-3">
<h3 id="orgdc946aa"><span class="section-number-3">3.3</span> One-Item Checklist for a Candidate Solution</h3>
<div class="outline-text-3" id="text-3-3">
<p>
An adequate module system for dependently-typed languages should make
use of dependent-types as much as possible. As such, there is essentially
one and only one primary goal for a module system to be considered
reasonable for dependently-typed languages: Needless distinctions should be
eliminated as much as possible.
</p>

<p>
The “write once, instantiate many” attitude is well-promoted in functional
communities predominately for <i>functions</i>, but we will take this approach to
modules as well, beyond the features of, e.g., *ML functors.
With one package declaration, one should be able to mechanically
derive data, record, typeclass, product, sum formulations, among many others.
All operations on the generic package then should also apply to the particular
package instantiations.
</p>

<p>
This one goal for a reasonable solution has a number of important and difficult
subgoals. The resulting system should be well-defined with a coherent semantic
underpinning &#x2014;possibly being a conservative extension&#x2014;; it should support the elementary uses
of pedestrian module systems;
the algorithms utilised need to be proven correct with a mechanical proof assistant,
considerations for efficiency cannot be dismissed if the system is to be usable;
the interface for modules should be as minimal as possible,
and, finally, a large number of existing use-cases must be rendered tersely
using the resulting system without jeopardising runtime performance in order to demonstrate its success.
</p>

<p>
During the research stage of the thesis, some of the sub-goals may be altered
radically, dismissed altogether, or new ones brought forth due to implementation
considerations. However, the one main goal will remain unchanged as it is how
we have chosen to measure the minimal adequacy for a module system for rich
settings that include dependent-types.
</p>
</div>
</div>
<div id="outline-container-org59b062f" class="outline-3">
<h3 id="org59b062f"><span class="section-number-3">3.4</span> Preliminary Research</h3>
<div class="outline-text-3" id="text-3-4">
<p>
The homogeneous treatment of structuring mechanisms is herein presented using a prototype
developed using the user-friendly Emacs application framework by means of textual expansion,
the details of which are largely uninteresting &#x2014;suffice it to say, the code is tremendously terse.
In this section we demonstrates that packaging concepts differ only in their use, leading to a uniform
syntax of which first-class records are an instance and so the resulting system is homoiconic in nature.
We introduce fictitious syntax, mostly in red, with its intended Agda elaboration in blue
&#x2014;the users write the red and expect it to behave like the blue; no “code generation” transpires.
</p>

<p>
The reader is advised to remember that the value of a prototype is in the guidance it provides,
not the implementation itself nor any of its design decisions &#x2014;such as using strings in meta-programming
scenarios. In other words, for the reader, portions of this section may serve as an exercise in foresight and patience.
( A brief demonstration of the prototype may be viewed at <a href="https://www.youtube.com/watch?v=NYOOF9xKBz8">https://www.youtube.com/watch?v=NYOOF9xKBz8</a> .)
</p>

<p>
A prime guiding design decision is
<i>try to avoid making any decisions, including unconscious restrictions, unless deemed necessary!</i>
</p>

<p>
The initiated reader will quickly notice that our package formers are just theory presentations
&#x2014;a list of name-type pairs. The chosen phrasing is due to the target audience, DTL programmers.
We are not committed to the name, but unlike the overloaded ‘module’, ‘package former’ is a good
new name without too many meanings. We have not provided full semantics for package formers, but
we have provided concrete well-defined elaborations to communicate the intent: A package former
is akin to a type former, it is ‘incomplete’ and does not define a concrete package until a certain
tag is provided.
It is part of the thesis effort to investigate which features of our proposed package formers
break, or become limited, when considered with other language constructs.
</p>

<p>
The uniformity in syntax reduces the variety of sub-languages in a dependently-typed language
by eliminating needless distinctions for notions of containers. The first subsection below
addresses syntactic similarity, whereas the second tackles computing similarity,
and we conclude with a brief discussion on foundational concerns.
</p>
</div>

<div id="outline-container-org3f2710b" class="outline-4">
<h4 id="org3f2710b"><span class="section-number-4">3.4.1</span> First Observation: Syntactic Similarity for Containers</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
Since the prototypical notion of packaging is that of records,
which are value terms, all, necessarily succeeding, notions of packaging
ought to be treated uniformly as value types.
Consequently, variations on packaging should only be signalled by necessary
keywords, and otherwise should be syntactically indistinguishable.
That is to say, a ‘variation’ is a tag identifying what particular
form of module is desired, such as <code>datatype</code> for an algebraic data type
with the declared fields as constructors, or as <code>record</code> to yield a record structure
with constituents being the declared fields.
</p>

<p>
For example, just as <code>List</code> is a type-former, we may declare a ‘package former’:
</p>

<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #b58900; font-style: italic;">PackageFormer</span> <span style="color: #b58900; font-style: italic;">TermP</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
    <span style="color: #b58900; font-style: italic;">Var</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Int</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v
    <span style="color: #b58900; font-style: italic;">Add</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v
</pre>
</div>

<p>
Note that a package former is just a sequence of names with types and,
as will be demonstrated later, optional default types.
It requires a particular “interpretation” &#x2014;possibly user-defined&#x2014;,
to produce some notion of package. This is signalled by the <code>Variation</code>
type, which for brevity contains <code>data, record, typeclass</code>, and a few more
that we will meet below.
</p>

<p>
For example, the <code>data</code> variation of packaging gives us a
free data type.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">TermData</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">TermP</span> <span style="color: #859900; font-weight: bold;">data</span>
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773;  data TermData : Set where</span>
<span style="color: #96A7A9; font-style: italic;">     Var : Int &#8594; TermData</span>
<span style="color: #96A7A9; font-style: italic;">     Add : TermData &#8594; TermData &#8594; TermData</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>
<p>
In the comment above, we indicate how our fictitious syntax is intended to be elaborated
into current Agda syntax. Besides syntax, induction principles are also derived:
Our envisioned system would be able to derive simple, tedious, uninteresting concepts;
leaving difficult, interesting, ones  for humans to solve.
For this type, below is the dependently typed eliminator, which in a DTL, corresponds to an induction
principle.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">   term-data-elim : &#8704; {&#8467;} {R : TermData &#8594; Set &#8467;}</span>
<span style="color: #96A7A9; font-style: italic;">          &#8594; (base : (n : Int) &#8594; R (Var n))</span>
<span style="color: #96A7A9; font-style: italic;">          &#8594; (ind  : &#8704; {s t} &#8594; R s &#8594; R t &#8594; R (Add s t))</span>
<span style="color: #96A7A9; font-style: italic;">          &#8594; (t : TermData) &#8594; R t</span>

<span style="color: #96A7A9; font-style: italic;">   term-data-elim base ind (Var n)   = base n</span>
<span style="color: #96A7A9; font-style: italic;">   term-data-elim base ind (Add s t) = ind rs rt</span>
<span style="color: #96A7A9; font-style: italic;">      where rs = term-data-elim base ind s</span>
<span style="color: #96A7A9; font-style: italic;">        rt = term-data-elim base ind t</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>

<p>
The type of the package former, for now, could simply be <code>Set</code>
&#x2014;c.f., the commented-out elaboration which declares <code>TermData ∶ Set</code>.
However, if we permit a sufficiently small subtyping system, we
may find it desirable to have the type of a package former be itself
a package former! Moreover, if package former <code>t</code> has type package former <code>t′</code>,
then the user should be able to use <code>t</code> at the levels <code>t ∶ s</code>
without too much overhead, where <code>s</code> is any subtype of <code>t</code> with <code>Set</code> being a minimal
such subtype. These thoughts are hurried and it is the purpose of the thesis
to investigate what is the appropriate route.
</p>

<p>
It is often the case that one begins working with a <code>record</code> of useful semantic
data, but then, say, for proof automation, may want to use the associated <code>datatype</code>
for syntax. The latter should be mechanically derivable, and this is what we aim
provide with our package formers.
We will not delve into the relationship between free data types and how, for example,
their associated catamorphism is necessarily also an interpreter
&#x2014;in the programming languages sense.
The reader is invited to consult a reference \parencite{cats_logic_shulman}.
</p>

<p>
We shall not discuss polymorphism along variations, the <code>v</code> components above,
as it is orthogonal to our immediate goals. For example, <code>TermP</code> could have a field typed
\newline \texttt{TermP (f v) → TermP (g v) → TermP v},
where <code>f</code> and <code>g</code> are operations on variations.
Nonetheless, this is a feature that one should be aware of.
</p>

<p>
The remaining items instantiate package formers for the usual
common uses. Including notions of records in item 1;
an algorithmic sketch underlying the examples of item 1 is presented in item2;
union types and external, second-class, modules in item 3;
package former polymorphism in item 4;
operating on package formers and inheritance in items 5 and 6; then discuss
how package formers handle the diamond problem in item 7.
Finally, we close in item 8 by discussing a problem not generally found
in pedestrian languages and how it is solved using package formers.
</p>
</div>

<ol class="org-ol">
<li><a id="org83e1752"></a>The Generality of Package Formers &#x2014;Products<br />
<div class="outline-text-5" id="text-3-4-1-1">
<p>
To demonstrate the generality of the notion of package formers we shall demonstrate
how other common forms could be ‘derived’ from the single declaration above.
It is to be noted that for such a small example, such derived code may be taken for
granted, however for much larger theories &#x2014;for example, a “field” comes with more than
20 fields&#x2014; the ability to derive different perspectives in a consistent fashion
is indispensable; especially when the package is refactored.
More realistically, a symmetric rig groupoid uses about 212 coherence laws \parencite{rig_computation},
for which case-splitting, to perform proofs, yields <a href="https://github.com/JacquesCarette/pi-dual">over 200 goals</a> thereby making
metaprogramming a tempting approach.
</p>

<p>
field ≅ ablean group ⟶ Carrier, op, inv, unit, assoc, 2 unit-laws, 2 inverse-laws, comm-law ⟶ 10 laws
      multiplicative monoid ⟶ Carrier, op, unit, assoc, 2 unit-laws ⟶ 6 laws
      the above two carries are identical  ⟶ 1 law
      distributively laws   ⟶ 2 laws
      integrity &amp; div-op &amp; non-zero division ⟶ 3 laws
</p>

<p>
Total ⟶ 22 laws
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">An instance of  TermRecord should have a carrier type</span>
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">containing the integers, &#8216;Var&#8217;, and supports some binary operation, &#8216;Add&#8217;.</span>
<span style="color: #b58900; font-style: italic;">TermRecord</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">TermP</span> record
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773;   record TermRecord  : Set where</span>
<span style="color: #96A7A9; font-style: italic;">      field</span>
<span style="color: #96A7A9; font-style: italic;">    Carrier : Set</span>
<span style="color: #96A7A9; font-style: italic;">    Var     : Int &#8594; Carrier</span>
<span style="color: #96A7A9; font-style: italic;">    Add     : Carrier &#8594; Carrier &#8594; Carrier</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>
<p>
In the previous  and following invocations, the name <code>Carrier</code> is a system internal, for now,
and can easily be <code>renamed</code> &#x2014;as will be demonstrated later on.
For now, we adhere to a single-sorted stance: Unless indicated otherwise, a <code>Carrier</code> will always
be included. An example of a two-sorted algebraic structure, graphs, is demonstrated at the end of this subsection.
</p>

<p>
Built-in names, such as <code>Carrier</code>, are generally not ideal. For example, a machine may provide the
names <code>FourLeggedFeline</code> and <code>CommutativeIdempotentMonoid</code> where a human may prefer <code>Cat</code> and <code>JoinSemilattice</code> instead.
As such, the resulting system, would accept ‘renaming’ functions to generate names. For now, we mostly limit
such an approach for brevity.
</p>


<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">TermOn</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">TermP</span> typeclass
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773;   record TermOn (Carrier : Set) : Set where</span>
<span style="color: #96A7A9; font-style: italic;">      field</span>
<span style="color: #96A7A9; font-style: italic;">    Var     : Int &#8594; Carrier</span>
<span style="color: #96A7A9; font-style: italic;">    Add     : Carrier &#8594; Carrier &#8594; Carrier</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">TermFunctionsOn</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">TermP</span> tuples
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">TermFunctionsOn : Set &#8594; Set</span>
<span style="color: #96A7A9; font-style: italic;">TermFunctionsOn C = (Int &#8594; C) &#215; (C &#8594; C &#8594; C)</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">TermFunctions</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">TermP</span> <span style="color: #b58900; font-style: italic;">&#931;</span>
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8773;  TermFunctions  =  &#931; C &#8758; Set  &#8226;  &#931; Var : Int &#8594; C  &#8226;  (C &#8594; C &#8594; C)</span>
</pre>
</div>

<p>
Let's show a more intricate yet desirable use.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">PointedSemigroup</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">TermP</span> record hiding <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Var</span><span style="color: #268bd2;">)</span> renaming <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Add</span> to <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">)</span>
             field
               <span style="color: #b58900; font-style: italic;">Id</span>     <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span>
               <span style="color: #268bd2;">&#10814;-</span>assoc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x y z <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#10814;</span> <span style="color: #268bd2;">(</span>y <span style="color: #268bd2;">&#10814;</span> z<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8801;</span> <span style="color: #268bd2;">(</span>x <span style="color: #268bd2;">&#10814;</span> y<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#10814;</span> z
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773;   record PointedSemigroup  : Set&#8321; where</span>
<span style="color: #96A7A9; font-style: italic;">      field</span>
<span style="color: #96A7A9; font-style: italic;">    Carrier : Set</span>
<span style="color: #96A7A9; font-style: italic;">    _&#10814;_     : Carrier &#8594; Carrier &#8594; Carrier</span>
<span style="color: #96A7A9; font-style: italic;">    Id      : Carrier</span>
<span style="color: #96A7A9; font-style: italic;">    &#10814;-assoc : &#8704; x y z &#8594; x &#10814; (y &#10814; z) &#8801; (x &#10814; y) &#10814; z</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>
</div>
</li>

<li><a id="org432c8ed"></a>Algorithmically Obtaining Elaborated Types<br />
<div class="outline-text-5" id="text-3-4-1-2">
<p>
We have discussed how the generic package formers elaborate
&#x2014;each blue comment indicates a standalone isomorphic Agda rendition&#x2014;,
as such it should be unsurprising that the constituents of a package former
are dependently typed functions <i>consuming</i> each concrete variation in
its traditional fashion. Let's clarify this idea further.
</p>


<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">PackageFormer</span> <span style="color: #b58900; font-style: italic;">TermP</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
   <span style="color: #b58900; font-style: italic;">Var</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Int</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v
   <span style="color: #b58900; font-style: italic;">Add</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v
</pre>
</div>

<p>
The ‘type’ of the first item, for example, is as follows
&#x2014;where <code>TermP v</code> is rewritten using the above introduced names
for the sake of clarity.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">Var</span> <span style="color: #b58900;">:</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>

<span style="color: #93a1a1;">{- </span><span style="color: #96A7A9; font-style: italic;">Datatype constructor -}</span>
<span style="color: #b58900; font-style: italic;">Var</span> datatype   <span style="color: #268bd2;">=</span>  <span style="color: #b58900; font-style: italic;">Int</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermData</span>
<span style="color: #93a1a1;">{- </span><span style="color: #96A7A9; font-style: italic;">Dependent projection -}</span>
<span style="color: #b58900; font-style: italic;">Var</span> record     <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">(</span>&#964; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermRecord</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Int</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermRecord.Carrier</span> &#964;
<span style="color: #b58900; font-style: italic;">Var</span> <span style="color: #b58900; font-style: italic;">&#931;</span>          <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">(</span>&#964; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermFunctions</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Int</span> <span style="color: #268bd2;">&#8594;</span> proj&#8321; &#964;
<span style="color: #93a1a1;">{- </span><span style="color: #96A7A9; font-style: italic;">Parameter of a constraint -}</span>
<span style="color: #b58900; font-style: italic;">Var</span> typeclass  <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">C</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">{</span><span style="color: #d33682;">{</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermOn</span> <span style="color: #b58900; font-style: italic;">C</span><span style="color: #d33682;">}</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Int</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">C</span>
<span style="color: #b58900; font-style: italic;">Var</span> tuples     <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">C</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermFunctionsOn</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Int</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">C</span>
<span style="color: #268bd2;">&#8943;</span>
</pre>
</div>

<p>
An initial glance suggests that this is all ad-hoc; let us demonstrate that
this is not the case. Suppose there were a method <code>𝒯</code> to obtain the user-provided types of
constituents; e.g., the given <code>Var ∶ Int → TermP v</code> is indistinguishable from \newline  <code>Var ∶ 𝒯 “Var” (TermP v)</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">Constituent</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">String</span> <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Draft idea, not ideal.</span>

<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8220;A &#10216;n&#10217;&#8594; B  &#8776;  A &#8594; &#8943; &#8594; A &#8594; B&#8221; with n-many A's.</span>
<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10216;</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10217;</span><span style="color: #268bd2;">&#8594;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>
<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10216;</span> zero   <span style="color: #268bd2;">&#10217;</span><span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>  <span style="color: #268bd2;">=</span>  <span style="color: #b58900; font-style: italic;">B</span>
<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10216;</span> succ n <span style="color: #268bd2;">&#10217;</span><span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>  <span style="color: #268bd2;">=</span>  <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">A</span> <span style="color: #d33682;">&#10216;</span> n <span style="color: #d33682;">&#10217;</span><span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span><span style="color: #268bd2;">)</span>

<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Constituents of package formers give rise to &#8220;Set &#10216;n&#10217;&#8594; Set&#8221; functions.</span>
<span style="color: #b58900; font-style: italic;">&#119983;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">P</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">PackageFormer</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Constituent</span> <span style="color: #b58900; font-style: italic;">P</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #268bd2;">&#10216;</span> arity <span style="color: #b58900; font-style: italic;">P</span> <span style="color: #268bd2;">&#10217;</span><span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>
<span style="color: #b58900; font-style: italic;">&#119983;</span> &#8220;<span style="color: #b58900; font-style: italic;">Var</span>&#8221; <span style="color: #b58900; font-style: italic;">X</span>  <span style="color: #268bd2;">=</span>  <span style="color: #b58900; font-style: italic;">Int</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>
<span style="color: #b58900; font-style: italic;">&#119983;</span> &#8220;<span style="color: #b58900; font-style: italic;">Add</span>&#8221; <span style="color: #b58900; font-style: italic;">X</span>  <span style="color: #268bd2;">=</span>  <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>
</pre>
</div>
<p>
It is now trivial to reify the above prescription for <code>Var</code> in a uniformly fashion
&#x2014;namely, <code>Var = 𝓉𝓎𝓅𝒆 “Var”</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell">&#120009;&#120014;&#120005;&#119942; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Constituent</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Variation</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>
&#120009;&#120014;&#120005;&#119942; c v<span style="color: #268bd2;">@</span>datatype  <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119983;</span> c <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">TermP</span> v<span style="color: #268bd2;">)</span>
&#120009;&#120014;&#120005;&#119942; c v<span style="color: #268bd2;">@</span>record    <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">(</span>&#964; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermP</span> v<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119983;</span> c <span style="color: #268bd2;">(</span><span style="color: #d33682;">(</span><span style="color: #b58900; font-style: italic;">TermP</span> v<span style="color: #d33682;">)</span><span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Carrier</span> &#964;<span style="color: #268bd2;">)</span>
&#120009;&#120014;&#120005;&#119942; c v<span style="color: #268bd2;">@</span><span style="color: #b58900; font-style: italic;">&#931;</span>         <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">(</span>&#964; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermP</span> v<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119983;</span> c <span style="color: #268bd2;">(</span>proj&#8321; &#964;<span style="color: #268bd2;">)</span>
&#120009;&#120014;&#120005;&#119942; c v<span style="color: #268bd2;">@</span>typeclass <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">C</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">{</span><span style="color: #d33682;">{</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermP</span> v <span style="color: #b58900; font-style: italic;">C</span><span style="color: #d33682;">}</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119983;</span> c <span style="color: #b58900; font-style: italic;">C</span>
&#120009;&#120014;&#120005;&#119942; c v<span style="color: #268bd2;">@</span>tuples    <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">C</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119983;</span> c <span style="color: #b58900; font-style: italic;">C</span>
<span style="color: #268bd2;">&#8943;</span>
</pre>
</div>
<p>
For example, invoking this approach we find that <code>Add</code>, on <code>TermRecord</code>'s, is typed \newline
<code>𝓉𝓎𝓅𝒆 “Add” record</code>, which may be rewritten as \newline
<code>(τ ∶ TermRecord) → TermRecord.Carrier τ → TermRecord.Carrier τ → TermRecord.Carrier τ</code>.
That is, as expected, <code>Add</code> on records consumes a record value then acts as a binary
operation on the carrier of said record value. Likewise, we invite the reader
to check that <code>Add</code> on algebraic datatype <code>TermData</code> is typed as a binary constructor.
</p>

<p>
Users have access to the elaborated types.
</p>

<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #b58900; font-style: italic;">TermP.Var</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span>v<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> &#120009;&#120014;&#120005;&#119942; &#8220;<span style="color: #b58900; font-style: italic;">Var</span>&#8221; v
 <span style="color: #b58900; font-style: italic;">TermP.Add</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span>v<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> &#120009;&#120014;&#120005;&#119942; &#8220;<span style="color: #b58900; font-style: italic;">Add</span>&#8221; v
</pre>
</div>
<p>
This is particularly useful when one wants to extract such types for re-use elsewhere.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">ListBop</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">TermP.Add</span> datatype <span style="color: #268bd2;">&#8728;</span> <span style="color: #b58900; font-style: italic;">List</span>
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773;  ListBop : Set &#8594; Set</span>
<span style="color: #96A7A9; font-style: italic;">   ListBop C = (List C &#8594; List C &#8594; List C)</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>

<span style="color: #b58900; font-style: italic;">ConstrainedBop</span> <span style="color: #b58900;">:</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>
<span style="color: #b58900; font-style: italic;">ConstrainedBop</span> constraint  <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">TermP.Add</span> typeclass using constraint
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773; ConstrainedBop constraint  =  &#8704;{C} &#8594; constraint C &#8594; C &#8594; C &#8594; C</span>

<span style="color: #96A7A9; font-style: italic;">-- N.B., this would not elaborate without the &#8220;using&#8221;.</span>
<span style="color: #96A7A9; font-style: italic;">-- Semantically, &#8220;P.x y using z = (P.x y)[P v &#8788; z]&#8221;</span>
<span style="color: #96A7A9; font-style: italic;">-- &#9472;the &#8220;v&#8221; appears from &#8220;&#8704;{v}&#8221; above.</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>

<span style="color: #b58900; font-style: italic;">SetoidBop</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">TermP.Add</span> record using <span style="color: #b58900; font-style: italic;">Setoid</span>
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773; SetoidBop : Setoid &#8467;&#8320; &#8467;&#8320; &#8594; Set</span>
<span style="color: #96A7A9; font-style: italic;">  SetoidBop S = Setoid.Carrier C &#8594; Setoid.Carrier C &#8594; Setoid.Carrier C</span>

<span style="color: #96A7A9; font-style: italic;">-- N.B., this would not elaborate if &#8220;Sectoid.Carrier&#8221; were undefiend.</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>
<p>
These examples open a flurry of problems.
</p>

<p>
At this stage, it is sufficient to have observed what could possibly
be performed and that it is not without burden.
We will not attempt to clarify any problem nor propose any solution;
the thesis effort will contend with these matters further.
</p>
</div>
</li>

<li><a id="org128a848"></a>The Generality of Package Formers &#x2014;Sums &amp; Modules<br />
<div class="outline-text-5" id="text-3-4-1-3">
<p>
Thus far we have only discussed products; however
the proposed general notion of containers should also produce sum types
and be used in modules &#x2014;which are just packages.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">TermFunctionsSumOn</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">TermP</span> sum
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8773;  TermFunctionsSumOn C  =  (Int &#8594; C) &#8846; (C &#8594; C &#8594; C)</span>
</pre>
</div>

<p>
In general, this yields a disjoint collection of declarations
where each declaration is itself a Σ consisting of the context necessary
to ensure that the operations are well-defined.
</p>

<p>
For modules,
</p>

<div class="org-src-container">
<pre class="src src-haskell">  <span style="color: #b58900; font-style: italic;">PackageFormer</span> <span style="color: #b58900; font-style: italic;">MyDriver</span> <span style="color: #268bd2;">(</span>t <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermP</span> record renaming <span style="color: #d33682;">(</span><span style="color: #b58900; font-style: italic;">Carrier</span> to <span style="color: #b58900; font-style: italic;">C</span><span style="color: #d33682;">)</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span> <span style="color: #268bd2;">&#8943;</span>
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8773; module MyDriver (t : TermRecord[Carrier &#8788; C]) where &#8943;</span>
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8773; module MyDriver (C : Set) (Var : Int &#8594; C) (Add : C &#8594; C &#8594; C) where &#8943;</span>
</pre>
</div>
<p>
At least two ‘free’ invocation notations ought to be supplied:
</p>
<ol class="org-ol">
<li><code>MyDriver t</code></li>
<li><code>MyDriver type varOp addOp</code></li>
</ol>

<p>
Multifaceted invocations provide a common use case: No overhead to pack or unpack
the constituents of a type former so the sole purpose of an invocation.
However, the pragmatic feasibility of such an approach is unclear at this stage.
</p>
</div>
</li>

<li><a id="org5bcbd77"></a>Novel Genericity: ‘Package Polymorphism’<br />
<div class="outline-text-5" id="text-3-4-1-4">
<p>
We have a sufficient number of elaborations thus far to demonstrate
that the notion of package formers is not without merit.
It is now an appropriate moment to address an elephant in the room:
<i>The phrase <code>TermP v</code> semantically refers to which type?</i>
</p>

<p>
If <code>v = datatype</code> then <code>TermP v</code>
refers to the associated algebraic datatype.
If <code>v = record</code>, then there are at least two ways to interpret <code>TermP v</code>:
As either the record type or as the carrier of a record value.
Likewise for other variations. For now, we settle with a monadic-like interpretation:
We write <code>do τ ← TermP v; ⋯</code> whenever we wish to refer to the underlying carrier of a concrete
package former. Loosely put,
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">do</span> &#964; <span style="color: #268bd2;">&#8592;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v; b  <span style="color: #268bd2;">&#8776;</span>  v <span style="color: #268bd2;">&#9585;</span> <span style="color: #268bd2;">(</span>&#955; &#964; <span style="color: #268bd2;">&#8594;</span> b<span style="color: #268bd2;">)</span>

v<span style="color: #b58900;">@</span>datatype  <span style="color: #268bd2;">&#9585;</span> f  <span style="color: #268bd2;">=</span>  f <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">TermP</span> v<span style="color: #268bd2;">)</span>
v<span style="color: #b58900;">@</span>record    <span style="color: #268bd2;">&#9585;</span> f  <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">(</span>&#964; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermP</span> v<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> f <span style="color: #268bd2;">(</span><span style="color: #d33682;">(</span><span style="color: #b58900; font-style: italic;">TermP</span> v<span style="color: #d33682;">)</span><span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Carrier</span> &#964;<span style="color: #268bd2;">)</span>
v<span style="color: #b58900;">@</span><span style="color: #b58900; font-style: italic;">&#931;</span>         <span style="color: #268bd2;">&#9585;</span> f  <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">(</span>&#964; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermP</span> v<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> f <span style="color: #268bd2;">(</span>proj&#8321; &#964;<span style="color: #268bd2;">)</span>
v<span style="color: #b58900;">@</span>typeclass <span style="color: #268bd2;">&#9585;</span> f  <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span>&#964;<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">{</span><span style="color: #d33682;">{</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermP</span> v &#964;<span style="color: #d33682;">}</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> f &#964;
v<span style="color: #b58900;">@</span>tuples    <span style="color: #268bd2;">&#9585;</span> f  <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span>&#964;<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v &#964; <span style="color: #268bd2;">&#8594;</span> f &#964;
</pre>
</div>
<p>
The ‘over’ notation, <code>_╱_</code>, assumes <code>f</code> is a function acting on types;
however, this is not necessary, if the <code>∀</code> were replaced with <code>λ</code>, then
the result would be a term expression. This is yet another opportunity for investigation
during the thesis effort. Moreover, there is the possibility of providing
“implicit counterparts” to these variations,; e.g., for <code>tuples</code> one may want
<code>∀{τ} {_ ∶ TermP v τ} → f τ</code> instead, which could be variation, say, <code>tuples-imp</code>.
Likewise, we may want notation <code>do-Σ</code> to replace \newline <code>∀ ⋯ → ⋯</code> with <code>Σ ⋯ • ⋯</code>.
</p>

<p>
Unsurprisingly, this approach subsumes our earlier typing elaboration: \newline
<code>𝓉𝓎𝓅𝒆 c v  = do τ ← TermP v; 𝒯 c τ</code>.
More concretely, for example, a notion of ‘depth’ for terms may have type
<code>∀ {v} →  do τ ← TermP v; (τ → ℕ)</code> &#x2014;a function
that takes a package and yields a number.
In the case of <code>v = record</code>, such a function actually takes <i>two</i>
items: The first being a record value, the second being an element of
the carrier of that record value. In the case of <code>v = typeclass</code>,
the function takes an argument found by instance search. Likewise,
for the remaining variations.
</p>

<p>
Let us now turn to an example of a function operating on the above many, and all, variations of such packages.
This example may appear contrived, yet the power of this form of polymorphism
appears at the end of this subsection where one programs towards a <i>particular</i>
interface and has the result <i>generalised</i> to other variations
&#x2014;a prime use case is to code against a typeclass representation and use the
same methods on bundled records.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Suppose I have the following syntactic construction.</span>
repeat <span style="color: #b58900;">:</span> <span style="color: #b58900; font-style: italic;">TermData</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermData</span>
<span style="color: #b58900;">repeat</span> t <span style="color: #b58900; font-style: italic;">Zero</span>      <span style="color: #268bd2;">=</span>  <span style="color: #b58900; font-style: italic;">Var</span> 0
<span style="color: #b58900;">repeat</span> t <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Succ</span> n<span style="color: #268bd2;">)</span>  <span style="color: #268bd2;">=</span>  <span style="color: #b58900; font-style: italic;">Add</span> t <span style="color: #268bd2;">(</span>repeat t n<span style="color: #268bd2;">)</span>

<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Here is its semantic counterpart.</span>
run <span style="color: #b58900;">:</span> <span style="color: #268bd2;">(</span>&#964; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermRecord</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermRecord.Carrier</span> &#964; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermRecord.Carrier</span> &#964;
<span style="color: #b58900;">run</span> &#964; t <span style="color: #b58900; font-style: italic;">Zero</span>      <span style="color: #268bd2;">=</span>  <span style="color: #b58900; font-style: italic;">TermRecord.Var</span> &#964; 0
<span style="color: #b58900;">run</span> &#964; t <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Succ</span> n<span style="color: #268bd2;">)</span>  <span style="color: #268bd2;">=</span>  <span style="color: #b58900; font-style: italic;">TermRecord.Add</span> &#964; t <span style="color: #268bd2;">(</span>run &#964; t n<span style="color: #268bd2;">)</span>

<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Which is merely multiplication for the naturals.</span>
<span style="color: #859900; font-weight: bold;">_</span><span style="color: #b58900;">&#215;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span>
t <span style="color: #b58900;">&#215;</span> <span style="color: #b58900; font-style: italic;">Zero</span>     <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Zero</span>
t <span style="color: #b58900;">&#215;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Succ</span> n<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">=</span> t <span style="color: #268bd2;">+</span> <span style="color: #268bd2;">(</span>t <span style="color: #268bd2;">&#215;</span> n<span style="color: #268bd2;">)</span>
</pre>
</div>

<p>
The first two are instances of a package former, and it is not diffcult to construe the naturals as the carrier of a package former.
After which, we should be able to write one generic function, by writing according to the pacakge former as the interface.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">instance</span>
  <span style="color: #b58900; font-style: italic;">&#8469;Terms</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermOn</span> <span style="color: #b58900; font-style: italic;">&#8469;</span>
  <span style="color: #b58900; font-style: italic;">&#8469;Terms</span> <span style="color: #268bd2;">=</span> record <span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">Var</span> <span style="color: #268bd2;">=</span> &#955; n <span style="color: #268bd2;">&#8594;</span> 0; <span style="color: #b58900; font-style: italic;">Add</span> <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">+</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">}</span>

<span style="color: #93a1a1;">{- </span><span style="color: #96A7A9; font-style: italic;">IsConsumer is defined below; ignore for now. -}</span>
exp <span style="color: #b58900;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span>v<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">{</span><span style="color: #d33682;">{</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">IsConsumer</span> v<span style="color: #d33682;">}</span><span style="color: #268bd2;">}</span>  <span style="color: #268bd2;">&#8594;</span>  <span style="color: #859900; font-weight: bold;">do</span> &#964; <span style="color: #268bd2;">&#8592;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v; &#964; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8594;</span> &#964;
<span style="color: #b58900;">exp</span> t <span style="color: #b58900; font-style: italic;">Zero</span>     <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Var</span> 0
<span style="color: #b58900;">exp</span> t <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Succ</span> n<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Add</span> t <span style="color: #268bd2;">(</span>exp t n<span style="color: #268bd2;">)</span>
</pre>
</div>
<p>
For example, we immediately obtain an instance for strings.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">instance</span>
  <span style="color: #b58900; font-style: italic;">STerms</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermOn</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">Char</span><span style="color: #268bd2;">)</span>
  <span style="color: #b58900; font-style: italic;">STerms</span> <span style="color: #268bd2;">=</span> record <span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">Var</span> <span style="color: #268bd2;">=</span> &#955; n <span style="color: #268bd2;">&#8594;</span> <span style="color: #d33682; font-style: italic;">[]</span>; <span style="color: #b58900; font-style: italic;">Add</span> <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">++</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">}</span>

repeat<span style="color: #b58900;">-</span>s <span style="color: #268bd2;">=</span> exp <span style="color: #268bd2;">{</span>v <span style="color: #268bd2;">=</span> typeclass<span style="color: #268bd2;">}</span>
<span style="color: #93a1a1;">{- </span><span style="color: #96A7A9; font-style: italic;">Yields a whole family, which includes:</span>

<span style="color: #96A7A9; font-style: italic;">   repeat-s0 : {{TermOn (List Char)}} &#8594; List Char &#8594; &#8469; &#8594; List Char</span>
<span style="color: #96A7A9; font-style: italic;">   repeat-s0 c Zero = []</span>
<span style="color: #96A7A9; font-style: italic;">   repeat-s0 c (Succ n) = c ++ repeat c n</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>

<p>
Now that's re-use! One function for many semantically distinct types.
Notice that invoking <code>exp</code> on <code>ListBop</code> or <code>TermFunctionsSumOn</code> values is ill-typed
since the mechanically verifiable constraint <code>IsConsumer</code> fails for those variations.
Indeed, we may utilise a number of constraints on our package variations, such as
the following.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">data</span> <span style="color: #b58900; font-style: italic;">IsConsumer</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
  <span style="color: #b58900; font-style: italic;">Prod</span>    <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">IsConsumer</span> tuples
  <span style="color: #b58900; font-style: italic;">DepProd</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">IsConsumer</span> <span style="color: #b58900; font-style: italic;">&#931;</span>
  <span style="color: #b58900; font-style: italic;">Data</span>    <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">IsConsumer</span> datatype
  <span style="color: #b58900; font-style: italic;">Rec</span>     <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">IsConsumer</span> record
</pre>
</div>
<p>
When a user defines a variation, they can signal whether it is a consumer or not.
Likewise, one can indicate whether a variation should have <code>Set</code>-valued operations
on not. Note that a default mechanism could be implemented, but the user should
continue to have the ability to enforce a particular discipline
&#x2014;c.f., how <code>C#</code> allows the user to enforce the subtyping variance of a type former.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">data</span> <span style="color: #b58900; font-style: italic;">HasConstructiveRelations</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
  <span style="color: #b58900; font-style: italic;">Prod</span>    <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">HasConstructiveRelations</span> tuples
  <span style="color: #b58900; font-style: italic;">DepProd</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">HasConstructiveRelations</span> <span style="color: #b58900; font-style: italic;">&#931;</span>
  <span style="color: #b58900; font-style: italic;">Rec</span>     <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">HasConstructiveRelations</span> record
</pre>
</div>
<p>
For example, <code>data</code> declarations cannot contain proofs of an arbitrary, but fixed, constructive relation
without declaring it as a parameter to the type. Nonetheless, a user may want to be
able to express syntactic statements about such proof terms
&#x2014;say for proof automation&#x2014; and they should have the ability to toggle such
a feature.
</p>

<p>
A more important concern is the type of <code>exp</code>: The phrase <code>do τ ← TermP v; τ → ℕ → τ</code>
elaborates to different types according to the value of <code>v</code>, whence to define <code>exp</code>
it seems necessary to actually pattern match on it to obtain a concrete type, which,
for example, may contain more arguments. Case analysis on the possible packaging variations
is far from ideal &#x2014;one might as well re-implement the definition only on the cases they
want rather than all cases. The aim &#x2014;to be pursued further in the full thesis effort&#x2014;
is to invert the process: <i>Avoid case analysis in favour of a particularly convenient view.</i>
</p>

<p>
This is clarified best by referring to the current prototype language: Lisp.
Since all data and methods in a lisp are essentially lists, when one prescribes
how to project a value from a possibly nested datatype, then the same prescription
essentially directs how to get to the location of that value and so we obtain
<i>generic setters</i>. The following tiny example demonstrates this idea.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #268bd2;">(</span><span style="color: #cd6600;">setq</span> xs '<span style="color: #d33682;">(</span><span style="color: #2aa198;">"a"</span> nil <span style="color: #859900;">(</span>x y z<span style="color: #859900;">)</span> 12<span style="color: #d33682;">)</span><span style="color: #268bd2;">)</span>  <span style="color: #93a1a1;">;; </span><span style="color: #96A7A9; font-style: italic;">Heterogenous list of 4 items.</span>
<span style="color: #268bd2;">(</span>cadar <span style="color: #d33682;">(</span>cdaddr xs<span style="color: #d33682;">)</span><span style="color: #268bd2;">)</span>              <span style="color: #93a1a1;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; y</span>
<span style="color: #268bd2;">(</span><span style="color: #cd6600;">setf</span> <span style="color: #d33682;">(</span>cadar <span style="color: #859900;">(</span>cdaddr xs<span style="color: #859900;">)</span><span style="color: #d33682;">)</span> 'woah<span style="color: #268bd2;">)</span> <span style="color: #93a1a1;">;; </span><span style="color: #96A7A9; font-style: italic;">xs &#8658; '("a" nil (x woah z) 12))</span>
</pre>
</div>
<p>
It is this flexibility that we aim to provide to users.
They code not against a generic variation, but rather along one that
is the most appropriate task at hand. We would hope that it would not
be unrealistic to then mechanically derive the other forms from it.
For example, suppose we wish to define retracts on magmas; rather than
define the concept for each possible view, we define it once and obtain it
for other views.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">PackageFormer</span> <span style="color: #b58900; font-style: italic;">MagmaP</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">MagmaP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">MagmaP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">MagmaP</span> v

<span style="color: #b58900; font-style: italic;">MagmaOn</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">MagmaP</span> typeclass
<span style="color: #b58900; font-style: italic;">AMagma</span>  <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">MagmaP</span> record
</pre>
</div>

<p>
The ubiquity of magmas &#x2014;literally everywhere&#x2014; lends itself to recall that
working with structure, possibly needless structure, may usurp the goals of
proof \parencite{purposes_of_proof}: No mathematician would naturally say
<i>let M be an algebra on set C</i> when it suffices to say <i>let M be an algebra</i>;
yet it may be <i>convenient</i> to phrase problems more elegantly when the carrier
set is mentioned explicitly \parencite{packaging_mathematical_structures}.
On the other hand,
having the carrier explicit for the sake of typeclass resolution
relies on decidable type (non)equality; which may be resonable for a simplly
typed language but for a DTL type normalisation generally requires non-trivial,
non-constant, computation.
Anyhow, as mentioned earlier, bundling data
is akin to currying or nesting quantifiers, yet is vastly more expensive
since library designers generally commit early to one form or another;
in this case \newline <code>AMagma ≅ Σ C : Set • MagmaOn C</code>
and \newline
<code>MagmaOn C ≅ Σ M : AMagma • M.Carrier ≡ C</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell">retract <span style="color: #b58900;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">S</span> <span style="color: #b58900; font-style: italic;">T</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span>f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">S</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">T</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">MagmaOn</span> <span style="color: #b58900; font-style: italic;">T</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">MagmaOn</span> <span style="color: #b58900; font-style: italic;">S</span>
<span style="color: #b58900;">retract</span> f <span style="color: #b58900; font-style: italic;">Tgt</span> <span style="color: #268bd2;">=</span> record <span style="color: #268bd2;">{</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> &#955; x y <span style="color: #268bd2;">&#8594;</span> f x <span style="color: #268bd2;">&#10814;</span> f y<span style="color: #268bd2;">}</span> <span style="color: #859900; font-weight: bold;">where</span> open <span style="color: #b58900; font-style: italic;">MagmaOn</span> <span style="color: #b58900; font-style: italic;">Tgt</span>
</pre>
</div>
<p>
Since <code>MagmaOn = MagmaP v</code> where <code>v = typeclass</code>, we would ideally be able
to derive the generic form &#x2014;possibly via case analysis.
</p>

<div class="org-src-container">
<pre class="src src-haskell">retract<span style="color: #b58900;">-</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span>v<span style="color: #268bd2;">}</span>
      <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8704;</span> <span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">S</span> <span style="color: #b58900; font-style: italic;">T</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">(</span>f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">S</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">T</span><span style="color: #268bd2;">)</span>
      <span style="color: #268bd2;">&#8594;</span>  <span style="color: #859900; font-weight: bold;">do</span>   tgt <span style="color: #268bd2;">&#8592;</span> <span style="color: #b58900; font-style: italic;">MagmaP</span> v; tgt <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">T</span>  <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Intentionally no parens.</span>
      <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span><span style="color: #859900; font-weight: bold;">do</span><span style="color: #268bd2;">-</span><span style="color: #b58900; font-style: italic;">&#931;</span> src <span style="color: #268bd2;">&#8592;</span> <span style="color: #b58900; font-style: italic;">MagmaP</span> v; src <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">S</span><span style="color: #268bd2;">)</span>
retract<span style="color: #b58900;">-</span>v <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8943;</span> <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Unclear at this stage.</span>
</pre>
</div>

<p>
The record case could, semi-algorithmically, yield:
</p>

<div class="org-src-container">
<pre class="src src-haskell">retract<span style="color: #b58900;">-</span>v <span style="color: #268bd2;">{</span>record<span style="color: #268bd2;">}</span>  <span style="color: #b58900; font-style: italic;">:</span>  <span style="color: #268bd2;">&#8704;</span> <span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">S</span> <span style="color: #b58900; font-style: italic;">T</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">(</span>f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">S</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">T</span><span style="color: #268bd2;">)</span>
            <span style="color: #268bd2;">&#8594;</span>  <span style="color: #268bd2;">&#8704;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Tgt</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">AMagma</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">AMagma.Carrier</span> <span style="color: #b58900; font-style: italic;">Tgt</span> <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">T</span>
            <span style="color: #268bd2;">&#8594;</span>  <span style="color: #b58900; font-style: italic;">&#931;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Src</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">AMagma</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8226;</span> <span style="color: #b58900; font-style: italic;">AMagma.Carrier</span> <span style="color: #b58900; font-style: italic;">Src</span> <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">S</span>
retract<span style="color: #b58900;">-</span>v <span style="color: #268bd2;">{</span>record<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">S</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">T</span><span style="color: #268bd2;">}</span> f <span style="color: #b58900; font-style: italic;">Tgt</span> refl <span style="color: #268bd2;">=</span>  record <span style="color: #268bd2;">{</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">S</span>
                        ;  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> &#955; x y <span style="color: #268bd2;">&#8594;</span> f x <span style="color: #268bd2;">&#10814;</span> f y <span style="color: #268bd2;">}</span>
                       , refl
                       <span style="color: #859900; font-weight: bold;">where</span> open <span style="color: #b58900; font-style: italic;">AMagma</span> <span style="color: #b58900; font-style: italic;">Tgt</span>
</pre>
</div>
<p>
From a usability perspective the trivial proofs should not be present
and so we need to algorithmically rewrite the above type to omit them, as follows.
We would like to preserve the argument syntax, <code>retract f Tgt</code>, that was originally declared.
Unfortunately, for the record case, the type of <code>f</code> must refer to the types of the other magamas
if we eliminate the trivial equalities. One possible workaround, as follows, is thus to simply provide
a omit the tedious equality proofs since they can be found by instance search.
</p>

<div class="org-src-container">
<pre class="src src-haskell">retract<span style="color: #b58900;">-</span>v <span style="color: #268bd2;">{</span>record<span style="color: #268bd2;">}</span>  <span style="color: #b58900; font-style: italic;">:</span>  <span style="color: #268bd2;">&#8704;</span> <span style="color: #268bd2;">{</span><span style="color: #b58900; font-style: italic;">S</span> <span style="color: #b58900; font-style: italic;">T</span><span style="color: #268bd2;">}</span> <span style="color: #268bd2;">(</span>f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">S</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">T</span><span style="color: #268bd2;">)</span>
            <span style="color: #268bd2;">&#8594;</span>  <span style="color: #268bd2;">&#8704;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Tgt</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">AMagma</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#10627;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">AMagma.Carrier</span> <span style="color: #b58900; font-style: italic;">Tgt</span> <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">T</span> <span style="color: #268bd2;">&#10628;</span>
            <span style="color: #268bd2;">&#8594;</span>  proj&#8321; <span style="color: #268bd2;">(</span><span style="color: #d33682;">&#10627;</span><span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #d33682;">&#10628;</span> <span style="color: #b58900; font-style: italic;">Src</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">AMagma</span> <span style="color: #268bd2;">&#8226;</span> <span style="color: #b58900; font-style: italic;">AMagma.Carrier</span> <span style="color: #b58900; font-style: italic;">Src</span> <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">S</span><span style="color: #268bd2;">)</span>
retract<span style="color: #b58900;">-</span>v <span style="color: #268bd2;">{</span>record<span style="color: #268bd2;">}</span> f <span style="color: #b58900; font-style: italic;">Tgt</span>  <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8943;</span>

<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8220;&#10627;&#931;&#10628; (x : A) &#8226; B x&#8221; consists of a pair</span>
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">where the second is found by instance search.</span>
</pre>
</div>
<p>
Notice that we also project at the end since we do not care about the tedious proof;
nor should its existence be forced upon the user.
</p>

<p>
Before we move on, there is particular reason we have deviated from our <code>TermP</code> example
to the <code>MagmaP</code> concept. The <code>datatype</code> variation for <code>MagmaP</code> does not provide a way
to speak of variables of the data type &#x2014;indeed <code>MagmaP datatype</code> has no closed terms,
whence no terms at all. It is thus appropriate to now introduce a variation for
syntactic terms <i>over</i> some variable set which is then utilised by a mechanically
derivable semantic function that is freely homomorphic.
</p>


<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">MagmaTermsOn</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">MagmaP</span> term<span style="color: #268bd2;">-</span>typeclass
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773; data MagmaTermsOn (Vars : Set) : Set where</span>
<span style="color: #96A7A9; font-style: italic;">    Var : Vars &#8594; MagmaTermsOn Vars</span>
<span style="color: #96A7A9; font-style: italic;">    _&#10814;_  : MagmaTermsOn Vars &#8594; MagmaTermsOn Vars &#8594; MagmaTermsOn Vars</span>

<span style="color: #96A7A9; font-style: italic;">MagmaTermsOn-sem : &#8704; {v} {A}  &#8594;  do &#964; &#8592; MagmaP v;</span>
<span style="color: #96A7A9; font-style: italic;">                 (f : A &#8594; &#964;) &#8594; MagmaTermsOn A &#8594; &#964;</span>
<span style="color: #96A7A9; font-style: italic;">MagmaTermsOn-sem {record} S f (Var x) = f x</span>
<span style="color: #96A7A9; font-style: italic;">MagmaTermsOn-sem {record} S f (l &#10814; r)  = ll s&#10814; rr</span>
<span style="color: #96A7A9; font-style: italic;">  where _&#10814;s_ = AMagma._&#10814;_ S</span>
<span style="color: #96A7A9; font-style: italic;">    ll = MagmaTermsOn-sem {record} S f l</span>
<span style="color: #96A7A9; font-style: italic;">    rr = MagmaTermsOn-sem {record} S f r</span>
<span style="color: #96A7A9; font-style: italic;">&#8943;</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>

<p>
We will return to homomorphisms later on, for now it is important to notice
that some variations may be useless &#x2014;as in the empty datatypes.
There is also the opportunity to explore co-inductive datatypes.
</p>
</div>
</li>
<li><a id="orgafd50bc"></a>Common Operations on Package Formers<br />
<div class="outline-text-5" id="text-3-4-1-5">
<p>
It is rather common in the record variation to have multiple instances being
mentioned and it is desirable to refer to them with syntactically distinct yet appealing
names &#x2014;such as using subscripts, primes, or other decoration. Moreover, a notion of
homomorphism, structure-preservation, can usually be automatically inferred.
</p>

<p>
Here we show what such declarations looks like, later we show that such things
could be <i>user defined</i>.
</p>


<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">PackageFormer</span> <span style="color: #b58900; font-style: italic;">TermRelP</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
   <span style="color: #b58900; font-style: italic;">Var</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Int</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermRelP</span> v
   <span style="color: #b58900; font-style: italic;">Add</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermRelP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermRelP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermRelP</span> v
   <span style="color: #b58900; font-style: italic;">Rel</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermRelP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermRelP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>  <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">This time we have a relation as well.</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">Declare</span> <span style="color: #b58900; font-style: italic;">PackageFormer</span> <span style="color: #b58900; font-style: italic;">TermRelP</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> decorated <span style="color: #268bd2;">(</span>&#955; x <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">++</span> <span style="color: #2aa198;">"&#8242;"</span><span style="color: #268bd2;">)</span>
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773; PackageFormer TermRelP&#8242; (v : Variation) : Set where</span>
<span style="color: #96A7A9; font-style: italic;">   Var&#8242; : Int &#8594; TermRelP&#8242; v</span>
<span style="color: #96A7A9; font-style: italic;">   Add&#8242; : TermRelP&#8242; v &#8594; TermRelP&#8242; v &#8594; TermRelP&#8242; v</span>
<span style="color: #96A7A9; font-style: italic;">   Rel&#8242; : TermRelP&#8242; v &#8594; TermRelP&#8242; v &#8594; Set</span>

<span style="color: #96A7A9; font-style: italic;">-- Coherence Meta-property: &#8704; v, d  &#8226;  TermRelP v decorated d  &#8773;  TermRelP v</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">Declare</span> <span style="color: #b58900; font-style: italic;">Homomorphism</span> <span style="color: #b58900; font-style: italic;">TermRelP</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span>
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773; PackageFormer TermRelP-Homomorphism (v : Variation) : Set where</span>

<span style="color: #96A7A9; font-style: italic;">    Src : TermRelP v   decorated  (&#955; x &#8594; x ++ "&#8321;")</span>
<span style="color: #96A7A9; font-style: italic;">    Tgt : TermRelP v   decorated  (&#955; x &#8594; x ++ "&#8322;")</span>

<span style="color: #96A7A9; font-style: italic;">    map : Src &#8594; Tgt</span>
<span style="color: #96A7A9; font-style: italic;">    -- Elaborates to &#8220;Carrier Src &#8594; Carrier Tgt&#8221; in &#8220;record&#8221; variation.</span>

<span style="color: #96A7A9; font-style: italic;">    var_preservation : &#8704; n   &#8594; map (Var&#8321; n) &#8801; Var&#8322; n</span>
<span style="color: #96A7A9; font-style: italic;">    add_preservation : &#8704; x y &#8594; map (Add&#8321; x y) &#8801; Add&#8322; (map x) (map y)</span>
<span style="color: #96A7A9; font-style: italic;">    rel_preservation : &#8704; x y &#8594; Rel&#8321; x y &#8594; Rel&#8322; (map x) (map y)</span>

<span style="color: #96A7A9; font-style: italic;">NB: The &#8220;decorated&#8221; annotations are local to the package.</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>
</div>
</li>

<li><a id="org6b945e6"></a>Inheritance &amp; Defaults for Package Formers<br />
<div class="outline-text-5" id="text-3-4-1-6">
<p>
Things get a bit more interesting with multiple packaging,
fields making use of dependent types, and of (multiple) default implementations.
Besides defaults, a desirable feature of our envisioned system is the ability to lift definitional extensions
into fields of the package, say for more efficient implementations.
</p>


<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">PackageFormer</span> <span style="color: #b58900; font-style: italic;">TermP</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
   <span style="color: #b58900; font-style: italic;">Var</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Int</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v
   <span style="color: #b58900; font-style: italic;">Add</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v
</pre>
</div>


<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">PackageFormer</span> <span style="color: #b58900; font-style: italic;">PreOrderedTermP</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>  inherits<span style="color: #268bd2;">-</span>from <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">TermP</span> v<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">where</span>
   <span style="color: #b58900; font-style: italic;">Ord</span>   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">OrderedTermP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">OrderedTermP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>
   <span style="color: #b58900; font-style: italic;">Refl</span>  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Ord</span> x x
   <span style="color: #b58900; font-style: italic;">Trans</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x y z <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Ord</span> x y <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Ord</span> y z <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Ord</span> x z

   <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Two default &#8216;implementations&#8217;</span>

   <span style="color: #859900; font-weight: bold;">default</span>&#8321; <span style="color: #b58900; font-style: italic;">Ord</span> x y                <span style="color: #268bd2;">=</span>  x <span style="color: #268bd2;">&#8801;</span> y
   <span style="color: #859900; font-weight: bold;">default</span>&#8321; <span style="color: #b58900; font-style: italic;">Refl</span>  x                <span style="color: #268bd2;">=</span>  refl
   <span style="color: #859900; font-weight: bold;">default</span>&#8321; <span style="color: #b58900; font-style: italic;">Trans</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> refl refl  <span style="color: #268bd2;">=</span>  refl

   <span style="color: #859900; font-weight: bold;">default</span>&#8322; <span style="color: #b58900; font-style: italic;">Ord</span> x y                <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">&#8868;</span>
   <span style="color: #859900; font-weight: bold;">default</span>&#8322; <span style="color: #b58900; font-style: italic;">Refl</span>  x                <span style="color: #268bd2;">=</span>  tt
   <span style="color: #859900; font-weight: bold;">default</span>&#8322; <span style="color: #b58900; font-style: italic;">Trans</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span>        <span style="color: #268bd2;">=</span>  tt
</pre>
</div>

<p>
Notice how “free type” formation incorporates this new open-ended
construct, <code>Ord</code>, as a two-value holder. An alternative interpretation would
be to eliminate it altogether from the elaborated data declaration.
Anyhow, since we elaborate a relation as a pair former, proofs for
such a relation cannot be included &#x2014;otherwise it's not a “free” type!
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">PreOrderedTermData</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">PreOrderedTermP</span> <span style="color: #859900; font-weight: bold;">data</span>
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773;  data PreOrderedTermData : Set where</span>
<span style="color: #96A7A9; font-style: italic;">     Var : Int &#8594; OrderedTermData</span>
<span style="color: #96A7A9; font-style: italic;">     Add : PreOrderedTermData &#8594; PreOrderedTermData &#8594; PreOrderedTermData</span>
<span style="color: #96A7A9; font-style: italic;">     Ord : PreOrderedTermData &#8594; PreOrderedTermData &#8594; PreOrderedTermData</span>

<span style="color: #96A7A9; font-style: italic;">     -- No reflexitivity axiom on &#8216;Ord&#8217;, nor transitivity!</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">PreOrderedTermData</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">PreOrderedTermP</span> <span style="color: #859900; font-weight: bold;">data</span> with<span style="color: #268bd2;">-</span><span style="color: #859900; font-weight: bold;">default</span>&#8321;
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773;  data PreOrderedTermData : Set where</span>
<span style="color: #96A7A9; font-style: italic;">     Var : Int &#8594; OrderedTermData</span>
<span style="color: #96A7A9; font-style: italic;">     Add : PreOrderedTermData &#8594; PreOrderedTermData &#8594; PreOrderedTermData</span>

<span style="color: #96A7A9; font-style: italic;">     -- No &#8216;Ord&#8217; construction, but instead a constructive relation and properties:</span>

<span style="color: #96A7A9; font-style: italic;">     Ord : PreOrderedTermData &#8594; PreOrderedTermData &#8594; Set</span>
<span style="color: #96A7A9; font-style: italic;">     Ord x y  =  x &#8801; y</span>

<span style="color: #96A7A9; font-style: italic;">     Refl  : &#8704; x &#8594; Ord x x</span>
<span style="color: #96A7A9; font-style: italic;">     Refl  x  =  refl</span>

<span style="color: #96A7A9; font-style: italic;">     Trans : &#8704; x y z &#8594; Ord x y &#8594; Ord y z &#8594; Ord x z</span>
<span style="color: #96A7A9; font-style: italic;">     Trans _ _ _ refl refl  =  refl</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>
<p>
The naming <code>Ord, Refl, Trans</code> could have been altered to refer to the newly declared data
type, for simplicity we have avoided such a transformation.
Moreover, we could reserve <code>with-default₀</code> to simply omit constructive relations from
being reified as data constructors.
</p>


<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">PreOrderedTermRecord</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">PreOrderedTermP</span> record
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773;   record PreOrderedTermRecord : Set where</span>
<span style="color: #96A7A9; font-style: italic;">      field</span>
<span style="color: #96A7A9; font-style: italic;">    Carrier : Set</span>
<span style="color: #96A7A9; font-style: italic;">    Var     : Int &#8594; Carrier</span>
<span style="color: #96A7A9; font-style: italic;">    Add     : Carrier &#8594; Carrier &#8594; Carrier</span>
<span style="color: #96A7A9; font-style: italic;">    Ord     : Carrier &#8594; Carrier &#8594; Set</span>
<span style="color: #96A7A9; font-style: italic;">    Refl    : &#8704; x &#8594; Ord x x</span>
<span style="color: #96A7A9; font-style: italic;">    Trans   : &#8704; x y z &#8594; Ord x y &#8594; Ord y z &#8594; Ord x z</span>

<span style="color: #96A7A9; font-style: italic;">     -- Notice that the reflexitivity &amp; transitivity axioms are kept!</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>
<p>
Moreover, the default implementations means we also have the following
declaration, where distinctions are made by the occurenace, or absence, of fields.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">    record PreOrderedTermRecord : Set where</span>
<span style="color: #96A7A9; font-style: italic;">      field</span>
<span style="color: #96A7A9; font-style: italic;">    Carrier : Set</span>
<span style="color: #96A7A9; font-style: italic;">    Var     : Int &#8594; Carrier</span>
<span style="color: #96A7A9; font-style: italic;">    Add     : Carrier &#8594; Carrier &#8594; Carrier</span>

<span style="color: #96A7A9; font-style: italic;">      Ord     : Carrier &#8594; Carrier &#8594; Set</span>
<span style="color: #96A7A9; font-style: italic;">      Ord x y =  x &#8801; y</span>

<span style="color: #96A7A9; font-style: italic;">      Refl    : &#8704; x &#8594; Ord x x</span>
<span style="color: #96A7A9; font-style: italic;">      Refl _ = refl</span>

<span style="color: #96A7A9; font-style: italic;">      Trans   : &#8704; x y z &#8594; Ord x y &#8594; Ord y z &#8594; Ord x z</span>
<span style="color: #96A7A9; font-style: italic;">      Trans _ _ _ refl refl = refl</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>
<p>
Here is our first observation of a uniform presentation of packaging,
where the “intended use” differs: Whether we want axioms or not?
</p>

<p>
Not only is the use amicable, but utilities written for the first elaboration
effortlessly apply to instances of the second elaboration. Unfortunately,
the relationship is not symmetric
&#x2014;e.g., using the additional information provided by the default implementations,
 <code>∀ x y → Ord x y → Add x y ≡ Add y x</code> is provable for the latter but
not the former. As such, there is need to be able to mark results applying
to a subtype of a package former, or to eliminate such a desirable feature
that reduces needless distinctions when applying utilties of the former to the
latter. The thesis will provide a solution with a discussion of the alternatives
and why they were not adopted.
</p>
</div>
</li>

<li><a id="org07c16ff"></a>Package Formers Dispense with The Diamond Problem<br />
<div class="outline-text-5" id="text-3-4-1-7">
<p>
Let's consider combining multiple containers.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">Package</span> <span style="color: #b58900; font-style: italic;">UnitalTermP</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> inherits<span style="color: #268bd2;">-</span>from <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">TermP</span> v<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">where</span>
   unit <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">UnitalTermP</span> v
   lid  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Add</span> unit x <span style="color: #268bd2;">&#8801;</span> x
   rid  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Add</span> x unit <span style="color: #268bd2;">&#8801;</span> x
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">Package</span> <span style="color: #b58900; font-style: italic;">PreOrderedMonoid</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>
      inherits<span style="color: #268bd2;">-</span>from <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">UnitalTermP</span> v; <span style="color: #b58900; font-style: italic;">PreOrderedTermP</span> v<span style="color: #268bd2;">)</span>
  <span style="color: #859900; font-weight: bold;">where</span>
   associative <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x y z <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Add</span> x y<span style="color: #268bd2;">)</span> z <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">Add</span> x <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Add</span> y z<span style="color: #268bd2;">)</span>
   monotone    <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x x' y y' <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Ord</span> x x' <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Ord</span> y y' <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Ord</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Add</span> x y<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Add</span> x' y'<span style="color: #268bd2;">)</span>
</pre>
</div>
<p>
This package ought to be indistinguishable from the following, whence allowing tremendously flexible
declarations and uses. In particular, there is no longer a need to distinguish between a hierarchical
and a flattened perspective, since they are considered identical.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">Package</span> <span style="color: #b58900; font-style: italic;">PreOrderedMonoid</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>

   unitaltermp <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">UnitalTermP</span> v
   preorderedtermp <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">PreOrderedTermP</span> v

   associative <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x y z <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Add</span> x y<span style="color: #268bd2;">)</span> z <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">Add</span> x <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Add</span> y z<span style="color: #268bd2;">)</span>
   monotone    <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x x' y y' <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Ord</span> x x' <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Ord</span> y y' <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Ord</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Add</span> x y<span style="color: #268bd2;">)</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Add</span> x' y'<span style="color: #268bd2;">)</span>

   <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">From which sub-structure does the above &#8220;Add&#8221; arise?</span>
   <span style="color: #93a1a1;">--</span>
   <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">The &#8220;record&#8221; and &#8220;typeclass&#8221; variations elaborate with axioms declaring</span>
   <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">that identical names are indeed identical operations:</span>
   carrier_coherence <span style="color: #b58900; font-style: italic;">:</span> unitaltermp<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8801;</span> preorderedtermp<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Carrier</span>
   var_coherence     <span style="color: #b58900; font-style: italic;">:</span> unitaltermp<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Var</span>     <span style="color: #268bd2;">&#8801;</span> preorderedtermp<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Var</span>
   add_coherence     <span style="color: #b58900; font-style: italic;">:</span> unitaltermp<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Add</span>     <span style="color: #268bd2;">&#8801;</span> preorderedtermp<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Add</span>
   <span style="color: #93a1a1;">--</span>
   <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">They also elaborate with default tedious implementations:</span>
   carrier_coherence <span style="color: #268bd2;">=</span> refl; var_coherence <span style="color: #268bd2;">=</span> refl; add_coherence <span style="color: #268bd2;">=</span> refl

   <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Moreover, we can continue the &#8216;default&#8217; implementation.</span>
   <span style="color: #859900; font-weight: bold;">default</span>&#8321; monotone <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> refl refl <span style="color: #268bd2;">=</span> refl
   <span style="color: #859900; font-weight: bold;">default</span>&#8322; monotone <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span>       <span style="color: #268bd2;">=</span> tt
</pre>
</div>
</div>
</li>

<li><a id="org5deff5b"></a>Package Formers &amp; Representational Shifts<br />
<div class="outline-text-5" id="text-3-4-1-8">
<p>
Let us close this section by demonstrating how this genericity can aid in
ubiquitous representational shifts that appear rather often in dependently typed programming.
In pedestrian languages, there are usually less ways to accomplish a task in
dependently typed languages and so programming style is not of great concern.
In contrast, in a DTL, a user could, for example, work over an abstract data type
where a particular argument is fixed or where it is allowed to vary.
The two approaches are a matter of style, but can lead to awkward situations.
</p>

<p>
More concretely, we consider the bread and buffer of coding: Graphs.
Without dependent types we can only speak about graphs <i>over</i> a given vertex type,
with dependent types we can speak about <i>a</i> graph, irrespective of vertex type.
The former is tantamount to the context <code>Vertex ∶ Type ⊢ Edges ∶ Vertex → Vertex  → Type</code>,
and an empty assumption context <code>⊢ Vertex ∶ Set, Edges ∶ Vertex → Vertex → Type</code>
for the latter.
However, the latter form sometimes leads us into contexts where we have two
graphs <code>G</code> and <code>H</code> for which we make the tedious constraint \newline <code>Vertex G ≡ Vertex H</code>.
It would be less clumsy to explicitly declare the two graphs to be <i>over</i> the
same vertex type.
</p>

<p>
The previous paragraph mentioned a terse dependently-typed presentation of graphs,
let us use the classic presentation as it may be more familiar to readers.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">PackageFormer</span> <span style="color: #b58900; font-style: italic;">GraphP</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
  <span style="color: #b58900; font-style: italic;">Vertex</span>, <span style="color: #b58900; font-style: italic;">Edges</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>
  src, tgt      <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Edges</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Vertex</span>

  <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">The dependently typed notion of edges.</span>
  derivied
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Vertex</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Vertex</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>
    x <span style="color: #268bd2;">&#10230;</span> y  <span style="color: #268bd2;">=</span>  <span style="color: #b58900; font-style: italic;">&#931;</span> e <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Edges</span>  <span style="color: #268bd2;">&#8226;</span>  src e <span style="color: #268bd2;">&#8801;</span> x  <span style="color: #268bd2;">&#8743;</span>  tgt e <span style="color: #268bd2;">&#8801;</span> y
</pre>
</div>


<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">AGraph</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">GraphP</span> record renaming <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Carrier</span> to &#8220;<span style="color: #b58900; font-style: italic;">Vertex</span>&#8221;<span style="color: #268bd2;">)</span>
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773;   record AGraph : Set where</span>
<span style="color: #96A7A9; font-style: italic;">      field</span>
<span style="color: #96A7A9; font-style: italic;">    Vertex Edges : Set</span>
<span style="color: #96A7A9; font-style: italic;">    src    tgt   : Edges &#8594; Vertex</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>

<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">NB. The implicitly generated name &#8220;Carrier&#8221; has been identified with</span>
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">the *declared* name &#8220;Vertex&#8221;. This is acceptable since they have the same type.</span>
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Without the identification, the record elaboration would have provided a</span>
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">third type field named &#8220;Carrier&#8221;.</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">GraphOver</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">TermP</span> typeclass renaming <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">Carrier</span> to &#8220;<span style="color: #b58900; font-style: italic;">Vertex</span>&#8221;<span style="color: #268bd2;">)</span>
<span style="color: #93a1a1;">{-</span>
<span style="color: #96A7A9; font-style: italic;">&#8773;   record GraphOver (Vertex : Set) : Set where</span>
<span style="color: #96A7A9; font-style: italic;">       field</span>
<span style="color: #96A7A9; font-style: italic;">      Edges   : Set</span>
<span style="color: #96A7A9; font-style: italic;">      src tgt : Edges &#8594; Vertex</span>
<span style="color: #96A7A9; font-style: italic;">-}</span>
</pre>
</div>
<p>
With these in hand, our goal is to replace the following first line with the second.
However, since both types <code>GraphOver</code> and <code>AGraph</code> are declared as one liners,
such a transition is a cheap as possible.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">AGraph</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Vertex</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">Vertex</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8943;</span>

<span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">V</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">GraphOver</span> <span style="color: #b58900; font-style: italic;">V</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8943;</span>
</pre>
</div>
<p>
In order to <i>replace a semantic constraint with a syntactic constraint</i>
the user simply need to use a <i>variant</i> on packaging. Furthermore, we
are ensured \newline <code>AGraph ≅ Σ V ∶ Set • GraphOver V</code>.
</p>

<p>
Dependently-typed graphs are an curious structure. With a bit of renaming, and adding a few laws,
we obtain a ‘setoid’ &#x2013;i.e., an undirected graph where every node has a self-loop, and paths
correspond are essentially edges.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">PackageFormer</span> <span style="color: #b58900; font-style: italic;">SetoidP</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
  <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Graph structure</span>
  <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>
  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8776;</span><span style="color: #859900; font-weight: bold;">_</span>     <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Carrier</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>
  <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">Properties</span>
  refl  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span>e<span style="color: #268bd2;">}</span>     <span style="color: #268bd2;">&#8594;</span> e <span style="color: #268bd2;">&#8776;</span> e
  sym   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span>d e<span style="color: #268bd2;">}</span>   <span style="color: #268bd2;">&#8594;</span> e <span style="color: #268bd2;">&#8776;</span> d <span style="color: #268bd2;">&#8594;</span> d <span style="color: #268bd2;">&#8776;</span> e
  trans <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span><span style="color: #268bd2;">{</span>c d e<span style="color: #268bd2;">}</span> <span style="color: #268bd2;">&#8594;</span> c <span style="color: #268bd2;">&#8776;</span> d <span style="color: #268bd2;">&#8594;</span> d <span style="color: #268bd2;">&#8776;</span> e <span style="color: #268bd2;">&#8594;</span> c <span style="color: #268bd2;">&#8776;</span> d
</pre>
</div>
<p>
A non-dependently-typed ‘signature’ of a structure is generally obtained by discarding the relational operators
and all properties. For <code>SetoidP</code> one would immediately think the signature consists of just <code>Carrier</code>.
However, if we view it instead as undirected graphs with self-loops at each node and edge-transitivity, then
one would say the signature is the vertices <code>Carrier</code> and the edges <code>_≈_</code>. It is thus not clear when an item,
<code>_≈_</code> or <code>_⟶_</code>, forms constructive proofs or provides a type family. As such, signature extraction thus requires
a parameter identifying which elements constitute ‘proof matter’ &#x2014;then one simply filters a pacakge-former
against this criterion to obtain the associated signature. More generally, this allows us to take an <code>X</code> structure
and obtain may of its the associated views about where knowledge is consolidated \parencite{realms}, including:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">X</span>         <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#10216;</span> <span style="color: #b58900; font-style: italic;">Carrier</span>; <span style="color: #b58900; font-style: italic;">Operations</span>; <span style="color: #b58900; font-style: italic;">Properties</span> <span style="color: #268bd2;">&#10217;</span>     <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">C.f., SetoidP</span>
<span style="color: #b58900; font-style: italic;">XOver</span> <span style="color: #b58900; font-style: italic;">C</span>   <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#10216;</span> <span style="color: #b58900; font-style: italic;">Operations</span>; <span style="color: #b58900; font-style: italic;">Properties</span> <span style="color: #268bd2;">&#10217;</span>
<span style="color: #b58900; font-style: italic;">IsX</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #b58900; font-style: italic;">Ops</span> <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#10216;</span> <span style="color: #b58900; font-style: italic;">Properties</span> <span style="color: #268bd2;">&#10217;</span>
<span style="color: #b58900; font-style: italic;">XSig</span>      <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#10216;</span> <span style="color: #b58900; font-style: italic;">Carrier</span>; <span style="color: #b58900; font-style: italic;">Operations</span><span style="color: #268bd2;">&#10217;</span>                  <span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">C.f., GraphP</span>
</pre>
</div>
<p>
Having the signature in hand, one can easily and mechanically generate many derivied concepts.
For example, a ‘homomorphism’ is a family of functions of the underlying sorts such that
the given operations are preserved. Likewise, equality of homomorphisms is extensional equality of
the underlying maps. One can then generate closed and open terms and their interpretation functions.
With this approach to signature extraction, we can use the same algorithms
for the production of, say homomorphisms or other constructs, on completely
different algebraic structures, whether they be monoids or graphs.
Moreover, this implies that concepts generally not considered for a class
of algebras can easily be derived and experimented with; likewise for exploring
new algebraic theories.
These matters are an application, rather than a goal, of our envisioned system.
</p>

<p>
Sometimes constraints on an item can be derived, leaked by a signature.
</p>

<p>
E.g., the signature of sets, on a carrier, leaks that the carrier necessary
has decidable equality.
</p>

<p>
The curiosity of graphs is that they are one of the simplest <i>two-sorted</i> structures
and one of the most common in computing. Counter to intuition, existing packaging
systems, namely canonical structures and typeclasses, are oriented toward having
a distinct parameter: They cannot work well with multi-parameters; like classical
single-sorted algebra. However, the both <i>aim to solve a usability problem:</i>
<i>Having to spell out everything is too tedious.</i> Typeclasses are essentially dictionary look-up,
having unicity as an issue. Whereas canonical structures require familiarity with how unifer works
&#x2013;we provide enough information to the unifer to find the desired structure&#x2013; but, in general,
canonical structures do not scale. It is one of the thesis efforts to ensure the the unionised
approach scales by a complex example with clear avenues of extension.
</p>

<p>
It should be clear from these examples that package formers provide
expectant generality, including the common uses one is mostly interested in.
What about unexpected uses? What if a user wishes to utilise a representation
we did not conceive of? They should be able to use the existing language to
form it.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org8fd714c" class="outline-4">
<h4 id="org8fd714c"><span class="section-number-4">3.4.2</span> Second Observation: Computing Similarity for Containers</h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
By necessity of the first corollary, we are forced to utilise a uniform language
between the varying notions of packaging thereby relegating their treatment
to be a normal aspect of a language's core vernacular, rather than an extra-linguistic feature.
The previous examples hint at possible issues regarding well-definedness of certain constructs.
Moreover, we only elaborated on a few compositional operations,
<code>inherits-from, renaming, decorated</code>, yet users
may well wish to utilise their own compositional schemes and so it is imperative that we allow
them such a flexibility.
Consequently, users ought to be able to define their own compositional mechanisms, thereby
necessitating that they be able to manipulate package declarations themselves
which in-turn forces the language to be somewhat homoiconic. Moreover, to avoid a hierarchy
of languages, the facility for manipulating package declarations must itself be a part of
the core language, rather than an extra-linguistic feature &#x2014;c.f., Coq's Ltac.
</p>

<p>
In our envisioned setup, every <code>PackageFormer</code> declaration adds a clause to a special
function,
</p>

<div class="org-src-container">
<pre class="src src-haskell">packageInfo <span style="color: #b58900;">:</span> <span style="color: #b58900; font-style: italic;">PackageFormer</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">PackageInfo</span>
<span style="color: #b58900;">packageInfo</span> <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#10218;</span>compiler defined<span style="color: #268bd2;">&#10219;</span>
</pre>
</div>
<p>
Where a <code>PackageInfo</code> consists of <code>Name</code>, which is a list of parameter names and types, along with the name of the package former;
and <code>Declarations</code>, a list of name-type pairs whose last element is the target type.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #93a1a1;">{- </span><span style="color: #96A7A9; font-style: italic;">Draft: Lots of string manipulation, not ideal. -}</span>
<span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">PackageInfo</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
  field
    <span style="color: #b58900; font-style: italic;">Name</span>         <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">String</span> <span style="color: #268bd2;">&#215;</span> <span style="color: #b58900; font-style: italic;">String</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#215;</span> <span style="color: #b58900; font-style: italic;">String</span>
    <span style="color: #b58900; font-style: italic;">Declarations</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">String</span> <span style="color: #268bd2;">&#215;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">String</span><span style="color: #268bd2;">)</span>
<span style="color: #93a1a1;">--</span>
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">This is just another package,</span>
<span style="color: #93a1a1;">-- </span><span style="color: #96A7A9; font-style: italic;">it incidentally happens to be the representation of packages!</span>
</pre>
</div>

<p>
It is to be noted that there is no commitment to a string-based representation.
It is only a prototype and the thesis will likely move to a better typed
representation &#x2014;otherwise, we may run into too many problems of ill-formed
package formers.
</p>


<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">PackageFormer</span> <span style="color: #b58900; font-style: italic;">TermP</span> <span style="color: #268bd2;">(</span>v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #268bd2;">)</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
  <span style="color: #b58900; font-style: italic;">Var</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Int</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v
  <span style="color: #b58900; font-style: italic;">Add</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">TermP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">TermP</span> v
</pre>
</div>
<p>
The above declaration provides, under the hood, the following clause to <code>packageInfo</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">packageInfo</span> <span style="color: #b58900; font-style: italic;">TermP</span> <span style="color: #268bd2;">=</span> record <span style="color: #268bd2;">{</span> <span style="color: #b58900; font-style: italic;">Name</span>         <span style="color: #268bd2;">=</span> <span style="color: #d33682;">[</span><span style="color: #2aa198;">"v"</span>, <span style="color: #b58900; font-style: italic;">Variation</span><span style="color: #d33682;">]</span> , <span style="color: #2aa198;">"TermP"</span>
               ; <span style="color: #b58900; font-style: italic;">Declarations</span> <span style="color: #268bd2;">=</span> <span style="color: #d33682;">[</span> <span style="color: #859900;">(</span><span style="color: #2aa198;">"Var"</span>, <span style="color: #cb4b16;">[</span><span style="color: #2aa198;">"Int"</span>, <span style="color: #2aa198;">"TermP v"</span><span style="color: #cb4b16;">]</span><span style="color: #859900;">)</span>
                        , <span style="color: #859900;">(</span><span style="color: #2aa198;">"Add"</span>, <span style="color: #cb4b16;">[</span><span style="color: #2aa198;">"TermP v"</span>, <span style="color: #2aa198;">"TermP v"</span>, <span style="color: #2aa198;">"TermP v"</span><span style="color: #cb4b16;">]</span><span style="color: #859900;">)</span>
                        <span style="color: #d33682;">]</span>
               <span style="color: #268bd2;">}</span>
</pre>
</div>

<p>
We are now in a position to provide the semantics for the keyword <code>Declare</code>,
from the previous section. It takes a <code>PackageInfo</code> and declares a <code>PackageFormer</code>.
There should be a compile-time warning if such declarations are meaningless, ill-formed.
</p>

<p>
For example, the previous \newline <code>Declare PackageFormer TermRelP (v ∶ Variation) decorated (λ x → x ++ "′")</code>
can thus be obtained by a user by defining <code>decorated</code> as an operation on packages!
</p>

<div class="org-src-container">
<pre class="src src-haskell">_decorated_ <span style="color: #b58900;">:</span> <span style="color: #b58900; font-style: italic;">PackageInfo</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">(</span><span style="color: #b58900; font-style: italic;">String</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">String</span><span style="color: #268bd2;">)</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">PackageInfo</span>
<span style="color: #b58900;">pk</span> decorated f <span style="color: #268bd2;">=</span> record <span style="color: #268bd2;">{</span> <span style="color: #b58900; font-style: italic;">Name</span>         <span style="color: #268bd2;">=</span> bimap id f pk<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Name</span>
            ; <span style="color: #b58900; font-style: italic;">Declarations</span> <span style="color: #268bd2;">=</span> fmap <span style="color: #d33682;">(</span>bimap f id<span style="color: #d33682;">)</span> pk<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Declarations</span>
            <span style="color: #268bd2;">}</span>
</pre>
</div>

<p>
To rectify the seemingly wild mixfix notions, we request from the compiler
the following suitably general syntactic sugar.
An operation, call it, <code>altered-by</code> of the type <code>PackageInfo → List PackageInfo → List X → PackageInfo</code>
automatically obtains the syntactic sugar <code>p altered-by (q0; …; qk) with (f0; ...; fN)</code> &#x2014;c.f., the <code>inherits-from</code> syntax above.
</p>

<p>
With such terse functional programs for forming composition schemes,
there is no need to build much into the compiler.
</p>

<p>
Users can define other similar operations, such as <code>decorated-rounded</code>
which replaces the first two binary relations' names with <code>⊆</code> and <code>⊂</code>;
or <code>decorated-square</code> to make the renamings <code>⊑</code> and <code>⊏</code>.
Additionally, such renames would propagate into any axioms or derived laws.
Moreover, the flexibility to invoke such operations in complex ways allows for
intricate renamings to be generated at tremendous scale without worry that
future renames would need to be made if the orginal packages included new items.
Numerous examples of such renaming transpire manually in the impressive
RATH \parencite{RATH} development, as well as in Agda's standard library.
</p>

<p>
When working with multiple values of the same record type, for example,
one encounters a usability problem: Refereeing to the constituents without being verbose.
The simplest solution is to qualify each invocation, as in <code>instance.field</code>, however this
is rather cumbersome, inelegant, and is awkward for mixfix names. An alternative is to
locally rename the fields according to a scheme reflecting their use. For example, in
a produce construction of 5 items, the field names would be renamed to have a subscript number.
In a setting of two instances, a user may instead prefer a primed and an undecorated version
of field names. Thus far, by hand we have created these tedious subscript and primed renamings,
with our envisioned systems, we need no longer worry about such boilerplate.
</p>

<p>
In nearly the same fashion, a user could have defined the <code>inherits-from</code> compositional scheme.
Such a scheme may assume that all identically named items have the same types, and crash otherwise.
A user could define a better scheme that takes a renaming function, or another function to handle
the crash, or simply omitt conflicting names altogether.
The examples suggest that many commonly occurring compositional mechanisms \parencite{tpc}
can be directly provided by a library, rather than by a particular compiler
&#x2014;this includes the ability to hide fragments, expose the largest well-defined fragment,
and to combine packages along a given substructure.
</p>

<p>
Rather than select what we think is best, we can simply provide the general mechanism to the
library designer and allow them the freedom to provide their own schemes.
</p>
</div>
</div>

<div id="outline-container-org3d88793" class="outline-4">
<h4 id="org3d88793"><span class="section-number-4">3.4.3</span> Next Steps</h4>
<div class="outline-text-4" id="text-3-4-3">
<p>
Our brief examples demonstrate that the less design decisions about packaging
made by language designers, the more general, applicable, and, most importantly, increased homogeneity
in the resulting datatype language without becoming unityped but rather thanks to being dependently-typed.
As mentioned in the previous section on existing approaches, one formalism for
packages is that of theories and theory combinators; below we thus draw on some problems from theory combinators
rendered toward packaging systems.
</p>

<p>
We have mentioned that the <code>record</code> and <code>typeclass</code> perspectives solve the common requirement of
structures sharing an identical field. Other than that, we have essentially only
outlined a general mechanism for declaring packages and compositional schemes, but have not
discussed which are the most common and most useful packaging combinators.
It is also desirable to discuss the formal properties of such combinators
&#x2014;if anything, to ensure they are sensible and behave as expected.
Moreover, which combinators act as a basis for all packaging combinators?
Whence their use ensures the resulting composition is well-formed
and they could be targeted for optimisations.
</p>

<p>
To make our approach accessible, the generic package operations are brought to the user
rather than baked into the compiler &#x2014;too great a distance for most users.
The <code>Declare</code> syntax reifies <code>PackageInfo</code>'s into package declarations, but we have not mentioned
under what constraints it can actually provide compiler-time, or typechecking-time,
errors of ill-formedness. Moreover, how (in)efficient is this process?
Could it be extended to work on variable, runtime provided, declarations
for refying packages? Perhaps there is a constraint that suffices for the most common cases?
Moreover, having observable <code>PackageInfo</code>'s being automatically generated for every package declaration
renders representation hiding nearly moot.
</p>

<p>
The proposed approach boarders on meta-programming.
Can type erasure and other compiler-specific optimisations be brought into
the homoiconic-like setting being pursued here?
We have mentioned a few ‘built in’ variations for packaging; can such a feature
be liberated from the compiler and be bent to the users' will?
We would need the ability to explain how a package elaborates.
</p>

<p>
Tremendous flexibility is demanded from the back-end so as to ignore needless distinctions
at the users' level. Whereas the practicality is promising, the feasibility of an
implementation for such ambiguous parsing \parencite{ambiguous_parsing} is unclear.
It is also unclear what effects identifying syntactically distinct items
has on, say, normalisation and propositional equality.
</p>

<p>
The numerous claims and associaited bookkeeping of details pushes us into using a proof assistant, Agda.
</p>

<p>
Our examples have been ‘variation’ polymorphic;
we have been even more generic by defining <code>decorated</code>.
What are the limits of programming genericity provided by our scheme?
It would unsurprising if this approach yields
the next 700 module systems.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org8fc6de2" class="outline-2">
<h2 id="approach_and_timeline"><span class="section-number-2">4</span> Approach and Timeline</h2>
<div class="outline-text-2" id="text-approach_and_timeline">
<p>
Packages, modules, classes, (dependent) records, (named) contexts, telescopes, theories, specifications
&#x2014;whatever you wish to call them are essential structuring principles that
enable modularity, encapsulation, inheritance, and reuse in formal libraries and programs.
Moreover, as we have demonstrated, with the exception of use-cases,
there are no significant differences between them in a dependently-typed setting, as \parencite{theories_as_types} present a type theoretic calculus
of a variant of record types that corresponds to theories.
</p>
</div>

<div id="outline-container-org714c72e" class="outline-3">
<h3 id="org714c72e"><span class="section-number-3">4.1</span> Implementation Matter</h3>
<div class="outline-text-3" id="text-4-1">
<p>
We will realise our proposal in an existing compiler
and so working with it necessitates our implementations to be more than
just ‘research quality’ but actually ready for a broad audience.
</p>

<p>
Which compiler and for which language?
</p>

<p>
Since our attention is focused on dependently typed languages within the
realm of  Type Theory
\parencite{lof_constructive_math}, Agda \parencite{agda_web} is a natural
candidate.
</p>

<p>
Agda is currently one of the most used tools for proof and program experimentation
involving dependent types. With its support for mixfix Unicode lexemes, it has
become a strong competitor to Coq \parencite{coq_website,coq_inductive_coc, coq_coc} for both proof construction \parencite{agda_fixpoints, agda_quantifier_elim, agda_nondeterministic, agda_mergesort, agda_type_Safety, agda_aop}
and general program construction \parencite{agda_web, agda_trains, agda_bitcoin, agda_hardware}
&#x2014;Agda's lack of <i>syntactic</i> distinction between
programs and propositions, along with its pattern matching utilities in-place of
‘tactic sledgehammers’ \parencite{tactics}, it has also become an attractive
language for introducing dependent types and functional programming
\parencite{agda_iowa_book, agda_plf, agda_teaching}. With its syntactic similarity to Haskell, many Agda users treat
their Agda code as if it were lazy with the <code>let</code> and <code>where</code> clauses preserving sharing
&#x2014;which is not the case, since such clauses rewrite to top-level functions
\parencite{agda_docs}.
Instead, Agda's evaluation strategy is normal order: Function definitions
are invoked before arguments are evaluated, but computations of arguments
are <i>not</i> shared. This is a prime location for efficiency issues since type-checking
in a dependently typed language tends to involve evaluation of terms.
Surprisingly this has not stopped users from producing large-scale software
developments \parencite{RATH, agda_trains, agda_web}.
</p>

<p>
Needless to say,
a poor choice of elaboration strategy can lead to a loss of sharing
&#x2014;not that Agda has sharing to begin with&#x2014;,
contain too many undesirable side-effects, hinder efficiency, or forgo compile-time optimisations.
For example,
Agda, as currently implemented using the Glasgow Haskell Compiler (GHC), is a realisation
of  Type Theory (MLTT) that is heralded as
both a programming language and proof assistant.
Unfortunately MLTT, as many other dependent logics
&#x2014;such as the Calculus of Constructions with inductive types, which underlies both
the Coq and Lean proof assistants&#x2014;
does not account for modules, thereby leaving these as consistency-preserving hacks thrown onto the implementation.
As mentioned earlier, Agda simply rewrites modules into top
level functions with module parameters realised as parameters to the resulting functions.
This is an implementation detail and has little impact on theory construction,
however, code reuse becomes unreasonably slow
due to the loss of sharing that happens when module arguments need to be
re-normalised in each function-counterpart.
Consequently, only a minor subset of the Agda community actually <i>executes</i> their
programs. The rest of the community is generally content with type checking only;
which does not hinder the reliability of proof.
</p>

<p>
It is important to note that we employ Agda only as a proof-of-concept for
our proposed exploration of first-class structuring-mechanisms in dependently typed languages.
Admittedly Agda's support for Unicode mixfix lexemes makes it a pleasure to work
in, with mechanised proofs being little work more than their LaTeX renditions.
</p>
</div>
</div>

<div id="outline-container-org71ce4c8" class="outline-3">
<h3 id="org71ce4c8"><span class="section-number-3">4.2</span> Next Steps</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The approach we intend to follow consists of the following steps.
Notice that feedback loop of practice into theory.
</p>

<ol class="org-ol">
<li><p>
Really study the other mechanisms that already exist.
</p>

<p>
<b>Exhibiting such a weakness may suggest insufficient preparatory work!</b>
<b>Possibly resulting in a fail!</b>
</p>

<ul class="org-ul">
<li>Survey module systems in theory, in existing DTLs, <b>and</b> in non-DTLs.</li>

<li>As far as we can tell, besides the MTT \cite{mmt_main_paper, mmt_api}
group, no one else is working on actually implementing
solutions to the flaws we have identified, such as combination over
structures.</li>

<li>This is promising in terms of novelty, if anything.</li>

<li>Analyse why there are not multiple implementations of such seemingly
immensely useful concepts.</li>
</ul></li>
</ol>

<ol class="org-ol">
<li>Distill the <i>true</i> requirements for a solution;
ensure good <i>fit for purpose</i> criteria exists.

<ul class="org-ul">
<li>Understand the requirements of `modularity mechanisms' for DTLs.</li>
<li>Narrow down a design by choosing a set of requirements.</li>
<li>Identify necessary, and practical, trade-offs.
Conflicting feature sets? Usability?</li>
<li>Ideally we want our implementations to avoid too much overhead,
such as creating an entire new language; this may necessitate the
weakening of other functionality.</li>
</ul></li>

<li>Deepen understanding of the opportunities given by DTL.

<ul class="org-ul">
<li><p>
Understand the relationships between
modules, records, contexts, telescopes, and signatures.
</p>
<ul class="org-ul">
<li>Do they have differing `types'?</li>
<li>As types themselves, do they have differing `values'?</li>
<li>In the setting of DTLs, are they essentially isomorphic?</li>
<li>What are the intended uses? What intentions do particular choices communicate?
<ul class="org-ul">
<li>E.g., “\(x = y\)” communicates an equality and nothing more, whereas</li>
</ul></li>
</ul>
<p>
“\(x\! \iff\! y\)” communicates a Boolean equality: A redundant, particularised, equality
symbol serves to succinctly and elegantly communicate more information.
</p></li>
</ul></li>

<li>Formulate basic, draft, semantics for a small set of DTL module primitives.

<ul class="org-ul">
<li>What is the type of a package former?</li>
<li>How does it fit into Agda's existing type hierarchy?</li>
<li>What are the types of the primitives themselves?
<ul class="org-ul">
<li>We wish to avoid metaprogramming
after all, and so wish to remain within the language rather than
in a metalanguage.</li>
</ul></li>
</ul></li>

<li>Prototype some mechanisms; a combination of old, adapted, and novel ones
to demonstrate the power of the system.

<ul class="org-ul">
<li>Implement the structuring mechanism combinators discussed earlier
&#x2014;such as combination over common-substructures.

<ul class="org-ul">
<li>Possibly begin with reifying first class grouping mechanisms by
representing contexts &#x2014;i..e, sequences of declarations with optional definitions&#x2014;
as records in Agda with the undefined declarations being fields and the rest being
derived or definitional.</li>
</ul></li>
</ul></li>

<li>Evaluate the mechanisms &#x2014;using fit-for-criteria.

<ul class="org-ul">
<li>Since the realisation would be in Agda, we would keep in touch with the community
to ensure that the additions contribute to program design.</li>

<li>Evaluate the strength of the resulting additions in terms
of practical use for library designers as well as in terms of program speed.</li>
</ul></li>

<li>Make sure to have a denotational semantics for the mechanisms.

<ul class="org-ul">
<li>Ensure that the additions are minimal, orthogonal, and construct a sound
type theory around them.</li>
</ul></li>

<li>Refine 2-6 until elegance, or deadline, is reached, whichever comes first.</li>
</ol>

<p>
Our timeline will discuss how we will carry out this approach in multiple
passes and will discuss the conditions of a successful pass.
</p>
</div>
</div>

<div id="outline-container-orga5744ee" class="outline-3">
<h3 id="orga5744ee"><span class="section-number-3">4.3</span> Timeline</h3>
<div class="outline-text-3" id="text-4-3">
<p>
We shall iterate through the `approach phase' three times,
utilising a feedback loop of practice into theory.
The phases are discussed below.
</p>

<p>
As our results will likely need to be re-proven for definitional adjustment,
we intend to <i>mechanise</i> all of our proofs in Agda as well &#x2014;when possible.
Therefore, Agda plays multiple roles: A dependently-typed language to experiment
with, as well as a proof checker for our results.
</p>
</div>

<div id="outline-container-org8ab14fb" class="outline-4">
<h4 id="org8ab14fb"><span class="section-number-4">4.3.1</span> The First Pass: May-October 2019</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
This stage concludes successfully provided the following checkpoints are achieved.
</p>

<ul class="org-ul">
<li>A thorough understanding of what is being done by others, and how
our approach differs, is obtained <i>and</i> documented.</li>

<li>Understand the Agda compilation ecosystem, provide a report on how to make
alterations to it, and actually implement at least one structuring mechanism
and provide use cases as well as preliminary efficiency analysis.</li>

<li>A publication covering existing mechanisms, their features and flaws,
and possibly an explanation of why there is theoretical work on these issues
but little to no implementation on them
&#x2014;with a focus on practical uses and possible hurdles to use.

<ul class="org-ul">
<li>A side-effect of this is to produce an evaluation strategy for the mechanisms.</li>
<li>Moreover, this necessitates looking into the associated semantics,
evaluating them, and proposing semantics for the mechanism we have designed.</li>
</ul></li>

<li>Thesis writing should have begun and nearing completion are sections
on introduction and background.</li>
</ul>
</div>
</div>

<div id="outline-container-org8db9a3b" class="outline-4">
<h4 id="org8db9a3b"><span class="section-number-4">4.3.2</span> The Middle Pass: November 2019 - February 2020</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
This stage concluded successfully provided the following checkpoints are achieved.
</p>

<ul class="org-ul">
<li>The success of the previous stage ensures an understanding of the Agda compilation
ecosystem, as such it should take less time to implement the more mechanisms,
theory combinators. The goal is to have the remaining mechanisms implemented,
with a focus on the combination-over-a-structure mechanism.

<ul class="org-ul">
<li>With each implementation, reach-out to the Agda community to solicit
feedback regarding improvements and possible use cases.</li>
</ul></li>

<li>Extending the semantics for the newly implemented mechanisms.

<ul class="org-ul">
<li>Evaluating which mechanisms are more primitive, which are derived, and
which can be used to <i>allow users to make their own <b>using</b> the concrete language itself</i>!</li>
</ul></li>

<li>A publication of case studies utilising these combinators, as well as
a comparison of how these are an improvement over traditional methods.

<ul class="org-ul">
<li>Analysing the interactions between features; does the addition of one
hinder another.</li>

<li>Empirical tests for efficiency and utility.</li>
</ul></li>

<li>Thesis writing should have progressed with sections on
use cases, semantics, and feature design,
having substantial matter if not nearing completion.</li>
</ul>
</div>
</div>

<div id="outline-container-org86aa35f" class="outline-4">
<h4 id="org86aa35f"><span class="section-number-4">4.3.3</span> The Final Pass: March - April 2020</h4>
<div class="outline-text-4" id="text-4-3-3">
<p>
This stage concluded successfully provided the following checkpoints are achieved.
</p>

<ul class="org-ul">
<li>Ensure that our implementations are meeting our requirements for a solution.</li>

<li>Begin mechanisation of proofs authenticating that the denotational
semantics has desired, expected, properties; such as soundness and safeness.</li>
</ul>
</div>
</div>

<div id="outline-container-orgae7bf04" class="outline-4">
<h4 id="orgae7bf04"><span class="section-number-4">4.3.4</span> Concluding Phase</h4>
<div class="outline-text-4" id="text-4-3-4">
<p>
Wrap up all proof matters and finish the thesis.
</p>

<p>
Suffice to say life tends to be more hectic than a schedule may permit
and as such some times may deviate from the above intentions.
Regardless, the goal will be to complete the thesis within 2 years time;
in particular before September 2020.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc2b6231" class="outline-2">
<h2 id="conclusion"><span class="section-number-2">5</span> Conclusion</h2>
<div class="outline-text-2" id="text-conclusion">
<p>
As already discussed,
more often than not a module system is an afterthought secondary citizen
whose primary purpose is to act as a namespace delimiter
&#x2014;e.g., C#'s <code>namespace</code> construct&#x2014;
while relatively more effort is given to their abstraction encapsulation
counterpart, e.g., C#'s <code>class</code>'es.
Some languages' module systems blend both namespace management and
implementation hiding, e.g., as in the Haskell programming language.
Other languages such as OCaml take modules even further: Not only are modules
used for namespace organisation and datatype abstraction, but they can also be
passed around as values for manipulation as if they were nothing special, thereby
collapsing the distinction between record constructs and organisational constructs.
</p>

<p>
The proposed research is to build upon the existing state of module
systems and develop an extension to a compiler to substantiate our claims,
and to ultimately discover new semantical relationships between programming
language constructs in a dependently typed setting with modules as first-class
citizens. This involves redesigning and enhancing existing module systems
to take into account dependent types as well as producing rewrite theorems
to ensure acceptable performance times.
</p>

<p>
Intended outcomes include:
</p>
<ol class="org-ol">
<li>A clean module system for DTLs
<ul class="org-ul">
<li>Dependent types blur many distinctions therefore rendering certain
traditional programming constructs as inter-derivable and so only
a minimal amount need be supported directly, while the rest can be
defined within the extended type theory we will be creating.
Since modules are records, which are
one-field algebraic data types, and we can form sums of modules, it
would not be surprising if first-class modules suffice for arbitrary data type
definitions.</li>
</ul></li>

<li><i>Utility Objectives</i>: A variety of use-cases contrasting the resulting system with previous
approaches. In particular, the system should:

<ul class="org-ul">
<li>Reduce amount of ‘noise’ necessary for working with grouping mechanisms in a number of ways.</li>
<li>It should be easy and elegant to use and, possibly, to extend.</li>
</ul></li>
<li>A module system that enables rather than inhibits (or worse) efficiency.
<ul class="org-ul">
<li>Currently Agda modules, for example, are sugar for extra functional parameters
and so all implicit sharing in modules is lost at compilation time.</li>
<li>Deeply nested, deeply tagged, operations could be costly and so being apply
to <i>soundly</i> flatten modules and <i>soundly</i> extract operations and results
is a necessity when speed is concerned &#x2014;moreover, this needs to be mechanical and succinct if it is to be useful.</li>
</ul></li>
<li>Demonstrate that module features usually requiring meta-programming can be brought
to the data-value level.
<ul class="org-ul">
<li>Names and types, for example, in a module should be accessible
and alterable. For example, we can obtain a rig by combining two instances
of a monoid module where we would rename the fields of one, or both, of them.</li>
<li>Thereby relegating abstract syntax tree and programs-as-strings manipulations
to the edges of the computing environment.</li>
</ul></li>
</ol>

<p>
Most importantly, we intend to implement our theory to obtain
validation that it “works”!
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Musa Al-hassy</p>
<p class="date">Created: 2019-08-20 Tue 07:51</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
