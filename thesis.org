#+title: Do-it-yourself Module Systems
# subtitle: We can change things later, but can't change it if there's nothing to change!

* TODO COMMENT Abstract [100%]

* COMMENT Table of Contents                                    :Github:TOC_4:
- [[#introduction][Introduction]]

* Introduction

   A fundamental argument for the use of module systems in the design of large
 programs is that the structure of the program is partitioned into coherent
 semantical units that are furnished with an interface belying the complexity of
 their implementations. A well-established example is the use of the humble
 record to ‘bundle’ up the extensional properties of an object; here one works
 with objects as if they were atomic, rather than considering their the
 collection of their identifying properties.  Users of dependently-typed
 languages like Agda and Coq will argue strongly that the effective use of
 module systems is extremely important for subsequent program development, and
 even uses of dynamically typed languages like Javascript will admit that, for
 example, namespace violations are an area of concern.  A fundamental aspect of
 =PackageFormer= is that the relationship between a grouping mechanism and its
 constituent structuring sub-grouping mechanisms is made explicit: One extracts
 grouping mechanisms from declarations involving existing grouping mechanisms.
 In contrast to type theory wherein a type is specified by characterising how
 its elements may be formed, our approach allows both the building-up of
 grouping mechanisms from their parts and, also, the ‘tearing down’ of parts of
 existing grouping mechanisms ---as is the case of dropping a property from a
 record type to obtain another record type, or of transforming a record type
 into an algebraic data type.  Depending on their nature, grouping
 specifications may either allow the automatic derivation of ‘introduction
 rules’ wherein the teared-down grouping is transformed into the new grouping,
 or allow ‘elimination rules’ wherein the individual groupings that built-up the
 new grouping are can be identified.  The semantics of a grouping specification
 is essentially the ‘flattening’ of properties that extensionally constitute it.
 Our work describes the necessary primitives that allow grouping declarations.

 The intention is not to provide a fixed set of general-purpose grouping
 combinators that are sufficient to encompass all the future needs of all
 programmers but to provide a discipline whereby programmers may invent their
 own type constructors peculiar to their own problem domain.

* TODO COMMENT Review of Related Work [0%]
   --Remaining Tasks--
 + [ ] …
 + [ ] …
 + [ ] …
 + [ ] …
* TODO COMMENT Our Approach [0%]
 --Remaining Tasks--
 + [ ] Plan of Attack
 + [ ] Implementation Details
 + [ ] Discussion of Results
 + [ ] Future Work

* TODO COMMENT Conclusions [0%]
   --Remaining Tasks--
 + [ ] …
 + [ ] …
 + [ ] …
 + [ ] …

* COMMENT What's a thesis? [0%]
  + [ ] The argument
    - What is it? Is it being argued clearly?
    - What's the plan?
  + [ ] An exposition of an orginal piece of research.
  + [ ] Distinctive contribution to the knowledge of the subject?
  + [ ] Evidence of orginality shown by the discovery of new facts?
  + [ ] How is the research best appreciated?
  + [ ] Ideas not mentioned in the thesis might as well not exist! Mention ideas.

* COMMENT Planning an Argument [0%]
  One sentence for each:
  + [ ] Introduction to the area of study.
  + [ ] The problem being tackled.
  + [ ] What the literature says about the problem.
    - A review of previous work shows you know the subject.
    - Besides being descriptive, the review needs to be critical.
    - Summary of the essential features of other work as it relates to this study.
  + [ ] How /I/ tackle this problem.
    - What is the philosophy of approach?
    - How were you systematic?
    - How is this linked back to the literature review?
  + [ ] How /I/ implement my solution.
    - Provide details so that others can follow what was done.
    - Justify the approach taken.
    - Does the software appear to work satisfcatorily?
  + [ ] The result.
    - Application of the approach reduces thousands of lines of code to
      human-readable specfications with an extensible system?
    - *Link back to how the solutions obtained relate to the questions posed?*
    - Accurately identitfy & summarise patterns or trends in the results.
    - Provide a critical analysis to show you know its limitations.
    - ‘Future Work’ to show what's missing.
    - Beware of specfulations not grounded in the results.
  + [ ] Conclusion ---repetition of the intro, but with reference to the detail.

  An outline acts as a workplan for which the entire research process is an
  exercise addressing each item. Each item becomes at least one section in
  the writeup.

  + [ ] Set out clearly what each chapter should say.

* COMMENT Say everything thrice [0%]

  It's not repetition, but linking and rationale.

  + [ ] In the thesis as a whole.
    - [ ] Introduction - What the thesis will say.
    - [ ] Body - Details of the work.
    - [ ] Conclusion - What the thesis said.

  + [ ] Within each chapter/section.
    - [ ] Signposting - What this section says.
    - [ ] Body - The details.
    - [ ] Summary - What this section has said.

  + [ ] Within each paragraph.
    - [ ] Each paragraph describes a single idea.
    - [ ] The first sentence introduces the idea ---linking it with the previous one.
    - [ ] The last sentence concludes the idea ---linking it with the next one.

  Signposts ensure it's clear what's being discussed and why
  ---from a writer's perspective, they help get the contents right.

* COMMENT The Examiner's View

  They'll read it in meetings, trains, or planes.
  They're busy and an initial scan may be:

  1. abstract - what's it about?
  2. bibliography - Does it cite the right stuff? Has it been published already?
  3. conclusions - What was achieved? Do I believe it?
  4. contents listing - Is everything there? Is the argument clear?

  Weakeness in these locations might suggest large corrections.

* COMMENT What If I'm stuck?

  1. The task at hand may be too difficult.
  2. *Ask for help!*
  3. Change the plan.
  4. Cut away irrelevant bits.
