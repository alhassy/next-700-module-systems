#+title: Do-it-yourself Module Systems
# subtitle: We can change things later, but can't change it if there's nothing to change!


* COMMENT Proposed Outline

1. Motivating the problem
   - Where has this problem been encountered in the wild?
   - What benefits would there be to solving this problem?
   - Mention ~1 * x + 0 = x~ problem from the ICFP20 paper.
     * Two monoidal units on the same carrier satisfy this law.

   Here is where the "STORY" is placed.

2. Background: What's necessary to solve this problem?
   - What is needed to just understand this problem?
   - Agda
   - System F
   - Monads
   - Metaprogramming

   Maybe tackle this "as needed", rather than upfront.

3. PackageFormer
   - Why an editor extension? Why Lisp is reasonable?
   - Utility of a protottype?
   - Things learned from making a protottype?
     * Perhaps show the minimal code needed to get PF working; <= 300 lines?
     * Much more Lisp for implementing common grouping mechanisms; e.g., pushouts.
   - How usable is it?
   - What exotic notions of grouping mechanisms can be coded-up? Utilit!?
   - [Disadvantages of PackageFormer?
   - Comparision to other systems.

4. Contexts
   - Why PackageFormer is not enough.
   - Discuss Agda macros ---need to be self-contained.
   - Motivate the need for a practical syntax.
   - The reason it's a "do it yourself" system is that the semantics, >>=,
     can be tweaked easily for other forms of grouping besides Pi/Sigma ;-)
   - Current limitations; e.g., lack of termination/positivity of certain constructs;
     or how termtype generation requires the ADT carrier to be the first element
     of the sequence/context, whereas a DAG interpretation of Contexts would be better?
   - How does this compare with PF?
   - What are the benefits of Context?
   - Concrete problems its usage can solve.

5. Related works
   - Who has worked on this problem and where have they gotten?
   - What are their shortcomings and advantages wrt to our approach?
   - Shortcomings of our approach.
   - Missing features and next steps.

6. Conclusion
   - What we have done
   - How it is useful to others, now.

* Table of Contents                                    :Github:TOC_4:
- [[#image][Image]]
- [[#story][Story]]
- [[#motivating-the-problem-----examples-from-the-wild][Motivating the problem --- Examples from the Wild]]
  - [[#introduction][Introduction]]
  - [[#adding-zero-then-multiplying-by-one-results-in-a-type-error][Adding Zero then Multiplying by One Results in a Type Error]]
  - [[#renaming][Renaming]]
    - [[#renaming-problems-from-agdas-standard-library][Renaming Problems from Agda's Standard Library]]
    - [[#renaming-problems-from-the-rath-agda-library][Renaming Problems from the RATH-Agda Library]]
    - [[#renaming-problems-from-the-agda-categories-library][Renaming Problems from the Agda-categories Library]]
  - [[#from-isùìß-to-ùìß----packing-away-components][From ~Isùìß~ to ~ùìß~ ---Packing away components]]
  - [[#redundancy-derived-features-and-feature-exclusion][Redundancy, Derived Features, and Feature Exclusion]]
  - [[#extensions][Extensions]]
  - [[#summary-of-some-design-patterns-in-dependently-typed-programming][Summary of Some Design Patterns in Dependently-Typed Programming]]

* Image :ignore:
#+html: <img src="patterns.png">

* COMMENT Abstract
* TODO Story

1. There are a host of repeated module patterns since modules are not a first-class construct.
   - E.g., IsX and X in Agda's standard library.
   - E.g., Hom, and universal algebra constructs, /for/ a paraticular theory.
   - E.g., common renaming patterns such as X_i or X' or etc for a theory X.
     - Cannot do this in Context due to Agda's limited support for fresh names.
     - Doable in PF.

2. To show that first-class modules are /reasonable/, we begin by providing
   PackageFormer: A specfication and manipulation language for modules.

   - Why Emacs Lisp? Super close to the Agda homebase.
   - Discuss how the issues in (1) are now doable.

3. The ideas learned from making the prototype lead us to form Context.
   - E.g., a termtype arises by keeping only the fields that target the elected ADT carrier.
   - Ideas of :waist!

4. Shallow comparision of PF and Context.

# --------------------------------------------------------------------------------
# #
# Put the STORY into the section on motivating problems?

* Motivating the problem --- Examples from the Wild :STORY:

** Introduction :ignore:
Tedium is for machines; interesting problems are for people.

In this section, we showcase a number of problems that occur in developing
libraries of code, with an eye to dependently-typed languages. We will refer
back to these real-world examples later on when developing our frameworks for
reducing their tedium and size.

Incidentally, the common solutions to the problems presented may be construed as
‚Äúdesign patterns for dependently-typed programming‚Äù. Design patterns are
algorithms yearning to be formalised. The power of the host language dictates
whether design patterns remain as informal directions to be implemented in an
ad-hoc basis then checked by other humans, or as a library methods that are
written once and may be freely applied by users. For instance, [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Morphism.html#1][Agda's
~Algebra.Morphism~ ‚Äúlibrary‚Äù]] presents an example(!) of the homomorphism design
pattern ---which shows how to form operation-preserving functions for algebraic
structures. The documentation reads: ~An example showing how a morphism type can
be defined~. An example, rather than a library method, is all that can be done
since the current implementation of Agda does not have the necessary
meta-programming utilities to construct new types in a practical way ---at
least, not out of the box.
# #
# + The procedure is essentially the same for other algebraic structures.
# + It takes time to do form these explicitly, even for the common structures.

** Adding Zero then Multiplying by One Results in a Type Error

   In theory, lists and vectors are the same ---where the latter are essentially
   lists indexed by their lengths. In practice, however, the additional length
   information stated up-front as an integral part of the data structure makes
   it not only easier to write programs that would otherwise by awkward or
   impossible in the latter case. For instance, below we demonstrate that the
   function ~head~, which extracts the first element of a non-empty list, not only
   has a difficult type to read, but also requires an auxiliary relation in
   order to be expressed. In contrast, the vector variant has a much simpler
   type with the non-emptiness proviso expressed by requesting a positive
   length.

#+BEGIN_SRC agda :tangle list-is-not-vec.agda :prologue "module list-is-not-vec where \nopen import Notation \n"
data List (A : Set) : Set where
  []  : List A
  _‚à∑_ : A ‚Üí List A ‚Üí List A

data Vec (A : Set) : ‚Ñï ‚Üí Set where
  []  : Vec A 0
  _‚à∑_ : ‚àÄ {n} ‚Üí A ‚Üí Vec A n ‚Üí Vec A (suc n)

data not-null {A : Set} : List A ‚Üí Set where
  indeed : ‚àÄ {x xs} ‚Üí not-null (x ‚à∑ xs)

head : ‚àÄ {A} ‚Üí Œ£ xs ‚à∂ List A ‚Ä¢ not-null xs ‚Üí A
head (x ‚à∑ xs , indeed) = x

head‚Ä≤ : ‚àÄ {A n} ‚Üí Vec A (suc n) ‚Üí A
head‚Ä≤ (x ‚à∑ xs) = x
#+END_SRC

This phenomena applies not only to derived concepts such as non-emptiness, but
also to explicit features of a datatype. A common scenario is when two instances
of an algebraic structure share the same carrier and thus it is reasonable to
connect the two somehow by a coherence axiom. Perhaps the most popular instance
of this scenario is in the setting of rings: There is an additive monoid ~(R, +,
0)~ and a multiplicative monoid ~(R, √ó, 0)~ on the same underlying set, and their
interaction is dictated by two distributivity axioms, such as ~a √ó (b + c) ‚âà (a
√ó b) + (a √ó c)~. As with ~head~ above, depending on which features of a monoid are
exposed upfront, such axioms may be either difficult to express or relatively easy.

For brevity, since our interest is in expressing the aforementioned distributivity axiom,
we shall ignore all other features of a monoid, to obtain a magma.
#+BEGIN_SRC agda :tangle list-is-not-vec.agda
record Magma‚ÇÄ : Set‚ÇÅ where
  field
    Carrier : Set
    _‚®æ_      : Carrier ‚Üí Carrier ‚Üí Carrier

module Distributivity‚ÇÄ
    (Additive Multiplicative : Magma‚ÇÄ)
    (open Magma‚ÇÄ Additive renaming (Carrier to R‚Çä; _‚®æ_ to _+_))
    (open Magma‚ÇÄ Multiplicative renaming (Carrier to R‚Çì; _‚®æ_ to _√ó_))
    (shared-carrier :  R‚Çä ‚â° R‚Çì)
    where

  coe‚Çì : R‚Çä ‚Üí R‚Çì
  coe‚Çì = subst id shared-carrier

  coe‚Çä : R‚Çì ‚Üí R‚Çä
  coe‚Çä = subst id (sym shared-carrier)

  distribute‚ÇÄ : ‚àÄ {a : R‚Çì} {b c : R‚Çä}
                ‚Üí   a √ó coe‚Çì (b + c)
                  ‚â° coe‚Çì (coe‚Çä(a √ó coe‚Çì b) + coe‚Çä(a √ó coe‚Çì c))
  distribute‚ÇÄ = {!!}
#+END_SRC
It is a bit of a challenge to understand the type of ~distribute‚ÇÄ~.
Even though the carriers of the monoids are propositionally equal, ~R‚Çä ‚â° R‚Çì~,
they are not the same by definition. As such, we are forced to ‚Äúcoe‚Äùrce back and forth;
leaving the distributivity axiom as an exotic property of addition, multiplication, and coercions.
Even worse, without the cleverness of declaring two coercion helpers, the typing of ~distribute‚ÇÄ~
would have been so large and confusing that the concept would be rendered near useless.

Let's clarify what equality means. One says ~ùìÅ ‚â° ùìá~ is <<</definitionally
equal/>>> when both sides are indistinguishable after all possible definitions
in the terms ~ùìÅ~ and ~ùìá~ have been used. In contrast, the equality is
<<</propositionally equal/>>> when one must perform actual work, such as using
inductive reasoning. In general, if there are no variables in ~ùìÅ ‚â° ùìá~ then we have
definitional equality ---i.e., simplify as much as possible then compare---
otherwise we have propositional equality ---real work to do. Below is an example
about the types of vectors.
#+BEGIN_SRC agda :tangle list-is-not-vec.agda
definitional : ‚àÄ {A} ‚Üí Vec A 5 ‚â° Vec A (2 + 3)
definitional = refl

propoistional : ‚àÄ {A m n} ‚Üí Vec A (m + n) ‚â° Vec A (n + m)
propoistional = {!!}
#+END_SRC

In theory, parameterised structures are no different from their unparameterised, or ‚Äúbundled‚Äù, counterparts.
However, in practice, this is wholly untrue: Below we can phrase the distributivity axiom nearly as it was
stated informally earlier since the shared carrier is declared upfront.
#+BEGIN_SRC agda :tangle list-is-not-vec.agda
record Magma‚ÇÅ (Carrier : Set) : Set‚ÇÅ where
  field
    _‚®æ_      : Carrier ‚Üí Carrier ‚Üí Carrier

module Distributivity‚ÇÅ
    (R : Set) {- The shared carrier -}
    (Additive Multiplicative : Magma‚ÇÅ R)
    (open Magma‚ÇÅ Additive       renaming (_‚®æ_ to _+_))
    (open Magma‚ÇÅ Multiplicative renaming (_‚®æ_ to _√ó_))
    where

  distribute‚ÇÅ : ‚àÄ {a b c : R}
                ‚Üí a √ó (b + c) ‚â° (a √ó b) + (a √ó c)
  distribute‚ÇÅ = {!!}
#+END_SRC
In contrast to the bundled definition of magmas, this form requires no cleverness to form coercion helpers,
and is closer to the informal and usual distributivity statement.

By the same arguments above, the simple statement relating the two units of a ring $1 √ó r + 0 ‚âà r$
---or any units of monoids sharing the same carrier--- is easily phrased using an unbundled presentation
and would require coercions otherwise. We invite the reader to pause at this moment to appreciate the difficulty
in simply expressing this property.

Computing is filled with exciting problems; machines should help us reduce if
not eliminate boring tasks.

#+begin_quote
*Unbundling Design Pattern*:
If a feature of a class is shared among instances, then use an unbundled form of the class
to avoid ‚Äúcoercion hell‚Äù.
#+end_quote

Observe that we assigned superficial renamings, aliases, to the prototypical
binary operation ~_‚®æ_~ so that we may phrase the distributivity axiom in its
expected notational form. This leads us to our next topic of discussion.

** Renaming

The use of an idea is generally accompanied with particular notation that is
accepted by the community. Even though the choice of bound names it
theoretically irrelevant, certain communities would consider it unacceptable to
deviate from convention. Here are a few examples:

- ~x(f)~ :: Using ~x~ as a /function/ and ~f~ as an /argument/.; likewise $\frac{\partial x}{\partial f}$.

  With the exception of people familiar with the Yoneda Lemma, or continuations,
  such a notation is simply ‚Äúwrong‚Äù!

- ~a √ó a ‚âà a~ :: An idempotent operation denoted by multiplication; likewise for commutative operations.

  It is more common to use addition or join, ~‚äî~.

- ~0 √ó a ‚âà a~ :: The identity of ‚Äúmultiplicative symbols‚Äù should never resemble
  ‚Äú0‚Äù; instead it should resemble ‚Äú1‚Äù or, at least, ~‚Äúe‚Äù~ ---the standard
  abbreviation of the influential algebraic works of German authors who used
  ‚ÄúEinheit‚Äù which means ‚Äúidentity‚Äù.

- ~f + g~ :: Even if monoids are defined with the prototypical binary operation
  denoted ‚Äú+‚Äù, it would be ‚Äúwrong‚Äù to continue using it to denote functional composition.
  One would need to introduce the new name ‚Äú‚àò‚Äù or, at least, ‚Äú¬∑‚Äù.

From the few examples above, it is immediate that to even present a prototypical
notation for an idea, one immediately needs auxiliary notation when specialising
to a particular instance. For example, to use ‚Äúadditive symbols‚Äù such as ~+, ‚äî,
‚äï~ to denote an arbitrary binary operation leads to trouble in the function
composition instance above, whereas using ‚Äúmultiplicative symbols‚Äù such as ~√ó,
¬∑, *~ leads to trouble in the idempotent case above.

Regardless of prototypical choices, there will always be a need to rename.

#+begin_quote
*Renaming Design Pattern*:
Use superficial aliases to better communicate an idea;
especially so, when the topic domain is specialised.
#+end_quote

Let's now turn to examples of renaming from three libraries:
1. Agda's standard library,
2. The RATH-Agda library, and
3. A recent categories library.

Each will provide a workaround to the problem of renaming. In particular, the
solutions are, respectively:

1. Rename as needed.
   - There is no systematic approach to account for the many common renamings.
   - Users are encouraged to do the same, since the standard library does it this way.

2. Pack-up the /common/ renamings as modules, and invoke them when needed.
   - Which renamings are provided is left at the discretion of the designer
     ---even ‚Äúexpected‚Äù renamings may not be there since, say, there are too many
     choices or not enough man power to produce them.
   - The pattern to pack-up renamings leads nicely to consistent naming.

3. Names don't matter.
   - Users of the library need to be intimately connected with the definitions
     are domain to use the library.
   - Consequently, there are many inconsistencies in naming.

  The ~open ‚ãØ public ‚ãØ renaming ‚ãØ~ pattern shown below will be presented in a
   future section as a library method.

*** Renaming Problems from Agda's Standard Library

[[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Structures.html#2757][Here is an excerpt from Agda's standard library]], notice how the prototypical
notation for monoids is rename repeatedly /as needed/. Sometimes it is
relabelled with additive symbols, other times with multiplicative symbols.
#+BEGIN_SRC agda2
record IsNearSemiring {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
                      (+ * : Op‚ÇÇ A) (0# : A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    +-isMonoid    : IsMonoid ‚âà + 0#
    *-isSemigroup : IsSemigroup ‚âà *
    distrib ≥      : * DistributesOver ≥ +
    zeroÀ°         : LeftZero 0# *

  open IsMonoid +-isMonoid public
         renaming ( assoc       to +-assoc
                  ; ‚àô-cong      to +-cong
                  ; isSemigroup to +-isSemigroup
                  ; identity    to +-identity
                  )

  open IsSemigroup *-isSemigroup public
         using ()
         renaming ( assoc    to *-assoc
                  ; ‚àô-cong   to *-cong
                  )

record IsSemiringWithoutOne {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
                            (+ * : Op‚ÇÇ A) (0# : A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    +-isCommutativeMonoid : IsCommutativeMonoid ‚âà + 0#
    *-isSemigroup         : IsSemigroup ‚âà *
    distrib               : * DistributesOver +
    zero                  : Zero 0# *

  open IsCommutativeMonoid +-isCommutativeMonoid public
         hiding (identityÀ°)
         renaming ( assoc       to +-assoc
                  ; ‚àô-cong      to +-cong
                  ; isSemigroup to +-isSemigroup
                  ; identity    to +-identity
                  ; isMonoid    to +-isMonoid
                  ; comm        to +-comm
                  )

  open IsSemigroup *-isSemigroup public
         using ()
         renaming ( assoc       to *-assoc
                  ; ‚àô-cong      to *-cong
                  )

record IsSemiringWithoutAnnihilatingZero
         {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
         (+ * : Op‚ÇÇ A) (0# 1# : A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    +-isCommutativeMonoid : IsCommutativeMonoid ‚âà + 0#
    *-isMonoid            : IsMonoid ‚âà * 1#
    distrib               : * DistributesOver +

  open IsCommutativeMonoid +-isCommutativeMonoid public
         hiding (identityÀ°)
         renaming ( assoc       to +-assoc
                  ; ‚àô-cong      to +-cong
                  ; isSemigroup to +-isSemigroup
                  ; identity    to +-identity
                  ; isMonoid    to +-isMonoid
                  ; comm        to +-comm
                  )

  open IsMonoid *-isMonoid public
         using ()
         renaming ( assoc       to *-assoc
                  ; ‚àô-cong      to *-cong
                  ; isSemigroup to *-isSemigroup
                  ; identity    to *-identity
                  )

record IsRing
         {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
         (_+_ _*_ : Op‚ÇÇ A) (-_ : Op‚ÇÅ A) (0# 1# : A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    +-isAbelianGroup : IsAbelianGroup ‚âà _+_ 0# -_
    *-isMonoid       : IsMonoid ‚âà _*_ 1#
    distrib          : _*_ DistributesOver _+_

  open IsAbelianGroup +-isAbelianGroup public
         renaming ( assoc               to +-assoc
                  ; ‚àô-cong              to +-cong
                  ; isSemigroup         to +-isSemigroup
                  ; identity            to +-identity
                  ; isMonoid            to +-isMonoid
                  ; inverse             to -‚Äøinverse
                  ; ‚Åª¬π-cong             to -‚Äøcong
                  ; isGroup             to +-isGroup
                  ; comm                to +-comm
                  ; isCommutativeMonoid to +-isCommutativeMonoid
                  )

  open IsMonoid *-isMonoid public
         using ()
         renaming ( assoc       to *-assoc
                  ; ‚àô-cong      to *-cong
                  ; isSemigroup to *-isSemigroup
                  ; identity    to *-identity
                  )
#+END_SRC

At first glance, one solution would be to package up these renamings into helper modules:
#+BEGIN_SRC agda2
-- Orginal notations
--------------------------------------------------------------------------------
record IsMonoid {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
                (‚àô : Op‚ÇÇ A) (Œµ : A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    isSemigroup : IsSemigroup ‚âà ‚àô
    identity    : Identity Œµ ‚àô

record IsCommutativeMonoid {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
                           (_‚àô_ : Op‚ÇÇ A) (Œµ : A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    isSemigroup : IsSemigroup ‚âà _‚àô_
    identityÀ°   : LeftIdentity Œµ _‚àô_
    comm        : Commutative _‚àô_

    ‚ãÆ
  isMonoid : IsMonoid ‚âà _‚àô_ Œµ
  isMonoid = record { ‚ãØ }

-- Renaming helpers
--------------------------------------------------------------------------------
module AdditiveIsMonoid {a ‚Ñì} {A : Set a} {‚âà : Rel A ‚Ñì}
               {_‚àô_ : Op‚ÇÇ A} {Œµ : A} (+-isMonoid : IsMonoid ‚âà _‚àô_ Œµ)  where

   open IsMonoid +-isMonoid public
         renaming ( assoc       to +-assoc
                  ; ‚àô-cong      to +-cong
                  ; isSemigroup to +-isSemigroup
                  ; identity    to +-identity
                  )

module AdditiveIsCommutativeMonoid {a ‚Ñì} {A : Set a} {‚âà : Rel A ‚Ñì}
               {_‚àô_ : Op‚ÇÇ A} {Œµ : A} (+-isCommutativeMonoid : IsMonoid ‚âà _‚àô_ Œµ)  where

   open AdditiveIsMonoid (CommutativeMonoid.isMonoid +-isCommutativeMonoid) public
   open IsCommutativeMonoid +-isCommutativeMonoid public using ()
      renaming ( comm to +-comm
               ; isMonoid to +-isMonoid)
#+END_SRC
However, one then needs to make similar modules for /additive notation/ for
~IsAbelianGroup, IsRing, IsCommutativeRing, ‚Ä¶~. Moreover, this still invites
repetition: Additional notations, as used in ~IsSemiring~, would require
additional helper modules.
#+BEGIN_SRC agda2
module MultiplicativeIsMonoid {a ‚Ñì} {A : Set a} {‚âà : Rel A ‚Ñì}
               {_‚àô_ : Op‚ÇÇ A} {Œµ : A} (*-isMonoid : IsMonoid ‚âà _‚àô_ Œµ)  where

   open IsMonoid *-isMonoid public
         renaming ( assoc       to *-assoc
                  ; ‚àô-cong      to *-cong
                  ; isSemigroup to *-isSemigroup
                  ; identity    to *-identity
                  )
#+END_SRC

Unless carefully organised, such notational modules would bloat the standard
library, resulting in difficulty when navigating the library. As it stands
however, the new algebraic structures appear large and complex due to the
‚Äúrenaming hell‚Äù encountered to provide the expected conventional notation.

*** Renaming Problems from the RATH-Agda Library

The impressive [[http://relmics.mcmaster.ca/RATH-Agda/RATH-Agda-2.2.pdf][Relational Algebraic Theories in Agda]] library takes a disciplined
approach: Copy-paste notational modules, possibly using a find-replace mechanism
to vary the notation. The use of a find-replace mechanism leads to consistent naming
across different notations.

#+caption: Relation.Binary.Setoid.Utils
#+begin_quote
For contexts where calculation in different setoids is necessary, we provide
‚Äúdecorated‚Äù versions of the ~Setoid‚Ä≤~ and ~SetoidCalc~ interfaces:
#+end_quote
#+BEGIN_SRC agda2
module SetoidA {i j : Level} (S : Setoid i j) = Setoid‚Ä≤ S renaming
    ( ‚Ñì to ‚ÑìA ; Carrier to A‚ÇÄ ; _‚âà_ to _‚âàA_ ; ‚âà-isEquivalence to ‚âàA-isEquivalence
    ; ‚âà-isPreorder to ‚âàA-isPreorder ; ‚âà-preorder to ‚âàA-preorder
    ; ‚âà-indexedSetoid to ‚âàA-indexedSetoid
    ; ‚âà-refl to ‚âàA-refl ; ‚âà-reflexive to ‚âàA-reflexive ; ‚âà-sym to ‚âàA-sym
    ; ‚âà-trans to ‚âàA-trans ; ‚âà-trans‚ÇÅ to ‚âàA-trans‚ÇÅ ; ‚âà-trans‚ÇÇ to ‚âàA-trans‚ÇÇ
    ; _‚ü®‚âà‚âà‚ü©_ to _‚ü®‚âàA‚âà‚ü©_ ; _‚ü®‚âà‚âàÀò‚ü©_ to _‚ü®‚âàA‚âàÀò‚ü©_ ; _‚ü®‚âàÀò‚âà‚ü©_ to _‚ü®‚âàAÀò‚âà‚ü©_ ; _‚ü®‚âàÀò‚âàÀò‚ü©_ to _‚ü®‚âàAÀò‚âàÀò‚ü©_
    ; _‚ü®‚â°‚âà‚ü©_ to _‚ü®‚â°‚âàA‚ü©_ ; _‚ü®‚â°‚âàÀò‚ü©_ to _‚ü®‚â°‚âàAÀò‚ü©_ ; _‚ü®‚â°Àò‚âà‚ü©_ to _‚ü®‚â°Àò‚âàA‚ü©_ ; _‚ü®‚â°Àò‚âàÀò‚ü©_ to _‚ü®‚â°Àò‚âàAÀò‚ü©_
    ; _‚ü®‚âà‚â°‚ü©_ to _‚ü®‚âàA‚â°‚ü©_ ; _‚ü®‚âà‚â°Àò‚ü©_ to _‚ü®‚âàA‚â°Àò‚ü©_ ; _‚ü®‚âàÀò‚â°‚ü©_ to _‚ü®‚âàAÀò‚â°‚ü©_ ; _‚ü®‚âàÀò‚â°Àò‚ü©_ to _‚ü®‚âàAÀò‚â°Àò‚ü©_
    )

module SetoidB {i j : Level} (S : Setoid i j) = Setoid‚Ä≤ S renaming
    ( ‚Ñì to ‚ÑìB ; Carrier to B‚ÇÄ ; _‚âà_ to _‚âàB_ ; ‚âà-isEquivalence to ‚âàB-isEquivalence
    ; ‚âà-isPreorder to ‚âàB-isPreorder ; ‚âà-preorder to ‚âàB-preorder
    ; ‚âà-indexedSetoid to ‚âàB-indexedSetoid
    ; ‚âà-refl to ‚âàB-refl ; ‚âà-reflexive to ‚âàB-reflexive ; ‚âà-sym to ‚âàB-sym
    ; ‚âà-trans to ‚âàB-trans ; ‚âà-trans‚ÇÅ to ‚âàB-trans‚ÇÅ ; ‚âà-trans‚ÇÇ to ‚âàB-trans‚ÇÇ
    ; _‚ü®‚âà‚âà‚ü©_ to _‚ü®‚âàB‚âà‚ü©_ ; _‚ü®‚âà‚âàÀò‚ü©_ to _‚ü®‚âàB‚âàÀò‚ü©_ ; _‚ü®‚âàÀò‚âà‚ü©_ to _‚ü®‚âàBÀò‚âà‚ü©_ ; _‚ü®‚âàÀò‚âàÀò‚ü©_ to _‚ü®‚âàBÀò‚âàÀò‚ü©_
    ; _‚ü®‚â°‚âà‚ü©_ to _‚ü®‚â°‚âàB‚ü©_ ; _‚ü®‚â°‚âàÀò‚ü©_ to _‚ü®‚â°‚âàBÀò‚ü©_ ; _‚ü®‚â°Àò‚âà‚ü©_ to _‚ü®‚â°Àò‚âàB‚ü©_ ; _‚ü®‚â°Àò‚âàÀò‚ü©_ to _‚ü®‚â°Àò‚âàBÀò‚ü©_
    ; _‚ü®‚âà‚â°‚ü©_ to _‚ü®‚âàB‚â°‚ü©_ ; _‚ü®‚âà‚â°Àò‚ü©_ to _‚ü®‚âàB‚â°Àò‚ü©_ ; _‚ü®‚âàÀò‚â°‚ü©_ to _‚ü®‚âàBÀò‚â°‚ü©_ ; _‚ü®‚âàÀò‚â°Àò‚ü©_ to _‚ü®‚âàBÀò‚â°Àò‚ü©_
    )

module SetoidC {i j : Level} (S : Setoid i j) = Setoid‚Ä≤ S renaming
    ( ‚Ñì to ‚ÑìC ; Carrier to C‚ÇÄ ; _‚âà_ to _‚âàC_ ; ‚âà-isEquivalence to ‚âàC-isEquivalence
    ; ‚âà-isPreorder to ‚âàC-isPreorder ; ‚âà-preorder to ‚âàC-preorder
    ; ‚âà-indexedSetoid to ‚âàC-indexedSetoid
    ; ‚âà-refl to ‚âàC-refl ; ‚âà-reflexive to ‚âàC-reflexive ; ‚âà-sym to ‚âàC-sym
    ; ‚âà-trans to ‚âàC-trans ; ‚âà-trans‚ÇÅ to ‚âàC-trans‚ÇÅ ; ‚âà-trans‚ÇÇ to ‚âàC-trans‚ÇÇ
    ; _‚ü®‚âà‚âà‚ü©_ to _‚ü®‚âàC‚âà‚ü©_ ; _‚ü®‚âà‚âàÀò‚ü©_ to _‚ü®‚âàC‚âàÀò‚ü©_ ; _‚ü®‚âàÀò‚âà‚ü©_ to _‚ü®‚âàCÀò‚âà‚ü©_ ; _‚ü®‚âàÀò‚âàÀò‚ü©_ to _‚ü®‚âàCÀò‚âàÀò‚ü©_
    ; _‚ü®‚â°‚âà‚ü©_ to _‚ü®‚â°‚âàC‚ü©_ ; _‚ü®‚â°‚âàÀò‚ü©_ to _‚ü®‚â°‚âàCÀò‚ü©_ ; _‚ü®‚â°Àò‚âà‚ü©_ to _‚ü®‚â°Àò‚âàC‚ü©_ ; _‚ü®‚â°Àò‚âàÀò‚ü©_ to _‚ü®‚â°Àò‚âàCÀò‚ü©_
    ; _‚ü®‚âà‚â°‚ü©_ to _‚ü®‚âàC‚â°‚ü©_ ; _‚ü®‚âà‚â°Àò‚ü©_ to _‚ü®‚âàC‚â°Àò‚ü©_ ; _‚ü®‚âàÀò‚â°‚ü©_ to _‚ü®‚âàCÀò‚â°‚ü©_ ; _‚ü®‚âàÀò‚â°Àò‚ü©_ to _‚ü®‚âàCÀò‚â°Àò‚ü©_
    )
#+END_SRC

This keeps going to cover the alphabet ~SetoidD, SetoidE, SetoidF, ‚Ä¶, SetoidZ~
then we shift to subscripted versions ~Setoid‚ÇÄ, Setoid‚ÇÅ, ‚Ä¶, Setoid‚ÇÑ~.

Next, RATH-Agda shifts to the need to calculate with setoids:
#+BEGIN_SRC agda2
module SetoidCalcA {i j : Level} (S : Setoid i j) where
  open SetoidA S public
  open SetoidCalc S public renaming
    ( _‚ñ° to _‚ñ°A
    ; _‚âà‚ü®_‚ü©_ to _‚âàA‚ü®_‚ü©_
    ; _‚âàÀò‚ü®_‚ü©_ to _‚âàAÀò‚ü®_‚ü©_
    ; _‚âà‚â°‚ü®_‚ü©_ to _‚âàA‚â°‚ü®_‚ü©_
    ; _‚âà‚ü®‚ü©_ to _‚âàA‚ü®‚ü©_
    ; _‚âà‚â°Àò‚ü®_‚ü©_ to _‚âàA‚â°Àò‚ü®_‚ü©_
    ; ‚âà-begin_ to ‚âàA-begin_
    )
module SetoidCalcB {i j : Level} (S : Setoid i j) where
  open SetoidB S public
  open SetoidCalc S public renaming
    ( _‚ñ° to _‚ñ°B
    ; _‚âà‚ü®_‚ü©_ to _‚âàB‚ü®_‚ü©_
    ; _‚âàÀò‚ü®_‚ü©_ to _‚âàBÀò‚ü®_‚ü©_
    ; _‚âà‚â°‚ü®_‚ü©_ to _‚âàB‚â°‚ü®_‚ü©_
    ; _‚âà‚ü®‚ü©_ to _‚âàB‚ü®‚ü©_
    ; _‚âà‚â°Àò‚ü®_‚ü©_ to _‚âàB‚â°Àò‚ü®_‚ü©_
    ; ‚âà-begin_ to ‚âàB-begin_
    )
module SetoidCalcC {i j : Level} (S : Setoid i j) where
  open SetoidC S public
  open SetoidCalc S public renaming
    ( _‚ñ° to _‚ñ°C
    ; _‚âà‚ü®_‚ü©_ to _‚âàC‚ü®_‚ü©_
    ; _‚âàÀò‚ü®_‚ü©_ to _‚âàCÀò‚ü®_‚ü©_
    ; _‚âà‚â°‚ü®_‚ü©_ to _‚âàC‚â°‚ü®_‚ü©_
    ; _‚âà‚ü®‚ü©_ to _‚âàC‚ü®‚ü©_
    ; _‚âà‚â°Àò‚ü®_‚ü©_ to _‚âàC‚â°Àò‚ü®_‚ü©_
    ; ‚âà-begin_ to ‚âàC-begin_
    )
#+END_SRC
This keeps going to cover the alphabet ~SetoidCalcD, SetoidCalcE, SetoidCalcF, ‚Ä¶, SetoidCalcZ~
then we shift to subscripted versions ~SetoidCalc‚ÇÄ, SetoidCalc‚ÇÅ, ‚Ä¶, SetoidCalc‚ÇÑ~.
If we ever have more than 4 setoids in hand, or prefer other decorations, then
we would need to produce similar helper modules.
| Each ~Setoidùí≥ùí≥ùí≥~ takes 10 lines, for a total of at-least 600 lines! |

Indeed, such renamings bloat the library, but, unlike the Standard Library, they
allow new records to be declared easily ---‚Äúrenaming hell‚Äù has been deferred
from the user to the library designer. However, later on, in ~Categoric.CompOp~,
we see the variations ~LocalEdgeSetoidùíü~ and ~LocalSetoidCalcùíü~ where decoration
~ùíü~ ranges over ~‚ÇÄ, ‚ÇÅ, ‚ÇÇ, ‚ÇÉ, ‚ÇÑ, R~. The inconsistency in not providing the other
decorations used for ~Setoidùìì~ earlier is understandable: These take time to
write and maintain.

Various similar decorations can be found in RATH, such as for ~Semigroupoidùíü~ in
~Categoric.Semigroupoid~.

*** Renaming Problems from the Agda-categories Library

With RATH-Agda's focus on notational modules at one end of the spectrum, and the
Standard Library's casual do-as-needed in the middle, it is inevitable that
there are other equally popular libraries but at the other end of the spectrum.
The [[https://github.com/agda/agda-categories][Agda-categories]] library seemingly ignored the need for meaningful names
altogether! Below are a few notable instances.

+ Functors have fields named ~F‚ÇÄ, F‚ÇÅ, F-resp-‚âà, ‚Ä¶~.
  - This could be considered reasonable even if one has a functor named ~G~.
  - This [[https://github.com/agda/agda-categories/blob/master/src/Categories/Category/Product.agda][leads to expressions]] such as ~< F.F‚ÇÄ , G.F‚ÇÄ >~.
  - Incidentally, and somewhat inconsistently, a ~Pseudofunctor~ has fields ~P‚ÇÄ,
    P‚ÇÅ, P-homomophism~ ---where the latter is documented /P preserves ‚âÉ/.

  On the opposite extreme, RATH-Agda's importance on naming has it functor record
  having fields named ~obj, mor, mor-cong~ instead of ~F‚ÇÄ, F‚ÇÅ, F-resp-‚âà~
  ---which refer to a functor's ‚Äúobj‚Äùect map, ‚Äúmor‚Äùphism map, and the fact that the
  ‚Äúmor‚Äùphism map is a ‚Äúcong‚Äùruence.

+ Such lack of concern for naming might be acceptable for well-known concepts
  such as functors, where some communities use ~F·µ¢~ to denote the object/0 or
  morphism/1 operations. However, considering [[https://github.com/agda/agda-categories/blob/master/src/Categories/Category/SubCategory.agda][subcategories]] one is sees field
  names ~U, R, Rid, _‚àòR_~ which are wholly unhelpful. Instead, more meaningful
  names such as ~embed, keep, id-kept, keep-resp-‚àò~ could have been used.

+ The ~Iso, Inverse,~ and ~NaturalIsomorphism~ records have fields ~to / from, f
  / f‚Åª¬π,~ and ~~F‚áíG / F‚áêG~, respectively.

  #  ( ~Categories.Category~ )

  Even though some of these build on one another, with Agda's namespacing
  features, all ‚Äúforward‚Äù and ‚Äúbackward‚Äù morphism fields could have been named,
  say, ~to~ and ~from~. The naming may not have propagated from ~Iso~ to other
  records possibly due to the low priority for names.

  From a usability perspective, projections like ~f~ are reminiscent of the OCaml
  community and may be more acceptable there. Since Agda is more likely to attract
  Haskell programmers than OCaml ones, such a particular projection seems completely
  our of place. Likewise, the field name ~F‚áíG~ seems only appropriate if the
  functors involved happen to be named ~F~ and ~G~.

  These unexpected deviations are not too surprising since the Agda-categories
  library seems to give names no priority at all. Field projections are treated
  little more than classic array indexing with numbers.


By largely avoiding renaming, Agda-categories has no ‚Äúrenaming hell‚Äù anywhere at
the heavy price of being difficult to read: Any attempt to read code requires
one to ‚Äúsquint away‚Äù the numerous projections to ‚Äúsee‚Äù the concepts of
relevance. Consider the [[https://github.com/agda/agda-categories/blob/master/src/Categories/Yoneda.agda][following excerpt]].
#+BEGIN_SRC agda
helper : ‚àÄ {F : Functor (Category.op C) (Setoids ‚Ñì e)}
                     {A B : Obj} (f : B ‚áí A)
                     (Œ≤ Œ≥ : NaturalTransformation Hom[ C ][-, A ] F) ‚Üí
                   Setoid._‚âà_ (F‚ÇÄ Nat[Hom[C][-,c],F] (F , A)) Œ≤ Œ≥ ‚Üí
                   Setoid._‚âà_ (F‚ÇÄ F B) (Œ∑ Œ≤ B ‚ü®$‚ü© f ‚àò id) (F‚ÇÅ F f ‚ü®$‚ü© (Œ∑ Œ≥ A ‚ü®$‚ü© id))
          helper {F} {A} {B} f Œ≤ Œ≥ Œ≤‚âàŒ≥ = S.begin
            Œ∑ Œ≤ B ‚ü®$‚ü© f ‚àò id          S.‚âà‚ü® cong (Œ∑ Œ≤ B) (id-comm ‚óã (‚ü∫ identityÀ°)) ‚ü©
            Œ∑ Œ≤ B ‚ü®$‚ü© id ‚àò id ‚àò f     S.‚âà‚ü® commute Œ≤ f CE.refl ‚ü©
            F‚ÇÅ F f ‚ü®$‚ü© (Œ∑ Œ≤ A ‚ü®$‚ü© id) S.‚âà‚ü® cong (F‚ÇÅ F f) (Œ≤‚âàŒ≥ CE.refl) ‚ü©
            F‚ÇÅ F f ‚ü®$‚ü© (Œ∑ Œ≥ A ‚ü®$‚ü© id) S.‚àé
            where module S where
                    open Setoid (F‚ÇÄ F B) public
                    open SetoidR (F‚ÇÄ F B) public
#+END_SRC

Here are a few downsides of not renaming:

1. The type of the function is difficult to comprehend; though it need not be.
   - Take ~_‚âà‚ÇÄ_ = Setoid._‚âà_ (F‚ÇÄ Nat[Hom[C][-,c],F] (F , A))~, and
   - Take ~_‚âà‚ÇÅ_ = Setoid._‚âà_ (F‚ÇÄ F B)~,
   - Then the type says: If ~Œ≤ ‚âà‚ÇÄ Œ≥~ then
     ~Œ∑ Œ≤ B ‚ü®$‚ü© f ‚àò id ‚âà‚ÇÅ F‚ÇÅ F f ‚ü®$‚ü© (Œ∑ Œ≥ A ‚ü®$‚ü© id)~
     ---a naturality condition!

2. The short proof is difficult to read!
   - The repeated terms such as ~Œ∑ Œ≤ B~ and ~Œ∑ Œ≤ A~ could have been renamed with
     mnemoic-names such as ~Œ∑‚ÇÅ, Œ∑‚ÇÇ~ or ~Œ∑‚Çõ, Œ∑‚Çú~ for ‚Äòs‚Äôource/1 and ‚Äòt‚Äôarget/2.

Recall that functors ~F~ have projections ~F·µ¢~, so the ‚Äúmor‚Äùphism map on a given
morphism ~f~ becomes ~F‚ÇÅ F f~, as in the excerpt above; however, using
RATH-Agda's naming it would have been ~mor F f~.

Since names are given a lower priority, one no longer needs to perform renaming.
Instead, one is content with projections. The downside is now there are too many
projections, leaving code difficult to comprehend. Moreover, this leads to
inconsistent renaming.

** From ~Isùìß~ to ~ùìß~ ---Packing away components

 The distributivity axiom from earlier required an unbundled structure /after/ a
 completely bundled structure was initially presented. Usual structure are rather
 large and have libraries built around them, so building and using an alternate form
 is not practical. However, multiple forms are usually desirable.

 To accommodate the need for both forms of structure, Agda's Standard Library
 begins with a [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Structures.html#1][type-level predicate]] such as ~IsSemigroup~ below, then [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.html#1][packs that up
 into a record]]. Here is an instance, along with comments from the library.
 #+caption: From the [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.html#601][Agda Standard Library on Algebra]]
 #+BEGIN_SRC agda2
-- Some algebraic structures (not packed up with sets, operations, etc.
record IsSemigroup {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
                   (‚àô : Op‚ÇÇ A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    isEquivalence : IsEquivalence ‚âà
    assoc         : Associative ‚àô
    ‚àô-cong        : ‚àô Preserves‚ÇÇ ‚âà ‚ü∂ ‚âà ‚ü∂ ‚âà

-- Definitions of algebraic structures like monoids and rings (packed in records
-- together with sets, operations, etc.)
record Semigroup c ‚Ñì : Set (suc (c ‚äî ‚Ñì)) where
  infixl 7 _‚àô_
  infix  4 _‚âà_
  field
    Carrier     : Set c
    _‚âà_         : Rel Carrier ‚Ñì
    _‚àô_         : Op‚ÇÇ Carrier
    isSemigroup : IsSemigroup _‚âà_ _‚àô_
 #+END_SRC

 If we refer to the former as ~IsX~ and the latter as ~X~, then we can see similar
 instances in the standard library for ~X~ being: ~Monoid, Group, AbelianGroup,
 CommutativeMonoid,~ ~SemigroupWithoutOne, NearSemiring, Semiring,
 CommutativeSemiringWithoutOne, CommutativeSemiring, CommutativeRing~.

 It thus seems that to present an idea ~X~, we require the same amount of space
 to present it unpacked or packed, and so doing both duplicates the process
 and only hints at the underlying principle: From ~IsX~ we pack away the carriers
 and function symbols to ~X~. The converse approach, starting from ~X~ and going to ~IsX~
 is not practical, as it leads to numerous unhelpful reflexivity proofs.

 #+begin_quote
 *Predicate Design Pattern:* Present a concept ùìß first as a predicate ~Isùìß~ on types
 and function symbols, then as a type ~ùí≥~ consisting of types, function symbols,
 and a proof that together they satisfy the ~Isùí≥~ predicate.

 *Œ£ Padding Anti-Pattern*: Starting from a bundled up type ~ùí≥~ consisting of types,
 function symbols, and how they interact, one may form the type ~Œ£ X ‚à∂ ùí≥ ‚Ä¢ ùí≥.f X ‚â°
 ùíá~ to specialise the feature ~ùí≥.f~ to the particular choice ~ùíá~. However, nearly all
 uses of this type will be of the form ~(X , refl)~ where the proof is unhelpful
 noise.
 #+end_quote

 Since the standard library uses the predicate pattern, ~Isùí≥~, which requires all
 sets and function symbols, the Œ£-padding anti-pattern becomes a necessary evil.
 Instead, it would be preferable to have the family ~ùí≥·µ¢~ which is the same as ~Isùí≥~
 but only takes ~ùíæ~-many elements ---c.f., ~Magma‚ÇÄ~ and ~Magma‚ÇÅ~ above. However,
 writing these variations and functions to move between them is not only tedious
 but also error prone. Later on, also demonstrated in [GPCE19], we shall show
 how the bundled form ~ùí≥~ acts as /the/ definition, with other forms being
 derived-as-needed.

 Incidentally, the particular choice ~ùí≥‚ÇÅ~, a predicate on one carrier, deserves
 special attention. In Haskell, instances of such a type are generally known as
 /typeclass instances/ and ~ùí≥‚ÇÅ~ is known as a /typeclass/. In Agda, we may mark such
 implementations for instance search using the keyword ~instance~.

 #+begin_quote
 *Typeclass Design Pattern*: Present a concept ùí≥ as a unary predicate ~ùìß‚ÇÅ~ that
 associates functions and properties with a given type. Then, mark all
 implementations with ~instance~ so that arbitrary ~ùí≥~-terms may be written without
 having to specify the particular instance.

 When there are multiple instance of an ùí≥-structure on a particular type, only
 one of them may be marked for instance search in a given scope.
 #+end_quote

** Redundancy, Derived Features, and Feature Exclusion

 A tenet of software development is not to over-engineer solutions; e.g., we need
 a notion of untyped composition, and so use ~Monoid~. However, at a later stage,
 we may realise that units are inappropriate and so we need to drop them to
 obtain the weaker notion of ~Semigroup~ ---for instance, if we wish to module
 finite functions as hashmaps, we need to omit the identity functions since they
 may have infinite domains; and we cannot simply enforce a convention, say, to
 treat empty hashmaps as the identities since then we would lose the empty
 functions. Incidentally, this example, among others, led to dropping the
 identity features from Categories to obtain so-called Semigroupoids.

 In weaker languages, we could continue to use the monoid interface at the cost
 of ‚Äúthrowing an exception‚Äù whenever the identity is used. However, this breaks
 the Interface Segregation Principle: Users should not be forced to bother with
 features they are not interested in. A prototypical scenario is exposing an
 expressive interface, possibly with redundancies, to users, but providing a
 minimal self-contained counterpart by dropping some features for the sake of
 efficiency or to act as a ‚Äúsmart constructor‚Äù that takes the least amount of
 data to reconstruct the rich interface.

 For example, in the Agda-categories library one finds concepts expressive
 interfaces, with redundant features, named ~ùí≥~, along with their minimal
 self-contained versions, named ~ùí≥Helper~. In particular, the [[https://github.com/agda/agda-categories/blob/master/src/Categories/Category/Core.agda][Category]] type and the
 [[https://github.com/agda/agda-categories/blob/master/src/Categories/NaturalTransformation/NaturalIsomorphism.agda][natural isomorphism]] type are instances of such a pattern. The redundant features
 are there to make the lives of users easier; e.g., Agda-categories states the following.
 #+begin_quote
 We add a symmetric proof of associativity so that the opposite category of the
 opposite category is definitionally equal to the original category.
 #+end_quote
 To underscore the intent, we present below a minimal setup needed to express the
 issue. The semigroup definition contains a redundant associativity axiom
 ---which can be obtained from the first one by applying symmetry of equality.
 This is done purposefully so that the ‚Äúopposite, or dual, transformer‚Äù ~_Àò~ is
 self-inverse on-the-nose; i.e., definitionally rather than propositionally.
 Definitionally equality does not need to be ‚Äòinvoked‚Äô, it is used silently when
 needed, thereby making the redundant setup worth it.
 #+begin_src agda2 :tangle op-involutive-on-the-nose.agda :prologue module op-involutive-on-the-nose where \nopen import Notation\n
record Semigroup : Set‚ÇÅ where
  constructor ùíÆ
  field
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    assoc ≥ : ‚àÄ {x y z} ‚Üí  (x ‚®æ y) ‚®æ z  ‚â°  x ‚®æ (y ‚®æ z)
    assocÀ° : ‚àÄ {x y z} ‚Üí  x ‚®æ (y ‚®æ z)  ‚â°  (x ‚®æ y) ‚®æ z

    -- Notice:  assocÀ° ‚âà sym assoc ≥

_Àò : Semigroup ‚Üí Semigroup
(ùíÆ Carrier _‚®æ_ assoc ≥ assocÀ°) Àò = ùíÆ Carrier (Œª b a ‚Üí a ‚®æ b)  assocÀ° assoc ≥

ÀòÀò‚âàid : ‚àÄ {S} ‚Üí (S Àò) Àò ‚â° S
ÀòÀò‚âàid = refl
 #+end_src

 #+begin_quote
 *On-the-nose Redundancy Design Pattern* [Agda-Categories]: Include redundant
 features if they allow certain common constructions to be definitional equal,
 thereby requiring no overhead to use such an equality. Then, provide a smart
 constructor so users are not forced to produce the redundant features manually.
 #+end_quote

 Incidentally, since this is not a library method, inconsitencies are bound to
 arise; in particular, in the ~ùí≥~ and ~ùí≥Helper~ naming scheme: The ~NaturalIsomorphism~
 type has ~NIHelper~ as its minimised version, and the type of [[https://github.com/agda/agda-categories/blob/master/src/Categories/Category/Monoidal/Symmetric.agda][symmetric monoidal
 categories]] is oddly called ~Symmetric‚Ä≤~ with its helper named ~Symmetric~. Such
 issues could be reduced, if not avoided, if library methods were used instead.

 It is interesting to note that duality forming operators, such as ~_Àò~ above, are
 a design pattern themselves. How? In the setting of algebraic structures, one
 picks an operation to have its arguments flipped, then systematically ‚Äòflips‚Äô
 all proof obligations via a user-provided symmetry operator. We shall return to
 this as a library method in a future section.

 # Since names are given a low priority, the brading operation is simply called ~B~!
 # A symbol closer to the standard model, inverses ~_‚Åª¬π~, such as ~_Àò~ may have been
 # more suggestive.

 Another example of purposefully keeping redundant features is for the sake of
 efficiency.
  #+begin_quote
 For division semi-allegories, even though right residuals, restricted residuals,
 and symmetric quotients all can be derived from left residuals, we still assume
 them all as primitive here, since this produces more readable goals, and also
 makes connecting to optimised implementations easier.

 ---RATH-Agda ¬ß15.13
  #+end_quote

 For instance, the above semigroup type could have been augmented with an
 ordering if we view ~_‚®æ_~ as a meet-operation. Instead, we lift such a derived
 operation as a primitive field, in case the user has a better implementation.
  #+begin_src agda2 :tangle op-involutive-on-the-nose.agda
record Order (S : Semigroup) : Set‚ÇÅ where
  open Semigroup S public
  field
    _‚äë_    : Carrier ‚Üí Carrier ‚Üí Set
    ‚äë-def  : ‚àÄ {x y} ‚Üí (x ‚äë y) ‚â° (x ‚®æ y ‚â° x)

  {- Results about _‚®æ_ and _‚äë_ here ‚Ä¶ -}

defaultOrder : ‚àÄ S ‚Üí Order S
defaultOrder S = let open Semigroup S
                 in record { _‚äë_ = Œª x y ‚Üí x ‚®æ y ‚â° x ; ‚äë-def = refl }
  #+end_src

  #+begin_quote
 *Efficient Redundancy Design Pattern* [RATH-Agda, ¬ß17.1]: To enable efficient
 implementations, replace derived operators with additional fields for them and
 for the equalities that would otherwise be used as their definitions. Then,
 provide instances of these fields as derived operators, so that in the absence
 of more efficient implementations, these default implementations can be used
 with negligible penalty over a development that defines these operators as
 derived in the first place.
  #+end_quote

 # Also
 # which RATH-Agda does a number of times ---e.g., due to the converse
 # operator, not only are division operators are inter-definable but
 # symmetric-quotient congruence laws are derivable.

** Extensions

   In our previous discussion, we needed to drop features from ~Monoid~ to get
   ~Semigroup~. However, excluding the unit element from the monoid also required
   excluding the identity laws. More generally, all features reachable, via
   occurrence relationships, must be dropped when a particular feature is
   dropped. In some sense, a generated graph of features needs to be ‚Äúripped out‚Äù
   from the starting type, and the generated graph may be the whole type. As
   such, in general, we do not know if the resulting type even has any features.

   Instead, in an ideal world, it is preferable to begin with a minimal interface
   then /extend/ it with features as necessary. E.g., begin with ~Semigroup~
   then add orthogonal features until ~Monoid~ is reached. Extensions are also
   known by /subclassing/ or /inheritance/.

 #+BEGIN_SRC mermaid :file semigroup-to-monoid.png :theme default :background-color transparent  :tangle no :tangle no :exports results
graph LR                          %% A ‚ÄúL‚Äùeft to ‚ÄúR‚Äùight graph

Semigroup[<strong>Semigroup</strong><br>carrier <br> binary operation <br> associtivity law ]
PointedSemigroup[<strong>PointedSemigroup</strong><br>carrier <br> binary operation <br> <i>unit element</i> <br> associtivity law ]
LeftUnitalSemigroup[<strong>LeftUnitalSemigroup</strong><br>carrier <br> binary operation <br> unit element <br> <i>left identity law</i> <br> associtivity law ]
RightUnitalSemigroup[<strong>RightUnitalSemigroup</strong><br>carrier <br> binary operation <br> unit element <br> <i>right identity law</i> <br> associtivity law ]
Monoid[<strong>Monoid</strong><br>carrier <br> binary operation <br> unit element <br> <i>left identity law <br> right identity law</i> <br> associtivity law ]

Semigroup --> PointedSemigroup

PointedSemigroup --> LeftUnitalSemigroup
PointedSemigroup --> RightUnitalSemigroup

LeftUnitalSemigroup --> Monoid
RightUnitalSemigroup --> Monoid
 #+END_SRC

 #+RESULTS:
 [[file:semigroup-to-monoid.png]]

 #+begin_quote
 *Extension Design Pattern:* To extend a structure ~ùí≥~ by new features ~f‚ÇÄ, ‚Ä¶, f‚Çô~
 which may mention features of ~ùí≥~, make a new structure ~ùí¥~ with fields for ~ùí≥, f‚ÇÄ,
 ‚Ä¶, f‚Çô~. Then publicly open ~ùí≥~ in this new structure so that the features of ~ùí≥~ are
 visible directly from ~ùì®~ to all users.
 #+end_quote

 The libraries mentioned thus far generally implement extensions in this way.
 By way of example, here is how monoids could be built directly from semigroups in one step.
 #+begin_src agda2 :tangle semigroups_to_monoids.agda :prologue module list-is-not-vec where \nopen import Notation\n
record Semigroup : Set‚ÇÅ where
  field
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    assoc  : ‚àÄ {x y z} ‚Üí  (x ‚®æ y) ‚®æ z  ‚â°  x ‚®æ (y ‚®æ z)

record Monoid : Set‚ÇÅ where
  field
    semigroup : Semigroup

  open Semigroup semigroup public  {- (0) -}

  field
    Id      : Carrier
    leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x

open Monoid

neato : ‚àÄ {M} ‚Üí Carrier M ‚Üí Carrier M ‚Üí Carrier M
neato {M} = _‚®æ_ M    {- Possible due to (0) above -}
 #+end_src

 Notice how we accessed the binary operation ~_‚®æ_~ feature from ~Semigroup~ as if it
 were a native feature of ~Monoid~. Unfortunately, ~_‚®æ_~ is only superficially native
 to ~Monoid~ ---any actual instance, such as ~woah~ below, needs to define the binary
 operation in a ~Semigroup~ instance first.
 #+begin_src agda2 :tangle semigroups_to_monoids.agda
woah : Monoid
woah = record { semigroup = {!!} ; Id = {!!} ; leftId = {!!} ; rightId = {!!} }
 #+end_src

 While library designers may be content to build ~Monoid~ out of ~Semigroup~, users
 should not be forced to learn about how the hierarchy was built. Even worse,
 when the library designers decide to incorporate, say, ~LeftUnitalSemigroup~ then
 all users' code would break. Instead, it would be preferable to have a
 ‚Äòflattened‚Äô presentation for the users that ‚Äúdoes not leak out implementation
 details‚Äù. We shall return to this in a future section.

** Summary of Some Design Patterns in Dependently-Typed Programming
   :PROPERTIES:
   :CUSTOM_ID: design-patterns
   :END:

 simple setoid renaming and
 does much more elsewhere‚Äî,

 Below is a summary of the design patterns mentioned above, using monoids as the
 prototypical structure. Some patterns we did not cover, as they will be covered
 in future sections.

 #+caption: PL Research is about getting free stuff: From the left-most node, we can get a lot!
 # #+BEGIN_SRC mermaid  :file patterns.png :theme forest :background-color transparent
 #+BEGIN_SRC mermaid  :file patterns.png :theme forest :exports results
graph TD %% LR and TD are both also good!

%% A(<br><hr> Carrier : Set <br> _‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier <br> Id : Carrier)
A(<hr> carrier <br> binary operation <br> point <br> left identity law <br> right identity law <br> associtivity law)
B(carrier <br> binary operation <br> point <br><hr> left identity law <br> right identity law <br> associtivity law)
C(carrier <br><hr> binary operation <br> point <br> left identity law <br> right identity law <br> associtivity law)

D{<hr> <pre>Branch <br>Nil </pre>}               %% Using verbatim environment
E{Variables <br><hr> <pre>Embed <br>Branch <br>Nil </pre>} %% Using verbatim environment
F((<hr> &ensp;carrier <br> &ensp;binary operation <br> &ensp;point))

A-. Predicate  &ensp;<br> .->B
B-. Œ£ Padding  &ensp;<br>.->A
A-. Typeclass  &ensp;<br> .-> C
C-. Œ£ Padding &ensp;<br> .-> A

A-. Closed Termtype  &ensp;<br> .-> D
D-. Interpreter &ensp;<br> .-> A
A-. Open Termtype &ensp;<br> .-> E
E-. Interpreter  &ensp;<br> .-> C
E-. Setoid &ensp;<br> .-> A
A-. Signature &ensp;<br> .-> F
E-- Instance  &ensp;<br> --> F

A-. Renaming &ensp;<br> .-> R
R-. Renaming &ensp;<br> .-> A
R(<hr> universe of discourse <br> composition <br> unit <br> left unital <br> right unital <br> parenthesis shift)

A-- Theorem Proving &ensp;<br> -->A

E-- Simplifier  &ensp;<br> -->E
E-- Metaprogramming  &ensp;<br> -->E

UA> Universal <br> Algebra ]

A-. Œª Homomorphism &nbsp;<br> Œª Kernel &nbsp;<br> Œª Products &nbsp;<br> Œª FOL termtypes &nbsp;<br> Œª etc .-> UA
C-. Œª Products &nbsp;<br> Œª Substructure &nbsp;<br> Œª etc .-> UA
UA-. Œª Pushouts / Pullbacks &nbsp;<br> Œª Extensions / Exclusions &nbsp;<br> Œª Duality / Views &nbsp;<br> Œª etc .-> UA

subgraph  %% A subgraph environment places the legend in the top left, which is better than it being in the bottom somewhere.
Legend[<center>Legend</center>0. Parameters occur above the waist line <br> 1. Fields occur below the waist line <br> 2. Dashed lines are design patterns ]
end
 #+END_SRC
 #+RESULTS:
 [[file:patterns.png]]

 Remarks:

 0. It is important to note that the ~termtype~ constructions could also be
    co-inductive, thereby yielding possibly infinitely branching syntax-trees.

    - In the ‚Äúsimplify‚Äù pattern, one could use axioms as rewrite rules.

 1. It is more convenient to restrict a carrier or to form products along carriers using the typeclass version.

 2. As discussed earlier, the name /typeclass/ is justified not only by the fact
    that this is the shape used by typeclasses in Haskell and Coq, but also that
    instance search for such records is supported in Agda by using the ~instance~
    keyword.

 There are many more design patterns in dependently-typed programming. Since
 grouping mechanisms are our topic, we have only presented those involving
 organising data.

* COMMENT Introduction

   A fundamental argument for the use of module systems in the design of large
 programs is that the structure of the program is partitioned into coherent
 semantical units that are furnished with an interface belying the complexity of
 their implementations. A well-established example is the use of the humble
 record to ‚Äòbundle‚Äô up the extensional properties of an object; here one works
 with objects as if they were atomic, rather than considering the
 collection of their identifying properties.  Users of dependently-typed
 languages like Agda and Coq will argue strongly that the effective use of
 module systems is extremely important for subsequent program development, and
 even users of dynamically typed languages like Javascript will admit that, for
 example, namespace violations are an area of concern.  A fundamental aspect of
 =PackageFormer= is that the relationship between a grouping mechanism and its
 constituent structuring sub-grouping mechanisms is made explicit: One extracts
 grouping mechanisms from declarations involving existing grouping mechanisms.
 In contrast to type theory wherein a type is specified by characterising how
 its elements may be formed, our approach allows both the building-up of
 grouping mechanisms from their parts and, also, the ‚Äòtearing down‚Äô of parts of
 existing grouping mechanisms ---as is the case of dropping a property from a
 record type to obtain another record type, or of transforming a record type
 into an algebraic data type.  Depending on their nature, grouping
 specifications may either allow the automatic derivation of ‚Äòintroduction
 rules‚Äô wherein the teared-down grouping is transformed into the new grouping,
 or allow ‚Äòelimination rules‚Äô wherein the individual groupings that built-up the
 new grouping can be identified.  The semantics of a grouping specification
 is essentially the ‚Äòflattening‚Äô of properties that extensionally constitute it.
 Our work describes the necessary primitives that allow grouping declarations.

 The intention is not to provide a fixed set of general-purpose grouping
 combinators that are sufficient to encompass all the future needs of all
 programmers but to provide a small kerneal of ‚Äòmeta-primitives‚Äô whereby
 programmers may invent their own grouping mechanisms peculiar to their own
 problem domain.

* COMMENT Background: What's necessary to solve this problem?
   - What is needed to just understand this problem?
   - Agda
   - System F
   - Monads
   - Metaprogramming

   Maybe tackle this "as needed", rather than upfront.

* COMMENT Related works
** Who has worked on this problem and where have they gotten?
** What are their shortcomings and advantages wrt to our approach?
** Shortcomings of our approach.
** Missing features and next steps.
* COMMENT PackageFormer
** Why an editor extension? Why Lisp is reasonable?
** Utility of a protottype?
** Things learned from making a protottype?
     * Perhaps show the minimal code needed to get PF working; <= 300 lines?
     * Much more Lisp for implementing common grouping mechanisms; e.g., pushouts.
** How usable is it?
** What exotic notions of grouping mechanisms can be coded-up? Utilit!?
** [Disadvantages of PackageFormer?
** Comparision to other systems.

** TODO COMMENT Two
 Design patterns for theories become library methods! An interesting side-effect
 of having meta-primitives for packages is that traditional patterns for theories
 ‚Äîe.g., homomorphisms, syntax, interpretation functions‚Äî can now be codified as
 general re-usable methods.

** TODO One

 Think of a language that does not support currying and you need to have a
 function of 10 arguments that needs to support accepting any number of arguments
 less than 10, say for partial application. In such languages, one must utilise
 the builder design pattern, or quickly copy-paste the function 10 times,
 altering it slightly each time. In general, if such a function definition
 requires N lines and M forms of the function are needed, then nearly N √ó M lines
 of code are written manually.

* COMMENT Contexts
** Why PackageFormer is not enough.
** Discuss Agda macros ---need to be self-contained.
** Motivate the need for a practical syntax.
** The reason it's a "do it yourself" system is that the semantics, >>=,
     can be tweaked easily for other forms of grouping besides Pi/Sigma ;-)
** Current limitations; e.g., lack of termination/positivity of certain constructs;
     or how termtype generation requires the ADT carrier to be the first element
     of the sequence/context, whereas a DAG interpretation of Contexts would be better?
** How does this compare with PF?
** What are the benefits of Context?
** Concrete problems its usage can solve.

* COMMENT Conclusion
** What we have done
** How it is useful to others, now.
* TODO COMMENT Our Approach [0%]
 --Remaining Tasks--
 + [ ] Plan of Attack
 + [ ] Implementation Details
 + [ ] Discussion of Results
 + [ ] Future Work

* TODO COMMENT Conclusions [0%]
   --Remaining Tasks--
 + [ ] ‚Ä¶
 + [ ] ‚Ä¶
 + [ ] ‚Ä¶
 + [ ] ‚Ä¶

* COMMENT What's a thesis? [0%]
  + [ ] The argument
    - What is it? Is it being argued clearly?
    - What's the plan?
  + [ ] An exposition of an orginal piece of research.
  + [ ] Distinctive contribution to the knowledge of the subject?
  + [ ] Evidence of orginality shown by the discovery of new facts?
  + [ ] How is the research best appreciated?
  + [ ] Ideas not mentioned in the thesis might as well not exist! Mention ideas.

* COMMENT Planning an Argument [0%]
  One sentence for each:
  + [ ] Introduction to the area of study.
  + [ ] The problem being tackled.
  + [ ] What the literature says about the problem.
    - A review of previous work shows you know the subject.
    - Besides being descriptive, the review needs to be critical.
    - Summary of the essential features of other work as it relates to this study.
  + [ ] How /I/ tackle this problem.
    - What is the philosophy of approach?
    - How were you systematic?
    - How is this linked back to the literature review?
  + [ ] How /I/ implement my solution.
    - Provide details so that others can follow what was done.
    - Justify the approach taken.
    - Does the software appear to work satisfcatorily?
  + [ ] The result.
    - Application of the approach reduces thousands of lines of code to
      human-readable specfications with an extensible system?
    - *Link back to how the solutions obtained relate to the questions posed?*
    - Accurately identitfy & summarise patterns or trends in the results.
    - Provide a critical analysis to show you know its limitations.
    - ‚ÄòFuture Work‚Äô to show what's missing.
    - Beware of specfulations not grounded in the results.
  + [ ] Conclusion ---repetition of the intro, but with reference to the detail.

  An outline acts as a workplan for which the entire research process is an
  exercise addressing each item. Each item becomes at least one section in
  the writeup.

  + [ ] Set out clearly what each chapter should say.

* COMMENT Say everything thrice [0%]

  It's not repetition, but linking and rationale.

  + [ ] In the thesis as a whole.
    - [ ] Introduction - What the thesis will say.
    - [ ] Body - Details of the work.
    - [ ] Conclusion - What the thesis said.

  + [ ] Within each chapter/section.
    - [ ] Signposting - What this section says.
    - [ ] Body - The details.
    - [ ] Summary - What this section has said.

  + [ ] Within each paragraph.
    - [ ] Each paragraph describes a single idea.
    - [ ] The first sentence introduces the idea ---linking it with the previous one.
    - [ ] The last sentence concludes the idea ---linking it with the next one.

  Signposts ensure it's clear what's being discussed and why
  ---from a writer's perspective, they help get the contents right.

* COMMENT The Examiner's View

  They'll read it in meetings, trains, or planes.
  They're busy and an initial scan may be:

  1. abstract - what's it about?
  2. bibliography - Does it cite the right stuff? Has it been published already?
  3. conclusions - What was achieved? Do I believe it?
  4. contents listing - Is everything there? Is the argument clear?

  Weakeness in these locations might suggest large corrections.

  + [ ] Run spellchecking everywhere.
  + [ ] Run the grammar checker as well.

* COMMENT What If I'm stuck?

  1. The task at hand may be too difficult.
  2. *Ask for help!*
  3. Change the plan.
  4. Cut away irrelevant bits.
