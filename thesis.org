#+title: Do-it-yourself Module Systems
# subtitle: We can change things later, but can't change it if there's nothing to change!
# subtitle: The Next 700 Module Systems
# +DESCRIPTION: Thesis for Musa Al-hassy; McMaster University 2020.
#+AUTHOR: [[mailto:alhassm@mcmaster.ca][Musa Al-hassy]]
#+EMAIL: alhassy@gmail.com
#+OPTIONS: d:nil
# toc:nil d:nil title:nil

#+PROPERTY: header-args :tangle no :comments link

# At the end of a section, explain why the section is there,
# and what the reader should take away from it.

# MA: LaTeX pads colons, :, with spacing.
# For inline typing annotations, use ghost colon ‚Äú\:‚Äù to avoid this issue.

#+macro: {{{newline}}} @@latex: \newline@@

* COMMENT Proposed Outline

1. Motivating the problem
   - Where has this problem been encountered in the wild?
   - What benefits would there be to solving this problem?
   - Mention ~1 * x + 0 = x~ problem from the ICFP20 paper.
     * Two monoidal units on the same carrier satisfy this law.

   Here is where the "STORY" is placed.

2. Background: What's necessary to solve this problem?
   - What is needed to just understand this problem?
   - Agda
   - System F
   - Monads
   - Metaprogramming

   Maybe tackle this "as needed", rather than upfront.

3. PackageFormer
   - Why an editor extension? Why Lisp is reasonable?
   - Utility of a protottype?
   - Things learned from making a protottype?
     * Perhaps show the minimal code needed to get PF working; <= 300 lines?
     * Much more Lisp for implementing common grouping mechanisms; e.g., pushouts.
   - How usable is it?
   - What exotic notions of grouping mechanisms can be coded-up? Utilit!?
   - [Disadvantages of PackageFormer?
   - Comparision to other systems.

4. Contexts
   - Why PackageFormer is not enough.
   - Discuss Agda macros ---need to be self-contained.
   - Motivate the need for a practical syntax.
   - The reason it's a "do it yourself" system is that the semantics, >>=,
     can be tweaked easily for other forms of grouping besides Pi/Sigma ;-)
   - Current limitations; e.g., lack of termination/positivity of certain constructs;
     or how termtype generation requires the ADT carrier to be the first element
     of the sequence/context, whereas a DAG interpretation of Contexts would be better?
   - How does this compare with PF?
   - What are the benefits of Context?
   - Concrete problems its usage can solve.

5. Related works
   - Who has worked on this problem and where have they gotten?
   - What are their shortcomings and advantages wrt to our approach?
   - Shortcomings of our approach.
   - Missing features and next steps.

6. Conclusion
   - What we have done
   - How it is useful to others, now.

* TODO Abstract
# Abstract and toc                                                   :ignore:
   :PROPERTIES:
   :CUSTOM_ID: abstract
   :END:

 # Use:  x vs.{{{null}}} ys
 # This informs LaTeX not to put the normal space necessary after a period.
 #
 #+MACRO: null  @@latex:\null{}@@

 #+begin_abstract

 Structuring-mechanisms, such as Java's ~package~ and Haskell's ~module~, are often
 afterthought secondary citizens whose primary purpose is to act as namespace
 delimiters, while relatively more effort is given to their abstraction
 encapsulation counterparts, e.g., Java's classes and Haskell's typeclasses. A
 /dependently-typed language/ (DTL) is a typed language where we can write /types/
 that depend on /terms/; thereby blurring conventional distinctions between a
 variety of concepts. In contrast, languages with non-dependent type systems
 tend to distinguish /external vs.{{{null}}} internal/ structuring-mechanisms
 ---as in Java's ~package~ for namespacing vs.{{{null}}} ~class~ for abstraction
 encapsulation--- with more dedicated attention and power for the internal case
 ---as it is expressible within the type theory.

 \vspace{1em}

 # cite:ocaml_website, maude_module_algebra, B_reuse
 To our knowledge, relatively few languages ---such as OCaml, Maude, and the B
 Method--- allow for the manipulation of external structuring-mechanisms as they
 do for internal ones. Sufficiently expressive type systems, such as those of
 dependently typed languages, allow for the internalisation of many concepts
 thereby conflating a number of traditional programming notions. Since DTLs
 permit types that depend on terms, the types may require non-trivial term
 calculation in order to be determined. Languages without such expressive type
 systems necessitate certain constraints on its constructs according to their
 intended usage. It is not clear whether such constraints have been brought to
 more expressive languages out of necessity or out of convention. Hence we
 propose a systematic exploration of the structuring-mechanism design space for
 dependently typed languages to understand /what are the module systems for DTLs?/

 \vspace{1em}

 First-class structuring-mechanisms have values and types of their own which
 need to be subject to manipulation by the user, so it is reasonable to consider
 manipulation combinators for them from the beginning. Such combinators would
 correspond to the many generic operations that one naturally wants to perform
 on structuring-mechanisms ---e.g., combining them, hiding components, renaming
 components--- some of which, in the external case, are impossible to perform in
 any DTL without resorting to third-party tools for pre-processing. Our aim is
 to provide a sound footing for systems of structuring-mechanisms so that
 structuring-mechanisms become another common feature in dependently typed
 languages. An important contribution of this work will be an implementation, as
 an extension of the current Agda implementation, of our module combinators
 ---which we hope to be accepted into a future release of Agda.

 If anything, our aim is practical ---to save developers from ad hoc copy-paste
 preprocessing hacks.
 #+begin_center org
 #+begin_small
 ---Source: https://github.com/alhassy/next-700-module-systems-proposal---
 #+end_small
 #+end_center
 #+end_abstract

#+begin_export latex
 \newpage
 \thispagestyle{empty}
 \tableofcontents
 \newpage
#+end_export

* Table of Contents                                    :Github:TOC_4ish:
- TODO [[#abstract][Abstract]]
- [[#introduction----the-thesis-story][Introduction ---The Thesis‚Äô ‚ÄúStory‚Äù]]
  - [[#a-language-has-many-tongues][A Language Has Many Tongues]]
  - [[#needless-distinctions-for-containers][Needless Distinctions for Containers]]
  - [[#novel-contributions][Novel Contributions]]
  - [[#overview-of-the-remaining-chapters][Overview of the Remaining Chapters]]
- [[#motivating-the-problem----examples-from-the-wild][Motivating the problem ---Examples from the Wild]]
  - [[#adding-zero-then-multiplying-by-one-results-in-a-type-error][Adding Zero then Multiplying by One Results in a Type Error]]
  - [[#renaming][Renaming]]
    - [[#renaming-problems-from-agdas-standard-library][Renaming Problems from Agda's Standard Library]]
    - [[#renaming-problems-from-the-rath-agda-library][Renaming Problems from the RATH-Agda Library]]
    - [[#renaming-problems-from-the-agda-categories-library][Renaming Problems from the Agda-categories Library]]
  - [[#from-isùìß-to-ùìß----packing-away-components][From ~Isùìß~ to ~ùìß~ ---Packing away components]]
  - [[#redundancy-derived-features-and-feature-exclusion][Redundancy, Derived Features, and Feature Exclusion]]
  - [[#extensions][Extensions]]
  - [[#summary-of-some-design-patterns-in-dependently-typed-programming][Summary of Some Design Patterns in Dependently-Typed Programming]]
- [[#current-approaches][Current Approaches]]
  - [[#expectations-of-module-systems][Expectations of Module Systems]]
  - [[#ad-hoc-grouping-mechanisms][Ad hoc Grouping Mechanisms]]
  - [[#theory-presentations-a-structuring-mechanism][Theory Presentations: A Structuring Mechanism]]
  - [[#json-is-foundational-from-prototypes-to-classes][‚ÄúJSON is Foundational‚Äù: From Prototypes to Classes]]
    - [[#prototypical-concepts][Prototypical Concepts]]
    - [[#1-prototype-example][‚ü®1‚ü© Prototype Example]]
    - [[#2-manual-constructor-functions][‚ü®2‚ü© Manual Constructor Functions]]
    - [[#3-constructor-functions-with-new][‚ü®3‚ü© Constructor Functions with ~new~]]
    - [[#4-class-notation][‚ü®4‚ü© ~class~ Notation]]
    - [[#conclusion][Conclusion]]
- [[#the-first-choice-what-is-the-target-setting][The First Choice: What is the target setting?]]
  - [[#what-setting-are-we-targeting-why][What setting are we targeting, why?]]
  - [[#existing-systems][Existing Systems]]
    - [[#agda---haskell-on-steroids][Agda --‚ÄúHaskell on steroids‚Äù]]
    - [[#coq----the-standard-proof-assistant][Coq ---‚ÄúThe standard proof assistant‚Äù]]
    - [[#idris----agda-with-tactics][Idris ---‚ÄúAgda with tactics‚Äù]]
    - [[#lean----proofs-for-metaprogramming][Lean ---‚ÄúProofs for metaprogramming‚Äù]]
    - [[#ats----dependent-types-for-systems-programming][ATS ---‚ÄúDependent types for systems programming‚Äù]]
    - [[#f----the-immature-adult][F^* ---‚Äúthe immature adult‚Äù]]
    - [[#beluga][Beluga]]
    - [[#notable-mentions][Notable Mentions*]]
    - [[#modules-in-coq-then-in-agda][Modules in Coq then in Agda]]
  - TODO [[#a-whirlwind-tour-of-agda][A Whirlwind Tour of Agda]]
    - [[#intro-2][Intro]]
    - [[#dependent-functions][Dependent Functions]]
    - [[#dependent-datatypes][Dependent Datatypes]]
    - [[#the-curry-howard-correspondence----propositions-as-types][The Curry-Howard Correspondence ---‚ÄúPropositions as Types‚Äù]]
    - [[#propositional-equality][Propositional Equality]]
    - [[#modules----namespace-management][Modules ---Namespace Management]]
      - [[#module-keywords][Module Keywords]]
    - [[#records][Records]]
    - [[#interacting-with-the-real-world----compilation-haskell-and-io][Interacting with the real world ---Compilation, Haskell, and IO]]
  - TODO [[#facets-of-structuring-mechanisms-an-agda-rendition][Facets of Structuring Mechanisms: An Agda Rendition]]
- TODO [[#solution-requirements][Solution Requirements]]
    - [[#missing-features][Missing Features]]
    - [[#desirable-features][Desirable Features]]
    - [[#one-item-checklist-for-a-candidate-solution][One-Item Checklist for a Candidate Solution]]
    - [[#preliminary-research][Preliminary Research]]
      - [[#first-observation-syntactic-similarity-for-containers][First Observation: Syntactic Similarity for Containers]]
      - [[#second-observation-computing-similarity-for-containers][Second Observation: Computing Similarity for Containers]]
      - [[#next-steps][Next Steps]]
- TODO [[#the-second-choice-packageformer][The Second Choice: PackageFormer]]
- TODO [[#the-third-choice-contexts][The Third Choice: Contexts]]
- [[#bib][Bib]]

* Introduction ---The Thesis‚Äô ‚ÄúStory‚Äù
  :PROPERTIES:
  :CUSTOM_ID: introduction
  :END:

** Intro                                                             :ignore:
In this chapter we aim to present the narrative that demonstrates the
distinction between what can currently be accomplished and what is desired when
working with composition of software units. We arrive at the observation that
packaging concepts differ only in their use ---for example, a typeclass and a
record are both sequences of declarations that only differ in that the former is
used for polymorphism with instance search whereas the latter is used as a
structure, grouping related items together. In turn, we are led to propose that
the various packaging concepts ought to have a uniform syntax. Moreover, since
records are a particular notion of packaging, the commitment to syntactic
similarity gives rise to a [[https://en.wikipedia.org/wiki/Homoiconicity][homoiconic]] nature to the host language.

Within this work we refer to a /simple type theory/ as a language that contains
typed lambda terms for terms and formuale; if in addition it contains lambda
terms whose types are indexed by values then we say it is a /dependently-typed
language/, or ‚ÄòDTL‚Äô for short ---depending on intent, value-indexed types could
be interpreted as /propositions/ and their terms as /proofs/. With the exception of
declarations and ephemeral notions, nearly everything in a DTL is a typed lambda
term. Just as Lisp's homoiconic nature blurs data and code leaving it not as a
language with primitives but rather a language with meta-primitives, so too the
lack of distinction between term and type lends itself to generic and uniform
concepts in DTLs thereby leaving no syntactic distinction between a constructive
proof and an algorithm.

The sections below explore our primary observation, which is discussed further
later on in Chapter ???. Section 1 demonstrates the variety of languages present in a
single system which are conflated in a DTL, section 2 discusses that such
conflation should by necessity apply to notions of packaging, and section 3
concludes with contributed work to ensure that happens.

** A Language Has Many Tongues

:Armkeh:
- In the introduction to section 1, you discuss "the variety of languages
  present in a single system". I feel this makes sense after reading "A coding
  language is actually many languages working together" below, but I found it
  confusing on first read. Maybe put languages in quotes and change system to
  language?
:End:

A programming language is actually many languages working together.

The most basic of imperative languages comes with a notion of ‚Äòstatement‚Äô that
is executed by the computer to alter ‚Äòstate‚Äô and a notion of ‚Äòvalue‚Äô that can be
assigned to memory locations. Statements may be sequenced or looped, whereas
values may be added or multiplied, for example. In general, the operations on
one linguistic category cannot be applied to the other. Unfortunately, a rigid
separation between the two sub-languages means that binary choice, for example,
conventionally invites two notations with identical semantics ---e.g.; in ~C~ one
writes ~if (cond) clause‚ÇÅ else clause‚ÇÇ~ for statements but must use the notation
~cond?term‚ÇÅ:term‚ÇÇ~ for values. Hence, there are value and statement languages.

Let us continue using the ~C~ language for our examples since it is so ubiquitous
and has influenced many languages. Such a choice has the benefit of referring to
a concrete language, rather than speaking in vague generalities. Besides Agda
---our language of choice--- we shall also refer to Haskell as a representative
of the functional side of programming. For example, in Haskell there is no
distinction between values and statements ---the latter being a particular
instance of the former--- and so it uses the same notation ~if_then_else_~ for
both. However, in practice, statements in Haskell are more pragmatically used as
a body of a ~do~ block for which the rules of conditionals and local variables
change ---hence, Haskell is not as uniform as it initially appears.

In ~C~, one declares an integer value by ~int x;~ but a value of a user-defined type
~T~ is declared ~struct T x;~ since, for simplicity, one may think of ~C~ having an
array named ~struct~ that contains the definitions of user-defined types ~T~ and the
notation ~struct T~ acts as an array access. Since this is a clunky notation, we
can provide an alias using the declaration ~typedef existing-name new-name;~.
Unfortunately, the existing name must necessarily be a type, such as ~struct T~ or
~int~, and cannot be an arbitrary term. One must use ~#define~ to produce term
aliases, which are handled by the ~C~ preprocessor, which also provides ~#include~
to import existing libraries. Hence, the type language is distinct from the
libraries language, which is part of the preprocessor language.

In contrast, Haskell has a pragma language for enabling certain features of the
compiler. Unlike ~C~, it has an interface language using ~typeclass~-es which
differs from its ~module~ language
cite:haskell_modules_formally,haskell_in_haskell,classic_haskell_genericity
since the former's names may be qualified by the names of the latter but not the
other way around. In turn, ~typeclass~ names may be used as constraints on
types, but not so with ~module~ names. It may be argued that this interface
language is part of the type language, but it is sufficiently different that it
could be thought of as its own language cite:modular_modules ---for
example, it comes with keywords ~class, instance, =>~ that can only appear in
special phrases. In addition, by default, variable declarations are the same for
built-in and user-defined types ---whereas ~C~ requires using ~typedef~ to mimic such
behaviour. However, Haskell distinguishes between term and type aliases. In
contrast, Agda treats aliasing as nothing more than a normal definition.

Certain application domains require high degrees of confidence in the
correctness of software. Such program verification settings may thus have an
additional specification language. For ~C~, perhaps the most popular is the ANSI C
Specification Language, ACSL cite:acsl. Besides the ~C~ types, ACSL
provides a type ~integer~ for specifications referring to unbounded integers as
well as numerous other notions and notations not part of the ~C~ language. Hence,
the specification language generally differs from the implementation language.
In contrast, Haskell's specifications are generally cite:programatica in
comments but its relative Agda allows specifications to occur at the type level.

# When working with ACSL, or JML, or SPARK
Whether programs actually meet their specifications ultimately requires a proof
language. For example, using the Frama-C tool cite:frama_c, ACSL
specifications can be supported by Isabelle or Coq proofs. In contrast, being
dependently-typed, Agda allows us to use the implementation language also as a
proof language ---/the only distinction is a shift in our perspective; the syntax
is the same./ Tools such as Idris and Coq come with ‚Äòtactics‚Äô ---algorithms which
one may invoke to produce proofs--- and may combine them using specific
operations that only act on tactics, whence yet another tongue.

Hence, even the simplest of programming languages contain the first three of the
following sub-languages ---types may be treated at runtime.

1. Expression language;
  #   (Expressions are syntax; values are semantics (most of the time...).)
2. Statement, or control flow, language;
3. Type language;
4. Specification language;
5. Proof language;
6. Module language;
7. Meta-programming languages ---including Coq tactics, C preprocessor, Haskell
   pragmas, Template Haskell's various quotation brackets ~[x| ... ]~, Idris
   directives, etc.

As briefly discussed, the first five languages telescope down into one uniform
language within the dependently-typed language Agda. So why not the module
language?

** Needless Distinctions for Containers

Computing is compositionality. Large mind-bending software developments are
formed by composing smaller, much more manageable, pieces together. How? In the
previous section we outlined a number of languages equipped with term
constructors, yet we did not indicate which were more primitive and which could
be derived.

The methods currently utilised are ad hoc, e.g., ‚Äúdump the contents of
packages into a new uÃàber package‚Äù. What about when the packages contain
conflicting names? ‚ÄúMake an uÃàber package with field names for each package's
contents‚Äù. What about viewing the new uÃàber package as a hierarchy of its
packages? ‚ÄúMake conversion methods between the two representations.‚Äù This
/should be/ mechanically derivable.

In general, there are special-purpose constructs specifically for working with
packages of ‚Äúusual‚Äù, or ‚Äúday-to-day‚Äù expression- or statement-level code. That
is, a language for working with containers whose contents live in another
language. This forces the users to think of these constructs as rare notions
that are seldom needed ---since they belong to an ephemeral language. They are
only useful when connecting packages together and otherwise need not be learned.

When working with mutually dependent modules, a simple workaround to cyclic
typechecking and loading is to create an interface file containing the
declarations that dependents require. To mitigate such error-prone duplication
of declarations, one may utilise literate programming cite:knuth_lp to tangle
the declarations to multiple files ---the actual parent module and the interface
module. This was the situation with Haskell before its recent module signature
mechanism cite:haskell_backpack. Being a purely functional language, it is
unsurprising that Haskell treats nested record field updates awkwardly: Where a
C-like language may have {{{newline}}} ~a.b.c := d~, Haskell requires ~a { b = b a
{c = d}}~ which necessarily has field names ~b, c~ polluting the global function
namespace as field projections. Since a record is a possibly deeply nested list
of declarations, it is trivial to flatten such a list to mechanically generate
the names ~‚Äúa-b-c‚Äù~ ---since the dot is reserved--- unfortunately this is not
possible in the core language thereby forcing users to employ ‚Äòlenses‚Äô
cite:lenses to generate such accessors by compile-time meta-programming. In the
setting of DTLs, records in the form of nested Œ£-types tend to have tremendously
poor performance ---in existing implementations of Coq cite:coq_cat_experiences
and Agda cite:perna, the culprit generally being projections. More generally,
what if we wanted to do something with packages that the host language does not
support? ‚ÄúUse a pre-processor, approximate packaging at a different language
level, or simply settle with what you have.‚Äù

*Main Observation* Packages, modules, theories, contexts, traits, typeclasses,
interfaces, what have you all boil down to dependent records at the end of the
day and /really differ/ in /how/ they are used or implemented. At the end of section
3 we demonstrate various distinct presentations of such notions of packaging
arising from a single package declaration.

   # After discussing existing approach and foundations, along with the minimal
   # requirements of a candidate solution, we then present our preliminary findings
   # in section 3. In particular,

** Novel Contributions

The thesis investigates the current state of the art of grouping mechanisms
{{{newline}}} ---sometimes referred to as modules or packages---, their
shortcomings, and implementing candidate solutions based upon a
dependently-typed language.

The introduction of first-class structuring mechanisms drastically changes the
situation by allowing the composition and manipulation of structuring mechanisms
within the language itself. Granted, languages providing combinators for
structuring mechanisms are not new; e.g., such notions already exist for Full
Maude cite:maude_module_algebra and B cite:B_reuse. The former is closer in
spirit to our work, but it differs from ours in that it is based on a /reflective
logic/: A logic where certain aspects of its metatheory can be faithfully
represented within the logic itself. Not only does the meta-theory of our effort
not involve reflection, but our distinctive attribute is that our aim is to form
powerful module system features for Dependently-Typed Languages (DTLs).

To the uninitiated, the shift to DTLs may not appear useful, or at least would
not differ much from existing approaches. We believe otherwise; indeed, in
programming and, more generally, in mathematics, there are three ---below: 1,
2a, 2b--- essentially equivalent perspectives to understanding a concept. Even
though they are equivalent, each perspective has prompted numerous programming
languages; as such, the equivalence does not make the selection of a perspective
irrelevant. The perspectives are as follows:

1. ‚ÄúPoint-wise‚Äù or ‚ÄúConstituent-Based‚Äù:
   A concept is understood by studying the concepts it is ‚Äúmade out of‚Äù.

   Common examples include:
   - A mathematical set is determined by the elements it contains.
   - A method is determined by the sequence of statements or expressions it is
     composed from.
   - A package ---such as a record or data declaration--- is determined by
     its components, which may be /thought of/ as fields or constructors.

   Object-oriented programming is based on the notion of inheritance which
   is founded on the ‚Äúhas a‚Äù and ‚Äúis a‚Äù relationships.

2. ‚ÄúPoint-free‚Äù or Relationship Based:
   A concept is understood by its relationship to other concepts in the domain
   of discourse.

   This approach comes into two sub-classifications:

   a. ‚ÄúFirst Class Citizen‚Äù or ‚ÄúConcept as Data‚Äù:
      The concept is treated as a static entity and is
      identified by applying operations /onto it/ in order to observe its nature.

      Common examples include:
      - A singleton set is a set whose cardinality is 1.
      - A method, in any coding language, is a value with the ability to act on
        other values of a particular type.
      - A renaming scheme to provide different names for a given package; more
        generally, applicative modules.

   b. ‚ÄúSecond Class Citizen‚Äù or ‚ÄúConcept as Method‚Äù:
      The concept is treated as a dynamic entity that
      is fed input stimuli and is understood by its emitted observational output.

      Common examples include:
      - A singleton set is a set for which there is a unique mapping to it from
        any other set. Input any set, obtain a map from it to the singleton set.
      - A method, in any coding language, is unique up to observational
        equality: Feed it arguments, check its behaviour. Realistically, one may
        want to also consider efficiency matters.
      - Generative modules as in the ~new~ keyword from object-oriented
        programming: Basic construction arguments are provided and a container
        object is produced.

   Observing such a sub-classification as distinct led to traditional structural
   programming languages, whereas blurring the distinction somewhat led to
   functional programming.

A simple selection of equivalent perspectives leads to wholly distinct paradigms
of thought. It is with this idea that we seek to implement first-class grouping
mechanisms in a dependently typed language ---theories have been proposed, on
paper, but as just discussed /actual design decisions may have challenging
impacts on the overall system/. Most importantly, this is a /requirements driven/
approach to coherent modularisation constructs in dependently typed languages.

Later on, we shall demonstrate that with a sufficiently expressive type system,
a number of traditional programming notions regarding ‚Äòpackaging up data‚Äô become
conflated ---in particular: Records and modules; which for the most part can all
be thought of as ‚Äúdependent products with named components‚Äù. Languages without
such expressive type systems necessitate certain constraints on these concepts
according to their intended usage ---e.g., no multiple inheritance for Java's
classes and only one instance for Haskell's typeclasses. It is not clear whether
such constraints have been brought to more expressive languages out of
necessity, convention, or convenience. Hence, in chapter cite:sec:three, we
perform a systematic exploration of the structuring-mechanism design space for
DTLs as a starting point for the design of an appropriate dependently-typed
module system (cite:sec:four). Along the way, we intend to provide a set of
atomic combinators that suffice as building blocks for generally desirable
features of grouping mechanisms, and moreover we intend to provide an analyses
of their interactions.

That is, we want to look at the edge cases of the design space for
structuring-mechanism /systems/, not only what is considered convenient or
conventional. Along the way, we will undoubtedly encounter useless or
non-feasible approaches. The systems we intend to consider would account for,
say, module structures with intrinsic types ---hence treating them as first
class concepts--- so that our examination is based on sound principles.

Understandably, some of the traditional constraints have to do with
implementations. For example, a Haskell typeclass is generally implemented as a
dictionary that can, for the most part, be inlined whereas a record is, in some
languages, a contiguous memory block: They can be identified in a DTL, but their
uses force different implementation methodologies and consequently they are
segregated under different names.

In summary, our research builds upon the existing state of module systems
cite:types_for_modules in a dependently-typed setting cite:dtls_give_modules
which is substantiated by developing practical and pragmatic tools. Our outcomes
include:
  1. A clean module system for DTLs that treats modules uniformly as any other value type.
  2. A variety of use-cases contrasting the resulting system with previous
     approaches.
  3. A module system that enables rather than inhibits efficiency.
  4. Demonstrate that module features traditionally handled using
     meta-programming can be brought to the data-value level; thereby not
     actually requiring the immense power and complexity of meta-programming.

Most importantly, we intend to implement our theory to obtain validation that it
‚Äòworks‚Äô.
** Overview of the Remaining Chapters

When a programming languages does not provide sufficiently expressive
primitives for a concept ---such as typeclass derivation cite:deriving_via---
users use some form of pre-processing to accomplish their tasks. In our case,
the insufficient primitives are regarding the creation and manipulation of
theories ---i.e., records, classes, packages, modules. In section 3, we will
demonstrate an undisciplined prototype that clarified the requirements of our
envisioned system. Even though the prototype appears to be metaprogramming,
the aim is not to force users interested in manipulating packages to worry
about the intricacies of representations; that is, the end goal is to avoid
metaprogramming ---which is an over-glorified form of preprocessing. The goal
is to /use a dependently-typed language to implement/ /the ‚Äòmissing‚Äô module
system features directly inside the language./

An important design decision is whether the resulting development is intended to
be reasoned about or not. If reasoning is important, then a language that better
supports it is ideal. That is why we are using Agda ---using a simpler language
and maintaining data invariants eventually becomes much harder cite:hasochism.

The remainder of the thesis is organised as follows.

:Outline:
+ Chapter II discusses what is expected of modularisation mechanisms,
  how they could be simulated, their interdefinability in Agda, and
  discuss a theoretical basis for modularisation.

+ Chapter III outlines missing features from current modularisation systems,
  their use cases, and provides a checklist for a candidate module
  system for DTLs.

+ Chapter IV discusses issues regarding implementation matter and the next steps
  in this research, along with a proposed timeline.

+ Chapter V outlines the intended outcomes of this research effort.
:End:

+ *¬ß 2 Examples from the wild*

   There are a host of repeated module patterns since modules are not a
   first-class construct. We look at three Agda libraries and extract ‚Äúmodule
   design patterns for dependently-typed programming‚Äù ---to the best of our
   knowledge, we are the first to formalise such design patterns for a
   dependently-typed language. Three other, non-module, design patterns are
   discussed in cite:10.1145/1411204.1411213.

   :RoughOutline:
   - E.g., IsX and X in Agda's standard library.
   - E.g., Hom, and universal algebra constructs, /for/ a paraticular theory.
   - E.g., common renaming patterns such as X_i or X' or etc for a theory X.
     - Cannot do this in Context due to Agda's limited support for fresh names.
     - Doable in PF.
   :End:

+ *¬ß 3 Metaprogramming Module Meta-primitives*

   To show that first-class modules are /reasonable/, we begin by providing
   PackageFormer cite:DBLP:conf/gpce/Al-hassyCK19: A specfication and
   manipulation language for modules, for Agda.
   To show that the approach is promising, we demonstrate how some problems
   from ¬ß2 can be tackled.

   # - Emacs Lisp is used as an implementation language since Emacs is the de facto
   #   editor for Agda.

   - The tool is a *practical* sandbox for exploring do-it-yourself grouping mechanisms:
     From pushouts and pullbacks, to forming homomorphism types over a given theory.

+ *¬ß 4 Module Meta-primitives as Library Methods*

   The ideas learned from making the powerful ~PackageFormer~ prototype lead us to
   form the less-powerful ~Context~ framework, which has the orthogonal benefit of
   being an Agda library rather than an external pre-processing tool.
   :RoughOutline:
   - E.g., a termtype arises by keeping only the fields that target the elected
     ADT carrier.
   - Ideas of :waist!
   :End:

   - Along the way, we solve the *unbundling problem*: Features of a structure may be
     exposed at the type level as-needed.

+ *¬ß 5 Conclusion: The lingua franca dream as reality*

   We compare the external ~PackageFormer~ tool with the ~Context~ library, and
   discuss how the latter has brought us closer to our original goal of having a
   single language for expressing values, types, and modules.

 It has been an exciting journey, I hope you enjoy the ride!

* Motivating the problem ---Examples from the Wild

** Introduction :ignore:
Tedium is for machines; interesting problems are for people.

In this section, we showcase a number of problems that occur in developing
libraries of code, with an eye to dependently-typed languages. We will refer
back to these real-world examples later on when developing our frameworks for
reducing their tedium and size.

Incidentally, the common solutions to the problems presented may be construed as
‚Äúdesign patterns for dependently-typed programming‚Äù. Design patterns are
algorithms yearning to be formalised. The power of the host language dictates
whether design patterns remain as informal directions to be implemented in an
ad-hoc basis then checked by other humans, or as a library methods that are
written once and may be freely applied by users. For instance, [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Morphism.html#1][Agda's
~Algebra.Morphism~ ‚Äúlibrary‚Äù]] presents an example(!) of the homomorphism design
pattern ---which shows how to form operation-preserving functions for algebraic
structures. The documentation reads: ~An example showing how a morphism type can
be defined~. An example, rather than a library method, is all that can be done
since the current implementation of Agda does not have the necessary
meta-programming utilities to construct new types in a practical way ---at
least, not out of the box.
# #
# + The procedure is essentially the same for other algebraic structures.
# + It takes time to do form these explicitly, even for the common structures.

** Adding Zero then Multiplying by One Results in a Type Error

   In theory, lists and vectors are the same ---where the latter are essentially
   lists indexed by their lengths. In practice, however, the additional length
   information stated up-front as an integral part of the data structure makes
   it not only easier to write programs that would otherwise by awkward or
   impossible in the latter case. For instance, below we demonstrate that the
   function ~head~, which extracts the first element of a non-empty list, not only
   has a difficult type to read, but also requires an auxiliary relation in
   order to be expressed. In contrast, the vector variant has a much simpler
   type with the non-emptiness proviso expressed by requesting a positive
   length.

#+BEGIN_SRC agda :tangle list-is-not-vec.agda :prologue "module list-is-not-vec where \nopen import Notation \n"
data List (A : Set) : Set where
  []  : List A
  _‚à∑_ : A ‚Üí List A ‚Üí List A

data Vec (A : Set) : ‚Ñï ‚Üí Set where
  []  : Vec A 0
  _‚à∑_ : ‚àÄ {n} ‚Üí A ‚Üí Vec A n ‚Üí Vec A (suc n)

data not-null {A : Set} : List A ‚Üí Set where
  indeed : ‚àÄ {x xs} ‚Üí not-null (x ‚à∑ xs)

head : ‚àÄ {A} ‚Üí Œ£ xs ‚à∂ List A ‚Ä¢ not-null xs ‚Üí A
head (x ‚à∑ xs , indeed) = x

head‚Ä≤ : ‚àÄ {A n} ‚Üí Vec A (suc n) ‚Üí A
head‚Ä≤ (x ‚à∑ xs) = x
#+END_SRC

This phenomena applies not only to derived concepts such as non-emptiness, but
also to explicit features of a datatype. A common scenario is when two instances
of an algebraic structure share the same carrier and thus it is reasonable to
connect the two somehow by a coherence axiom. Perhaps the most popular instance
of this scenario is in the setting of rings: There is an additive monoid ~(R, +,
0)~ and a multiplicative monoid ~(R, √ó, 0)~ on the same underlying set, and their
interaction is dictated by two distributivity axioms, such as ~a √ó (b + c) ‚âà (a
√ó b) + (a √ó c)~. As with ~head~ above, depending on which features of a monoid are
exposed upfront, such axioms may be either difficult to express or relatively easy.

For brevity, since our interest is in expressing the aforementioned distributivity axiom,
we shall ignore all other features of a monoid, to obtain a magma.
#+BEGIN_SRC agda :tangle list-is-not-vec.agda
record Magma‚ÇÄ : Set‚ÇÅ where
  field
    Carrier : Set
    _‚®æ_      : Carrier ‚Üí Carrier ‚Üí Carrier

module Distributivity‚ÇÄ
    (Additive Multiplicative : Magma‚ÇÄ)
    (open Magma‚ÇÄ Additive renaming (Carrier to R‚Çä; _‚®æ_ to _+_))
    (open Magma‚ÇÄ Multiplicative renaming (Carrier to R‚Çì; _‚®æ_ to _√ó_))
    (shared-carrier :  R‚Çä ‚â° R‚Çì)
    where

  coe‚Çì : R‚Çä ‚Üí R‚Çì
  coe‚Çì = subst id shared-carrier

  coe‚Çä : R‚Çì ‚Üí R‚Çä
  coe‚Çä = subst id (sym shared-carrier)

  distribute‚ÇÄ : ‚àÄ {a : R‚Çì} {b c : R‚Çä}
                ‚Üí   a √ó coe‚Çì (b + c)
                  ‚â° coe‚Çì (coe‚Çä(a √ó coe‚Çì b) + coe‚Çä(a √ó coe‚Çì c))
  distribute‚ÇÄ = {!!}
#+END_SRC
It is a bit of a challenge to understand the type of ~distribute‚ÇÄ~.
Even though the carriers of the monoids are propositionally equal, ~R‚Çä ‚â° R‚Çì~,
they are not the same by definition. As such, we are forced to ‚Äúcoe‚Äùrce back and forth;
leaving the distributivity axiom as an exotic property of addition, multiplication, and coercions.
Even worse, without the cleverness of declaring two coercion helpers, the typing of ~distribute‚ÇÄ~
would have been so large and confusing that the concept would be rendered near useless.

Let's clarify what equality means. One says ~ùìÅ ‚â° ùìá~ is <<</definitionally
equal/>>> when both sides are indistinguishable after all possible definitions
in the terms ~ùìÅ~ and ~ùìá~ have been used. In contrast, the equality is
<<</propositionally equal/>>> when one must perform actual work, such as using
inductive reasoning. In general, if there are no variables in ~ùìÅ ‚â° ùìá~ then we have
definitional equality ---i.e., simplify as much as possible then compare---
otherwise we have propositional equality ---real work to do. Below is an example
about the types of vectors.
#+BEGIN_SRC agda :tangle list-is-not-vec.agda
definitional : ‚àÄ {A} ‚Üí Vec A 5 ‚â° Vec A (2 + 3)
definitional = refl

propoistional : ‚àÄ {A m n} ‚Üí Vec A (m + n) ‚â° Vec A (n + m)
propoistional = {!!}
#+END_SRC

In theory, parameterised structures are no different from their unparameterised, or ‚Äúbundled‚Äù, counterparts.
However, in practice, this is wholly untrue: Below we can phrase the distributivity axiom nearly as it was
stated informally earlier since the shared carrier is declared upfront.
#+BEGIN_SRC agda :tangle list-is-not-vec.agda
record Magma‚ÇÅ (Carrier : Set) : Set‚ÇÅ where
  field
    _‚®æ_      : Carrier ‚Üí Carrier ‚Üí Carrier

module Distributivity‚ÇÅ
    (R : Set) {- The shared carrier -}
    (Additive Multiplicative : Magma‚ÇÅ R)
    (open Magma‚ÇÅ Additive       renaming (_‚®æ_ to _+_))
    (open Magma‚ÇÅ Multiplicative renaming (_‚®æ_ to _√ó_))
    where

  distribute‚ÇÅ : ‚àÄ {a b c : R}
                ‚Üí a √ó (b + c) ‚â° (a √ó b) + (a √ó c)
  distribute‚ÇÅ = {!!}
#+END_SRC
In contrast to the bundled definition of magmas, this form requires no cleverness to form coercion helpers,
and is closer to the informal and usual distributivity statement.

By the same arguments above, the simple statement relating the two units of a ring $1 √ó r + 0 ‚âà r$
---or any units of monoids sharing the same carrier--- is easily phrased using an unbundled presentation
and would require coercions otherwise. We invite the reader to pause at this moment to appreciate the difficulty
in simply expressing this property.

Computing is filled with exciting problems; machines should help us reduce if
not eliminate boring tasks.

#+begin_quote
*Unbundling Design Pattern*:
If a feature of a class is shared among instances, then use an unbundled form of the class
to avoid ‚Äúcoercion hell‚Äù.
#+end_quote

Observe that we assigned superficial renamings, aliases, to the prototypical
binary operation ~_‚®æ_~ so that we may phrase the distributivity axiom in its
expected notational form. This leads us to our next topic of discussion.

** Renaming

The use of an idea is generally accompanied with particular notation that is
accepted by the community. Even though the choice of bound names it
theoretically irrelevant, certain communities would consider it unacceptable to
deviate from convention. Here are a few examples:

- ~x(f)~ :: Using ~x~ as a /function/ and ~f~ as an /argument/.; likewise $\frac{\partial x}{\partial f}$.

  With the exception of people familiar with the Yoneda Lemma, or continuations,
  such a notation is simply ‚Äúwrong‚Äù!

- ~a √ó a ‚âà a~ :: An idempotent operation denoted by multiplication; likewise for commutative operations.

  It is more common to use addition or join, ~‚äî~.

- ~0 √ó a ‚âà a~ :: The identity of ‚Äúmultiplicative symbols‚Äù should never resemble
  ‚Äú0‚Äù; instead it should resemble ‚Äú1‚Äù or, at least, ~‚Äúe‚Äù~ ---the standard
  abbreviation of the influential algebraic works of German authors who used
  ‚ÄúEinheit‚Äù which means ‚Äúidentity‚Äù.

- ~f + g~ :: Even if monoids are defined with the prototypical binary operation
  denoted ‚Äú+‚Äù, it would be ‚Äúwrong‚Äù to continue using it to denote functional composition.
  One would need to introduce the new name ‚Äú‚àò‚Äù or, at least, ‚Äú¬∑‚Äù.

From the few examples above, it is immediate that to even present a prototypical
notation for an idea, one immediately needs auxiliary notation when specialising
to a particular instance. For example, to use ‚Äúadditive symbols‚Äù such as ~+, ‚äî,
‚äï~ to denote an arbitrary binary operation leads to trouble in the function
composition instance above, whereas using ‚Äúmultiplicative symbols‚Äù such as ~√ó,
¬∑, *~ leads to trouble in the idempotent case above.

Regardless of prototypical choices, there will always be a need to rename.

#+begin_quote
*Renaming Design Pattern*:
Use superficial aliases to better communicate an idea;
especially so, when the topic domain is specialised.
#+end_quote

Let's now turn to examples of renaming from three libraries:
1. Agda's standard library,
2. The RATH-Agda library, and
3. A recent categories library.

Each will provide a workaround to the problem of renaming. In particular, the
solutions are, respectively:

1. Rename as needed.
   - There is no systematic approach to account for the many common renamings.
   - Users are encouraged to do the same, since the standard library does it this way.

2. Pack-up the /common/ renamings as modules, and invoke them when needed.
   - Which renamings are provided is left at the discretion of the designer
     ---even ‚Äúexpected‚Äù renamings may not be there since, say, there are too many
     choices or not enough man power to produce them.
   - The pattern to pack-up renamings leads nicely to consistent naming.

3. Names don't matter.
   - Users of the library need to be intimately connected with the definitions
     are domain to use the library.
   - Consequently, there are many inconsistencies in naming.

  The ~open ‚ãØ public ‚ãØ renaming ‚ãØ~ pattern shown below will be presented in a
   future section as a library method.

*** Renaming Problems from Agda's Standard Library

[[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Structures.html#2757][Here is an excerpt from Agda's standard library]], notice how the prototypical
notation for monoids is rename repeatedly /as needed/. Sometimes it is
relabelled with additive symbols, other times with multiplicative symbols.
#+BEGIN_SRC agda2
record IsNearSemiring {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
                      (+ * : Op‚ÇÇ A) (0# : A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    +-isMonoid    : IsMonoid ‚âà + 0#
    *-isSemigroup : IsSemigroup ‚âà *
    distrib ≥      : * DistributesOver ≥ +
    zeroÀ°         : LeftZero 0# *

  open IsMonoid +-isMonoid public
         renaming ( assoc       to +-assoc
                  ; ‚àô-cong      to +-cong
                  ; isSemigroup to +-isSemigroup
                  ; identity    to +-identity
                  )

  open IsSemigroup *-isSemigroup public
         using ()
         renaming ( assoc    to *-assoc
                  ; ‚àô-cong   to *-cong
                  )

record IsSemiringWithoutOne {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
                            (+ * : Op‚ÇÇ A) (0# : A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    +-isCommutativeMonoid : IsCommutativeMonoid ‚âà + 0#
    *-isSemigroup         : IsSemigroup ‚âà *
    distrib               : * DistributesOver +
    zero                  : Zero 0# *

  open IsCommutativeMonoid +-isCommutativeMonoid public
         hiding (identityÀ°)
         renaming ( assoc       to +-assoc
                  ; ‚àô-cong      to +-cong
                  ; isSemigroup to +-isSemigroup
                  ; identity    to +-identity
                  ; isMonoid    to +-isMonoid
                  ; comm        to +-comm
                  )

  open IsSemigroup *-isSemigroup public
         using ()
         renaming ( assoc       to *-assoc
                  ; ‚àô-cong      to *-cong
                  )

record IsSemiringWithoutAnnihilatingZero
         {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
         (+ * : Op‚ÇÇ A) (0# 1# : A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    +-isCommutativeMonoid : IsCommutativeMonoid ‚âà + 0#
    *-isMonoid            : IsMonoid ‚âà * 1#
    distrib               : * DistributesOver +

  open IsCommutativeMonoid +-isCommutativeMonoid public
         hiding (identityÀ°)
         renaming ( assoc       to +-assoc
                  ; ‚àô-cong      to +-cong
                  ; isSemigroup to +-isSemigroup
                  ; identity    to +-identity
                  ; isMonoid    to +-isMonoid
                  ; comm        to +-comm
                  )

  open IsMonoid *-isMonoid public
         using ()
         renaming ( assoc       to *-assoc
                  ; ‚àô-cong      to *-cong
                  ; isSemigroup to *-isSemigroup
                  ; identity    to *-identity
                  )

record IsRing
         {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
         (_+_ _*_ : Op‚ÇÇ A) (-_ : Op‚ÇÅ A) (0# 1# : A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    +-isAbelianGroup : IsAbelianGroup ‚âà _+_ 0# -_
    *-isMonoid       : IsMonoid ‚âà _*_ 1#
    distrib          : _*_ DistributesOver _+_

  open IsAbelianGroup +-isAbelianGroup public
         renaming ( assoc               to +-assoc
                  ; ‚àô-cong              to +-cong
                  ; isSemigroup         to +-isSemigroup
                  ; identity            to +-identity
                  ; isMonoid            to +-isMonoid
                  ; inverse             to -‚Äøinverse
                  ; ‚Åª¬π-cong             to -‚Äøcong
                  ; isGroup             to +-isGroup
                  ; comm                to +-comm
                  ; isCommutativeMonoid to +-isCommutativeMonoid
                  )

  open IsMonoid *-isMonoid public
         using ()
         renaming ( assoc       to *-assoc
                  ; ‚àô-cong      to *-cong
                  ; isSemigroup to *-isSemigroup
                  ; identity    to *-identity
                  )
#+END_SRC

At first glance, one solution would be to package up these renamings into helper modules:
#+BEGIN_SRC agda2
-- Orginal notations
--------------------------------------------------------------------------------
record IsMonoid {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
                (‚àô : Op‚ÇÇ A) (Œµ : A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    isSemigroup : IsSemigroup ‚âà ‚àô
    identity    : Identity Œµ ‚àô

record IsCommutativeMonoid {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
                           (_‚àô_ : Op‚ÇÇ A) (Œµ : A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    isSemigroup : IsSemigroup ‚âà _‚àô_
    identityÀ°   : LeftIdentity Œµ _‚àô_
    comm        : Commutative _‚àô_

    ‚ãÆ
  isMonoid : IsMonoid ‚âà _‚àô_ Œµ
  isMonoid = record { ‚ãØ }

-- Renaming helpers
--------------------------------------------------------------------------------
module AdditiveIsMonoid {a ‚Ñì} {A : Set a} {‚âà : Rel A ‚Ñì}
               {_‚àô_ : Op‚ÇÇ A} {Œµ : A} (+-isMonoid : IsMonoid ‚âà _‚àô_ Œµ)  where

   open IsMonoid +-isMonoid public
         renaming ( assoc       to +-assoc
                  ; ‚àô-cong      to +-cong
                  ; isSemigroup to +-isSemigroup
                  ; identity    to +-identity
                  )

module AdditiveIsCommutativeMonoid {a ‚Ñì} {A : Set a} {‚âà : Rel A ‚Ñì}
               {_‚àô_ : Op‚ÇÇ A} {Œµ : A} (+-isCommutativeMonoid : IsMonoid ‚âà _‚àô_ Œµ)  where

   open AdditiveIsMonoid (CommutativeMonoid.isMonoid +-isCommutativeMonoid) public
   open IsCommutativeMonoid +-isCommutativeMonoid public using ()
      renaming ( comm to +-comm
               ; isMonoid to +-isMonoid)
#+END_SRC
However, one then needs to make similar modules for /additive notation/ for
~IsAbelianGroup, IsRing, IsCommutativeRing, ‚Ä¶~. Moreover, this still invites
repetition: Additional notations, as used in ~IsSemiring~, would require
additional helper modules.
#+BEGIN_SRC agda2
module MultiplicativeIsMonoid {a ‚Ñì} {A : Set a} {‚âà : Rel A ‚Ñì}
               {_‚àô_ : Op‚ÇÇ A} {Œµ : A} (*-isMonoid : IsMonoid ‚âà _‚àô_ Œµ)  where

   open IsMonoid *-isMonoid public
         renaming ( assoc       to *-assoc
                  ; ‚àô-cong      to *-cong
                  ; isSemigroup to *-isSemigroup
                  ; identity    to *-identity
                  )
#+END_SRC

Unless carefully organised, such notational modules would bloat the standard
library, resulting in difficulty when navigating the library. As it stands
however, the new algebraic structures appear large and complex due to the
‚Äúrenaming hell‚Äù encountered to provide the expected conventional notation.

*** Renaming Problems from the RATH-Agda Library

The impressive [[http://relmics.mcmaster.ca/RATH-Agda/RATH-Agda-2.2.pdf][Relational Algebraic Theories in Agda]] library takes a disciplined
approach: Copy-paste notational modules, possibly using a find-replace mechanism
to vary the notation. The use of a find-replace mechanism leads to consistent naming
across different notations.

#+caption: Relation.Binary.Setoid.Utils
#+begin_quote
For contexts where calculation in different setoids is necessary, we provide
‚Äúdecorated‚Äù versions of the ~Setoid‚Ä≤~ and ~SetoidCalc~ interfaces:
#+end_quote
#+BEGIN_SRC agda2
module SetoidA {i j : Level} (S : Setoid i j) = Setoid‚Ä≤ S renaming
    ( ‚Ñì to ‚ÑìA ; Carrier to A‚ÇÄ ; _‚âà_ to _‚âàA_ ; ‚âà-isEquivalence to ‚âàA-isEquivalence
    ; ‚âà-isPreorder to ‚âàA-isPreorder ; ‚âà-preorder to ‚âàA-preorder
    ; ‚âà-indexedSetoid to ‚âàA-indexedSetoid
    ; ‚âà-refl to ‚âàA-refl ; ‚âà-reflexive to ‚âàA-reflexive ; ‚âà-sym to ‚âàA-sym
    ; ‚âà-trans to ‚âàA-trans ; ‚âà-trans‚ÇÅ to ‚âàA-trans‚ÇÅ ; ‚âà-trans‚ÇÇ to ‚âàA-trans‚ÇÇ
    ; _‚ü®‚âà‚âà‚ü©_ to _‚ü®‚âàA‚âà‚ü©_ ; _‚ü®‚âà‚âàÀò‚ü©_ to _‚ü®‚âàA‚âàÀò‚ü©_ ; _‚ü®‚âàÀò‚âà‚ü©_ to _‚ü®‚âàAÀò‚âà‚ü©_ ; _‚ü®‚âàÀò‚âàÀò‚ü©_ to _‚ü®‚âàAÀò‚âàÀò‚ü©_
    ; _‚ü®‚â°‚âà‚ü©_ to _‚ü®‚â°‚âàA‚ü©_ ; _‚ü®‚â°‚âàÀò‚ü©_ to _‚ü®‚â°‚âàAÀò‚ü©_ ; _‚ü®‚â°Àò‚âà‚ü©_ to _‚ü®‚â°Àò‚âàA‚ü©_ ; _‚ü®‚â°Àò‚âàÀò‚ü©_ to _‚ü®‚â°Àò‚âàAÀò‚ü©_
    ; _‚ü®‚âà‚â°‚ü©_ to _‚ü®‚âàA‚â°‚ü©_ ; _‚ü®‚âà‚â°Àò‚ü©_ to _‚ü®‚âàA‚â°Àò‚ü©_ ; _‚ü®‚âàÀò‚â°‚ü©_ to _‚ü®‚âàAÀò‚â°‚ü©_ ; _‚ü®‚âàÀò‚â°Àò‚ü©_ to _‚ü®‚âàAÀò‚â°Àò‚ü©_
    )

module SetoidB {i j : Level} (S : Setoid i j) = Setoid‚Ä≤ S renaming
    ( ‚Ñì to ‚ÑìB ; Carrier to B‚ÇÄ ; _‚âà_ to _‚âàB_ ; ‚âà-isEquivalence to ‚âàB-isEquivalence
    ; ‚âà-isPreorder to ‚âàB-isPreorder ; ‚âà-preorder to ‚âàB-preorder
    ; ‚âà-indexedSetoid to ‚âàB-indexedSetoid
    ; ‚âà-refl to ‚âàB-refl ; ‚âà-reflexive to ‚âàB-reflexive ; ‚âà-sym to ‚âàB-sym
    ; ‚âà-trans to ‚âàB-trans ; ‚âà-trans‚ÇÅ to ‚âàB-trans‚ÇÅ ; ‚âà-trans‚ÇÇ to ‚âàB-trans‚ÇÇ
    ; _‚ü®‚âà‚âà‚ü©_ to _‚ü®‚âàB‚âà‚ü©_ ; _‚ü®‚âà‚âàÀò‚ü©_ to _‚ü®‚âàB‚âàÀò‚ü©_ ; _‚ü®‚âàÀò‚âà‚ü©_ to _‚ü®‚âàBÀò‚âà‚ü©_ ; _‚ü®‚âàÀò‚âàÀò‚ü©_ to _‚ü®‚âàBÀò‚âàÀò‚ü©_
    ; _‚ü®‚â°‚âà‚ü©_ to _‚ü®‚â°‚âàB‚ü©_ ; _‚ü®‚â°‚âàÀò‚ü©_ to _‚ü®‚â°‚âàBÀò‚ü©_ ; _‚ü®‚â°Àò‚âà‚ü©_ to _‚ü®‚â°Àò‚âàB‚ü©_ ; _‚ü®‚â°Àò‚âàÀò‚ü©_ to _‚ü®‚â°Àò‚âàBÀò‚ü©_
    ; _‚ü®‚âà‚â°‚ü©_ to _‚ü®‚âàB‚â°‚ü©_ ; _‚ü®‚âà‚â°Àò‚ü©_ to _‚ü®‚âàB‚â°Àò‚ü©_ ; _‚ü®‚âàÀò‚â°‚ü©_ to _‚ü®‚âàBÀò‚â°‚ü©_ ; _‚ü®‚âàÀò‚â°Àò‚ü©_ to _‚ü®‚âàBÀò‚â°Àò‚ü©_
    )

module SetoidC {i j : Level} (S : Setoid i j) = Setoid‚Ä≤ S renaming
    ( ‚Ñì to ‚ÑìC ; Carrier to C‚ÇÄ ; _‚âà_ to _‚âàC_ ; ‚âà-isEquivalence to ‚âàC-isEquivalence
    ; ‚âà-isPreorder to ‚âàC-isPreorder ; ‚âà-preorder to ‚âàC-preorder
    ; ‚âà-indexedSetoid to ‚âàC-indexedSetoid
    ; ‚âà-refl to ‚âàC-refl ; ‚âà-reflexive to ‚âàC-reflexive ; ‚âà-sym to ‚âàC-sym
    ; ‚âà-trans to ‚âàC-trans ; ‚âà-trans‚ÇÅ to ‚âàC-trans‚ÇÅ ; ‚âà-trans‚ÇÇ to ‚âàC-trans‚ÇÇ
    ; _‚ü®‚âà‚âà‚ü©_ to _‚ü®‚âàC‚âà‚ü©_ ; _‚ü®‚âà‚âàÀò‚ü©_ to _‚ü®‚âàC‚âàÀò‚ü©_ ; _‚ü®‚âàÀò‚âà‚ü©_ to _‚ü®‚âàCÀò‚âà‚ü©_ ; _‚ü®‚âàÀò‚âàÀò‚ü©_ to _‚ü®‚âàCÀò‚âàÀò‚ü©_
    ; _‚ü®‚â°‚âà‚ü©_ to _‚ü®‚â°‚âàC‚ü©_ ; _‚ü®‚â°‚âàÀò‚ü©_ to _‚ü®‚â°‚âàCÀò‚ü©_ ; _‚ü®‚â°Àò‚âà‚ü©_ to _‚ü®‚â°Àò‚âàC‚ü©_ ; _‚ü®‚â°Àò‚âàÀò‚ü©_ to _‚ü®‚â°Àò‚âàCÀò‚ü©_
    ; _‚ü®‚âà‚â°‚ü©_ to _‚ü®‚âàC‚â°‚ü©_ ; _‚ü®‚âà‚â°Àò‚ü©_ to _‚ü®‚âàC‚â°Àò‚ü©_ ; _‚ü®‚âàÀò‚â°‚ü©_ to _‚ü®‚âàCÀò‚â°‚ü©_ ; _‚ü®‚âàÀò‚â°Àò‚ü©_ to _‚ü®‚âàCÀò‚â°Àò‚ü©_
    )
#+END_SRC

This keeps going to cover the alphabet ~SetoidD, SetoidE, SetoidF, ‚Ä¶, SetoidZ~
then we shift to subscripted versions ~Setoid‚ÇÄ, Setoid‚ÇÅ, ‚Ä¶, Setoid‚ÇÑ~.

Next, RATH-Agda shifts to the need to calculate with setoids:
#+BEGIN_SRC agda2
module SetoidCalcA {i j : Level} (S : Setoid i j) where
  open SetoidA S public
  open SetoidCalc S public renaming
    ( _‚ñ° to _‚ñ°A
    ; _‚âà‚ü®_‚ü©_ to _‚âàA‚ü®_‚ü©_
    ; _‚âàÀò‚ü®_‚ü©_ to _‚âàAÀò‚ü®_‚ü©_
    ; _‚âà‚â°‚ü®_‚ü©_ to _‚âàA‚â°‚ü®_‚ü©_
    ; _‚âà‚ü®‚ü©_ to _‚âàA‚ü®‚ü©_
    ; _‚âà‚â°Àò‚ü®_‚ü©_ to _‚âàA‚â°Àò‚ü®_‚ü©_
    ; ‚âà-begin_ to ‚âàA-begin_
    )
module SetoidCalcB {i j : Level} (S : Setoid i j) where
  open SetoidB S public
  open SetoidCalc S public renaming
    ( _‚ñ° to _‚ñ°B
    ; _‚âà‚ü®_‚ü©_ to _‚âàB‚ü®_‚ü©_
    ; _‚âàÀò‚ü®_‚ü©_ to _‚âàBÀò‚ü®_‚ü©_
    ; _‚âà‚â°‚ü®_‚ü©_ to _‚âàB‚â°‚ü®_‚ü©_
    ; _‚âà‚ü®‚ü©_ to _‚âàB‚ü®‚ü©_
    ; _‚âà‚â°Àò‚ü®_‚ü©_ to _‚âàB‚â°Àò‚ü®_‚ü©_
    ; ‚âà-begin_ to ‚âàB-begin_
    )
module SetoidCalcC {i j : Level} (S : Setoid i j) where
  open SetoidC S public
  open SetoidCalc S public renaming
    ( _‚ñ° to _‚ñ°C
    ; _‚âà‚ü®_‚ü©_ to _‚âàC‚ü®_‚ü©_
    ; _‚âàÀò‚ü®_‚ü©_ to _‚âàCÀò‚ü®_‚ü©_
    ; _‚âà‚â°‚ü®_‚ü©_ to _‚âàC‚â°‚ü®_‚ü©_
    ; _‚âà‚ü®‚ü©_ to _‚âàC‚ü®‚ü©_
    ; _‚âà‚â°Àò‚ü®_‚ü©_ to _‚âàC‚â°Àò‚ü®_‚ü©_
    ; ‚âà-begin_ to ‚âàC-begin_
    )
#+END_SRC
This keeps going to cover the alphabet ~SetoidCalcD, SetoidCalcE, SetoidCalcF, ‚Ä¶, SetoidCalcZ~
then we shift to subscripted versions ~SetoidCalc‚ÇÄ, SetoidCalc‚ÇÅ, ‚Ä¶, SetoidCalc‚ÇÑ~.
If we ever have more than 4 setoids in hand, or prefer other decorations, then
we would need to produce similar helper modules.
| Each ~Setoidùí≥ùí≥ùí≥~ takes 10 lines, for a total of at-least 600 lines! |

Indeed, such renamings bloat the library, but, unlike the Standard Library, they
allow new records to be declared easily ---‚Äúrenaming hell‚Äù has been deferred
from the user to the library designer. However, later on, in ~Categoric.CompOp~,
we see the variations ~LocalEdgeSetoidùíü~ and ~LocalSetoidCalcùíü~ where decoration
~ùíü~ ranges over ~‚ÇÄ, ‚ÇÅ, ‚ÇÇ, ‚ÇÉ, ‚ÇÑ, R~. The inconsistency in not providing the other
decorations used for ~Setoidùìì~ earlier is understandable: These take time to
write and maintain.

Various similar decorations can be found in RATH, such as for ~Semigroupoidùíü~ in
~Categoric.Semigroupoid~.

*** Renaming Problems from the Agda-categories Library

With RATH-Agda's focus on notational modules at one end of the spectrum, and the
Standard Library's casual do-as-needed in the middle, it is inevitable that
there are other equally popular libraries but at the other end of the spectrum.
The [[https://github.com/agda/agda-categories][Agda-categories]] library seemingly ignored the need for meaningful names
altogether! Below are a few notable instances.

+ Functors have fields named ~F‚ÇÄ, F‚ÇÅ, F-resp-‚âà, ‚Ä¶~.
  - This could be considered reasonable even if one has a functor named ~G~.
  - This [[https://github.com/agda/agda-categories/blob/master/src/Categories/Category/Product.agda][leads to expressions]] such as ~< F.F‚ÇÄ , G.F‚ÇÄ >~.
  - Incidentally, and somewhat inconsistently, a ~Pseudofunctor~ has fields ~P‚ÇÄ,
    P‚ÇÅ, P-homomophism~ ---where the latter is documented /P preserves ‚âÉ/.

  On the opposite extreme, RATH-Agda's importance on naming has it functor record
  having fields named ~obj, mor, mor-cong~ instead of ~F‚ÇÄ, F‚ÇÅ, F-resp-‚âà~
  ---which refer to a functor's ‚Äúobj‚Äùect map, ‚Äúmor‚Äùphism map, and the fact that the
  ‚Äúmor‚Äùphism map is a ‚Äúcong‚Äùruence.

+ Such lack of concern for naming might be acceptable for well-known concepts
  such as functors, where some communities use ~F·µ¢~ to denote the object/0 or
  morphism/1 operations. However, considering [[https://github.com/agda/agda-categories/blob/master/src/Categories/Category/SubCategory.agda][subcategories]] one is sees field
  names ~U, R, Rid, _‚àòR_~ which are wholly unhelpful. Instead, more meaningful
  names such as ~embed, keep, id-kept, keep-resp-‚àò~ could have been used.

+ The ~Iso, Inverse,~ and ~NaturalIsomorphism~ records have fields ~to / from, f
  / f‚Åª¬π,~ and ~~F‚áíG / F‚áêG~, respectively.

  #  ( ~Categories.Category~ )

  Even though some of these build on one another, with Agda's namespacing
  features, all ‚Äúforward‚Äù and ‚Äúbackward‚Äù morphism fields could have been named,
  say, ~to~ and ~from~. The naming may not have propagated from ~Iso~ to other
  records possibly due to the low priority for names.

  From a usability perspective, projections like ~f~ are reminiscent of the OCaml
  community and may be more acceptable there. Since Agda is more likely to attract
  Haskell programmers than OCaml ones, such a particular projection seems completely
  our of place. Likewise, the field name ~F‚áíG~ seems only appropriate if the
  functors involved happen to be named ~F~ and ~G~.

  These unexpected deviations are not too surprising since the Agda-categories
  library seems to give names no priority at all. Field projections are treated
  little more than classic array indexing with numbers.


By largely avoiding renaming, Agda-categories has no ‚Äúrenaming hell‚Äù anywhere at
the heavy price of being difficult to read: Any attempt to read code requires
one to ‚Äúsquint away‚Äù the numerous projections to ‚Äúsee‚Äù the concepts of
relevance. Consider the [[https://github.com/agda/agda-categories/blob/master/src/Categories/Yoneda.agda][following excerpt]].
#+BEGIN_SRC agda
helper : ‚àÄ {F : Functor (Category.op C) (Setoids ‚Ñì e)}
                     {A B : Obj} (f : B ‚áí A)
                     (Œ≤ Œ≥ : NaturalTransformation Hom[ C ][-, A ] F) ‚Üí
                   Setoid._‚âà_ (F‚ÇÄ Nat[Hom[C][-,c],F] (F , A)) Œ≤ Œ≥ ‚Üí
                   Setoid._‚âà_ (F‚ÇÄ F B) (Œ∑ Œ≤ B ‚ü®$‚ü© f ‚àò id) (F‚ÇÅ F f ‚ü®$‚ü© (Œ∑ Œ≥ A ‚ü®$‚ü© id))
          helper {F} {A} {B} f Œ≤ Œ≥ Œ≤‚âàŒ≥ = S.begin
            Œ∑ Œ≤ B ‚ü®$‚ü© f ‚àò id          S.‚âà‚ü® cong (Œ∑ Œ≤ B) (id-comm ‚óã (‚ü∫ identityÀ°)) ‚ü©
            Œ∑ Œ≤ B ‚ü®$‚ü© id ‚àò id ‚àò f     S.‚âà‚ü® commute Œ≤ f CE.refl ‚ü©
            F‚ÇÅ F f ‚ü®$‚ü© (Œ∑ Œ≤ A ‚ü®$‚ü© id) S.‚âà‚ü® cong (F‚ÇÅ F f) (Œ≤‚âàŒ≥ CE.refl) ‚ü©
            F‚ÇÅ F f ‚ü®$‚ü© (Œ∑ Œ≥ A ‚ü®$‚ü© id) S.‚àé
            where module S where
                    open Setoid (F‚ÇÄ F B) public
                    open SetoidR (F‚ÇÄ F B) public
#+END_SRC

Here are a few downsides of not renaming:

1. The type of the function is difficult to comprehend; though it need not be.
   - Take ~_‚âà‚ÇÄ_ = Setoid._‚âà_ (F‚ÇÄ Nat[Hom[C][-,c],F] (F , A))~, and
   - Take ~_‚âà‚ÇÅ_ = Setoid._‚âà_ (F‚ÇÄ F B)~,
   - Then the type says: If ~Œ≤ ‚âà‚ÇÄ Œ≥~ then
     ~Œ∑ Œ≤ B ‚ü®$‚ü© f ‚àò id ‚âà‚ÇÅ F‚ÇÅ F f ‚ü®$‚ü© (Œ∑ Œ≥ A ‚ü®$‚ü© id)~
     ---a naturality condition!

2. The short proof is difficult to read!
   - The repeated terms such as ~Œ∑ Œ≤ B~ and ~Œ∑ Œ≤ A~ could have been renamed with
     mnemoic-names such as ~Œ∑‚ÇÅ, Œ∑‚ÇÇ~ or ~Œ∑‚Çõ, Œ∑‚Çú~ for ‚Äòs‚Äôource/1 and ‚Äòt‚Äôarget/2.

Recall that functors ~F~ have projections ~F·µ¢~, so the ‚Äúmor‚Äùphism map on a given
morphism ~f~ becomes ~F‚ÇÅ F f~, as in the excerpt above; however, using
RATH-Agda's naming it would have been ~mor F f~.

Since names are given a lower priority, one no longer needs to perform renaming.
Instead, one is content with projections. The downside is now there are too many
projections, leaving code difficult to comprehend. Moreover, this leads to
inconsistent renaming.

** From ~Isùìß~ to ~ùìß~ ---Packing away components

 The distributivity axiom from earlier required an unbundled structure /after/ a
 completely bundled structure was initially presented. Usual structure are rather
 large and have libraries built around them, so building and using an alternate form
 is not practical. However, multiple forms are usually desirable.

 To accommodate the need for both forms of structure, Agda's Standard Library
 begins with a [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Structures.html#1][type-level predicate]] such as ~IsSemigroup~ below, then [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.html#1][packs that up
 into a record]]. Here is an instance, along with comments from the library.
 #+caption: From the [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.html#601][Agda Standard Library on Algebra]]
 #+BEGIN_SRC agda2
-- Some algebraic structures (not packed up with sets, operations, etc.
record IsSemigroup {a ‚Ñì} {A : Set a} (‚âà : Rel A ‚Ñì)
                   (‚àô : Op‚ÇÇ A) : Set (a ‚äî ‚Ñì) where
  open FunctionProperties ‚âà
  field
    isEquivalence : IsEquivalence ‚âà
    assoc         : Associative ‚àô
    ‚àô-cong        : ‚àô Preserves‚ÇÇ ‚âà ‚ü∂ ‚âà ‚ü∂ ‚âà

-- Definitions of algebraic structures like monoids and rings (packed in records
-- together with sets, operations, etc.)
record Semigroup c ‚Ñì : Set (suc (c ‚äî ‚Ñì)) where
  infixl 7 _‚àô_
  infix  4 _‚âà_
  field
    Carrier     : Set c
    _‚âà_         : Rel Carrier ‚Ñì
    _‚àô_         : Op‚ÇÇ Carrier
    isSemigroup : IsSemigroup _‚âà_ _‚àô_
 #+END_SRC

 If we refer to the former as ~IsX~ and the latter as ~X~, then we can see similar
 instances in the standard library for ~X~ being: ~Monoid, Group, AbelianGroup,
 CommutativeMonoid,~ ~SemigroupWithoutOne, NearSemiring, Semiring,
 CommutativeSemiringWithoutOne, CommutativeSemiring, CommutativeRing~.

 It thus seems that to present an idea ~X~, we require the same amount of space
 to present it unpacked or packed, and so doing both duplicates the process
 and only hints at the underlying principle: From ~IsX~ we pack away the carriers
 and function symbols to ~X~. The converse approach, starting from ~X~ and going to ~IsX~
 is not practical, as it leads to numerous unhelpful reflexivity proofs.

 #+begin_quote
 *Predicate Design Pattern:* Present a concept ùìß first as a predicate ~Isùìß~ on types
 and function symbols, then as a type ~ùí≥~ consisting of types, function symbols,
 and a proof that together they satisfy the ~Isùí≥~ predicate.

 *Œ£ Padding Anti-Pattern*: Starting from a bundled up type ~ùí≥~ consisting of types,
 function symbols, and how they interact, one may form the type ~Œ£ X ‚à∂ ùí≥ ‚Ä¢ ùí≥.f X ‚â°
 ùíá~ to specialise the feature ~ùí≥.f~ to the particular choice ~ùíá~. However, nearly all
 uses of this type will be of the form ~(X , refl)~ where the proof is unhelpful
 noise.
 #+end_quote

 Since the standard library uses the predicate pattern, ~Isùí≥~, which requires all
 sets and function symbols, the Œ£-padding anti-pattern becomes a necessary evil.
 Instead, it would be preferable to have the family ~ùí≥·µ¢~ which is the same as ~Isùí≥~
 but only takes ~ùíæ~-many elements ---c.f., ~Magma‚ÇÄ~ and ~Magma‚ÇÅ~ above. However,
 writing these variations and functions to move between them is not only tedious
 but also error prone. Later on, also demonstrated in [GPCE19], we shall show
 how the bundled form ~ùí≥~ acts as /the/ definition, with other forms being
 derived-as-needed.

 Incidentally, the particular choice ~ùí≥‚ÇÅ~, a predicate on one carrier, deserves
 special attention. In Haskell, instances of such a type are generally known as
 /typeclass instances/ and ~ùí≥‚ÇÅ~ is known as a /typeclass/. In Agda, we may mark such
 implementations for instance search using the keyword ~instance~.

 #+begin_quote
 *Typeclass Design Pattern*: Present a concept ùí≥ as a unary predicate ~ùìß‚ÇÅ~ that
 associates functions and properties with a given type. Then, mark all
 implementations with ~instance~ so that arbitrary ~ùí≥~-terms may be written without
 having to specify the particular instance.

 When there are multiple instance of an ùí≥-structure on a particular type, only
 one of them may be marked for instance search in a given scope.
 #+end_quote

** Redundancy, Derived Features, and Feature Exclusion
<<<sec:redundancy_derived_features_feature_exclusion>>>

 A tenet of software development is not to over-engineer solutions; e.g., we need
 a notion of untyped composition, and so use ~Monoid~. However, at a later stage,
 we may realise that units are inappropriate and so we need to drop them to
 obtain the weaker notion of ~Semigroup~ ---for instance, if we wish to module
 finite functions as hashmaps, we need to omit the identity functions since they
 may have infinite domains; and we cannot simply enforce a convention, say, to
 treat empty hashmaps as the identities since then we would lose the empty
 functions. Incidentally, this example, among others, led to dropping the
 identity features from Categories to obtain so-called Semigroupoids.

 In weaker languages, we could continue to use the monoid interface at the cost
 of ‚Äúthrowing an exception‚Äù whenever the identity is used. However, this breaks
 the Interface Segregation Principle: Users should not be forced to bother with
 features they are not interested in. A prototypical scenario is exposing an
 expressive interface, possibly with redundancies, to users, but providing a
 minimal self-contained counterpart by dropping some features for the sake of
 efficiency or to act as a ‚Äúsmart constructor‚Äù that takes the least amount of
 data to reconstruct the rich interface.

 For example, in the Agda-categories library one finds concepts expressive
 interfaces, with redundant features, named ~ùí≥~, along with their minimal
 self-contained versions, named ~ùí≥Helper~. In particular, the [[https://github.com/agda/agda-categories/blob/master/src/Categories/Category/Core.agda][Category]] type and the
 [[https://github.com/agda/agda-categories/blob/master/src/Categories/NaturalTransformation/NaturalIsomorphism.agda][natural isomorphism]] type are instances of such a pattern. The redundant features
 are there to make the lives of users easier; e.g., Agda-categories states the following.
 #+begin_quote
 We add a symmetric proof of associativity so that the opposite category of the
 opposite category is definitionally equal to the original category.
 #+end_quote
 To underscore the intent, we present below a minimal setup needed to express the
 issue. The semigroup definition contains a redundant associativity axiom
 ---which can be obtained from the first one by applying symmetry of equality.
 This is done purposefully so that the ‚Äúopposite, or dual, transformer‚Äù ~_Àò~ is
 self-inverse on-the-nose; i.e., definitionally rather than propositionally.
 Definitionally equality does not need to be ‚Äòinvoked‚Äô, it is used silently when
 needed, thereby making the redundant setup worth it.
 #+begin_src agda2 :tangle op-involutive-on-the-nose.agda :prologue module op-involutive-on-the-nose where \nopen import Notation\n
record Semigroup : Set‚ÇÅ where
  constructor ùíÆ
  field
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    assoc ≥ : ‚àÄ {x y z} ‚Üí  (x ‚®æ y) ‚®æ z  ‚â°  x ‚®æ (y ‚®æ z)
    assocÀ° : ‚àÄ {x y z} ‚Üí  x ‚®æ (y ‚®æ z)  ‚â°  (x ‚®æ y) ‚®æ z

    -- Notice:  assocÀ° ‚âà sym assoc ≥

_Àò : Semigroup ‚Üí Semigroup
(ùíÆ Carrier _‚®æ_ assoc ≥ assocÀ°) Àò = ùíÆ Carrier (Œª b a ‚Üí a ‚®æ b)  assocÀ° assoc ≥

ÀòÀò‚âàid : ‚àÄ {S} ‚Üí (S Àò) Àò ‚â° S
ÀòÀò‚âàid = refl
 #+end_src

 #+begin_quote
 *On-the-nose Redundancy Design Pattern* [Agda-Categories]: Include redundant
 features if they allow certain common constructions to be definitional equal,
 thereby requiring no overhead to use such an equality. Then, provide a smart
 constructor so users are not forced to produce the redundant features manually.
 #+end_quote

 Incidentally, since this is not a library method, inconsitencies are bound to
 arise; in particular, in the ~ùí≥~ and ~ùí≥Helper~ naming scheme: The ~NaturalIsomorphism~
 type has ~NIHelper~ as its minimised version, and the type of [[https://github.com/agda/agda-categories/blob/master/src/Categories/Category/Monoidal/Symmetric.agda][symmetric monoidal
 categories]] is oddly called ~Symmetric‚Ä≤~ with its helper named ~Symmetric~. Such
 issues could be reduced, if not avoided, if library methods were used instead.

 It is interesting to note that duality forming operators, such as ~_Àò~ above, are
 a design pattern themselves. How? In the setting of algebraic structures, one
 picks an operation to have its arguments flipped, then systematically ‚Äòflips‚Äô
 all proof obligations via a user-provided symmetry operator. We shall return to
 this as a library method in a future section.

 # Since names are given a low priority, the brading operation is simply called ~B~!
 # A symbol closer to the standard model, inverses ~_‚Åª¬π~, such as ~_Àò~ may have been
 # more suggestive.

 Another example of purposefully keeping redundant features is for the sake of
 efficiency.
  #+begin_quote
 For division semi-allegories, even though right residuals, restricted residuals,
 and symmetric quotients all can be derived from left residuals, we still assume
 them all as primitive here, since this produces more readable goals, and also
 makes connecting to optimised implementations easier.

 ---RATH-Agda ¬ß15.13
  #+end_quote

 For instance, the above semigroup type could have been augmented with an
 ordering if we view ~_‚®æ_~ as a meet-operation. Instead, we lift such a derived
 operation as a primitive field, in case the user has a better implementation.
  #+begin_src agda2 :tangle op-involutive-on-the-nose.agda
record Order (S : Semigroup) : Set‚ÇÅ where
  open Semigroup S public
  field
    _‚äë_    : Carrier ‚Üí Carrier ‚Üí Set
    ‚äë-def  : ‚àÄ {x y} ‚Üí (x ‚äë y) ‚â° (x ‚®æ y ‚â° x)

  {- Results about _‚®æ_ and _‚äë_ here ‚Ä¶ -}

defaultOrder : ‚àÄ S ‚Üí Order S
defaultOrder S = let open Semigroup S
                 in record { _‚äë_ = Œª x y ‚Üí x ‚®æ y ‚â° x ; ‚äë-def = refl }
  #+end_src

  #+begin_quote
 *Efficient Redundancy Design Pattern* [RATH-Agda, ¬ß17.1]: To enable efficient
 implementations, replace derived operators with additional fields for them and
 for the equalities that would otherwise be used as their definitions. Then,
 provide instances of these fields as derived operators, so that in the absence
 of more efficient implementations, these default implementations can be used
 with negligible penalty over a development that defines these operators as
 derived in the first place.
  #+end_quote

 # Also
 # which RATH-Agda does a number of times ---e.g., due to the converse
 # operator, not only are division operators are inter-definable but
 # symmetric-quotient congruence laws are derivable.

** Extensions

   In our previous discussion, we needed to drop features from ~Monoid~ to get
   ~Semigroup~. However, excluding the unit element from the monoid also required
   excluding the identity laws. More generally, all features reachable, via
   occurrence relationships, must be dropped when a particular feature is
   dropped. In some sense, a generated graph of features needs to be ‚Äúripped out‚Äù
   from the starting type, and the generated graph may be the whole type. As
   such, in general, we do not know if the resulting type even has any features.

   Instead, in an ideal world, it is preferable to begin with a minimal interface
   then /extend/ it with features as necessary. E.g., begin with ~Semigroup~
   then add orthogonal features until ~Monoid~ is reached. Extensions are also
   known by /subclassing/ or /inheritance/.

 #+BEGIN_SRC mermaid :file semigroup-to-monoid.png :theme default :background-color transparent  :tangle no :tangle no :exports results
graph LR                          %% A ‚ÄúL‚Äùeft to ‚ÄúR‚Äùight graph

Semigroup[<strong>Semigroup</strong><br>carrier <br> binary operation <br> associtivity law ]
PointedSemigroup[<strong>PointedSemigroup</strong><br>carrier <br> binary operation <br> <i>unit element</i> <br> associtivity law ]
LeftUnitalSemigroup[<strong>LeftUnitalSemigroup</strong><br>carrier <br> binary operation <br> unit element <br> <i>left identity law</i> <br> associtivity law ]
RightUnitalSemigroup[<strong>RightUnitalSemigroup</strong><br>carrier <br> binary operation <br> unit element <br> <i>right identity law</i> <br> associtivity law ]
Monoid[<strong>Monoid</strong><br>carrier <br> binary operation <br> unit element <br> <i>left identity law <br> right identity law</i> <br> associtivity law ]

Semigroup --> PointedSemigroup

PointedSemigroup --> LeftUnitalSemigroup
PointedSemigroup --> RightUnitalSemigroup

LeftUnitalSemigroup --> Monoid
RightUnitalSemigroup --> Monoid
 #+END_SRC

 #+RESULTS:
 [[file:semigroup-to-monoid.png]]

 #+begin_quote
 *Extension Design Pattern:* To extend a structure ~ùí≥~ by new features ~f‚ÇÄ, ‚Ä¶, f‚Çô~
 which may mention features of ~ùí≥~, make a new structure ~ùí¥~ with fields for ~ùí≥, f‚ÇÄ,
 ‚Ä¶, f‚Çô~. Then publicly open ~ùí≥~ in this new structure so that the features of ~ùí≥~ are
 visible directly from ~ùì®~ to all users.
 #+end_quote

 The libraries mentioned thus far generally implement extensions in this way.
 By way of example, here is how monoids could be built directly from semigroups in one step.
 #+begin_src agda2 :tangle semigroups_to_monoids.agda :prologue module list-is-not-vec where \nopen import Notation\n
record Semigroup : Set‚ÇÅ where
  field
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    assoc  : ‚àÄ {x y z} ‚Üí  (x ‚®æ y) ‚®æ z  ‚â°  x ‚®æ (y ‚®æ z)

record Monoid : Set‚ÇÅ where
  field
    semigroup : Semigroup

  open Semigroup semigroup public  {- (0) -}

  field
    Id      : Carrier
    leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x

open Monoid

neato : ‚àÄ {M} ‚Üí Carrier M ‚Üí Carrier M ‚Üí Carrier M
neato {M} = _‚®æ_ M    {- Possible due to (0) above -}
 #+end_src

 Notice how we accessed the binary operation ~_‚®æ_~ feature from ~Semigroup~ as if it
 were a native feature of ~Monoid~. Unfortunately, ~_‚®æ_~ is only superficially native
 to ~Monoid~ ---any actual instance, such as ~woah~ below, needs to define the binary
 operation in a ~Semigroup~ instance first.
 #+begin_src agda2 :tangle semigroups_to_monoids.agda
woah : Monoid
woah = record { semigroup = {!!} ; Id = {!!} ; leftId = {!!} ; rightId = {!!} }
 #+end_src

 While library designers may be content to build ~Monoid~ out of ~Semigroup~, users
 should not be forced to learn about how the hierarchy was built. Even worse,
 when the library designers decide to incorporate, say, ~LeftUnitalSemigroup~ then
 all users' code would break. Instead, it would be preferable to have a
 ‚Äòflattened‚Äô presentation for the users that ‚Äúdoes not leak out implementation
 details‚Äù. We shall return to this in a future section.

** Summary of Some Design Patterns in Dependently-Typed Programming
   :PROPERTIES:
   :CUSTOM_ID: design-patterns
   :END:

 Below is a summary of the design patterns mentioned above, using monoids as the
 prototypical structure. Some patterns we did not cover, as they will be covered
 in future sections.

 #+caption: PL Research is about getting free stuff: From the left-most node, we can get a lot!
 # #+BEGIN_SRC mermaid  :file patterns.png :theme forest :background-color transparent
 #+BEGIN_SRC mermaid  :file patterns.png :theme forest :exports results
graph TD %% LR and TD are both also good!

%% A(<br><hr> Carrier : Set <br> _‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier <br> Id : Carrier)
A(<hr> carrier <br> binary operation <br> point <br> left identity law <br> right identity law <br> associtivity law)
B(carrier <br> binary operation <br> point <br><hr> left identity law <br> right identity law <br> associtivity law)
C(carrier <br><hr> binary operation <br> point <br> left identity law <br> right identity law <br> associtivity law)

D{<hr> <pre>Branch <br>Nil </pre>}               %% Using verbatim environment
E{Variables <br><hr> <pre>Embed <br>Branch <br>Nil </pre>} %% Using verbatim environment
F((<hr> &ensp;carrier <br> &ensp;binary operation <br> &ensp;point))

A-. Predicate  &ensp;<br> .->B
B-. Œ£ Padding  &ensp;<br>.->A
A-. Typeclass  &ensp;<br> .-> C
C-. Œ£ Padding &ensp;<br> .-> A

A-. Closed Termtype  &ensp;<br> .-> D
D-. Interpreter &ensp;<br> .-> A
A-. Open Termtype &ensp;<br> .-> E
E-. Interpreter  &ensp;<br> .-> C
E-. Setoid &ensp;<br> .-> A
A-. Signature &ensp;<br> .-> F
E-- Instance  &ensp;<br> --> F

A-. Renaming &ensp;<br> .-> R
R-. Renaming &ensp;<br> .-> A
R(<hr> universe of discourse <br> composition <br> unit <br> left unital <br> right unital <br> parenthesis shift)

A-- Theorem Proving &ensp;<br> -->A

E-- Simplifier  &ensp;<br> -->E
E-- Metaprogramming  &ensp;<br> -->E

UA> Universal <br> Algebra ]

A-. Œª Homomorphism &nbsp;<br> Œª Kernel &nbsp;<br> Œª Products &nbsp;<br> Œª FOL termtypes &nbsp;<br> Œª etc .-> UA
C-. Œª Products &nbsp;<br> Œª Substructure &nbsp;<br> Œª etc .-> UA
UA-. Œª Pushouts / Pullbacks &nbsp;<br> Œª Extensions / Exclusions &nbsp;<br> Œª Duality / Views &nbsp;<br> Œª etc .-> UA

subgraph  %% A subgraph environment places the legend in the top left, which is better than it being in the bottom somewhere.
Legend[<center>Legend</center>0. Parameters occur above the waist line <br> 1. Fields occur below the waist line <br> 2. Dashed lines are design patterns ]
end
 #+END_SRC
 #+RESULTS:
 [[file:patterns.png]]

 Remarks:

 0. It is important to note that the ~termtype~ constructions could also be
    co-inductive, thereby yielding possibly infinitely branching syntax-trees.

    - In the ‚Äúsimplify‚Äù pattern, one could use axioms as rewrite rules.

 1. It is more convenient to restrict a carrier or to form products along carriers using the typeclass version.

 2. As discussed earlier, the name /typeclass/ is justified not only by the fact
    that this is the shape used by typeclasses in Haskell and Coq, but also that
    instance search for such records is supported in Agda by using the ~instance~
    keyword.

 There are many more design patterns in dependently-typed programming. Since
 grouping mechanisms are our topic, we have only presented those involving
 organising data.

* TODO COMMENT Background: What's necessary to solve this problem?
   - What is needed to just understand this problem?
   - Agda
   - System F
   - Monads
   - Metaprogramming

   Maybe tackle this "as needed", rather than upfront.

* Current Approaches
   :PROPERTIES:
   :CUSTOM_ID: current_approaches
   :END:

** COMMENT Who has worked on this problem and where have they gotten?
** COMMENT What are their shortcomings and advantages wrt to our approach?
** COMMENT Shortcomings of our approach.
** COMMENT Missing features and next steps.

** Intro                                                             :ignore:

Structuring mechanisms for proof assistants are seen as tools providing
administrative support for large mechanisation developments
cite:LF_practical_module_system, with support for them usually being
conservative: Support for structuring-mechanisms elaborates, or rewrites, into
the language of the ambient system's logic. Conservative extensions are
reasonable to avoid bootstrapping new foundations altogether but they come at
the cost of limiting expressiveness to the existing foundations; thereby
possibly producing awkward or unusual uses of linguistic phrases of the ambient
language.

We may use the term ‚Äòmodule‚Äô below due to its familiarity, however some of the
issues addressed also apply to other instances of grouping mechanisms ---such as
records, code blocks, methods, files, families of files, and namespaces.

In section ref:sec:module_expectations we define modularisation; in section
ref:sec:module_ad_hoc we discuss how to simulate it, and in section
ref:sec:module_existing we review what current systems can and cannot do; then
in section ref:sec:module_agda we provide legitimate examples of the
interdefinability of different grouping mechanisms within Agda. We conclude in
section ref:sec:module_theory by taking a look at an implementation-agnostic
representation of grouping mechanisms that is sufficiently abstract to ignore
any differences between a record and an interface but is otherwise sufficiently
useful to encapsulate what is expected of module systems. Moreover, besides
looking at the current solutions, we also briefly discuss their shortcomings.

#+begin_quote
The /purpose/ of this section is to establish a working definition of ‚Äúgrouping
mechanism‚Äù, how it can be simulated when it is not a primitive construct, and a
brief theory of their foundations which are exemplified using JavaScript.
#+end_quote

JavaScript will be the language of choice to demonstrate these ideas since it
has a primitive notion of module: Every notion of grouping mechanism boils down
to begin a list of ‚Äúkey:value‚Äù pairs, a so-called <<<JSON object>>>.

** Expectations of Module Systems
<<<sec:module_expectations>>>

# JC: 2.1 is wonderful. For your thesis, I will want this expanded (references,
# table of where the feature exists, etc), but this is enough for the proposal.

Packaging systems are not so esoteric that we need to dwell on their uses; yet
we recall primary use cases to set the stage for the rest of our discussions.

+ Namespacing :: Modules provide new unique local scopes for identifiers thereby
  permitting de-coupling.

  The ability to have multiple files contribute to the same namespace is also
  desirable for de-coupled developments. This necessitates an independence of
  module names from the names of physical files ---such de-conflation permits
  recursive modules.

+ Information Hiding :: Modules ought to provide the ability to enforce content
  /not/ to be accessible, or alterable, from outside of the module to enforce that
  users cannot depend on implementation design decisions.

+ Citizenship :: Grouping mechanisms need not be treated any more special than
  record types. As such, one ought to be able to operate on them and manipulate
  them like any first-class citizen.

  In particular, packages themselves have types which happen to be packages.
  Besides being the JavaScript approach, this is also the case with universal
  algebra, and Ocaml, where ‚Äòstructures‚Äô are typed by ‚Äòsignatures‚Äô.
  Incidentally, Ocaml and JavaScript use the same language for modules and for
  their /types/, whereas, for example, Haskell's recent retrofitting
  cite:haskell_backpack, of its weak module system to allow such interfacing, is
  not entirely in the core language since, for example, instantiating happens by
  the package manager rather than by a core language declaration.

+ Polymorphism :: Grouping mechanisms should group all kinds of things without prejudice.

  This includes ‚Äònested datatypes‚Äô: Local types introduced for implementation
  purposes, where only certain functionality is exposed. E.g., in an Agda record
  declaration, it may be nice to declare a local type where the record fields
  refer to it. This approach naturally leads into hierarchical modules as well.

  Interestingly, such nesting is expressible in [[http://fsl.cs.illinois.edu/images/5/5e/Cayenne.pdf][Cayenne]], a long-gone predecessor
  of Agda. The language lived for about 7 years and it is unclear why it is no longer
  maintained. Speculation would be that dependent types were poorly understood by
  the academics let alone the coders ---moreover, it had essentially one maintainer
  who has since moved on to other projects.

  With the metaprogramming inspired approach we are proposing, it is only
  reasonable that, for example, one be able to mechanically transform a package
  with a local type declaration into a package with the local declaration
  removed and a new component added to abstract it. That is, a particular
  implementation is no longer static, but dynamic. Real world uses cases of this
  idea can be found in the earlier section
  ref:sec:redundancy_derived_features_feature_exclusion.

It would not be unreasonable to consider adding to this enumeration:

+ Sharing :: The computation performed for a module parameter should be shared
  across its constituents, rather than inefficiently being recomputed for each
  constituent ---as is the case in the current implementation of Agda.

It is however debatable whether the following is the ‚Äòright‚Äô way to incorporate
object-oriented notions of encapsulation.

+ Generative modules :: A module, rather than being pure like a function, may
  have some local state or initial setup that is unique to each ‚Äòinstantiation‚Äô
  of the module ---rather than being purely applying a module to parameters.

  #  As I remember Leroy-1995, the point was that SML's generative system is
  #  replaced in OCaml with an applicative system.
  SML supports such features. Whereas Haskell, for example, has its typeclass
  system essentially behave like an implicitly type-indexed record for the
  ‚Äòunnamed instance record‚Äô declarations; thereby rendering useless the
  interfaces supporting, say, only an integer constant.

+ Subtyping :: This gives rise to ‚Äòheterogeneous equality‚Äô where altering type
  annotations can suddenly make a well-typed expression ill-typed. E.g., any two
  record values are equal /at/ the subtype of the empty record, but may be unequal
  at any other type annotation.

  Since a package could contain anything, such as notational declarations, it is
  unclear how even homogeneous equality should be defined ---assuming notations
  are not part of a package's type.

Below is a table briefly summarising the above module features for popular
languages like C and JavaScript, and less popular languages Agda and Ocaml.

#+caption: How languages support module uses
| Concept / Language  | C                    | JavaScript                     | Agda                   | Ocaml                      |
|---------------------+----------------------+--------------------------------+------------------------+----------------------------|
| Namespacing         | file dependent       | functions and ~class~            | ~module~ and ~record~      | Signatures                 |
| Encapsulation       | No                   | Yes                            | Yes                    | Yes                        |
| First-class modules | No                   | Yes: JSON prototype objects    | No                     | Yes: Functors              |
| Polymorphism        | Yes: Void Pointers   | Yes: Dynamically checked       | Yes: Dependently typed | Yes: Strongly typed        |
|---------------------+----------------------+--------------------------------+------------------------+----------------------------|
| Sharing             | Yes with ~#define~     | Yes, as function arguments     | No                     | Yes, as function arguments |
| Generative modules  | ~struct, malloc, free~ | Constructors and ~new~           | No                     | Yes                        |
| Subtyping           | No                   | Yes with prototype inheritance | No                     | Yes                        |

There are many other concerns regarding packages ---such as deriving excerpts,
decoration with higher-order utilities, literate programming support, and
matters of compilation along altered constituents--- but they serve to distract
from our core discussions and are thus omitted.

*** COMMENT ‚ü™ Originally lengthy & messy version ‚ü´ What's Expected of Module Systems?

**** Namespacing

  Modules ought to provide new unique local scopes ---say, by hiding or exporting--- wherein names are considered unique.
  Consequently, the same name declared in distinct modules ought to be considered
  distinct names. This idea permits de-coupling: Implementations are independent
  of one another, whence alterations can transpire in parallel, and development
  may proceed rapidly.
  # Maintaibility!

  Consider the case of de-coupled implementations that incidentally contain
  the exact same datatype declaration ---for example, the modules were created
  at different times by completely different people, and we cannot alter either code.
  If we could alter the code, we might factor out the similarities; otherwise,
  it would be fruitful to provide aliases to the datatype /and/ its constructors:
  The latter is usually not possible in many languages, but it is in Haskell and Agda
  for example, thereby permitting pattern matching on previously-identical constructor names.

{{{remark(WK: Interchangable? Really? Example!)}}}

**** COMMENT Separate Compilation ---WK: Why is this important? What for?

Module code is built /once/ in a while ---e..g, when it was last altered.
  As such, scripts that rely on pre-existing module code should not waste
  time rebuilding the module library. For example, in Agda, files are
  built once to produce ~agdai~ ---‚Äúinteractive Agda‚Äù--- files, which are then
  used speedily by other files. Our scripts, in Agda, go through the process
  of parsing, typechecking, and producing the ~agdai~ files ---this process
  needn't be repeated for pre-existing modules.

  Alternatively, for example, if a file contains two code blocks each referring
  to distinct namespaces and only one of them is altered, then the state of the
  other namespace ought to remain the same ---even if it indirectly refers to the
  former namespace--- and so should not require to be rebuilt.
  With sufficient care, a similar argument could be presented for methods
  and code blocks.

**** Grouping Mechanisms Should Group All Kinds Of Things!

***** Genericity ---Parameters and State

Module matter may be utilised in unimagined manners, so should be adaptable.

  - To support such adaptability, varying degrees of polymorphic, generic, programming
    should be supported ---to avoid duplicate code, if anything else.

     E.g., Agda provides a hierarchy of types which can be quantified over, yet
     there are record and module constructs that are essentially the same but
     this is inexpressible in Agda since these two grouping mechanisms have
     distinct citizenship classification in Agda.

  - Modules may require an initial communication to occur with an external
   system ---such as setting up a network connection or initialising a global
   variable---.

   To provide such support, consideration should be given to effectful module
   invocations. The distinction between effectful and pure module operations is notable
   within the OCaml and SML communities in the form of `functors',
   {{{remark(Both effectful and pure?)}}}
   even though the concepts are widely popular
   in stateful languages ---e.g., in the guise of a constructor method for a
   class in an object oriented language.

   Being total and pure, Agda currently does not support such effectful
   modules. Utilising secondary options, such as pragmas, may be one
   of the best possible approximations. In fact this is essentially what
   the C preprocessor does when it includes header files ---the preprocessor copies and pastes
   contents of other files into the current script.

  - Modules may be parameterised ---such as which network to connect to, or
    which file to read from.

    The computation performed for a parameter should be shared across its
    constituents, rather than inefficiently being recomputed by each constituent.
    Haskell, for example, forms a ‚Äòthunk‚Äô of memory that refers to the result
    of the /unevaluated/ computation such that each constituent refers to it.
    Once any constituent actually makes use of it, then it is evaluated, and
    all other constituents continue to point to the same memory location
    which now has the resulting computed value.
    However, the current implementation of Agda forces each
    constituent to re-compute the value of a parameter ---there is minimal
    sharing.

{{{remark()}}}

***** Instance-Specific Variables in Pure Languages

  Before even getting to nested type declarations, one desirable feature of any
  grouping mechanism is to contain instance specific-variables.

  For example, suppose I have a type ~t~ that is to implement an interface ~i~
  containing an integer value ~rank~.
  In Haskell, for example, ~i~ is a typeclass and its utilities are dispatched according
  to the instances declared. Even if ~t~ is declared an instance of ~i~, the invocation ~rank~
  makes no reference to ~t~ in its type and it might as well be referring to the rank
  associated with any other type!
  The problem is that the instance is unnamed and the instance dictionary is indexed by the
  name ~t~, which is not referenced at all.
  As such, one would need to produce
  the following awkward workaround.
  In ~i~, we declare ~rank :: a -> Int~, even though we do not /intend/ to make any use of the argument,
  then at the invocation site we have ~rank (undefined :: t)~.
  This is all terribly roundabout; no wonder the Haskell library does not have a
  ‚Äòpointed carrier‚Äô typeclass! ( It does have a [[http://hackage.haskell.org/package/pointed-5.0.1/docs/Data-Pointed.html][‚Äòpointed type constructor‚Äô]] typeclass. )
  In contrast, C# interfaces, for example, can only contain methods and constants
  ---not arbitrary properties--- and avoid Haskell's problem.
  Incidentally, Scala, which can be thought of as a middle ground between Haskell and C#,
  allows the C#-like trait declaration.
  # https://gist.github.com/missingfaktor/2575397

  Observe that Haskell's distinction of constructs results in distinct tools:
  It needs both a type-class checker and a type-checker.
  The former is unnecessary if typeclasses were syntactic sugar for canonical record types,
  thereby having them as ordinary types.
  Conveniently, the reduction of distinctions not only makes it easier to learn a language
  but also demands less tooling on the compiler implementers.

***** Nested Type Declarations

  A grouping mechanism ought to provide support not only for amalgamating functionality
  but also for assembling data structures.
  Moreover the access to the two forms of data
  should be uniform ---e.g., by using the popular dot notation for both.
  #   Why? For example, a type of containers, say sets, exposes a certain functionality but
  #   the implementation of the container may be altered

  # https://stackoverflow.com/questions/2287267/alternatives-to-nested-interfaces-not-possible-in-c
  Depending on /intended/ usage, some grouping mechanisms do not allow the introduction
  of data structures. For example, C# does not allow this even for the case
  of an interface containing a nested interface ---incidentally, its
  close relative VB.NET does
  support such a feature.
  Unfortunately even Agda does not allow this; e.g., the following is invalid
  {{{code(Agda does not permit ~data~ in ~record~)}}}
  #+BEGIN_SRC agda org-agda
  record TreeContainer (A : Set) : Set‚ÇÅ where

    data Rose : Set where Children : A ‚Üí List Rose ‚Üí Rose

    field
      initial  : Rose
      insert   : A ‚Üí Rose ‚Üí Rose
  #+END_SRC

  Note that the type ~Rose~ is not intended to be a field, but rather a local type that
  need not exist elsewhere. Unfortunately this is not possible for Agda records,
  but is only available at the module level ---which is not first class.
  It seems there was a proposal to include such features into
  Agda's older sibling, Haskell, some 6 years ago but the lack of dependent types
  made some features awkward, or impossible, to express, thereby leading to the abandonment
  of the project. @@latex: \iffalse ---this is merely speculation; but
  possibly related, \fi @@
  Interestingly, there is now currently
  much effort exerted into bringing dependent-types into Haskell in a
  harmonious fashion.

  :GraphsAreDTs:
  WK: What purpose does this remark serve at this location?

  For example, the ubiquitous notion of graphs is inherently
  a dependent type since the functions associating an edge with its source and target
  vertices have types depending on which type the vertices are and which type the edges are.

  {{{code(Graphs are Inherently a Dependent Type)}}}
  #+BEGIN_SRC agda org-agda
record Graph : Set‚ÇÅ where
  field
    vertices : Set
    edges    : Set
    src tgt  : edges ‚Üí vertices
#+END_SRC
:End:

  That one works /over/ some given carrier type ---the fact that indexing by type is the only
  way to distinguish instance ‚Äòrecords‚Äô--- has led the Haskell community to produce
  a number of isomorphic data types, using the ~newtype~ keyword, for the sole purpose of providing different typeclass
  instances. For example, the Booleans have the isomorphic copies [[http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html#t:All][~All~]] and [[http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html#t:Any][~Any~]]
  for which there are conjunctive and disjunctive monoid instances, respectively;
  as well as conversions to the standard Booleans.
  Besides the essential duplication, comments are the only way to communicate the desired
  behaviour of the monoid typeclass ---in contrast, the Agda compiler can check such a specification.
  Nonetheless, type classes provide for tremendously terse code and it would be nice to
  declare which instance is to be used in a given scope cite:named_instances
  ---this is doable in Agda, Idris, and PureScript, to name a few,
  and there is a proposal to bring this to Haskell.

  :WhyTCsNotEnought:
    WK: What purpose does this remark serve at this location?

  It is to be noted that a naive approach such as inserting Boolean terms expressing
  the specification of a typeclass and having, say, QuickCheck ensure they hold on randomly
  generated input does not scale. Such an approach would work for ensuring, say, that
  the additive integers yield a monoid, but would fail to show that lists produce a functor
  since the random generation of /functions/ for ~fmap~ would be rather costly, to say the least.
  Another naive approach would be to reduce the Boolean terms to normal then checking for
  reflexivity. This only works for basic concepts, but is tremendously brittle:
  Ensuring the naturals under addition form a monoid would require an inductive proof,
  thereby necessitating a proof term to begin with. As such, explicit proof is necessary
  for the large scale verification of behavioural properties of data types.
  :End:

  :Cayenne:
  WK: What purpose does this remark serve at this location?

  Perhaps more realistically, consider a container type that supports certain
  functionality yet the particular implementation, call it ~C,~ is chosen dynamically.
  {{{code(Dynamic Containers)}}}
  #+BEGIN_SRC agda org-agda
record IntegerContainer : Set‚ÇÅ where
  field
    C      : Set   {- The container implementation. -}
    empty  : C
    insert : Int ‚Üí C ‚Üí C
#+END_SRC

  However, the ~TreeContainer~ record is expressible in Cayenne, a long-gone predecessor
  of Agda. The language lived for about 7 years and it is unclear why it is no longer
  maintained. Speculation would be that dependent types were poorly understood by
  the academics let alone the coders ---a statement that remains true today as we have
  already discussed.
 # http://fsl.cs.illinois.edu/images/5/5e/Cayenne.pdf
 :End:

**** Excerpting ---Deriving Modules

  There is a tendency to depend on a particular set of modules when forming
  numerous scripts ---for example, requiring numeric, list, vector,
  and a variety of equality and isomorphism notions when working on a problem of representing bags.
  The common solution is to manually produce a module that re-exports the
  desired utilities.

  In the extreme case that we actually use one utility from each of /N/ modules,
  then our scripts will not depend on /N/ utility functions but rather on
  /N/ many modules ---which is not necessarily true. However, that is what appears
  on the surface and so those files must be built. For the sake of efficiency,
  it would be desirable to have a new module formed, say in the back-end,
  that includes only the minimum setup, from each module, needed to have the
  utility functions working. Ideally the system could be commanded to either
  produce such an amalgamated module implicitly in some local directory,
  or to weave it into the back-end ---either way, there would be side-effects.

  Besides efficiency, if this module could be presented
  by the system to the user, it would also make the resulting scripts more self-contained
  and so more re-usable. Moreover, for presentation purposes, it is convenient
  to have precisely only what is needed rather a hodge-podge of imports
  from a variety of libraries which may not even be publicly accessible
  ---as is the case with many personal libraries.

  Emacs' Org major mode provides for the ability to make such `tangling'
  happen. It has already been demonstrated that Agda code can be tangled from
  literate programming cite:knuth_lp with Org-mode documents, however the goal is to be
  able to do so directly within Agda itself.

**** Access Controls
{{{remark(Difference between this section and the next?)}}}

A key feature of grouping mechanisms is information hiding; the
ability to encapsulate data representations so that data invariants
may be maintained by the library utilities.
Thus, modules should have access controls
  ---the ability to enforce content /not/ to be accessible, or alterable, from
  outside of the module.

{{{remark(More general: To enfore that users cannot depend on implementation design decisions.)}}}

  In particular, when the implementation of a concept leaks details divergent
  from its intended interface, or if the implementation is likely to change,
  one should provide an interface and be able to make the definitions opaque
  to the system so that its normalisation is not overly aggressive.
  For example, suppose we implement bags using lists.
  Using knowledge of the implementation, users could produce methods
  that are undefinable for bags; e.g., any fold using a
  non-commutative operator. This is an opportunity to
  provide a definition and mark it as opaque.
  Agda does this with the ~abstract~ keyword
  ---which happens to be experimental since it's semantics are not
  well-understood.
  :PoorExample:
  For example, suppose we want to implement an addition algorithm over the
  natural numbers, but we have yet to settle on the implementation
  ---e.g., whether it is recursive on the first or second argument, or if it
  makes a translation to binary then back---, then this is an opportunity to
  provide a definition and mark it as opaque.
  #   Agda does this with the ~abstract~ keyword.
  :End:

  It is important to observe that many languages may hide method names, but
  this feature of Agda goes further. It hides the method implementation altogether
  from the user, so they cannot rely on it for reasoning purposes nor
  efficiency hacks. The latter being common programming tricks; e.g.,
  knowledge of ~gcc~ compiler implementations lets users favour certain constructs
  or form expressions that are considered undefined by the C language specification.

**** Representation Hiding

{{{remark(Difference between this section and the previous?)}}}

We've remarked that a module should serve multiple purposes, such as
  namespacing, but it should also provide support for creating abstract
  data types.

  For example,
  {{{remark(WK: What does this illustrate? DT? Context?)}}}
  suppose a library is intended to provide an in implementation
  for the notion of bags ---also known as multisets---, then the module would
  contain the implementation but the exported data would hide the implementation
  matter. Indeed, access to implementation matter could render dangerously incoherent
  operations to be permissible; such as deriving an order on a type by considering
  the hidden bag implementation.

  Another example of where access to an implementation radically alters
  the possibilities is in the relm of databases. A stack may be implemented
  using a linked list, but providing only a restricted core functionality.
  The latter can serve as a basic database, but the former cannot since one
  cannot implement the general ~select~ database operation on stacks
  to alter elements. {{{remark(WK: Insufficiant declaration of constraints!)}}}


  Stacks are not functorial. {{{remark(---Musa: Yes they are!)}}}
  #+begin_src haskell
---  fmap using only stack interface.

fmap f s | null s    = s
     | otherwise = let (hd, tl) = pop s in push(f hd, fmap f tl)
  #+end_src

**** Operations on grouping mechanisms ---grouping mechanisms as first-class citizens!

  A common experience is coding an algorithm along with print statements
  to keep the user notified of the events taking place, or of coding an
  algorithm and keeping track of a table of pre-computed values, i.e., memoiziation.
  The core logic of the algorithm is polluted with an extra-desirable
  functionality, which makes the core logic un-reusable when other functionality
  is desired. The solution is a ‚Äòdecorator‚Äô, a higher-order function that
  takes the core algorithm as a method and yields a method that adds the
  extra-desirable functionalities.

  {{{remark(WK: ‚Äúaspect-oriented‚Äù?)}}}
  For matters of efficiency, it may be desirable to take a module of polymorphic
  code and instantiate its variables to concrete types and values, possibly
  eliminating recursion as well to produce static code that incurs less dynamic
  penalty.

  Another common operation, which happens to be supported in OCaml, is obtaining the
  interface of a module. The manner in which code is grouped could be optimally
  aimed at maintainability or at usability. These are different problems and
  so should be decoupled.

**** Physical Independence

  In a zealous appeal to the principle of separation of concerns, some
  systems insist on only one module per file; moreover, the module's name
  must be the name of the physical file.
  However, incessant appeal to that principle results in fragmented hierarchies.
  It may be prudent to have multiple files contributing to the same module
  namespace, as in C, thereby necessitating filenames be independent from the module names.

{{{remark(WK: See also: ghc ---split-objs, ---split-sections)}}}

**** Subtyping & (Type-directed) Equality

  Subtyping is a controversial issue.
  On the one hand, it permits re-use.
  On the other hand, it makes type inference cite:type_inference_in_math rather weak.
  It's incorporation however does allow for using records for manifest fields.
  Then again, type inference is already sufficiently weak in a dependently-typed language,
  so this may not be too much of a burden.

  Moreover this now gives rise to (heterogeneous!) equality issues:
  If two records have only one common field with the same value, but otherwise have many
  other distinct fields, then they are equal only /at/ the sub-record consisting of that field,
  and are otherwise unequal /at/ any other type. Altering the type annotation can suddenly
  make a well-typed expression ill-typed.
  # This is worrisome, to say the least.
  #  This becomes more anxiety provoking when ‚Äòproof irrelevance‚Äô and term erasure enter
  #  the scene.
  #
  # Altering the type annotation can suddenly make equal items unequal.

  Powerful languages like Agda allow for the declaration of patterns, notation, and
  precedence. Modelling a module by a record would suggest module equality is structural
  record equality ---but do we really want to consider notational declarations?
  If we do not, then we are considering equality /at/ the greatest common sub-record type?

  Perhaps sub-typing should be in the background but not in the foreground?
  This may lead to a divergent treatment of first-class versus second-class grouping mechanisms.

{{{remark(WK: Look at OCaml singatures, module types, and modules. Similar in Coq?)}}}

**** COMMENT ? Hierarchical Modules
**** COMMENT ? Recursive Modules

   One potential solution would be to deconflate the unit of namespacing from the
unit of compilation (from the unit of filesystem organization).)
** Ad hoc Grouping Mechanisms
<<<sec:module_ad_hoc>>>

# ad hoc ‚à∑ created or done for a ‚Äúparticular‚Äù purpose as necessary.
# Synonyms:	impromptu, improvised, rough and ready, makeshift, make-do, cobbled together, thrown together.

Many popular coding languages do not provide top-level modularisation
mechanisms, yet users have found ways to emulate some or all of their
/requirements/. We shall emphasise a record-like embedding in this section, then
illustrate it in Agda in the next section. We shall number the required features
then illustrate their simulation in JavaScript.

[0] *Namespacing:* Ubiquitous languages, such as C, Shell, and JavaScript, that do not
have built-in support for namespaces mimic it by a consistent naming discipline
as in {{{newline}}} ~theModule_theComponent~. This way, it is clear where
~theComponent~ comes from; namely, the ‚Äòmodule‚Äô ~theModule~ which may have its
interface expressed as a C header file or as a JSON literal. This is a variation
of Hungarian Notation cite:hungarian_notation.

# https://docs.racket-lang.org/guide/macro-module.html
Incidentally, a Racket source file, module, and ‚Äòlanguage‚Äô declaration are
precisely the same. Consequently, Racket modules, like Ocaml's, may contain
top-level effectful expressions. In a similar fashion, Python packages are
directories containing an ~__init__.py~ file which is used for the the same
purpose as Scala's ~package object~'s ---for package-wide definitions.

[1] *Objects:* An object can be simulated by having a record structure contain the
properties of the class which are then instantiated by record instances. Public
class methods are then normal methods whose first argument is a reference to the
structure that contains the properties. The relationship between an object
instance and its class prototype can be viewed across a number of domains, as
illustrated in the following table.

# Records, Prefixes, & Record Consuming Operations

#+LaTeX: \begin{tcolorbox}[title=\hfill Muliple Forms of the Template-Instantiation Duality]
#+BEGIN_CENTER
| *Template*            | $\qquad\text{\emph{has a}}\qquad$ | *Instance*           |
| ‚âà class             |                                   | ‚âà object           |
| ‚âà type              |                                   | ‚âà value            |
| ‚âà theorem statement |                                   | ‚âà witnessing proof |
| ‚âà specification     |                                   | ‚âà implementation   |
| ‚âà interface         |                                   | ‚âà implementation   |
| ‚âà signature         |                                   | ‚âà algebra          |
| ‚âà logic             |                                   | ‚âà theory           |
| ‚âà metamodel         |                                   | ‚âà model            |
#+END_CENTER
#+LaTeX: \end{tcolorbox}

[2] *Modules:* Languages that do not support a module may mimic it by placing ‚Äúmodule
contents‚Äù within a record. Keeping all contents within one massive record also
solves the namespacing issue.

In older versions of JavaScript, for example, a module is a JSON literal
---i.e., a comma separated list of key-value pairs. Moreover, encapsulation is
simulated by having the module be encoded as a function that yields a record
which acts as the public contents of the module, while the non-returned matter
is considered private. Due to JavaScript's dynamic nature we can easily adjoin
functionality to such ‚Äòmodules‚Äô at any later point; however, we cannot access
any private members of the module. This inflexibility of private data is both a
heavy burden as well as a championed merit of the Object Oriented Paradigm.

[3] *Sub-Modules:* If a module is encoded as a record, then a sub-module is a
field in the record which itself happens to be a module encoding.

[4] *Parameterised Modules:* If a module can be considered as encoded as the
returned record from a function, then the arguments to such a function are the
parameters to the module.

[5] *Mixins:* A /mixin/ is the ability to extend a datatype /X/ with functionality /Y/
long after, and far from, its definition. Mixins ‚Äòmix in‚Äô new functionality by
permitting /X obtains traits Y/ ---unlike inheritance which declares /X is a Y/.
Examples of this include Scala's traits, Java's inheritance, Haskell's
typeclasses, and C#'s extension methods.

Let us see a concrete realisation of such a simulation of module features in
JavaScript.
#+BEGIN_SRC js :results output
// [2] A simple unparamterised module with no private information.
// [0] The field ‚Äúname‚Äù is not global, but lives in a dedicated namespace.
function Person (nom, age) { this.name = nom; this.age = age; }

// [1] An object instance; i.e., the dictionary literal {name: "GoÃàdel", age: 12}
goÃàdel = new Person("GoÃàdel", 12)

// [5] Let's mixin new functionality, say, a new method
goÃàdel.prove = () => console.log("I have an incomplete proof...")

// [2, 4] A module parameterised by another module that is a ‚Äúsubmodule‚Äù of ‚ÄúPerson‚Äù.
// [3] The non-Person parts of the parameter are in module ‚ÄúP‚Äù.
function alter_module({name, age, ...P}) {

    // ‚ÄúPrivate‚Äù fields
    information = `I am ${name}! I am ${age} years of age!`
    function speak() { console.log(information) }

    // The return value; fields that are promoted to ‚Äúpublic‚Äù
    return {name, speak}
}

// Invoking the function-on-modules ‚Äúalter_module‚Äù
// which mixes-in the ‚Äúspeak‚Äù method but drops the ‚Äúage‚Äù field
kurt  = alter_module(goÃàdel)
kurt.speak() // ‚áí I am GoÃàdel! I am 12 years of age!

// [0] Notice that the ‚ÄúgoÃàdel‚Äù module ‚Äòlost‚Äô the ‚Äúage‚Äù field
// when it was transformed into the ‚Äúkurt‚Äù module.
console.log(kurt) // ‚áí { name: 'GoÃàdel', speak: [Function: speak] }
#+END_SRC

Typescript cite:understanding_typescript occupies an interesting position with
regards to mixins: It is one of the few languages to provide union and
intersection combinators for its ~interface~ grouping mechanism, thereby most
easily supporting the little theories cite:little_theories method and making
theories a true lattice. Interestingly, intersection of interfaces results in a
type that contains the declarations of its arguments and if a field name has
conflicting types then it is, recursively, assigned the intersection of the
distinct types ---the base cases of this recursive definition are primitive
types, for which distinct types yield an empty intersection. In contrast, its
union types are disjoint sums.
#
# https://codingblast.com/typescript-intersection-types/

In the dependently-typed setting, one also obtains so-called ‚Äòcanonical
structures‚Äô cite:coq_canonical, which not only generalise the previously
mentioned mixins but also facilitate a flexible style of logic programming by
having user-defined algorithms executed during unification; thereby permitting
one to /omit many details cite:coq_canonical_tutorial and have them inferred/. As
mentioned earlier regarding objects, we could simulate mixins by encoding a
class as a record and a mixin as a record-consuming method. Incidentally
languages admitting mixins give rise to an alternate method of module encoding:
A ‚Äòmodule /of type M‚Äô is encoded as an instantiation of the mixin trait M./

# In the sequel,
# when we discuss modules as contexts, it can be seen that the simplest form of
# mixins is context prepending.

These natural encodings only reinforce our idea that there is no real essential
difference between grouping mechanisms: Whether one uses a closure, record, or
module is a matter of preference the usage of which communicates particular
intent, as summarised briefly in the table below.

#+caption: Choice of grouping mechansims communicate intent
| Concept               | Possible Intent                                                                |
|-----------------------+--------------------------------------------------------------------------------|
| module                | Namespacing; organise related utilities under the same name                    |
| record                | Bundle up related features into one ‚Äòcoherent‚Äô unit                            |
| tuple                 | Quickly return multiple items from a function                                  |
|-----------------------+--------------------------------------------------------------------------------|
| function              | An indexed value                                                               |
|-----------------------+--------------------------------------------------------------------------------|
| parameterised modules | Namespaced utilities abstracted over other utilities; e.g., ~sort~ indexed by ~<~. |
| parameterised record  | A semantic unit that ‚Äòbuild upon‚Äô another coherent unit                        |

** Theory Presentations: A Structuring Mechanism
 <<<sec:module_theory>>>

 What of the most closely related theoretical work?

 Our envisioned effort would support a ‚Äúwrite one, obtain many‚Äù approach to
 package formation. In order to get there, we must first understand what is
 currently possible. As such, we investigate package formers are currently
 treated formally under the name of ‚Äòtheory presentations‚Äô. It is the aim of
 this section to attest that the introduction's story is not completely on shaky
 foundations, thereby asserting that the aforementioned goals of the
 introduction are not unachievable ---and the problems that will be posed in
 ref:old_sec:three are not trivial.

 As discussed, languages are usually designed with a bit more thought given to a
 first-class citizen notion of grouping than is given to second-class notions of
 packaging-up defined content. Object-oriented languages, for example, comprise
 features of both views by treating classes as external structuring mechanisms
 even though they are normal types of the type system. This internalising of
 external grouping features has not received much attention with the notable
 mentions being cite:theories_as_types,focalize. It is unclear whether there is
 any real distinction between these ‚Äòinternal, integrated‚Äô and ‚Äòexternal,
 stratified‚Äô forms of grouping, besides intended use. The two approaches have
 different advantages. Both approaches permit separation of concerns: The
 external point of view provides a high-level structuring of a development, the
 internal point of view provides essentially another type which can be the
 subject of the language's operations ---e.g., quantification or tactics---
 thereby being more amicable to computing transformations. Essentially it comes
 down to whether we want a ‚Äòmodule parameter‚Äô or a ‚Äòrecord field‚Äô ---why not
 write it the way you like and get the other form for free.

 #+caption: Parameters ‚âà Projections
 For example, a function ~f ‚à∂ X ‚Üí Y √ó Z~ is externally /an indexed value/, a way to
 structure data ---~Y √ó Z~ pairs--- according to some *parameters* ---~X~. By a slight
 change of perspective, the /type/ ~X ‚Üí Y √ó Z~ treated internally consists of /values/
 that have *field projections* ~eval‚Çì~: For any ~x ‚à∂ X~ and ~f ‚à∂ X ‚Üí Y √ó Z~, we have
 ~eval‚Çì f ‚à∂ Y √ó Z~.

 Since external grouping mechanisms tend to allow for intra-language features
 ---e.g., imports, definitions, notation, extra-logical declarations such as
 pragmas--- their systematic internalisation necessitates expressive record
 types. As such, a labelled product type or <<</context/>>> ---being a list of
 name-type declarations with optional definitions--- is a sufficiently generic
 rendition of what it means to group matter together.

 Below is a grammar, from cite:theories_as_types, for a simple yet powerful
 module system based on theory (presentations) and theory morphisms ---which are
 merely named contexts and named substitutions between contexts, respectively.
 Both may be formed modularly by using includes to copy over declarations of
 previously named objects. Unlike theories which may include arbitrary
 declarations, theory morphisms ~(V ‚à∂ P ‚Üí Q) ‚âî Œ¥~ are well-defined if for every
 ~P~-declaration ~x ‚à∂ T~, ~Œ¥~ contains a declaration ~x ‚âî t~ where ~t~ may refer to all
 names declared in ~Q~.

 {{{code(Syntax for Dependently Typed Œª-calculus with Theories)}}}
 #+BEGIN_SRC haskell
-- Contexts
Œì  ::= ‚àÖ                       -- empty context
     | x : œÑ [:= œÑ‚Ä≤], Œì         -- context with declaration, optional definition
     | Includes X, Œì           -- theory inclusion

-- Terms
œÑ ::= x | œÑ‚ÇÅ œÑ‚ÇÇ | Œª x : œÑ‚Ä≤ ‚Ä¢ œÑ -- variables, application, lambdas
    | Œ† x : œÑ‚Ä≤ ‚Ä¢ œÑ             -- dependent product
    | [Œì] | ‚ü®Œì‚ü© | œÑ.x          -- record ‚Äú[type]‚Äù and ‚Äú‚ü®element‚ü©‚Äù formers, projections
    | Mod X                    -- contravariant ‚Äútheory to record‚Äù internalisation

-- Theory, external grouping, level
Œò ::= ‚àÖ                        -- empty theory
    | X := Œì, Œò                -- a theory can contain named contexts
    | (X : (X‚ÇÅ ‚Üí X‚ÇÇ)) := Œì     -- a theory can be a first-class theory morphism

-- Proviso: In record formers, Œì must be flat; i.e., does not contain includes.
 #+END_SRC

 #+LaTeX: \def\Mod{\mathsf{Mod}\,}

This concept of packaging indeed captures much of what's expected of grouping
mechanisms; e.g.,

 + Grouping mechanism should group all kinds of things and indeed there is no
   constraint on what a theory presentation may contain.

 + Namespacing: Every module context can be construed as a record whose contents
   can then be accessed by record field projection.

   /Theories as Types/ cite:theories_as_types presents the first formal approach
   that systematically internalises theories into record types. Their central
   idea is to introduce a new operator ~Mod~ ---read ‚Äúmodels of‚Äù--- that turns a
   theory $T$ into a type =Mod T= which /behaves/ like a record type.

 + Operations on grouping mechanisms cite:tpc.

Observe that a context is, up to syntactical differences, essentially a
JavaScript object notation literal. Consequently, the notion of a mixin as
described for JSON literals is here rendered as a theory morphism.
# ?
# ?
#+caption: Theory presentations in practice
| Theory Presentations | JavaScript                                              |
|----------------------+---------------------------------------------------------|
| Context / Record     | JSON object: ~{key‚ÇÄ: value‚ÇÄ, ‚Ä¶, key‚Çô: value‚Çô}~            |
| Empty context        | Empty dictionary: ~{}~                                    |
| Inclusion            | In-place syntactic unpacking: ~{...Œì, k‚ÇÄ:v‚ÇÄ, ‚Ä¶, k‚Çô: v‚Çô}~  |
| Theory               | A file or a JSON object or an object-returning function |
| Translation          | Function from JSON objects to JSON objects              |
| View                 | Specification preserving translation                     |

For example, with the abbreviation =(Œ† x : A ‚Ä¢ B) = (A ‚Üí B)=, we may form a small
/theory/ hierarchy of signatures ---which is a just list of /named/ contexts.
#+BEGIN_SRC haskell
  MagmaSig ‚âî Carrier ‚à∂ Set, _‚®æ_ ‚à∂ Carrier ‚Üí Carrier ‚Üí Carrier, ‚àÖ
, MonSig   ‚âî Includes MagmaSig, Id ‚à∂ Carrier, ‚àÖ
, Forget ‚à∂ MagmaSig ‚Üí MonSig ‚âî (Carrier ‚âî Carrier, Id ‚âî Id, ‚àÖ)
, ‚àÖ
#+END_SRC
This theory is then realised as follows in JavaScript ---ignoring the types.
#+BEGIN_SRC js :results output
let MagmaSig = {Carrier: undefined, op: undefined}
let MonSig   = {...MagmaSig, id: undefined}
let Forget   = (Mon) => ({Carrier: Mon.Carrier, op: Mon.op})
#+END_SRC

In practice, an object's features behave, to some degree, in a /known/ fashion;
e.g., what operators may be applied or how the object's features interact with
one another. For instance, a <<</monoid/>>> is an object consisting of a set
~Carrier~, a value ~Id~ of that set, and a binary operation ~_‚®æ_~ on the set;
moreover, the interaction of the latter two is specified by requesting that the
operation is associative and ~Id~ is the identity element for the binary
operation. In contrast, a <<</magma/>>> is simply a set along with a binary
operation. As such, the translation ~Forget~, above, not only gives us a
translation of features, but it also satisfies all zero coherence laws of a
magma.

 As mentioned earlier, a theory morphism, also known as a <<</view/>>>, is a map
 between contexts that implements the interface of the source using utilities of
 the target; whence results about specific structures can be constructed by
 transport along views cite:little_theories: A view =V ‚à∂ ùíÆ ‚Üí ùíØ= gives rise to a
 term homomorphism ~ùí±~ from ~P~-terms to ~Q~-terms that is type-preserving in that
 whenever =Œò, ùíÆ ‚ä¢ e ‚à∂ œÑ= then =Œò, ùíØ ‚ä¢ ùí± e : ùí± œÑ=. Thus, views preserve judgements
 and, via the propositions-as-types representations, also preserve truth.

 # Theory interpretations are also called translations, theory morphisms, immersions, and realisations.
 More concretely, a view =V = (U, Œ≤) ‚à∂ ùíÆ ‚Üí ùíØ= is essentially a predicate $U$, of
 the target theory, denoting a /universe of discourse/ along with an
 arity-preserving mapping =Œ≤= of ùíÆ-symbols, or declarations, to ùíØ-expressions
 ---by itself, =Œ≤= is called a <<</translation/>>>. It is lifted to terms as
 follows ---notice that the translated variable-binders are relativised to the
 new domain.
 #+latex:  \begin{tcolorbox}[title=\hfill ùí± Extended to Terms]
 | ~ùí± x ‚âà x~                              | Provided ~x~ is an ùíÆ-variable symbol       |
 | ~ùí±(f e‚ÇÅ ‚Ä¶ e‚Çô) ‚âà (Œ≤ f) (ùí± e‚ÇÅ) ‚Ä¶ (ùí± e‚Çô)~ | Provided ~f~ is an ~n~-ary ùíÆ-function symbol |
 | ~ùí±(ùí¨ x ‚Ä¢ P) ‚âà (ùí¨ x ‚à£ U x ‚Ä¢ ùí± P)~       | Provided ~ùí¨~ is a variable-binder ~‚àÄ, ‚àÉ, Œª~  |
#+latex:  \end{tcolorbox}
:Alternate_LaTeX_Form:
 #+BEGIN_EXPORT latex
 \begin{tcolorbox}[title=\hfill $\Phi$ Extended to Terms]
 \vspace{-1em}
 \begin{align*}
 \Phi(x) &= x  & & \text{ Provided $x$ is an $\mathcal{S}$-variable symbol }
 \\
 \Phi\left( f(t_1, \ldots, t_n) \right)
 &= \beta(f) \left(\Phi\, t_1, \ldots, \Phi\, t_n\right)
 & & \text{ Provided $f$ is a $n$-ary $\mathcal{S}$-function symbol}
 \\
 \Phi\left(\mathcal{Q}\, x \;\bullet\; P\right)
 &= \left(\mathcal{Q}\, x \;‚ùô\; U\, \;x \bullet\; \Phi(P) \right)
 & & \text{ Provided $\mathcal{Q}$ is a variable-binder $\forall, \exists, \lambda$ }
 \end{align*}
 \end{tcolorbox}
 #+END_EXPORT
:End:

 The /Standard Interpretation Theorem/ cite:theory_interpretations_farmer provides
 sufficient conditions for a translation to be an ‚Äòinterpretation‚Äô which
 transports results between formalisations. It states: A translation is an
 interpretation provided ùíÆ-axioms =P= are lifted to theorems =ùí± P=, the universe of
 discourse is non-empty =‚àÉ x ‚Ä¢ U x=, and the interpretation of the universe
 contains the interpretations of the symbols; i.e., for each ùíÆ-symbol =f= of arity
 =n=, {{{newline}}} ~ùí±(‚àÄ x‚ÇÅ, ‚Ä¶, x‚Çô ‚Ä¢ ‚àÉ y ‚Ä¢ f x‚ÇÅ ‚Ä¶ x‚Çô = y)~ holds.

 # Standard interpreations are used to compare the strength of theories: ùíØ is at
 # least as strong as ùíÆ provided ùì¢ is interpretable in ùíØ --indeed, that's why
 # every model of the latter gives rise to a model of the former! Also, standard
 # interpretations have long been used in logic to prove meta-mathematical
 # properties baout first-order theories, mainly rel;atoive consisitency,
 # decidiabilkity, and undecidiability.

 By virtue of being a validity preserving homomorphism, a standard
 interpretation syntactically and semantically embeds its source theory in its
 target theory. The most important consequence of interpretability is the
 /Standard Relative Satisfiability/ cite:theory_interpretations_farmer which says
 that a theory which is interpretable in a satisfiable theory is itself
 satisfiable; in programming terms this amount to: /If $X$ is an implementation/
 /of *interface* ùíØ and ùíÆ is interpretable in ùíØ then $X$ can be transformed into an
 implementation of ùíÆ./ Interestingly such ‚Äòsubtyping‚Äô can be derived in a
 mechanical fashion, but it can force the subtype relation to be cyclic.
 However, it is unclear under which conditions translations automatically give
 rise to interpretations: Can the issue be relegated to syntactic manipulation
 only?

 Theory interpretation has been studied for first-order predicate logic then
 extended to higher-order logic cite:theory_interpretations_farmer. The advent
 of dependent-types, in particular the blurring of operations and formulae
 cite:wiki_curry_howard, means that propositions of a language can be encoded
 into it as other sorts, dependent on existing sorts, thereby questioning /what
 it means to have a validity-preserving morphism/ when the axioms can be encoded
 as operations? As far as we can tell, it seems very little work regarding
 theory interpretations has been conducted in dependently-typed settings
 cite:mlt_partial,higher_order_interpretations,institution_interpretations,dtl_interpretations.

 #  {{{remark(WK: Then you should discuss it in more detail.)}}}

 In subsequent sections, ref:sec:prototype:morphisms, we shall identify a number
 of views that are formed /syntactically/ and the fact that they are indeed views
 then becomes the need to mechanically provide certain values ---which by the
 propositions-as-types view means we mechanically provide certain ‚Äúproofs of
 propositions‚Äù. Incidentally, moving forward, we shall consider an essentially
 untyped setting in which to perform such syntax shuffling ---that is, even
 though we are tackling DTLs, we shall follow a JavaScript-like approach with
 essentially /one/ notion of grouping rather than a theory presentation approach
 with two notions.

 :Irrelevant:
 Notice that records play dual roles. They not only serve as an internal form of grouping
 mechanisms, but inspired by the previous Agda renditions, also serve the purpose of
 forming dependent sum types.

 What about the presence of non-termination or inheritance
 ---i.e., partial functions and subtypes?
 The subject is only beginning to
 be seriously explored in higher-order logic and type theory.
 cite{theory_interpretations_farmer}.
 Views associating base types with subtypes get complicated since functions must now
 deal with restricted domains, consequently necessitating that all predicates on functions
 also be relativised.
 :End:
** ‚ÄúJSON is Foundational‚Äù: From Prototypes to Classes

   In the previous section, we indicated that going forward, we will be taking a
   JSON-like approach to working with modules. JavaScript has the reputation of
   being non-academic, along with its dynamically type-checked nature it is not
   surprising that the reader may take pause to consider whether our inclination
   is, plainly put, ‚Äòwrong‚Äô. To reassure the reader, we will show how JSON
   objects are a foundational way to group data by deriving the notion of a
   ~class~ from object-oriented programming. In fact, recent implementations of
   JavaScript have a ~class~ keyword which, for the most part, is syntactic sugar
   for JSON objects.

   We shall arrive at the ~class~ keyword as a means of moving away from design
   patterns and going to mechanical constructs.

*** Prototypical Concepts

 In English, /prototype/ means a preliminary model of something from which
 other forms are developed or /copied/. As such, a /prototypical/ object
 is an object denoting the original or typical form of something.

 In addition to their properties, JavaScript objects also have a prototype
 ---i.e., another object that is used as a source of additional properties. When
 an object gets a request for a property that it does not have, its prototype
 will be searched for the property, then the prototype‚Äôs prototype, and so on.

 | A <<</prototype/>>> is another object that is used as a fallback source of properties. |

 Adding new features or overriding methods are another primary use for
 prototypes. E.g., to attach a new property to a ‚Äòkind‚Äô of object, we simply
 need to attach it to the prototype ---since all those ‚Äòkinds‚Äô of objects use
 the prototype's properties. In this way, we overload a method by attaching it
 to prototypes. If, instead, we add the property to an object, rather than to
 its prototype, then the property is attached directly to the object and
 possibly shadowing the property of the same name that the prototype has, whence
 overriding.

*** ‚ü®1‚ü© Prototype Example

 Prototypes let us define properties that are the same for all instances, but
 properties that differ per instance are stored directly in the objects
 themselves. E.g., the prototypical person acts as a container for the
 properties that are shared by all people. An individual person object, like
 ~kathy~ below, contains properties that apply only to itself, such as its name,
 and derives shared properties from its prototype.

 #+BEGIN_SRC js
// An example object prototype
let prototypicalPerson    = {};
prototypicalPerson._world = 0;
prototypicalPerson.speak  = function () {
  console.log(`I am ${this.name}, a ${this.job}, in a world of `
               + `${prototypicalPerson._world} people.`) }
prototypicalPerson.job = `farmer`;

// Example use: Manually ensure the necessary properties are setup
// and then manually increment the number of people in the world.
let person = Object.create(prototypicalPerson);
person.name = `jasim`;
prototypicalPerson._world++;
person.speak() // ‚áí I am jasim, a farmer, in a world of 1 people.

// Another person requires just as much setup
let kathy = { ...prototypicalPerson }; // Same as ‚ÄúObject.create(‚ãØ)‚Äù
kathy.name = `kathy`;
prototypicalPerson._world++;
kathy.speak() // ‚áí I am kathy, a farmer, in a world of 2 people.
 #+END_SRC

 You can use ~Object.create~ to create an object with a specific prototype. The
 default prototype is ~Object.prototype~. For the most part,
 ~Object.create(someObject) ‚âà { ...someObject }~; i.e., we /copy/ the properties of
 ~someObject~ into an empty object, thereby treating ~someObject~ as a prototype
 from which we will build more sophisticated objects.

*** ‚ü®2‚ü© Manual Constructor Functions

 | /Classes are prototypes along with constructor functions!/ |

 A /class/ defines the shape of a kind of object; i.e., what properties it has;
 e.g., a Person can ~speak~, as all people can, but should have its own ~name~
 property to speak of. This idea is realised as a prototype along with a
 /constructor/ function that ensures an instance object not only derives from the
 proper prototype but also ensures it, itself, has the properties that instances
 of the class are supposed to have.

 #+BEGIN_SRC js
let prototypicalPerson    = {};
prototypicalPerson._world = 0;
prototypicalPerson.speak  = function () {
  console.log(`I am ${this.name}, a ${this.job}, in a world of `
               + `${prototypicalPerson._world} people.`) }

function makePerson(name, job = `farmer`) {
  let person  = Object.create(prototypicalPerson);
  person.name = name;
  person.job  = job;
  prototypicalPerson._world++;
  return person;
}

// Example use
let jasim = makePerson(`jasim`);
jasim.speak() // ‚áí I am jasim, a farmer, in a world of 1 people.
makePerson(`kathy`).speak() // ‚áí I am kathy, a farmer, in a world of 2 people.
 #+END_SRC

*** ‚ü®3‚ü© Constructor Functions with ~new~                            :classes:
 We can fuse these under one name by making the prototype a part of the constructor.
 - By convention, the names of constructors are capitalised so that they can
   easily be distinguished from other functions.

 #+BEGIN_SRC js
function Person(name, job = `farmer`) {
 this.name = name;
 this.job  = job;
 Person.prototype._world++;
}

Person.prototype._world = 0;
Person.prototype.speak = function () {
  console.log(`I am ${this.name}, a ${this.job}, in a world of `
               + `${Person.prototype._world} people.`) }

// Example use
let jasim = Object.create(Person.prototype)
Person.call(jasim, `jasim`)
jasim.speak() // ‚áí I am jasim, a farmer, in a world of 1 people.

// Example using shorthand
let kasim = new Person (`kathy`)
kasim.speak()  // ‚áí I am kathy, a farmer, in a world of 2 people.
 #+END_SRC

 If you put the keyword ~new~ in front of a function call, the function is
 treated as a constructor. This means that an object with the right prototype is
 automatically created, bound to ~this~ in the function, and returned at the end
 of the function.

 #+BEGIN_SRC js
  new f(args)
‚âà (_ => let THIS = Object.create(f.prototype);
        f.call(THIS, args); return THIS;) ()
 #+END_SRC

 All functions automatically get a property named ~prototype~, which by default
 holds a plain, empty object that derives from ~Object.prototype~. You can
 overwrite it with a new object if you want. Or you can add properties to the
 existing object, as the example does.

 Notice that the ~Person~ object /derives/ from ~Function.prototype~,
 but also has a /property/ named ~prototype~ which is used for instances
 created through it.
 #+BEGIN_SRC js
console.log( Object.getPrototypeOf(Person) == Function.prototype
           , Person instanceof Function
           , jasim  instanceof Person
           , Object.getPrototypeOf(jasim) == Person.prototype)
 #+END_SRC

 Hence, we can update our motto:
 | /Classes are constructor functions with a prototype property!/ |

*** ‚ü®4‚ü© ~class~ Notation
 Rather than declaring a constructor, /then/ attaching properties to its prototype,
 we may perform both steps together using ~class~ notation shorthand.

 #+BEGIN_SRC js
class Person {
  static #world = 0
  constructor(name, job = `farmer`) {
    this.name = name;
    this.job  = job;
    Person.#world++;
  }
  speak() {
    console.log(`I am ${this.name}, a ${this.job}, in a world of `
               + `${Person.#world} people.`)
  }
}

// Example use

let jasim = new Person(`jasim`)
jasim.speak()
// ‚áí I am jasim, a farmer, in a world of 1 people.

new Person(`kathy`).speak()
// ‚áí I am kathy, a farmer, in a world of 2 people.
 #+END_SRC

 :Hide:
 #+BEGIN_SRC js
// ‚Äúclass‚Äù is just a shorthand
console.log( Object.getPrototypeOf(Person) == Function.prototype
           , Person instanceof Function
           , jasim  instanceof Person
           , Object.getPrototypeOf(jasim) == Person.prototype)
 #+END_SRC
 :End:

 Notice that there is a special function named ~constructor~ which is
 bound to the class name, ~Person~, outside the class. The remainder of the
 class declarations are bound to the constructor's prototype.
 Thus, the earlier class declaration is equivalent to the constructor
 definition from the previous section. It just looks nicer.
 - Actually, this is even better: The ~static #world = 0~ declaration makes the
   property ~world~ /private/, completely inaccessible from the outside the
   class. The ~static~ keyword attaches the name not to particular instances
   (~this~) but rather to the constructor/class name (~Person~).
 - Indeed, in the previous examples we could have accidentally messed-up our world count.
   Now, we get an error if we write ~Person.#world~ outside of the class.

*** Conclusion

   Historically, physicists believed that matter was build of indivisible build
   blocks called /atoms/, then some hundred years later it was discovered that
   atoms are in-fact not atomic but are built from /neutrons, protons/, and
   /electrons/, then some fifty years later it was discovered that neutrons and
   protons are built from so called /quarks/. Similarly, albeit ironically, early
   versions of JavaScript were considered incomplete from an object-oriented
   perspective since they did not have a primitive, atomic, ~class~ construct.
   Akin to physicists, we have seen how JavaScript indeed has classes and is
   thus a full-fledged object-oriented language, only unlike other languages,
   they are not a primitive but a derived construct.

   Unsurprisingly, other features of object-oriented programming can also be
   derived ---and possibly more flexibly than their counterparts in languages
   that take them as primitive. For example, it can be useful to know whether an
   object ùîÅ was derived from a specific class ùìé and so there is the
   abbreviation: ~ùìç instanceof ùìé ‚âà Object.getPrototypeOf(ùìç) == ùìé.prototype~.
   Inheritance is then an abbreviation for using the previously discussed
   ~Object.create(parentPrototype)~ method. Finally, It can be pragmatic to have a
   few technical methods show up in all objects, such as ~toString~, which
   converts an object to a string representation. To accomplish this,
   JavaScript's /standard library/ objects have ~Object.prototype~ as their great
   ancestral prototype. In languages were classes are primitive, ~Object~ is the
   top of the class hierarchy.
   #+BEGIN_SRC js
// ‚ÄúObject‚Äù is maximal
console.log(Object.getPrototypeOf(Object.prototype)); // ‚áí null

// Empty object that *does* derive from ‚ÄúObject‚Äù
let basic = {}
console.log( basic instanceof Object // ‚áí true
           , "toString" in basic)    // ‚áí true

// Empty object that does not derive from ‚ÄúObject‚Äù
let maximal = Object.create(null);
console.log( maximal instanceof Object // ‚áí false
           , "toString" in maximal)    // ‚áí false
 #+END_SRC
 However, since JavaScript's classes are a derived concept, ~Object~ is not the
 /maximum/ class but rather a /maximal/ class: It has no parent class, but is not
 necessarily the parent of all other classes. Indeed, a declaration ~let basic =
 {}~, by default, creates an empty object whose parent is ~Object~ ---so as to have
 the aforementioned useful technical methods. If you pass ~null~ to ~Object.create~,
 as show above, the resulting object will not derive from ~Object~.
 This is exhilarating.

  So objects do more than just hold their own properties. They have prototypes,
  which are other objects. They‚Äôll act as if they have properties they don‚Äôt have
  as long as their prototype has that property.

* TODO The First Choice: What is the target setting?

** What setting are we targeting, why? :ignore:

Programming language communities whose language has an impressive type system,
such as Haskell's, have proverbs such as ‚Äúif it typechecks, ship it!‚Äù Such a
mostly in praise of the language's impressive type system. However, the motto is
not flawless; e.g., consider
cite:epigram_practical_programming_with_dependent_types the Haskell term ~if null
xs then tail xs else xs~ ---it typechecks, but crashes at run time since empty
lists have no (strictly smaller) tail. Dependently typed languages (DTLs)
provide a static means of expressing the significance of particular values in
legitimising some computations rather than others.

Dependent-types provide an immense level of expressivity thereby allowing
varying degrees of precision to be embedded, or omitted, from the type of a
declaration. This overwhelming degree of freedom comes at the cost of common
albeit non-orthogonal styles of coding and compilation, which remain as open
problems that are only mitigated by awkward workarounds such as Coq's
distinction of types and propositions for compilation efficiency. The
difficulties presented by DTLs are outweighed by the opportunities they provide
cite:dtl_why ---of central importance is that they blur distinctions between
usual programming constructs cite:dtls_give_modules, which is in alignment with
our thesis.

#+begin_quote
The /purpose/ of this section is to establish the necessary foundational aspects
of dependently-typed languages (DTLs) by reviewing the existing DTLs and
narrowing on Agda in particular.
#+end_quote

** TODO Existing Systems
 <<<sec:module_existing>>>
 :OldIntro:
 Is there any actual /need/ for the proposed research? Are the goals easily
 adaptable from the simply-typed settings? Is the declared arena of
 dependently-typed languages sufficiently intricate to warrant this much
 attention?

 In this section, we shall outline that DTLs constitute a difficult
 and poorly understood domain in comparison to conventional programming
 languages, such as the purely functional Haskell or the imperative Java.
 Then we outline the merits of including dependent types.
 Finally, we close with a comparison of some of the most popular DTLs.
 :End:

 We want to implement solutions in a dependently typed language. Let us discuss
 which are active and their capabilities.

 To the best of our knowledge, as confirmed by Wikipedia in
 cite:wiki_proof_assistants,wiki_proof_assistants_dependent, there are currently
 less than 15 /actively developed/ dependently-typed languages in-use /that are
 also used/ as proof-assistants ---which are intersting to us since we aim to
 mechanise all of our results: Algorithms as well as theorems.

 # *Matita*
 # last publication was 2012
 # website hasn't been updated since 2016
 # http://matita.cs.unibo.it/index.shtml


 # *NuPRL*
 # https://github.com/jonsterling/JonPRL
 # last touched 2-3 years ago!

 # *PVS*
 # not modified since 2014
 # http://pvs.csl.sri.com/

 # *Twelf* This is a logic programming language, similar to Prolog; it has been
 # used to formalise safety proofs for ‚Äòreal world‚Äô programming languages such
 # as Standard ML. Seems like that
 # Website hasn't been updated since 2009!
 # http://twelf.org/wiki/Main_Page

*** Agda --‚ÄúHaskell on steroids‚Äù
  Agda cite:agda_overview,agda_thesis is one of the more popular proof assistants
  around; possibly due to its syntactic inheritance from Haskell ---as is the case
  with Idris. Its Unicode mixfix lexemes permit somewhat faithful renditions of
  informal mathematics; e.g., calculational proofs can be encoded to be read by
  those unfamiliar with the system. It also allows traditional functional
  programming with the ability to ‚Äòescape under the hood‚Äô and write Haskell code.
  The language has not been designed solely with theorem proving in mind, as is
  the case for Coq, but rather has been designed with dependently-typed
  programming in mind cite:agda_web,agda_plf.

  The current implementation of the Agda language has a notion of second-class
  modules which may contain sub-modules along with declarations and definitions
  of first-class citizens. The intimate relationship between records and modules
  is perhaps best exemplified here since the current implementation provides a
  declaration to construe a record as if it were a module. This change in
  perspective allows Agda records to act as Haskell typeclasses. However, the
  relationship with Haskell is only superficial: Agda's current implementation
  does not support sharing. In particular, a parameterised module is only
  syntactic sugar such that each member of the module actually obtains a new
  functional parameter; as such, a computationally expensive parameter provided
  to a module invocation may be intended to be computed only once, but is
  actually computed at each call site.

*** Coq ---‚ÄúThe standard proof assistant‚Äù

  *Coq cite:coq_implementation,coq_cat_experiences:* Unquestionably one of, if not,
  the most popular proof assistant around. It has been used to produce mechanised
  proofs of the infamous Four Colour Theorem cite:coq_four_colour, the
  Feit-Thompson Theorem cite:coq_feit, and an optimising compiler for the C
  language: CompCert cite:coq_compcert,compcert_paper.

  Unlike Agda, Coq supports tactics cite:tacticstype ---a brute force approach
  that renders (hundredfold) case analysis as child's play: Just refine your
  tactics till all the subgoals are achieved. Ultimately the cost of utilising
  tactics is that a tactical proof can only be understood with the aid of the
  system, and may otherwise be un-insightful and so failing to meet most of the
  purposes of proof cite:purposes_of_proof ---which may well be a large barrier
  for mathematicians who value insightful proofs.

  The current implementation of Coq provides the base features expected of any
  module system. A notable difference from Agda is that it allows to ‚Äúcopy and
  paste‚Äù contents of modules using the ~include~ keyword. Consequently it provides
  a number of module combinators, such as ~<+~ which is the infix form of module
  inclusion cite:coq_manual. Since Coq module types are essentially contexts, the
  module type ~X <+ Y <+ Z~ is really the catenation of contexts, where later items
  may depend on former items. The Maude cite:maude,maude_module_algebra framework
  contains a similar yet more comprehensive algebra of modules and how they work
  with Maude theories.

  As the oldest proof assistant, in a later section we shall compare and contrast
  its module system with Agda's to some depth.

*** Idris ---‚ÄúAgda with tactics‚Äù
  Idris cite:idris_main is a general purpose, functional, programming language
  with dependent types; alongside ATS, below, it is perhaps the only language in
  this list that can truthfully boast to being general purpose and to have
  dependent types. It supports both equational and tactic based proof styles,
  like Agda and Coq respectively; unlike these two however, Idris erases unused
  proof-terms automatically rather than forcing the user to declare this far in
  advance as is the case with Agda and Coq. The only (negligible) downside, for
  us, is that the use of tactics creates a sort of distinction between the
  activities of proving and programming, which is mostly fictitious.
  #
  # Can tactics in Idris be used for programming?
  # They can in Coq, but this is for good reasons strongly discouraged.

  :Irrelevant:
  Moreover, Idris compiles to C whereas Agda compiles to Haskell thereby opening
  the possibility to use GHC's many optimisations without too much translation
  from the source: In contrast, Idris programs must be first transformed to their
  imperative counterparts cite:idris_website,idris_tdd.
  :End:

  Intended to be a more accessible and practical version of Agda, Idris
  implements the base module system features and includes interesting new ones.
  Until [[https://agda.readthedocs.io/en/v2.6.0/language/generalization-of-declared-variables.html][recently]], in Agda, one would write ~module _ (x : ‚Ñï) where ‚ãØ~ to
  parameterise every declaration in the block ‚Äú‚ãØ‚Äù by the name ~x~; whereas in
  Idris, one writes ~parameters (x : ‚Ñï) ‚ãØ~ to obtain the [[http://docs.idris-lang.org/en/latest/tutorial/modules.html][same behaviour]] ---which
  Agda has since improved upon it via ‚Äògeneralisation‚Äô: A declaration's type gets
  only the variables it actually uses, not every declared parameter.

  # http://docs.idris-lang.org/en/latest/tutorial/modules.html

  Other than such pleasantries, Idris does not add anything of note. However, it
  does provide new constraints. As noted earlier, the current implementation of
  Idris attempts to erase implicits aggressively therefore providing speedup over
  Agda. In particular, Idris modules and records can be parameterised but not
  indexed ---a limitation not in Agda.

  Unlike Coq, Idris has been designed to ‚Äúemphasise general purpose programming
  rather than theorem proving‚Äù cite:idris_faq,idris_tdd. However, like Coq, Idris
  provides a Haskell-looking typeclasses mechanism; but unlike Coq, it allows
  named instances. In contrast to Agda's record-instances, typeclasses result in
  backtracking to resolve operator overloading thereby having a slower type
  checker.

  # http://docs.idris-lang.org/en/latest/tutorial/interfaces.html

  # https://github.com/idris-lang/Idris-dev/wiki/Egg-%234:-Agda-style-records-and-modules

*** Lean ---‚ÄúProofs for metaprogramming‚Äù
  # Lean: lean_website,

  Lean cite:lean_system_desc,lean_formalizing_math is both a theorem prover and
  programming language; moreover it permits quotient types and so the
  usually-desired notion of extensional equality. It is primarily tactics-based,
  also permitting a ~calc~-ulational proof format not too dissimilar with the
  standard equational proof format utilised in Agda.

  # In our opinion, it is a nice language but we will remain with Agda since it
  # is a bit older, whence more stable, and it is also more syntactically pleasant.
  # cite:lean_website

  Lean is based on a version of the Calculus of Inductive Constructions, like
  Coq. Lean is heavily aimed at metaprogramming for formal verification, thereby
  bridging the gap between interactive and automated theorem proving.
  Unfortunately, inspecting the language shows that its rapid development is not
  backwards-compatible ---Lean 2 standard libraries have yet to be ported to Lean
  3---, and unlike, for example, Coq and Isabelle which are backed by other
  complete languages, Lean is backed by Lean, which is unfortunately too young to
  program various tactics, for example.

  :Other_remarks_on_Lean:
  The lean prover [[https://leanprover.github.io/introduction_to_lean/][tutorial]] is not even complete!

  It does not seem to be well docmented; only 1 file in the docs!
  It's been difficult finding anything superficially; I may need to install and try things out?
  :End:

*** ATS ---‚ÄúDependent types for systems programming‚Äù

  ATS, the Applied Type System cite:ats_website,ats_combining, is a language that
  combines programming and proving, but is aimed at unifying programming with
  formal specification. With the focus being more on programming than on proving.

  ATS is intended as an approach to practical programming with theorem proving.
  Its module system is largely influenced by that of Modula-3, providing what
  would today be considered the bare bones of a module system. Advocating a
  programmer-centric approach to program verification that syntactically
  intertwines programming and theorem proving, ATS is a more mature relative of
  Idris ---whereas Idris is Haskell-based, ATS is OCaml-based.

  # Unfortunately, ATS proofs are separate from implementation: One writes
  # a function /then/ writes a proof that it meets is specification.

  ATS is remarkable in that its performance is comparable to that of the C
  language, and it supports secure memory management by permitting type safe
  pointer arithmetic. In some regard, ATS is the fusions of Ocaml, C, and
  dependent types. Its module system has less to offer than Coq's.

 # A (Not So Gentle) Introduction To Systems Programming In ATS
 # https://www.youtube.com/watch?v=zt0OQb1DBko

*** F^* ---‚Äúthe immature adult‚Äù
  The F^* cite:fstar_website language supports dependent types, refinement types,
  and a weakest precondition calculus. However it is primarily aimed at program
  verification rather than general proof. Even though this language is roughly
  nine years in the making, it is not mature ---one encounters great difficult in
  doing anything past the initial language tutorial.
  # Language age ~ 9 years

  F^*'s module system is rather uninteresting, predominately acting as namespace
  management. It has very little to offer in comparison to Agda; e.g., within the
  last three years, it obtained a typeclass mechanism ---regardless, typeclasses
  can be simulated as dependent records.

  # The offical tutorial, https://rise4fun.com/fstar/tutorial,
  # gives only one syntactic item to deal with modules:
  # Module       m ::= module M tl1 ... tln ;; e [end]

  # http://complogic.cs.mcgill.ca/beluga/index.html
  #
*** TODO Beluga

  The distinctive feature and sole reason that we mention this language
  is its direct support for first-class contexts cite:beluga.
  A term ~t(x)~ may have free
  variables and so whether it is well-formed or what its type could be depend on the
  types of its free variables, necessitating one to either declare them before hand
  or to write, in Beluga, {{{newline}}} ~[ x : T  |-  t(x) ]~ for example.
  As we have mentioned, and will
  reiterate a few times, contexts are behaviourally indistinguishable from
  dependent sums.

  # Unlike the previously mentioned languages, Beluga provides a
  # dependently-typed language that supports specfiying formal systems in the
  # logical framework LF.

  A displeasure of Beluga is that, while embracing the Curry-Howard Correspondence,
  it insists on two syntactic categories: Data and computation.
  This is similar to Coq's distinction of ~Prop~ and ~Type~.
  Another issue is that to a large degree the terms one uses in their type
  declarations are closed and so have an empty context therefore one sees
  expressions of the form ~[ |- t ]~ since ~t~ is a closed term needing only the empty
  context. At a first glance, this is only a minor aesthetic concern; yet after
  inspection of the language's webpage, tutorials, and publication matter, it is
  concerning that nearly all code makes use of empty contexts ---which are easily
  spotted visually. The tremendous amount of empty contexts suggests that the language
  is not actually making substantial use of the concept, or it is yet unclear what
  pragmatic utility is provided by contexts, and, in either way,
  they might as well be relegated to a less intrusive notation.
  Finally, the language lacks any substantial standard libraries
  thereby rendering it more as a proof of concept rather than a serious system
  for considerable work.

  :Mizar_remarks:
  *Mizar*: Unlike the rest, it is based on (untyped) Tarski‚ÄìGrothendieck set theory
  which in some-sense has a ‚Äòhierarchy of sets‚Äô. Being based on set theory, it is non-constructive. It has a large library of formalised mathematics; like Coq.
  cite:mizar_website, mizar_overview, mizar_library.

  Like Idris, it provide a ‚Äòreservation‚Äô mechanism to name parameters for a block
  of code. Mizar ~environ~-ments are generally difficult to work with due to
  multiple namespaces for articles and vocabularies.
  There is otherwise nothing interesting to say regarding its module system.
  :End:

*** TODO Notable Mentions*
   The following are not actively being developed, as far we can
   tell from their websites or source repositories,
   but are interesting or have made useful contributions.
   In contrast to Beluga, Isabelle is a full-featured language and logical framework that also provides
   support for named contexts in the form of ‚Äòlocales‚Äô cite:locales, isabelle_locales;
   unfortunately it is not a dependently-typed language --though DTLs can be implemented in it.
   Mizar, unlike the above, is based on (untyped) Tarski‚ÄìGrothendieck set theory
   which in some-sense has a hierarchy of sets. Like Coq, it has a large library of formalised mathematics
   cite:mizar_website, mizar_overview, mizar_library.
   Developed in the early 1980s, Nuprl cite:prl_site is constructive with a
   refinement-style logic; besides being a mature language, it has been used to provide
   proofs of problems related to Girard's Paradox cite:girard_paradox.
   PVS, Prototype Verification System cite:pvs_prover, differs from other DTLs
   in its support for subset types; however, the language seems to be unmaintained as of 2014.
   Twelf cite:twelf_site is a logic programming language
   implementing Edinburgh's Logical Framework cite:lf_meta_mechanisation, lf_has_isabelle, lf_fast_proof_checking
   and has been used to prove safety properties of ‚Äòreal languages‚Äô such as SML.
   A notable practical module system cite:lf_practical_modules for Twelf has been implemented using signatures and signature morphisms.
   Matita cite:matita_main, matita_site} is a Coq-like system that is much lighter \parencite{matita_is_coq_light;
   it is been used for the verification of a complexity-preserving C compiler.
   # Matita home page last updated 2017! *Eek!*
   # Twelf home page last updated 2015! *Eek!*

   # https://github.com/jonsterling/JonPRL

   Dependent types are mostly visible within the functional community, however
      this is a matter of taste and culture as they can also be found in imperative
      settings, cite:dtl_imperative, albeit less prominently.
*** TODO Modules in Coq then in Agda

   # The Common Algebraic Specification Language
   # cite:casl_overview,casl_user_manual,casl_reference_manual will also be
   # investigated with the aim of extracting, and generalising, useful module
   # combinators and their properties.
   # #
   # Casl in general: http://www.cofi.info
   # Casl tools: http://hets.dfki.de
   # Casl libraries: http://www.cofi.info/Libraries
   # #
   # Coq <+ sutff: #
   # See https://coq.inria.fr/distrib/V8.7.2/refman/gallina-ext.html#sec90

   :WK_maude:
   Maude is based on rewriting logic,
   which uses term rewrite rules in two roles:
   + as equations, for algebraic specification
   + as (labelled) transitions.

   In the resulting transition systems,
   a ``state'' is an equivalence class of value terms
   modulo the associated set of equations,
   and transitions are rewrites using the second class of rules.

   Theories (and functional modules fmod) can only
   contain equations.
   :End:

   Incidentally, Coq modules are essentially Agda records ---which is unsurprising
   since our thesis states packaging containers are all essentially the same. In
   more detail, both notions coincide with that of a signature ---a sequence of
   pairs of name-type declarations. Where Agda users would speak of a /record
   instance/, Coq users would speak of a /module implementation/. To make matters
   worse, Coq has a notion of records which are far weaker than Agda's; e.g., by
   default all record field names are globally exposed and records are
   non-recursive.

   Coq's module system extends that of Ocaml; a notable divergence is that Coq
   permits parameterised module types ---i.e., parameterised record types, in Agda
   parlance. Such module types are also known as ‚Äòfunctors‚Äô by Coq and Ocaml users;
   which are ‚Äúgenerative‚Äù: Invocations generate new datatypes. Perhaps an example
   will make this rather strange concept more apparent. {{{code(Example of
   Generative Functors)}}}
   #+begin_src haskell
-- Coq                        -- Corresponding Agda

Module Type Unit. End Unit.   -- record Unit : Set where
Module TT <: Unit. End TT.    -- tt : Unit; tt = record {}

Module F (X : Unit).          -- module F (X : Unit) where
  End F.                      --     data t : Set where C : t

Module A := F TT.             -- module A = F tt
Module B := F TT.             -- module B = F tt

Fail Check eq_refl : A.t = B.t. --  ‚â†   eq : A.t ‚â° B.t ; eq = refl
   #+end_src
   As seen, in Coq the inductive types are different yet in Agda they are the same.
   This is because Agda treats such parameterised records, or functors, as
   ‚Äòapplicative‚Äô: They can only be applied, like functions.

   :Coq_code:
   MA: TODO: Where does the ~t~ come from on the Coq side?
   :End:
   :Agda_code:
   record Unit : Set where

   tt : Unit
   tt = record {}

   module F (X : Unit) where
     data t : Set where C : t

   module A = F tt

   module B = F tt

   open import Relation.Binary.PropositionalEquality

   it : A.t ‚â° B.t
   it = refl
   :End:

   For simplicity, we may think of generative functor applications ~F X~ as actually
   ~F X t~ where ~t~ is an implicit tag such as textual position or clock time.
   From an object-oriented programming perspective,
   ~F X~ for a generative functor ~F~ is like the
   ~new~ keyword in Java/C#: A new instance is created
   which is distinct from all other instances even though
   the same class is utilised. So much for the esotericity of generative functors.

   Unlike Agda, which uses records to provide traditional record types, Haskell-like
   typeclasses, and even a module perspective of both, Coq utilises distinct
   mechanisms for typeclasses and canonical structures. In contrast, Agda allows
   named instances since all instances are named and can be provided where an
   implicit failed to be found. Moreover, Coq's approach demands greater familiarity
   with the unifer than Agda's approach.
   # Coq typeclasses are nearly the same as Haskell's.
   # https://softwarefoundations.cis.upenn.edu/qc-current/Typeclasses.html

   # Nifty slides: ‚ÄúWhy Applicative Functors Matter‚Äù
   # https://www.cs.ox.ac.uk/ralf.hinze/WG2.8/24/slides/derek.pdf

  --------------------------------------------------------------------------------


   Module systems parameterise proofs and tactics over structures.

   #+BEGIN_SRC coq
(**

1. A ~Module Type~ contains the signature of the abstract structure to work from;
   it lists the ~Parameter~'s and ~Axiom~'s we want to use, possibly along
   with notation declaration to make the syntax easier.
,**)
(**

|      || Signature     | Structure      |
| Coq  || ‚âà module type | ‚âà module       |
| Agda || ‚âà record type | ‚âà record value |
| JavaScript || ‚âà prototype | ‚âà JSON object |

It is perhaps seen most easily in the last entry in the table, that
modules and modules types are essentially the same thing: They are just
partially defined record types. Again there is a difference in the usage intent:

| Concept | Intent |
|---------|--------|
| Module types | Any name may be opaque, undefined. |
| Modules | All names must be fully defined. |

,**)

Module Type Graph.
  Parameter Vertex : Type.
  Parameter Edges : Vertex -> Vertex -> Prop.
  Infix "<=" := Edges : order_scope.
  Open Scope order_scope.
  Axiom loops : forall e, e <= e.
  Parameter decidable : forall x y, {x <= y} + {not (x <= y)}.
  Parameter connected : forall x y, {x <= y} + {y <= x}.
End Graph.

(* To form an instance of the graph module type, we define a module *)
(* that satisfies the module type signature: The ~<:~ declaration requires *)
(* us to have definitions and theorems with the same names and types *)
(* as those listed in the module type's signature. *)

Require Import Bool.

Module BoolGraph <: Graph.
  Definition Vertex := bool.
  Definition Edges  := fun x => fun y => leb x y.
  Infix "<=" := Edges : order_scope.
  Open Scope order_scope.
  Theorem loops: forall x : Vertex, x <= x.
    Proof.
    intros; unfold Edges, leb; destruct x; tauto.
    Qed.
  Theorem decidable: forall x y, {Edges x y} + {not (Edges x y)}.
    Proof.
      intros; unfold Edges, leb; destruct x, y.
      all: (right; discriminate) || (left; trivial).
  Qed.
  Theorem connected: forall x y, {Edges x y} + {Edges y x}.
    Proof.
      intros; unfold Edges, leb. destruct x, y.
      all: (right; trivial; fail) || left; trivial.
  Qed.
End BoolGraph.

(*
Now we can write a ‚Äúmodule functor‚Äù: A module that takes some ~Module Type~ parameters. E.g., here is a module that define a minimum function.

Min is a function-on-modules; the input type is Graph
and the output module type is ‚ÄúSig Definition min : ‚ãØ. Parameter case_analysis: ‚ãØ. End‚Äù. This is similar to JavaScript's approach.
,*)
Module Min (G : Graph).
  Import G. (* I.e., open it so we can use names in unquantifed form. *)
  Definition min a b : Vertex := if (decidable a b) then a else b.
  Theorem case_analysis: forall P : Vertex -> Type, forall x y,        (x <= y -> P x) -> (y <= x -> P y) -> P (min x y).
  Proof.
    intros. (* P, x, y, and hypothesises H‚ÇÄ, H‚ÇÅ now in scope*)
    (* Goal: P (min x y) *)
    unfold min. (* Rewrite ‚Äúmin‚Äù according to its definition. *)
    (* Goal: P (if decidable x y then x else y) *)
    destruct (decidable x y). (* Pattern match on the result of ‚Äúdecidable‚Äù. *)
    (* Subgoal 1: P x  ---along with new hypothesis H‚ÇÉ : x ‚â§ y *)
    tauto. (* i.e., modus ponens using H‚ÇÅ and H‚ÇÉ *)
    (* Subgoal 2: P y  ---along with new hypothesis H‚ÇÉ : ¬¨ x ‚â§ y *)
    destruct (connected x y).
    (* Subgoal 2.1: P y ---along with new hypothesis H‚ÇÑ : x ‚â§ y *)
    absurd (x <= y); assumption.
    (* Subgoal 2.2: P y ---along with new hypothesis H‚ÇÑ : y ‚â§ x *
    )
    tauto. (* i.e., modus ponens using H‚ÇÇ and H‚ÇÑ *)
  Qed.
End Min.

(* We may now apply the module functor. *)

Module Conjunction := Min BoolGraph.
Export Conjunction.
Print min.
(*
min =
fun a b : BoolGraph.Vertex => if BoolGraph.decidable a b then a else b
     : BoolGraph.Vertex -> BoolGraph.Vertex -> BoolGraph.Vertex
 ,*)

(*
Unlike the previous functor, which had its return type inferred, we may
explicitly declare a return type. E.g., the following functor is
a Graph ‚Üí Graph function.
,*)
Module Dual (G : Graph) <: Graph.
  Definition Vertex := G.Vertex.
  Definition Edges  x y : Prop := G.Edges y x.
  Definition loops := G.loops.
  Infix "<=" := Edges : order_scope.
  Open Scope order_scope.
  Theorem decidable: forall x y, {x <= y} + {not (x <= y)}.
    Proof.
      unfold Edges. pose (H := G.decidable). auto.
  Qed.
  Theorem connected: forall x y, {Edges x y} + {Edges y x}.
    Proof.
      unfold Edges.  pose (H := G.connected). auto.
  Qed.
End Dual.

(* Example use, with renaming ‚Äúmin ‚Ü¶ max‚Äù *)
Module Max (G : Graph).
  (* Module applications cannot be chained; intermediate modules must be named. *)
  Module DualG   := Dual G.
  Module Flipped := Min DualG.
  Import G.
  Definition max := Flipped.min.
  Definition max_case_analysis:
        forall P : Vertex -> Type, forall x y,
        (y <= x -> P x) -> (x <= y -> P y) -> P (max x y)
        := Flipped.case_analysis.
End Max.

(*
See the ModuleSystemTutorial in Github coq/coq:
https://github.com/coq/coq/wiki/ModuleSystemTutorial
,*)


(* ---------------------------------------------------------------------------- *)

(* Coq has generative modules: Each application produces a new datatype instance. *)
Module Type Unit. End Unit. (* Empty signature. *)
Module TT <: Unit. End TT.  (* Empty structure. *)
Module F (X : Unit).
  Inductive t : Type := MakeT.
End F.

Module A := F TT.
Module B := F TT.
Fail Check eq_refl : A.t = B.t.
Print A.t.

Module Type Carrier. Parameter t : Type. End Carrier.
Module Nat <: Carrier. Definition t := nat. End Nat.

Module Type Morphism (X : Carrier) <: Carrier. Parameter t : Type. End Morphism.
Module Identity (X : Carrier) <: Morphism X. Definition t := X.t. End Identity.

Module Alias  (X : Carrier). Module M := X. End Alias.
Module AtNat  (F : Morphism). Module M := F Nat. End AtNat.

Module N := Alias Nat.
Print N.M.t.
(* N.M.t = Nat.t
     : Type

Modules Œ∑-expand and so aliasing does nothing.
 ,*)

Module O := AtNat Identity.
Print O.M.t.
(*
[ O.M.t : Type ] ; i.e., an opaque type

Type of functors do not Œ∑-reduce, and as such one cannot expect them to be applicative, and so are generative ^_^

See coq/coq OpenIssuesWithModules: https://github.com/coq/coq/wiki/OpenIssuesWithModules
 ,*)
   #+END_SRC

   Now the Agda equivalent.
   #+BEGIN_SRC agda2
open import Relation.Nullary {- Decidablity! -}
open import Data.Empty
open import Data.Sum
open import Data.Bool renaming (_‚â§_ to leb)
open import Data.Bool.Properties
--
--  f‚â§t : false ‚â§ true
--  b‚â§b : ‚àÄ {b} ‚Üí b ‚â§ b

record Graph : Set‚ÇÅ where
  field
    Vertex : Set
    _‚ü∂_  : Vertex ‚Üí Vertex ‚Üí Set
    loops  : ‚àÄ {e} ‚Üí e ‚ü∂ e
    decidable : ‚àÄ x y ‚Üí Dec (x ‚ü∂ y)
    connected : ‚àÄ x y ‚Üí (x ‚ü∂ y) ‚äé (y ‚ü∂ x)

BoolGraph : Graph
BoolGraph = record
              { Vertex = Bool
              ; _‚ü∂_ = leb
              ; loops = b‚â§b
              {- I only did the case analysis, the rest was ‚Äúauto‚Äù. -}
              ; decidable = Œª{ true  true  ‚Üí yes b‚â§b
                             ; true  false ‚Üí no (Œª ())
                             ; false true  ‚Üí yes f‚â§t
                             ; false false ‚Üí yes b‚â§b }
              {- I only did the case analysis, the rest was ‚Äúauto‚Äù. -}
              ; connected = Œª{ true true   ‚Üí inj‚ÇÅ b‚â§b
                             ; true false  ‚Üí inj‚ÇÇ f‚â§t
                             ; false true  ‚Üí inj‚ÇÅ f‚â§t
                             ; false false ‚Üí inj‚ÇÅ b‚â§b }
              }

record Min (G : Graph) : Set where
  open Graph G

  min : Vertex ‚Üí Vertex ‚Üí Vertex
  min x y with decidable x y
  ...| yes _  = x
  ...| no  _  = y

  case-analysis : ‚àÄ {P : Vertex ‚Üí Set} {x y}
                ‚Üí (x ‚ü∂ y  ‚Üí  P x)
                ‚Üí (y ‚ü∂ x  ‚Üí  P y)
                ‚Üí P (min x y)
  case-analysis {P} {x} {y} H‚ÇÄ H‚ÇÅ with decidable x y | connected x y
  ... | yes x‚ü∂y | _          = H‚ÇÄ x‚ü∂y
  ... | no ¬¨x‚ü∂y | inj‚ÇÅ x‚ü∂y = ‚ä•-elim (¬¨x‚ü∂y x‚ü∂y)
  ... | no ¬¨x‚ü∂y | inj‚ÇÇ y‚ü∂x = H‚ÇÅ y‚ü∂x

open Min

open import Relation.Binary.PropositionalEquality

Conjunction = Min BoolGraph

uip : ‚àÄ (p q : Conjunction) ‚Üí p ‚â° q
uip record {} record {} = refl

_ : Bool ‚Üí Bool ‚Üí Bool
_ = min I where I : Conjunction; I = record {}

Dual : Graph ‚Üí Graph
Dual G = let open Graph G in record
           { Vertex    = Vertex
           ; _‚ü∂_       = Œª x y ‚Üí  y ‚ü∂ x
           ; loops     = loops
           ; decidable = Œª x y ‚Üí decidable y x
           ; connected = Œª x y ‚Üí connected y x
           }

record Max (G : Graph) : Set where
  open Graph G
  private
    Flipped = Min (Dual G)
    I : Flipped
    I = record {}

  max : Vertex ‚Üí Vertex ‚Üí Vertex
  max = min I

  max-case-analysis : ‚àÄ {P : Vertex ‚Üí Set} {x y}
                ‚Üí (y ‚ü∂ x  ‚Üí  P x)
                ‚Üí (x ‚ü∂ y  ‚Üí  P y)
                ‚Üí P (max x y)
  max-case-analysis = case-analysis I
   #+END_SRC

** TODO A Whirlwind Tour of Agda
*** Intro :ignore:

Agda
cite:why_dependent_types_matter,dependent_matching_is_just_K,curry_howard,agda_plf
is based on @@latex:Martin-L{\"o}f's@@ intuitionistic type theory. By
identifying types with terms, the type of small types is a larger type; e.g., ~‚Ñï
‚à∂ Set‚ÇÄ~ and ~Set·µ¢ ‚à∂ Set·µ¢‚Çä‚ÇÅ~ ---the indices ~i~ are called /levels/ and the small type
~Set‚ÇÄ~ is abbreviated as ~Set~. In some regard, Agda adds /harmonious/ support for
dependent types to Haskell.

Unlike most languages, Agda not only allows arbitrary mixfix Unicode lexemes,
identifiers, but their use is encouraged by the community as a whole. Almost
anything can be a valid name; e.g., ~[]~ and ~_‚à∑_~ to denote list constructors
---underscores are used to indicate argument positions. Hence it's important to
be liberal with whitespace: ~e‚à∂œÑ~ is a valid identifier whereas ~e ‚à∂ œÑ~ declares ~e~
to be of type ~œÑ~. Agda's Emacs interface allows entering Unicode symbols in
traditional LaTeX-style; e.g., ~\_7, \McN, \to, ~\::~ are replaced by ~‚Çá, ùí©, ‚Üí, ‚à∑~.
Moreover, the Emacs interface allows programming by gradual refinement of
incomplete type-correct terms. One uses the ‚Äúhole‚Äù marker ~?~ as a placeholder
that is used to stepwise write a program.

*** Dependent Functions

  A /dependent function type/ has those functions whose result /type/ depends on the
  /value/ of the argument. If ~B~ is a type depending on a type ~A~, then ~(a ‚à∂ A) ‚Üí B a~
  is the type of functions ~f~ mapping arguments ~a ‚à∂ A~ to values ~f a ‚à∂ B a~.
  Vectors, matrices, sorted lists, and trees of a particular height are all
  examples of dependent types. One also sees the notations ~‚àÄ (a ‚à∂ A) ‚Üí B a~ and ~Œ†
  a ‚à∂ A ‚Ä¢ B a~ to denote dependent types.

  For example, /the/ generic identity function takes as /input/ a type ~X~ and returns
  as /output/ a function ~X ‚Üí X~. Here are a number of ways to write it in Agda.
  #+BEGIN_SRC agda :tangle AgdaReview.agda
id‚ÇÄ : (X : Set) ‚Üí X ‚Üí X
id‚ÇÄ X x = x

id‚ÇÅ id‚ÇÇ id‚ÇÉ : (X : Set) ‚Üí X ‚Üí X

id‚ÇÅ X = Œª x ‚Üí x
id‚ÇÇ   = Œª X x ‚Üí x
id‚ÇÉ   = Œª (X : Set) (x : X) ‚Üí x
  #+END_SRC

  All these functions explicitly require the type ~X~ when we use them, which is
  silly since it can be inferred from the element ~x~. Curly braces make an
  argument /implicitly inferred/ and so it may be omitted. E.g., the ~{X ‚à∂ Set} ‚Üí ‚ãØ~
  below lets us make a polymorphic function since ~X~ can be inferred by inspecting
  the given arguments. This is akin to informally writing $\mathsf{id}_X$ versus
  $\mathsf{id}$.

  #+latex: \begin{parallel}
  #+BEGIN_SRC agda
id : {X : Set} ‚Üí X ‚Üí X
id x = x

sad : ‚Ñï
sad = id‚ÇÄ ‚Ñï 3

nice : ‚Ñï
nice = id 3
  #+END_SRC
  #+latex: \columnbreak
  #+BEGIN_SRC agda
explicit : ‚Ñï
explicit = id {‚Ñï} 3

explicit‚Ä≤ : ‚Ñï
explicit‚Ä≤ = id‚ÇÄ _ 3
  #+END_SRC
  #+latex: \end{parallel}

  #+latex: \vspace{-1em}
  Notice that we may provide an implicit argument /explicitly/ by enclosing the
  value in braces in its expected position. Values can also be inferred when the
  ~_~ pattern is supplied in a value position. Essentially wherever the typechecker
  can figure out a value ---or a type---, we may use ~_~. In type declarations, we
  have a contracted form via ~‚àÄ~ ---which is *not* recommended since it slows down
  typechecking and, more importantly, types /document/ our understanding and it's
  useful to have them explicitly.

  In a type, ~(a : A)~ is called a /telescope/ and they can be combined for convenience.
  #
  #+latex: \begin{parallel}
  #+BEGIN_EXAMPLE agda
   {x : _} {y : _} (z : _) ‚Üí ‚ãØ
‚âà  ‚àÄ {x y} z ‚Üí ‚ãØ
  #+END_EXAMPLE
  #+latex: \columnbreak
  #+BEGIN_EXAMPLE agda
   (a‚ÇÅ : A) ‚Üí (a‚ÇÇ : A) ‚Üí (b : B) ‚Üí ‚ãØ
‚âà  (a‚ÇÅ a‚ÇÇ : A) (b : B) ‚Üí ‚ãØ
  #+END_EXAMPLE
  #+latex: \end{parallel} \vspace{-1.5em}

*** Dependent Datatypes

  Algebraic datatypes are introduced with a ~data~ declaration, giving the name,
  arguments, and type of the datatype as well as the constructors and their
  types. Below we define the datatype of lists of a particular length.

  #+BEGIN_SRC agda
data Vec {‚Ñì : Level} (A : Set ‚Ñì) : ‚Ñï ‚Üí Set ‚Ñì where
  []  : Vec A 0
  _‚à∑_ : {n : ‚Ñï} ‚Üí A ‚Üí Vec A n ‚Üí Vec A (1 + n)
  #+END_SRC

 Notice that, for a given type ~A~, the type of ~Vec A~ is ~‚Ñï ‚Üí Set~. This means that
 ~Vec A~ is a family of types indexed by natural numbers: For each number ~n~, we
 have a type ~Vec A n~. One says ~Vec~ is /parametrised/ by ~A~ (and ‚Ñì), and /indexed/ by
 ~n~. They have different roles: ~A~ is the type of elements in the vectors, whereas
 ~n~ determines the ‚Äòshape‚Äô ---length--- of the vectors and so needs to be more
 ‚Äòflexible‚Äô than a parameter.

 Notice that the indices say that the only way to make an element of ~Vec A 0~ is to
 use ~[]~ and the only way to make an element of ~Vec A (1 + n)~ is to use ~_‚à∑_~.
 Whence, we can write the following safe function since ~Vec A (1 + n)~ denotes
 non-empty lists and so the pattern ~[]~ is impossible.
 #+BEGIN_SRC agda
head : {A : Set} {n : ‚Ñï} ‚Üí Vec A (1 + n) ‚Üí A
head (x ‚à∑ xs) = x
 #+END_SRC

 The ~‚Ñì~ argument means the ~Vec~ type operator is /universe polymorphic/: We can make
 vectors of, say, numbers but also vectors of types. Levels are essentially
 natural numbers: We have ~lzero~ and ~lsuc~ for making them, and ~_‚äî_~ for taking the
 maximum of two levels. /There is no universe of all universes:/ ~Set‚Çô~ has type
 ~Set‚Çô‚Çä‚ÇÅ~ /for any n/, however the /type/ ~(n : Level) ‚Üí Set n~ is /not/ itself typeable
 ---i.e., is not in ~Set‚Çó~ for any ~l~--- and Agda errors saying it is a value of
 ~Setœâ~.

 Functions are defined by pattern matching, and must cover all possible cases.
 Moreover, they must be terminating and so recursive calls must be made on
 structurally smaller arguments; e.g., ~xs~ is a sub-term of ~x ‚à∑ xs~ below and
 catenation is defined recursively on the first argument. Firstly, we declare a
 /precedence rule/ so we may omit parenthesis in seemingly ambiguous expressions.
 #+BEGIN_SRC agda
infixr 40 _++_

_++_ : {A : Set} {n m : ‚Ñï} ‚Üí Vec A n ‚Üí Vec A m ‚Üí Vec A (n + m)
[]       ++ ys  =  ys
(x ‚à∑ xs) ++ ys  =  x ‚à∑ (xs ++ ys)
 #+END_SRC
 Notice that the *type encodes a useful property*: The length of the catenation is
 the sum of the lengths of the arguments.
*** The Curry-Howard Correspondence ---‚ÄúPropositions as Types‚Äù

     Agda is a programming language and a proof assistant. A proposition is
     proved by writing a program of the corresponding type.


     #+macro: twolines @@latex:\begin{tabular}[l]{@{}l@{}}$1\\$2\end{tabular}@@
     #+macro: hfill @@latex:\hfill@@

     #+caption: Programming and proving are two sides of the same coin
     # +latex: \vspace{-1em}
     | *Logic*                  | *Programming*                           | Example Use in Programming                                                  |
     |------------------------+---------------------------------------+-----------------------------------------------------------------------------|
     | proof / proposition    | element / type                        | ‚Äú$p$ is a proof of $P$‚Äù ‚âà ‚Äú$p$ is of type $P$‚Äù                              |
     |------------------------+---------------------------------------+-----------------------------------------------------------------------------|
     | $true$                 | singleton type                        | return type of side-effect only methods                                     |
     | $false$                | empty type                            | return type for non-terminating methods                                     |
     |------------------------+---------------------------------------+-----------------------------------------------------------------------------|
     | ‚áí                      | function type  {{{hfill}}}   ‚Üí        | methods with an input and output type                                       |
     | ‚àß                      | product type   {{{hfill}}}  √ó         | simple records of data and methods                                          |
     | ‚à®                      | sum type       {{{hfill}}} +          | enumerations or tagged unions                                               |
     |------------------------+---------------------------------------+-----------------------------------------------------------------------------|
     | ‚àÄ                      | dependent function type {{{hfill}}} Œ† | return type varies according to input /value/                           |
     | ‚àÉ                      | dependent product type {{{hfill}}}  Œ£ | record fields depend on each other's /values/                               |
     |------------------------+---------------------------------------+-----------------------------------------------------------------------------|
     | natural deduction      | type system                           | ensuring only ‚Äúmeaningful‚Äù programs                                         |
     | hypothesis             | free variable                         | global variables, closures                                                  |
     |------------------------+---------------------------------------+-----------------------------------------------------------------------------|
     | modus ponens           | function application                  | executing methods on arguments                                              |
     | ‚áí-introduction         | Œª-abstraction                         | {{{twolines(parameters acting as local variables, to method definitions)}}} |
     |------------------------+---------------------------------------+-----------------------------------------------------------------------------|
     | {{{twolines(induction;, elimination rules)}}} | Structural recursion                  | ~for~-loops are precisely ‚Ñï-induction |

     Let's augment the table a bit to relate concepts that we shall refer to in
     later sections.
     | *Logic*                   | *Programming*                                 |
     | Signature, term         | Syntax; interface, record type, ~class~       |
     | Algebra, Interpretation | Semantics; implementation, instance, object |
     | Free Theory             | Data structure                              |
     | Inference rule          | Algebraic datatype constructor              |
     | Monoid                  | Untyped programming / composition           |
     | Category                | Typed programming / composition             |

*** Propositional Equality

    #+latex: \hspace{-1.3em}
  An example of propositions-as-types is a definition of the identity relation
  ---the least reflexive relation. For a type ~A~ and an element ~x~ of ~A~, we define
  the family of proofs of ‚Äúbeing equal to $x$‚Äù by declaring only one inhabitant
  at index ~x~.

  #+latex: \begin{parallel}[2]
  #+BEGIN_SRC agda
data _‚â°_ {A : Set} : A ‚Üí A ‚Üí Set
  where
    refl : {x : A} ‚Üí x ‚â° x
  #+END_SRC
  #+latex: \columnbreak

  This states that ~refl {x}~ is a proof of ~l ‚â° r~ whenever ~l~ and ~r~ simplify, by
  definition chasing only, to ~x~ ---i.e., both ~l~ and ~r~ have ~x~ as their normal
  form.
  #+latex: \end{parallel} \vspace{-1em}

  This definition makes it easy to prove [[https://en.wikipedia.org/wiki/Identity_of_indiscernibles][Leibniz's substitutivity rule]], ‚Äúequals
  for equals‚Äù:
  #+BEGIN_SRC agda
subst : {A : Set} {P : A ‚Üí Set} {l r : A}
      ‚Üí l ‚â° r ‚Üí P l ‚Üí P r
subst refl it = it
  #+END_SRC
  Why does this work? An element of ~l ‚â° r~ must be of the form ~refl {x}~ for some
  canonical form ~x~; but if ~l~ and ~r~ are both ~x~, then ~P l~ and ~P r~ are the /same
  type/. Pattern matching on a proof of ~l ‚â° r~ gave us information about the rest
  of the program's type!

**** COMMENT and Calculational Proofs
  School math classes show calculations as follows.
  :calc:
  #+BEGIN_EXAMPLE agda
  p
‚â°‚ü® reason why p ‚â° q ‚ü©
  q
‚â°‚ü® reason why q ‚â° r ‚ü©
  r
‚àé
  #+END_EXAMPLE
  :End:

  We can treat these pieces as Agda /mixfix/ identifiers and associate to the right
  to obtain: ~p ‚â°‚ü® reason‚ÇÅ ‚ü© (q ‚â°‚ü® reason‚ÇÇ ‚ü© (r ‚àé))~. We can code this up!

  #+latex: \begin{parallel}[2]
  #+BEGIN_SRC agda
infixr 5 _‚â°‚ü®_‚ü©_
infix  6 _‚àé

_‚àé : {A : Set} (a : A) ‚Üí a ‚â° a
_ ‚àé = refl

_‚â°‚ü®_‚ü©_ : {A : Set} (p {q r} : A)
       ‚Üí p ‚â° q ‚Üí q ‚â° r ‚Üí p ‚â° r
_ ‚â°‚ü® refl ‚ü© refl = refl
  #+END_SRC
  #+latex: \end{parallel} \vspace{-1em}

*** Modules ---Namespace Management

    #+latex: \hspace{-1.3em}
  Agda modules are not a first-class construct, yet.
  + Within a module, we may have nested module declarations.
  + All names in a module are public, unless declared ~private~.
  #
  #+latex: \begin{parallel}[4]
  _A Simple Module_
  #+latex: \vspace{0.5em}
  #+BEGIN_SRC agda
module M where

  ùí© : Set
  ùí© = ‚Ñï

  private
    x : ‚Ñï
    x = 3

  y : ùí©
  y = x + 1
  #+END_SRC
  #+latex: \columnbreak
  _Using It_
  #+latex: \vspace{0.5em}
  #+BEGIN_SRC agda
use‚ÇÄ : M.ùí©
use‚ÇÄ = M.y

use‚ÇÅ : ‚Ñï
use‚ÇÅ = y
  where open M
  #+END_SRC

  #+BEGIN_EXAMPLE agda

open M

use‚ÇÇ : ‚Ñï
use‚ÇÇ = y
  #+END_EXAMPLE
  #+latex: \columnbreak
  _Parameterised Modules_
  #+latex: \vspace{0.5em}
  #+BEGIN_SRC agda
module M‚Ä≤ (x : ‚Ñï)
  where
    y : ‚Ñï
    y = x + 1
  #+END_SRC
  #+latex: \vfill
  _Names¬†are¬†Functions_
  #+latex: \vspace{0.2em}
  #+BEGIN_SRC agda
exposed : (x : ‚Ñï)
        ‚Üí ‚Ñï
exposed = M‚Ä≤.y
  #+END_SRC
  #+latex: \columnbreak

  _Using Them_
  #+latex: \vspace{0.5em}
  #+BEGIN_SRC agda
use‚Ä≤‚ÇÄ : ‚Ñï
use‚Ä≤‚ÇÄ = M‚Ä≤.y 3

module M‚Ä≥ = M‚Ä≤ 3

use‚Ä≥ : ‚Ñï
use‚Ä≥ = M‚Ä≥.y

use‚Ä≤‚ÇÅ : ‚Ñï
use‚Ä≤‚ÇÅ = y
  where
    open M‚Ä≤ 3
  #+END_SRC

  #+latex: \end{parallel}

  + Public names may be accessed by qualification or by opening them locally or globally.
  + Modules may be parameterised by arbitrarily many values and types ---but not by other modules.

  Modules are essentially implemented as syntactic sugar: Their declarations are treated
  as top-level functions that takes the parameters of the module as extra arguments.
  In particular, it may appear that module arguments are ‚Äòshared‚Äô among their declarations,
  but this is not so.

  ‚ÄúUsing Them‚Äù:
  + This explains how names in parameterised modules are used: They are treated as functions.
  + We may prefer to instantiate some parameters and name the resulting module.
  + However, we can still ~open~ them as usual.

**** COMMENT Anonymous Modules and Variables

  Anonymous modules correspond to named-then-immediately-opened modules,
  and serve to approximate the informal phrase ‚Äúfor any ~A ‚à∂ Set~ and ~a ‚à∂ A~, we have ‚ãØ‚Äù.
  This is so [[https://people.inf.elte.hu/divip/AIMXXVIII.pdf][common]] that the ~variable~ keyword was introduced and it's [[https://agda.readthedocs.io/en/v2.6.0.1/language/generalization-of-declared-variables.html][clever]]:
  Names in ~‚ãØ~ are functions of /only/ those ~variable~-s they actually mention.

  #+latex: \begin{parallel}
  #+BEGIN_EXAMPLE agda
   module _ {A : Set} {a : A} ‚ãØ
‚âà
   module T {A : Set} {a : A} ‚ãØ
   open T
  #+END_EXAMPLE
  #+latex: \columnbreak
  #+BEGIN_EXAMPLE agda
variable
  A : Set
  a : A
‚ãØ
  #+END_EXAMPLE
  #+latex: \end{parallel} \vspace{-1em}

**** Module Keywords                                                 :ignore:

  When opening a module, we can control which names are brought into scope with
  the ~using, hiding,~ and ~renaming~ keywords.
  | ~open M hiding (ùìÉ‚ÇÄ; ‚Ä¶; ùìÉ‚Çñ)~               | Essentially treat ~ùìÉ·µ¢~ as private      |
  | ~open M using  (ùìÉ‚ÇÄ; ‚Ä¶; ùìÉ‚Çñ)~               | Essentially treat /only/ ~ùìÉ·µ¢~ as public  |
  | ~open M renaming (ùìÉ‚ÇÄ to ùìÇ‚ÇÄ; ‚Ä¶; ùìÉ‚Çñ to ùìÇ‚Çñ)~ | Use names ~ùìÇ·µ¢~ instead of ~ùìÉ·µ¢~ |

  Splitting a program over several files will improve type checking performance,
  since when you are making changes the type checker only has to check the files
  that are influenced by the change.
  + ~import X.Y.Z~: Use the definitions of module ~Z~ which lives in file ~./X/Y/Z.agda~.
  + ~open M public~: Treat the contents of ~M~ as if they were public contents of the current module.

*** Records

    A record type is declared much like a datatype where the fields are indicated
    by the ~field~ keyword. The nature of records is summarised by the following
    equation.

    | ~record~ | ‚âà | ~module~ +  ~data~ with one constructor |

  #+latex: \begin{parallel}
  #+BEGIN_SRC agda
record PointedSet : Set‚ÇÅ where
  constructor MkIt  {- Optional -}
  field
    Carrier : Set
    point   : Carrier

  {- It's like a module,
  we can add derived definitions -}
  blind : {A : Set} ‚Üí A ‚Üí Carrier
  blind = Œª a ‚Üí point
  #+END_SRC
  #+latex: \columnbreak
  #+BEGIN_SRC agda
ex‚ÇÄ : PointedSet
ex‚ÇÄ = record {Carrier = ‚Ñï; point = 3}

ex‚ÇÅ : PointedSet
ex‚ÇÅ = MkIt ‚Ñï 3

open PointedSet

ex‚ÇÇ : PointedSet
Carrier ex‚ÇÇ = ‚Ñï
point   ex‚ÇÇ = 3
  #+END_SRC
  #+latex: \end{parallel} \vspace{-1em}

  Start with ~ex‚ÇÇ = ?~, then in the hole enter ~C-c C-c RET~ to obtain the /co-pattern/
  setup. Two tuples are the same when they have the same components, likewise a
  record is defined by its projections, whence /co-patterns/. If you're using many
  local definitions, you likely want to use co-patterns!

  To allow projection of the fields from a record, each record type comes with a
  module of the same name. This module is parameterised by an element of the
  record type and contains projection functions for the fields.

  #+latex: \begin{parallel}
  #+BEGIN_SRC agda
use‚Å∞ : ‚Ñï
use‚Å∞ = PointedSet.point ex‚ÇÄ
  #+END_SRC
  #+BEGIN_EXAMPLE agda
use¬π : ‚Ñï
use¬π = point where open PointedSet ex‚ÇÄ
  #+END_EXAMPLE
  # Spec since this clashes with the previous open.
  #+BEGIN_SRC agda
open PointedSet

use¬≤ : ‚Ñï
use¬≤ = blind ex‚ÇÄ true
  #+END_SRC
  #+latex: \columnbreak

 #+macro: newline @@latex: \newline@@

  You can even pattern match on records {{{newline}}} ---they're just ~data~ after
  all!
  #+latex: \vspace{1em}
  #+BEGIN_SRC agda
use¬≥ : (P : PointedSet) ‚Üí Carrier P
use¬≥ record {Carrier = C; point = x}
  = x

use‚Å¥ : (P : PointedSet) ‚Üí Carrier P
use‚Å¥ (MkIt C x)
  = x
  #+END_SRC
  #+latex: \end{parallel} \vspace{-1em}

 So much for records.

*** Interacting with the real world ---Compilation, Haskell, and IO
    :PROPERTIES:
    :header-args: :tangle "CompilingAgda.agda" :comments org
    :CUSTOM_ID: agda-interacting-with-the-real-world
    :END:

  # C-c C-v C-t tangles the following code into CompilingAgda.agda.
  # Then we may compile the result using:
  # (shell-command "NAME=CompilingAgda; time agda --compile $NAME.agda; ./$NAME")
  #
  # Btw: (find-file "./MAlonzo/Code/CompilingAgda.hs")

  In order to be useful, a program must interact with the real world. Agda
  relegates the work to Haskell. The only concept here that is used in later
  sections will be Agda's ~do~-syntax, and so the purpose of this section is to
  demonstrate how to use it in a real scenario.

  An Agda program module containing a ~main~ function is compiled into a standalone
  executable with ~agda --compile myfile.agda~. If the module has no main file, use
  the flag ~--no-main~. If you only want the resulting Haskell, not necessarily an
  executable program, then use the flag ~--ghc-dont-call-ghc~.

  The type of ~main~ should be ~Agda.Builtin.IO.IO A~, for some ~A~; this is just a
  proxy to Haskell's ~IO~. We may ~open import IO.Primitive~ to get /this/ ~IO~, but this
  one works with costrings, which are a bit awkward. Instead, we use the standard
  library's wrapper type, also named ~IO~. Then we use ~run~ to move from ~IO~ to
  ~Primitive.IO~; conversely one uses ~lift~.

  #+latex: \begin{minipage}[c]{0.55\linewidth}
  #+latex: \begin{tiny}
  #+BEGIN_SRC agda
open import Data.Nat                 using (‚Ñï; suc)
open import Data.Nat.Show            using (show)
open import Data.Char                using (Char)
open import Data.List as L           using (map; sum; upTo)
open import Function                 using (_$_; const; _‚àò_)
open import Data.String as S         using (String; _++_; fromList)
open import Agda.Builtin.Unit        using (‚ä§)
open import Codata.Musical.Colist    using (take)
open import Codata.Musical.Costring  using (Costring)
open import Data.BoundedVec.Inefficient as B using (toList)
open import Agda.Builtin.Coinduction using (‚ôØ_)
open import IO as IO                 using (run ; putStrLn ; IO)
import IO.Primitive as Primitive
  #+END_SRC
  #+latex: \end{tiny}
  #+latex: \end{minipage} % no space if you would like to put them side by side
  #+latex: \begin{minipage}[c]{0.5\linewidth}
  #+begin_quote org
  /Agda has *no* primitives for side-effects, instead it allows arbitrary/
  /Haskell functions to be imported as axioms, whose definitions are only/
  /used at run-time./
  #+end_quote
  #+latex: \end{minipage}

  Agda lets us use ~do~-notation as in Haskell. To do so, methods named ~_>>_~ and
  ~_>>=_~ need to be in scope ---that is all. The type of ~IO._>>_~ takes two ‚Äúlazy‚Äù
  IO actions and yield a non-lazy IO action. The one below is a homogeneously
  typed version.
  #+BEGIN_SRC agda
infixr 1 _>>=_ _>>_

_>>=_ : ‚àÄ {‚Ñì} {Œ± Œ≤ : Set ‚Ñì} ‚Üí IO Œ± ‚Üí (Œ± ‚Üí IO Œ≤) ‚Üí IO Œ≤
this >>= f = ‚ôØ this IO.>>= Œª x ‚Üí ‚ôØ f x

_>>_ : ‚àÄ{‚Ñì} {Œ± Œ≤ : Set ‚Ñì} ‚Üí IO Œ± ‚Üí IO Œ≤ ‚Üí IO Œ≤
x >> y = x >>= const y
  #+END_SRC

  Oddly, Agda's standard library comes with ~readFile~ and ~writeFile~, but the
  symmetry ends there since it provides ~putStrLn~ but not [[https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:getLine][~getLine~]]. Mimicking the
  ~IO.Primitive~ module, we define /two/ versions ourselves as proxies for Haskell's
  ~getLine~ ---the second one below is bounded by 100 characters, whereas the first
  is not.
  #+BEGIN_SRC agda
postulate
  getLine‚àû : Primitive.IO Costring

{-# FOREIGN GHC
  toColist :: [a] -> MAlonzo.Code.Codata.Musical.Colist.AgdaColist a
  toColist []       = MAlonzo.Code.Codata.Musical.Colist.Nil
  toColist (x : xs) =
    MAlonzo.Code.Codata.Musical.Colist.Cons x (MAlonzo.RTE.Sharp (toColist xs))
#-}

{- Haskell's prelude is implicitly available; this is for demonstration. -}
{-# FOREIGN GHC import Prelude as Haskell #-}
{-# COMPILE GHC getLine‚àû  = fmap toColist Haskell.getLine #-}

-- (1)
-- getLine : IO Costring
-- getLine = IO.lift getLine‚àû

getLine : IO String
getLine = IO.lift
  $ getLine‚àû Primitive.>>= (Primitive.return ‚àò S.fromList ‚àò B.toList ‚àò take 100)
  #+END_SRC
  We obtain ~MAlonzo~ strings, then convert those to colists, then eventually lift
  those to the wrapper ~IO~ type.

  Let's also give ourselves Haskell's ~read~ method.
  #+BEGIN_SRC agda
postulate readInt  : L.List Char ‚Üí ‚Ñï
{-# COMPILE GHC readInt = \x -> read x :: Integer  #-}
  #+END_SRC

  Now we write our ~main~ method.
  #+BEGIN_SRC agda
main : Primitive.IO ‚ä§
main = run do putStrLn "Hello, world! I'm a compiled Agda program!"

              putStrLn "What is your name?"
              name ‚Üê getLine

              putStrLn "Please enter a number."
              num ‚Üê getLine
              let tri = show $ sum $ upTo $ suc $ readInt $ S.toList num
              putStrLn $ "The triangle number of " ++ num ++ " is " ++ tri

              putStrLn "Bye, "
              -- IO.putStrLn‚àû name  {- If we use approach (1) above. -}
              putStrLn $ "\t" ++ name
  #+END_SRC
  For example, the 12·µó ∞ [[https://en.wikipedia.org/wiki/Triangular_number][triangle number]] is $\sum_{i=0}^{12} i = 78$.
  Interestingly, when an integer parse fails, the program just crashes.

  Calling this file ~CompilingAgda.agda~, we may compile then run it with:
  #+BEGIN_SRC shell :tangle no
NAME=CompilingAgda; time agda --compile $NAME.agda; ./$NAME
  #+END_SRC

  The very first time you compile may take ‚àº80 seconds since some prerequisites
  need to be compiled, but future compilations are within ‚àº10 seconds. The
  generated Haskell source lives under the newly created MAlonzo directory;
  namely ~./MAlonzo/Code/CompilingAgda.hs~.

  # *Debugging*
  - When compiling you may see an error ~Could not find module ‚ÄòNumeric.IEEE‚Äô~.
  - Simply open a terminal and install the necessary Haskell library:
    #+BEGIN_SRC shell :tangle no
cabal install ieee754
  #+END_SRC

*** COMMENT Other Agda features

  #+latex: \begin{tiny}
  #+BEGIN_SRC agda :tangle AgdaReview.agda
module AgdaReview where

open import Level using (Level)
open import Data.Nat
open import Data.Bool hiding (_<?_)
open import Data.List using (List; []; _‚à∑_; length)
  #+END_SRC
  #+latex: \end{tiny} \columnbreak

  + Different types can have the same constructor names.

  + Mixifx operators can be written prefix by having all underscores mentioned; e.g.,
    ~x ‚à∑ xs~ is the same as ~_‚à∑_ x xs~.

  + In a function definition, if you don't care about an argument
    and don't want to bother naming it, use ~_~ with whitespace around it.
    This is the ‚Äúwildcard pattern‚Äù.

**** Absurd Patterns

   #+latex: \hspace{-1.3em}
   When there are no possible constructor patterns, we may match on the pattern ~()~
   and provide no right hand side ---since there is no way anyone could provide an argument
   to the function.

   For example, here we define the datatype family of numbers smaller than a given natural number:
   ~fzero~ is smaller than ~suc n~ for any ~n~, and if ~i~ is smaller than ~n~ then ~fsuc i~ is smaller
   than ~suc n~.

   #+latex: \begin{parallel}
   #+BEGIN_SRC agda
{- Fin n  ‚âÖ  numbers i with i < n -}
data Fin : ‚Ñï ‚Üí Set where
  fzero : {n : ‚Ñï} ‚Üí Fin (suc n)
  fsuc  : {n : ‚Ñï}
        ‚Üí Fin n ‚Üí Fin (suc n)
   #+END_SRC
   #+latex: \columnbreak

   For each $n$, the type ~Fin n~ contains $n$ elements;
   e.g., ~Fin 2~ has elements ~fsuc fzero~ and ~fzero~,
   whereas ~Fin 0~ has no elements at all.

   #+latex: \end{parallel} \vspace{-1em}

   Using this type, we can write a safe indexing function that never ‚Äúgoes out of bounds‚Äù.
   #+BEGIN_SRC agda

_‚Äº_ : {A : Set} {n : ‚Ñï} ‚Üí Vec A n ‚Üí Fin n ‚Üí A
[] ‚Äº ()
(x ‚à∑ xs) ‚Äº fzero  = x
(x ‚à∑ xs) ‚Äº fsuc i = xs ‚Äº i
   #+END_SRC

   When we are given the empty list, ~[]~, then ~n~ is necessarily ~0~,
   but there is no way to make an element of type ~Fin 0~ and so we have the absurd pattern.
   That is, since the empty type ~Fin 0~ has no elements there is nothing to define
   ---we have a definition by /no cases/.

   Logically [[https://en.wikipedia.org/wiki/Principle_of_explosion][‚Äúanything follows from false‚Äù]] becomes the following program:
   #+BEGIN_SRC agda
data False : Set where

magic : {Anything-you-want : Set} ‚Üí False ‚Üí Anything-you-want
magic ()
   #+END_SRC

   Starting with ~magic x = ?~ then casing on ~x~ yields the program above
   since there is no way to make an element of ~False~
   ---we needn't bother with a result(ing right side), since there's no way to make
   an element of an empty type.

***** Preconditions as proof-object arguments

   Sometimes it is not easy to capture a desired precondition in the types, and
   an alternative is to use the following ~isTrue~-approach of passing around
   explicit proof objects.

   #+latex: \begin{parallel}
   #+BEGIN_SRC agda
{- An empty record has only
   one value: record {} -}
record True : Set where

isTrue : Bool ‚Üí Set
isTrue true  = True
isTrue false = False
   #+END_SRC
   #+latex: \columnbreak
   #+BEGIN_SRC agda
_<‚ÇÄ_ : ‚Ñï ‚Üí ‚Ñï ‚Üí Bool
_ <‚ÇÄ zero      = false
zero <‚ÇÄ suc y  = true
suc x <‚ÇÄ suc y = x <‚ÇÄ y
   #+END_SRC
   #+latex: \end{parallel} \vspace{-1em}

   #+BEGIN_SRC agda
find : {A : Set} (xs : List A) (i : ‚Ñï) ‚Üí isTrue (i <‚ÇÄ length xs) ‚Üí A
find [] i ()
find (x ‚à∑ xs) zero pf    = x
find (x ‚à∑ xs) (suc i) pf = find xs i pf

head‚Ä≤ : {A : Set} (xs : List A) ‚Üí isTrue (0 <‚ÇÄ length xs) ‚Üí A
head‚Ä≤ [] ()
head‚Ä≤ (x ‚à∑ xs) _ = x
   #+END_SRC

   Unlike the ~_‚Äº_~ definition, rather than there being no index into the empty list,
   there is no proof that a natural number ~i~ is smaller than 0.

**** Mechanically Moving from ~Bool~ to ~Set~ ---Avoiding ‚ÄúBoolean Blindness‚Äù

     #+latex: \hspace{-1.3em}
   In Agda we can represent a proposition as a type whose elements denote proofs
   of that proposition. Why would you want this? Recall how awkward it was to request
   an index be ‚Äúin bounds‚Äù in the ~find~ method, but it's much easier to encode this
   using ~Fin~ ---likewise, ~head‚Ä≤~ obtains a more elegant type when the non-empty precondition
   is part of the datatype definition, as in ~head~.

   Here is a simple recipe to go from Boolean functions to inductive datatype families.
   0. Write the Boolean function.
   1. Throw away all the cases with right side ~false~.
   2. Every case that has right side ~true~ corresponds to a new nullary constructor.
   3. Every case that has $n$ recursive calls corresponds to an ~n~-ary constructor.

   Following these steps for ~_<‚ÇÄ_~, from the left side of the page, gives us:

   #+BEGIN_SRC agda
data _<‚ÇÅ_ : ‚Ñï ‚Üí ‚Ñï ‚Üí Set where
  z< : {y : ‚Ñï} ‚Üí zero <‚ÇÅ y
  s< : {x y : ‚Ñï} ‚Üí x <‚ÇÅ y ‚Üí suc x <‚ÇÅ suc y
   #+END_SRC

   To convince yourself you did this correctly, you can prove ‚Äúsoundness‚Äù
   ---constructed values correspond to Boolean-true statements---
   and ‚Äúcompleteness‚Äù ---true things correspond to terms formed from constructors.
   The former is ensured by the second step in our recipe!

   #+BEGIN_SRC agda
completeness : {x y : ‚Ñï} ‚Üí isTrue (x <‚ÇÄ y) ‚Üí x <‚ÇÅ y
completeness {x}     {zero}  ()
completeness {zero}  {suc y} p = z<
completeness {suc x} {suc y} p = s< (completeness p)
   #+END_SRC

   We began with ~completeness {x} {y} p = ?~, then we wanted to case on ~p~
   but that requires evaluating ~x <‚ÇÄ y~ which requires we know the shapes of ~x~ and ~y~.
   /The shape of proofs usually mimics the shape of definitions they use/; e.g., ~_<‚ÇÄ_~ here.

** TODO Facets of Structuring Mechanisms: An Agda Rendition
   :PROPERTIES:
   :header-args: :tangle monoid_renditions.agda :comments link
   :END:
 <<<sec:module_agda>>>
 # JC: - 2.4 really helps situate things, and is in the proper place in the proposal
 # - ditto for 2.5

 :Setup:
 #+begin_src haskell
open import Relation.Binary.PropositionalEquality
open ‚â°-Reasoning

-- Z-notation for sums
open import Level
open import Data.Product using (Œ£ ; proj‚ÇÅ ; proj‚ÇÇ ; _√ó_ ; _,_)
Œ£‚à∂‚Ä¢ : {a b : Level} (A : Set a) (B : A ‚Üí Set b) ‚Üí Set (a ‚äî b)
Œ£‚à∂‚Ä¢ = Œ£
infix -666 Œ£‚à∂‚Ä¢
syntax Œ£‚à∂‚Ä¢ A (Œª x ‚Üí B) = Œ£ x ‚à∂ A ‚Ä¢ B

open import Data.Nat
open import Data.Nat.Properties
 #+end_src
 :End:

 In this section we provide a demonstration that with dependent-types we can show records, direct dependent types, and
 contexts ---which in Agda may be thought of as parameters to a module---
 are interdefinable.
 Consequently, we observe that the structuring mechanisms provided by the current
 implementation of Agda --and other DTLs-- have no real differences aside from those imposed by the language
 and how they are generally utilised.
 More importantly, this demonstration indicates our proposed direction of identifying
 notions of packages is on the right track.

 Our example will be implementing a monoidal interface in each format,
 then presenting /views/ between each format and that of the ~record~ format.
 Furthermore, we shall also construe each as a typeclass,
 thereby demonstrating that typeclasses are, essentially, not only a
 selected record but also a selected /value/ of a dependent type
 ---incidentally this follows from the previous claim that records
 and direct dependent types are essentially the same.

 Recall that the signature of a monoid consists of
 a type ~Carrier~ with a method ~_‚®æ_~ that composes values
 and an ~Id~-entity value.
 With Agda's lack of type-proof discrimination, i.e., its support for the
 Curry-Howard Correspondence, the ‚Äúpropositions as types‚Äù interpretation, we can encode the signature as well as the
 axioms of monoids to yield their theory presentation in the following two ways.
 Additionally, we have the derived result:
 ~Id~-entity can be popped-in and out as desired.

 The following code blocks contain essentially the same content, but
 presented using different notions of packaging. Even though both
 use the ~record~ keyword, the latter is treated as a typeclass
 since the carrier of the monoid is given ‚Äòstatically‚Äô and instance
 search is used to invoke such instances.
 {{{code(Monoids as Agda Records)}}}
 #+BEGIN_SRC haskell
record Monoid-Record : Set‚ÇÅ where
  infixl 5 _‚®æ_
  field
    -- Interface
    Carrier  : Set
    Id       : Carrier
    _‚®æ_      : Carrier ‚Üí Carrier ‚Üí Carrier

    -- Constraints
    lid   : ‚àÄ{x} ‚Üí (Id ‚®æ x) ‚â° x
    rid   : ‚àÄ{x} ‚Üí (x ‚®æ Id) ‚â° x
    assoc : ‚àÄ x y z ‚Üí (x ‚®æ y) ‚®æ z  ‚â°  x ‚®æ (y ‚®æ z)

  -- derived result
  pop-Id·µ£ : ‚àÄ x y  ‚Üí  x ‚®æ Id ‚®æ y  ‚â°  x ‚®æ y
  pop-Id·µ£ x y = cong (_‚®æ y) rid

open Monoid-Record {{...}} using (pop-Id·µ£)
 #+END_SRC

 {{{code(Monoids as Typeclasses)}}}
 #+BEGIN_SRC haskell
record HasMonoid (Carrier : Set) : Set‚ÇÅ where
  infixl 5 _‚®æ_
  field
    Id    : Carrier
    _‚®æ_   : Carrier ‚Üí Carrier ‚Üí Carrier
    lid   : ‚àÄ{x} ‚Üí (Id ‚®æ x) ‚â° x
    rid   : ‚àÄ{x} ‚Üí (x ‚®æ Id) ‚â° x
    assoc : ‚àÄ x y z ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)

  pop-Id-tc : ‚àÄ x y ‚Üí  x ‚®æ Id ‚®æ y  ‚â°  x ‚®æ y
  pop-Id-tc x y = cong (_‚®æ y) rid

open HasMonoid {{...}} using (pop-Id-tc)
 #+END_SRC

 The double curly-braces ~{{...}}~ serve to indicate that
 the given argument is to be found by instance resolution:
 The results for ~Monoid-Record~ and ~HasMonoid~ can be invoked without having to mention a monoid on
 a particular carrier, provided there exists one unique record value
 having it as carrier ---otherwise one must use named instances cite:named_instances.
 Notice that the carrier argument in the typeclasses approach, ‚Äústructure on a carrier‚Äù, is
 an (undeclared) implicit argument to the ~pop-Id-tc~ operation.

 Alternatively, in a DTL we may encode the monoidal interface using dependent products
 *directly* rather than use the syntactic sugar of records.
 The notation ~Œ£ x ‚à∂ A ‚Ä¢ B x~ denotes the type of pairs ~(x , pf)~ where ~x ‚à∂ A~ and ~pf ‚à∂ B x~
 ---i.e., a record consisting of two fields.
 It may be thought of as a constructive analogue to the classical set comprehension {{{newline}}} ~{ x ‚à∂ A‚ùôB x}~.

 {{{code(Monoids as Dependent Sums)}}}
 # ATTR_LATEX: :options fontsize={\fontsize{10}{11}\selectfont}
 #+BEGIN_SRC haskell
-- Type alias
Monoid-Œ£  :  Set‚ÇÅ
Monoid-Œ£  =    Œ£ Carrier ‚à∂ Set
         ‚Ä¢ Œ£ Id ‚à∂ Carrier
         ‚Ä¢ Œ£ _‚®æ_ ‚à∂ (Carrier ‚Üí Carrier ‚Üí Carrier)
         ‚Ä¢ Œ£ lid ‚à∂ (‚àÄ{x} ‚Üí Id ‚®æ x ‚â° x)
         ‚Ä¢ Œ£ rid ‚à∂ (‚àÄ{x} ‚Üí x ‚®æ Id ‚â° x)
         ‚Ä¢ (‚àÄ x y z ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z))

pop-Id-Œ£ : ‚àÄ{{M : Monoid-Œ£}}
               (let Id  = proj‚ÇÅ (proj‚ÇÇ M))
               (let _‚®æ_ = proj‚ÇÅ (proj‚ÇÇ (proj‚ÇÇ M)))
           ‚Üí  ‚àÄ (x y : proj‚ÇÅ M)  ‚Üí  (x ‚®æ Id) ‚®æ y  ‚â°  x ‚®æ y
pop-Id-Œ£ {{M}} x y = cong (_‚®æ y) (rid {x})
             where  _‚®æ_    = proj‚ÇÅ (proj‚ÇÇ (proj‚ÇÇ M))
                rid    = proj‚ÇÅ (proj‚ÇÇ (proj‚ÇÇ (proj‚ÇÇ (proj‚ÇÇ M))))
 #+END_SRC

 Of the renditions thus far, the ~Œ£~ rendering makes it clear that a monoid could have
 any subpart as a record with the rest being dependent upon said record.
 For example, if we had a semigroup type, we could have declared {{{newline}}}
 ~Monoid-Œ£ = Œ£ S ‚à∂ Semigroup ‚Ä¢ Œ£ Id ‚à∂ Semigroup.Carrier S~.
 There are a large number of such hyper-graphs, we have only presented a stratified view
 for brevity. In particular, ~Monoid-Œ£~ is the extreme unbundled version, whereas
 ~Monoid-Record~ is the other extreme, and there is a large spectrum in between --all of which are
 somehow isomorphic; e.g., ~Monoid-Record ‚âÖ Œ£ C ‚à∂ Set ‚Ä¢ HasMonoid C~.
 Our envisioned system would be able to derive any such view at will cite:casl_overview
 and so programs may be written according to one view, but easily repurposed for other
 view with little human intervention.

 :Irrelevant:
 Like a Java ~class~, within the ~record~ we may include derived results
 that are then available to all values, `instances', of the record type.
 Outside the ~record~, further properties may be added, though they now
 require an actual value, instance, to be given.
 :End:

 Instances and their use are as follows.
 One may realise that ~pop-0~ proofs as a form of polymorphism
 ---we will return to package former polymorphism when discussing preliminary research.
 {{{code(Instance Declarations)}}}
 #+BEGIN_SRC haskell
instance
   ‚Ñï-record = record { Carrier = ‚Ñï ; Id = 0 ; _‚®æ_ = _+_
             ; lid =  +-identityÀ° _  ; rid = +-identity ≥ _ ; assoc = +-assoc }

   ‚Ñï-tc : HasMonoid ‚Ñï
   ‚Ñï-tc = record { Id = 0; _‚®æ_ = _+_
         ; lid = +-identityÀ° _ ; rid = +-identity ≥ _ ; assoc = +-assoc }

   ‚Ñï-Œ£ : Monoid-Œ£
   ‚Ñï-Œ£ = ‚Ñï , 0 , _+_ , +-identityÀ° _ , +-identity ≥ _ , +-assoc
 #+END_SRC
 {{{code(No Monoids Mentioned at Use Sites)}}}
 #+BEGIN_SRC haskell
‚Ñï-pop-0·µ£ : ‚àÄ (x y : ‚Ñï) ‚Üí x + 0 + y  ‚â°  x + y
‚Ñï-pop-0·µ£ = pop-Id·µ£

‚Ñï-pop-0-tc : ‚àÄ (x y : ‚Ñï) ‚Üí x + 0 + y  ‚â°  x + y
‚Ñï-pop-0-tc = pop-Id-tc

‚Ñï-pop-0‚Çú : ‚àÄ (x y : ‚Ñï) ‚Üí x + 0 + y  ‚â°  x + y
‚Ñï-pop-0‚Çú = pop-Id-Œ£
 #+END_SRC

 Interestingly, notice that the grouping in ~‚Ñï-Œ£~ is just an unlabelled (dependent) product,
 and so when it is used in ~pop-Id-Œ£~ we project to the desired components.
 Whereas in the ~Monoid-Record~ case we could have projected the carrier by
 ~Carrier M~, now we would write ~proj‚ÇÅ M~.

 :Irrelevant:
 This is nearly identical to the previous implementation and possibly
 simpler due to the lack of the ~record { ‚ãØ }~ clutter required of /labelled products/.
 However, said clutter could have been removed by providing
 a ~constructor~ declaration in the definition of ~Monoid-Record~
 but we have decided not to do so, to make the labelling clear
 and distinct from the unlabelled product presentations.
 :End:

 Observe the lack of informational
 difference between the presentations, yet there is a
 /Utility Difference: Records give us the power to name our projections _*directly*_ with possibly meaningful names./
 Of course this could be achieved indirectly by declaring extra functions; e.g.,
 #+LaTeX: \def\mytitle{Agda}
 #+BEGIN_SRC haskell :tangle no
Carrier‚Çú : Monoid-Œ£ ‚Üí Set
Carrier‚Çú = proj‚ÇÅ
 #+END_SRC
 We will refrain from creating such boiler plate ---that is,
 /records allow us to omit such mechanical boilerplate./

 Finally, let us exhibit views between this form and the ~record~ form.
 #+LaTeX: \def\mytitle{Agda}
 #+BEGIN_SRC haskell
-- Following proves: Monoid-Record  ‚âÖ  Œ£ Set HasMonoid.

to-record-from-usual-type : Monoid-Œ£ ‚Üí Monoid-Record
to-record-from-usual-type (c , id , op , lid , rid , assoc)
  = record { Carrier = c ; Id = id ; _‚®æ_ = op
       ; lid = lid ; rid = rid ; assoc = assoc
       } -- Term construed by ‚ÄòAgsy‚Äô,
         -- Agda's mechanical proof search.

from-record-to-usual-type : Monoid-Record ‚Üí Monoid-Œ£
from-record-to-usual-type M =
  let open Monoid-Record M
  in Carrier , Id , _‚®æ_ , lid , rid , assoc

  {- Essentially moved from record{‚ãØ} to product listing -}
 #+END_SRC

 Furthermore, by definition chasing, ~refl~-exivity, these operations are seen to be inverse of
 each other. Hence we have two faithful non-lossy protocols for reshaping our grouped data.

 In our final presentation, we construe the grouping of the monoidal interface
 as a sequence of ‚Äúvariable : type‚Äù declarations ---i.e., a ‚Äòcontext‚Äô or ‚Äòtelescope‚Äô.
 Since these are not top level items by themselves, in Agda, we take a purely syntactic route
 by positioning them in a ~module~ declaration as follows.

 #+LaTeX: \def\mytitle{Agda}
 #+BEGIN_SRC haskell
module Monoid-Telescope-User
  (Carrier : Set) (Id : Carrier) (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier)
  (lid   : ‚àÄ{x} ‚Üí Id ‚®æ x ‚â° x) (rid : ‚àÄ{x} ‚Üí x ‚®æ Id ‚â° x)
  (assoc : ‚àÄ x y z ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z))
  where

  pop-Id‚Çò : ‚àÄ(x y : Carrier)  ‚Üí  (x ‚®æ Id) ‚®æ y  ‚â°  x ‚®æ y
  pop-Id‚Çò x y = cong (_‚®æ y) (rid {x})
 #+END_SRC

 Notice that this is nothing more than the named fields of ~Monoid-Record~
 squished into six lines. Additionally, if we insert a Œ£ before each name
 we essentially regain the ~Monoid-Œ£~ formulation.
 It seems contexts, at least superficially, are a nice middle ground between
 the previous two formulations.

 As promised earlier, we can regard the above telescope as a record:
 #+LaTeX: \def\mytitle{Agda}
 #+BEGIN_SRC haskell
  record-from-telescope : Monoid-Record
  record-from-telescope
    = record { Carrier = Carrier ; Id = Id ; _‚®æ_ = _‚®æ_
         ; lid = lid ; rid = rid ; assoc = assoc }
 #+END_SRC

 The structuring mechanism ~module~ is not a first class citizen in Agda.
 As such, to obtain the converse view, we work in a parameterised module.
 #+LaTeX: \def\mytitle{Agda}
 #+BEGIN_SRC haskell
module record-to-telescope (M : Monoid-Record) where

  open Monoid-Record M
  -- Treat record type as if it were a parameterised module type,
  -- instantiated with M.

  open Monoid-Telescope-User Carrier Id _‚®æ_ lid rid assoc
 #+END_SRC

 Notice that we just listed the components out ---rather reminiscent of the formulation
 ~Monoid-Œ£~. This observation only increases confidence in our thesis that there is no
 real distinctions of packaging mechanisms in DTLs.

 Undeniably instantiating the telescope approach to monoids for the natural number
 is nothing more than listing the required components.
 #+LaTeX: \def\mytitle{Agda}
 #+BEGIN_SRC haskell
open Monoid-Telescope-User ‚Ñï 0 _+_ (+-identityÀ° _) (+-identity ≥ _) +-assoc
 #+END_SRC

 C.f., the definition of ~‚Ñï-Œ£~: This is nearly the same instantiation with the primary
 syntactical difference being that this form had its arguments separated by spaces rather than commas!
 #+LaTeX: \def\mytitle{Agda}
 #+BEGIN_SRC haskell
‚Ñï-pop‚Çò  : ‚àÄ(x y : ‚Ñï)  ‚Üí  x + 0 + y  ‚â°  x + y
‚Ñï-pop‚Çò  =   pop-Id‚Çò
 #+END_SRC

 Notice how this presentation makes it explicitly clear why we cannot have multiple instances:
 There would be name clashes. Even if the data we used had distinct names, the derived result
 may utilise data having the same name thereby admitting name clashes elsewhere.
 ---This could be avoided in Agda by qualifying names and/or renaming.

 It is interesting to note that this presentation is akin to that of ~class~-es in C#/Java languages:
 The interface is declared in one place, monolithic-ly, as well as all
 derived operations there; if we want additional operations, we create
 another module that  takes that given module as an argument in the
 same way we create a class that inherits from that given class.

 Demonstrating the interdefinablity of different notions
 of packaging cements our thesis that it is essentially utility
 that distinguishes packages more than anything else.
 In particular, explicit distinctions have lead
 to a duplication of work where the same structure is formalised
 using different notions of packaging. In chapter 3 we will show how to avoid
 duplication by coding against a particular ‚Äòpackage former‚Äô rather than a
 particular variation thereof --this is akin to a type former.

* TODO Solution Requirements
   :PROPERTIES:
   :CUSTOM_ID: solution_requirements
   :END:

 From the outset we have proposed a particular approach to resolving
 the needless duplication present in current module systems that are
 utilised in non-dependently-typed languages. Up to this point, we have
 only discussed how our approach could mitigate certain troubles;
 such as a difference of perspectives of modules, or of equivalent
 operations acting on different perspectives of modules.
 We now turn to discussing, in the following subsections, what it is that
 is missing from existing module systems, what one actually wants to
 do with modules, and conclude with a checklist of features that our
 proposed system should meet in order to be considered usable
 and adequate as a thesis-level effort.

*** Missing Features
    :PROPERTIES:
    :header-args: :tangle translate_functions.agda :comments link
    :END:

 Certain mechanically-derivable concepts, such as different perspectives,
 are needlessly delegated to the user by pedestrian packaging systems.
 Besides being tedious and error-prone, the inexpressibility of derivates
 obscures the corresponding general principles underlying them, thus foregoing
 any machine assistance in ensuring any correctness or safety-ness guarantees.
 The desire to pursue a more economical yet powerful packaging system
 follows from our research team's expedited efforts that could have been mechanised .
 We will only mention two such use cases.

 # [[https://www.google.com/search?ei=MeLSXLaTIuqN5wLSsaTwDw&q=derivate&oq=derivate&gs_l=psy-ab.3..0i67j0i10j0j0i10l7.27397.29434..29651...0.0..0.100.195.1j1......0....1..gws-wiz.......0i71j0i7i10i30.ZZBrC21FopE][define derivate]] :: something derived, especially a product obtained chemically from a raw material.
 #
 #
 #       derivates
 #  or   what could be considered as derived views

 \noindent
 *Expressivity:*

 \noindent
 A common pattern that can be seen, for example, in the Agda standard library,
 is of a predicate ensuring desirable properties
 OF its inputs, then of a record containing the inputs as fields along
 with a proof of said predicate. More concretely, suppose we have a binary predicate
 named ~IsSemi~ and the record is named ~Semi~; the predicate form allows us to
 quantify over inputs as in ~‚àÄ x y ‚Üí IsSemi x y ‚Üí ‚ãØ~, in contrast the latter
 approach is intrinsic in nature: ~‚àÄ (s ‚à∂ Semi) ‚Üí ‚ãØ~
 ---contrast this with a mathematician naturally declaring ‚Äúlet ~s~ be a semigroup‚Äù,
 whereas almost never do mathematicians say ‚Äúlet ~x~ be a set and ~y~ be an operation on it that together constitute a semigroup‚Äù.

 At a first glance, it does not seem too troublesome to produce the record
 presentation from the predicate presentation: Simply /repeat all/ the inputs
 under a record declaration along with a proof obligation. However, the
 word ‚Äòrepeat‚Äô already suggests a problem, and ‚Äòall‚Äô suggests another one.
 What if one desires to
 utilise the record associated to the predicate by only packaging certain
 inputs but not others? This is akin to the problem of constructors
 in object-oriented languages: In Java, for example, one uses overloading
 to provide a number of user-written constructors for only a few resonable
 input invocations to construct an object; in contrast, Common Lisp permits
 optional named arguments, and so in one fell swoop, with one user-written,
 constructor, provides all possible combinations of constructor invocations
 ---we are aiming at this level of power and flexibility.
 #
 # WK: [OCaml] permits optional named arguments.

 Lest it's unclear, let's elaborate slightly on the idea.
 :Setup:
 #+begin_src haskell
open import Relation.Binary.PropositionalEquality
open ‚â°-Reasoning

-- Z-notation for sums
open import Level
open import Data.Product using (Œ£ ; proj‚ÇÅ ; proj‚ÇÇ ; _√ó_ ; _,_)
Œ£‚à∂‚Ä¢ : {a b : Level} (A : Set a) (B : A ‚Üí Set b) ‚Üí Set (a ‚äî b)
Œ£‚à∂‚Ä¢ = Œ£
infix -666 Œ£‚à∂‚Ä¢
syntax Œ£‚à∂‚Ä¢ A (Œª x ‚Üí B) = Œ£ x ‚à∂ A ‚Ä¢ B
 #+end_src
 :End:

 A semigroup is an algebraic structure that models (untyped) compositionality:
 It consists of a collection of objects of interests called the ~Carrier~ set,
 and an operation ~_‚®æ_~ to compose existing items to produce new items, and the operation
 is associative.
 Below is a spectrum of ways to bundle up such a structure
 --starting from being completely bundled up all the way to being
 completely exposed.
 {{{code(A value of ‚ÄúSemigroup0‚Äù is an arbitrary semigroup.)}}}
 #+begin_src haskell
-- One extreme: Completely bundled up
record Semigroup0 : Set‚ÇÅ where
  field
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    assoc   : ‚àÄ x y z ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
 #+end_src
 {{{code(A value of ‚ÄúSemigroup1 C‚Äù is a semigroup ‚Äústructure on‚Äù type ‚ÄúC.‚Äù)}}}
 #+begin_src haskell
-- ‚ÄòTypeclass‚Äô on a given Carrier
-- Alternatively: Carrier is known as runtime.
record Semigroup1 (Carrier : Set): Set‚ÇÅ where
  field
    _‚®æ_   : Carrier ‚Üí Carrier ‚Üí Carrier
    assoc : ‚àÄ x y z ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
 #+end_src
 {{{code(A value of ‚ÄúSemigroup2 C op‚Äù is a ‚Äúproof‚Äù that ‚ÄòC‚Äô with ‚Äòop‚Äô forms a semigroup.)}}}
 #+begin_src haskell
-- Two items known at run time --c.f., ‚ÄúIsSemi‚Äù above.
record Semigroup2
 (Carrier : Set)
 (_‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier) : Set where
  field
    assoc : ‚àÄ x y z ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
 #+end_src
 {{{code(The other extreme: Completely unbundled.)}}}
 #+begin_src haskell
-- A value of ‚ÄúSemigroup3 C op pf‚Äù is trivially the empty record, if any,
-- provided ‚Äòpf‚Äô is a proof that ‚ÄòC‚Äô forms a semigroup with ‚Äòop‚Äô.
-- This type is usualy written ‚ÄúŒ£ C ‚à∂ Set ‚Ä¢ Œ£ _‚®æ_ ‚à∂ C ‚Üí C ‚Üí C ‚Ä¢ Œ£ assoc ‚à∂ ‚ãØ‚Äù.
record Semigroup3
 (Carrier : Set)
 (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier)
 (assoc : ‚àÄ x y z ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)) : Set where
  -- no fields
 #+end_src
 Depending on the user's needs, it may be useful to have one form or another.
 Unfortunately they are enslaved to the choices of the library designer,
 or if they deviate then they must produce tedious conversion methods and use
 them to pad all the library methods for the structures.
 Even worse, such back and forth conversions will not only be representation
 shuffling but also wasteful of resources.

 For example, every bijective function $f : A \to B$ furnishes its target $B$ with a semigroup
 structure provided its source $A$ has the structure to begin with.
 Since the statement mentions the carriers of semigroups, it is only natural
 to formulate it an prove it using presentation ~Semigroup1~.
 {{{code(Elementary Properties of Functions)}}}
 #+begin_src haskell
Surjection : ‚àÄ{A B : Set} ‚Üí (A ‚Üí B) ‚Üí Set
Surjection {A} {B} f = ‚àÄ (b : B) ‚Üí Œ£ a ‚à∂ A ‚Ä¢ b ‚â° f a
-- (Œ£ a ‚à∂ A ‚Ä¢ P a) ‚âà { (a, proof) ‚ùô a ‚àà A ‚àß pf is a proof of P(a) }

Injection : ‚àÄ{A B : Set} ‚Üí (A ‚Üí B) ‚Üí Set
Injection {A} {B} f = ‚àÄ {x y} ‚Üí  f x ‚â° f y ‚Üí x ‚â° y
 #+end_src
 {{{code(An Involved Proof That We Would Like to Reuse)}}}
 #+begin_src haskell
translate1 : ‚àÄ{A B} ‚Üí (f : A ‚Üí B) ‚Üí Surjection f ‚Üí Injection f
       ‚Üí Semigroup1 A ‚Üí Semigroup1 B
translate1 f surj inj AS =
  let
    open Semigroup1 AS

    -- x ‚®æ‚Ä≤ y is obtained by applying f to the ‚®æ-composition of the pre-images of x and y.
    infix 5 _‚®æ‚Ä≤_
    _‚®æ‚Ä≤_ = Œª x y ‚Üí let a0 = proj‚ÇÅ (surj x); a1 = proj‚ÇÅ (surj y) in f (a0 ‚®æ a1)

    -- f distributes over ‚®æ turning it into ‚®æ‚Ä≤.
    factor : ‚àÄ {a a‚Ä≤} ‚Üí f a ‚®æ‚Ä≤ f a‚Ä≤ ‚â° f (a ‚®æ a‚Ä≤)
    factor {a} {a‚Ä≤} =
           let ùí∂  , m  = surj (f a)
           ùí∂‚Ä≤ , w  = surj (f a‚Ä≤)
           in
           begin
         f a ‚®æ‚Ä≤ f a‚Ä≤
           ‚â°‚ü® refl ‚ü©
         f (ùí∂ ‚®æ ùí∂‚Ä≤)
           ‚â°‚ü® cong f (cong‚ÇÇ _‚®æ_ (inj (sym m)) (inj (sym w)))  ‚ü©
         f (a ‚®æ a‚Ä≤)
           ‚àé

    distribute : ‚àÄ {a a‚Ä≤} ‚Üí f (a ‚®æ a‚Ä≤) ‚â° f a ‚®æ‚Ä≤ f a‚Ä≤
    distribute {a} {a‚Ä≤} = sym (factor {a} {a‚Ä≤})

  in -- Bundle up ‚®æ‚Ä≤ along with a proof of associtivity
    record { _‚®æ_ = _‚®æ‚Ä≤_; assoc = Œª x y z ‚Üí
     let
    -- Obtain f-pre-images
    a‚ÇÄ , x‚âàfa‚ÇÄ  =  surj x
    a‚ÇÅ , y‚âàfa‚ÇÅ  =  surj y
    a‚ÇÇ , z‚âàfa‚ÇÇ  =  surj z
     in
      {- Tersely, we rewrite along the pre-images,
     factor f, perform the associativity of ‚®æ,
     then distribute f and rewrite along the pre-images.
      -}
       begin
     (x ‚®æ‚Ä≤ y) ‚®æ‚Ä≤ z
       ‚â°‚ü® cong‚ÇÇ _‚®æ‚Ä≤_ (cong‚ÇÇ _‚®æ‚Ä≤_ x‚âàfa‚ÇÄ y‚âàfa‚ÇÅ) z‚âàfa‚ÇÇ ‚ü©
     (f a‚ÇÄ ‚®æ‚Ä≤ f a‚ÇÅ) ‚®æ‚Ä≤ f a‚ÇÇ
       ‚â°‚ü® cong (_‚®æ‚Ä≤ f a‚ÇÇ) factor ‚ü©
     f (a‚ÇÄ ‚®æ a‚ÇÅ) ‚®æ‚Ä≤ f a‚ÇÇ
       ‚â°‚ü® factor ‚ü©
     f ((a‚ÇÄ ‚®æ a‚ÇÅ) ‚®æ a‚ÇÇ)
       ‚â°‚ü® cong f (assoc _ _ _)  ‚ü©
     f (a‚ÇÄ ‚®æ (a‚ÇÅ ‚®æ a‚ÇÇ))
       ‚â°‚ü® distribute ‚ü©
     f a‚ÇÄ ‚®æ‚Ä≤ f (a‚ÇÅ ‚®æ a‚ÇÇ)
       ‚â°‚ü® cong (f a‚ÇÄ ‚®æ‚Ä≤_) distribute ‚ü©
     f a‚ÇÄ ‚®æ‚Ä≤ (f a‚ÇÅ ‚®æ‚Ä≤ f a‚ÇÇ)
       ‚â°‚ü® sym (cong‚ÇÇ _‚®æ‚Ä≤_ x‚âàfa‚ÇÄ (cong‚ÇÇ _‚®æ‚Ä≤_ y‚âàfa‚ÇÅ z‚âàfa‚ÇÇ))  ‚ü©
     x ‚®æ‚Ä≤ (y ‚®æ‚Ä≤ z)
       ‚àé
  }
 #+end_src
 ~translate1~ is a lengthy proof, we could repeat it, or invoke it.
 Since duplication with alteration is error-prone and non-generic,
 we shall aim for the latter.
 {{{code(Conversions are a Nuisance)}}}
 #+begin_src haskell
translate0 : ‚àÄ{B : Set} (AS : Semigroup0) (f : Semigroup0.Carrier AS ‚Üí B)
       ‚Üí Surjection f ‚Üí Injection f
       ‚Üí Semigroup0
translate0 {B} AS f surj inj = record { Carrier = B ; _‚®æ_ = _‚®æ_ ; assoc = assoc }
  where

       -- Repackage ‚ÄòAS‚Äô from a ‚ÄòSemigroup0‚Äô to a ‚ÄòSemigroup1‚Äô
       -- only to immediatley unpack it, so that its contents
       -- are available to be repacked above as a ‚ÄòSemigroup0‚Äô.

       pack : Semigroup1 (Semigroup0.Carrier AS)
       pack = let open Semigroup0 AS
           in record {_‚®æ_ = _‚®æ_; assoc = assoc }

       open Semigroup1 (translate1 f surj inj pack)
 #+end_src
 Observe that ~translate0~ repackages ~AS~ via ~pack~,
 then passes that as an argument to ~translate1~, which in turn unpacks it
 to form a new ~Semigroup0~, which is then unpacked in the
 last line above.
 Regardless of any possible wasteful amount of packing and unpacking of records
 --which may be mitigated via inlining--
 the way ~translate0~ is written is far from ideal;
 whereas ~translate1~ is the appropriate level of abstraction to pose the problem.
 Instead, it would be ideal to write the method at a sufficient level of generality
 such that ~translate0~ and ~translate1~ are, say, polymorphic instances thereof.
 This is what we shall propose in a later section.

 :Relocate_yoneda:
 Moreover, as a stylistic decision, implementers may prefer to view
 an object in either its predicate form ---with the constituents varying---
 or in its record form ---with the constituents fixed---, will all
 library utilities tied to a particular form.
 :End:

 :efficiency_remarks_incomplete:

 *Efficiency:*

 A hallmark of computing is to reduce new problems to ones already considered.
 One realisation of this principle is found in the sharing mechanisms of
 certain lazy languages: In the expression ~let y = f(x) in g(y, y)~,
 the term ~y~ is evaluated once and the result is shared among its multiple
 call sites. This idea comes under the name of /thunks/:
 When we encounter an instance of ~y~ and we need to ‚Äòthink‚Äô
 of its value, we realise we have already ‚Äòthunk‚Äô it.

 # :What:
 Memory is tremendously difficult to reason about {{{remark(reynolds calculus)}}},
 and lazy sharing only compounds to the troubles of garbage collection
 and complexity analysis {{{remark(Haskell)}}}.
 # :End:

 Dependently-typed languages are usually not only utilised for programming
 but generally also for proof; as such, their implementations adhere to
 a particular logic.

 To be completed ‚Ä¶

 :End:

 *Excerption:*

 In order to produce reusable components, theories ---i.e., packages--- are formed
 from existing theories by adding only one new concept at a time. Such an approach
 reduces the possibility of missing a useful structure in the hierarchy, as well
 as provides tremendous generality ---operations can be rendered using the minimal
 interface required rather than one that is overly expressive. This is a common
 scheme when formalising mathematics cite:typeclasses_for_maths,coq_cat_experiences.

 Unfortunately, a common scenario is when one wants to /instantiate/ such a deeply
 nested theory. More concretely, suppose we have the following fine-grained
 hierarchy.
 #+begin_src plantuml :file example_hierarchy.png :exports results :tangle (org-display-inline-images t t)
skinparam defaultTextAlignment center

[*] -> Empty
Empty -> Type
Type -down-> Pointed
Type -> Magma
Magma -> Semigroup
Pointed   -down-> Pointed_Semigroup
Semigroup -down-> Pointed_Semigroup
Pointed_Semigroup -down-> Left_Unital_Semigroup
Pointed_Semigroup -down-> Right_Unital_Semigroup
Left_Unital_Semigroup -down-> Monoid
Right_Unital_Semigroup -down-> Monoid

Type : Carrier
Pointed : Carrier, point
Magma : Carrier, binary_op
Semigroup : Carrier, binary_op, associativity

Pointed_Semigroup : Carrier, point, binary_op, associativity
Left_Unital_Semigroup : ‚ü™inherit above‚ü´, left_identity_law
Right_Unital_Semigroup : ‚ü™inherit above‚ü´, right_identity_law

Monoid : Carrier, point, binary_op, associativity, identity_laws

center footer  Example Hierarchy
 #+end_src
 #+RESULTS:
 [[file:example_hierarchy_10.png]]

 If we have the ingredients for a monoid in hand, we are unfortunately first
 required to produce a left or right unital semigroup, which requires us to produce
 a pointed semigroup first, and this regress continues to the base theory, ~Type~.
 Building on semigroups, monoids are a ubiquitous model of compositionality,
 and so this scenario
 happens rather often, in one guise or another. The amount of syntactic noise
 required to produce a simple instantiation is unreasonable: One should not be forced
 to work through the hierarchy if it provides no immediate benefit.
 It is to be noted that this issue does not generally apply to implementations of
 object-oriented class supporting multiple interfaces.
 # or rephrasing the hierarchy to be horizontal and unrelated,
 # so each piece is a typeclass, and we then use multiple class constraints.
 #
 # What about OCaml, F#, F*?

 Even worse, pragmatically speaking, to access a field deep down in a nested structure
 results in overtly lengthy and verbose names. Indeed, in the above example, the monoid
 operation lives at the bottom-most level, we would need to access all the intermediary
 levels to simply refer to it. Such verbose invocations would immediately give way to
 helper functions to refer to fields lower in the hierarchy; yet another opportunity
 for boilerplate to leak in.

 It is interesting to note that diamond hierarchies cannot be trivially eliminated
 when providing fine-grained hierarchies. As such, we make no rash decisions
 regarding limiting them ---and completely forgoe the unreasonable
 possibility of forbidding them.

 A more common example from programming is that of providing monad instances
 in Haskell. Most often users want to avoid tedious case analysis or prefer a
 sequential-style approach to producing programs, so they want to furnish a
 type constructor with a monad instance in order to utilise Haskell's ~do~-notation.
 Unfortunately, this requires an applicative instances, which in turn requires
 a functor instance. However, providing the return-and-bind interface for monads
 allows us to obtain functor and applicative instances.
 Consequently, many users simply provide local names for the return-and-bind
 interface then use that to provide the default implementations for the other
 interfaces. In this scenario, the standard approach is side-stepped by manually
 carrying out a mechanical and tedious set of steps that not only wastes time
 but obscures the generic process and could be error-prone.

 Instead, it would be desirable to ‚Äòflatten‚Äô the hierarchy into a single package,
 consisting of the fields throughout the hierarchy, possibly with default
 implementations, yet still be able to view
 the resulting package at base levels in the hierarchy.
 Another benefit of this approach is that it allows users to utilise the package
 without consideration of how the hierarchy was formed, thereby providing library
 designers with the freedom to alter it in the future.

 # One final benefit is exposition. It happens in academic literature, that an
 # audicance may not be familar with the rudiments of a hierarchy, nor should they
 # be forced to ...

 These features are considered ‚Äòmissing‚Äô since they are reasonably achievable
 in a dependently-typed system ---e.g., the different forms of dependently-typed
 bundling suggest a form of polymorphism.
 Their absence may be due to logistic reasons,
 such as no effort expedited in their direction, or due to issues surrounding
 the logical frameworks of the systems. Which is to blame is an investigation
 matter left to the thesis research.
*** Desirable Features

 Our preliminary research, and personal use with dependently-typed systems,
 has yielded three strongly desirable features of a module system for DTLs.

 *Uniformity:*

 A type alias and a value alias are merely aliases at the end of the day,
 so unlike Haskell, for example, which distinguishes the two, Agda, for example,
 does not. More generally, type families, simple types, type constructors,
 dependent types, etc, collapse into a single category: Dependent types.

 In particular, recall the canonical definition of ‚Äòterm‚Äô:
 {{{code(Grammar for Terms)}}}
 #+begin_src haskell
term ::=  x                    -- variable
      |   f(term_0, ‚Ä¶, term_N) -- function application
 #+end_src
 In pedestrian languages, one distinguishes between /value/ terms and /type/ terms,
 whence the ~t_i~ are constrained to be homogeneously all values or all types.
 In contrast, a dependently-typed languages makes no such limitation, thereby allowing
 the ~t_i~ to be heterogeneous. For example, in a simple type system, ~Maybe (A √ó List B)~
 is a term where all variables, $t_0, t_1 = A, B$, are of the same kind ---types.
 This is not so with the term {{{newline}}} ~Maybe (A √ó Vec B n)~ ---~A~ and ~B~ are types while ~n~ is a number.
 Our aim is not to educate the reader on the power and utility of dependent types;
 we invite the reader to consult any of the existing material cite:dtl_why, agda_overview.
 # This is akin to forming English sentences using only noun phrases,
 # as in ‚ÄúI thanked the man‚Äù, or sentences where the clauses may be of different
 # kinds, as in ‚ÄúI thanked the man who directed me‚Äù which contains noun and adjective
 # clauses.
 #
 # WK: ‚Äúthanked the man‚Äù is a verb phrase.
 #
 # ‚ÄúThe man knows much.‚Äù
 # vs. ‚ÄúThe man who introduced me to Emacs knows much.‚Äù
 #
 # since terms/values and types are in the same syntactic category, all these things really are the same.

 In the same vein, the varying notions of packaging are treated differently
 even though they are isomorphic in certain scenarios or interdefinable in others.
 As such, it would be useful to reduce the syntactic distinction between them.

 *Genericity:*

 Type polymorphism permits us to produce functions written once with type variables
 and have them applied to radically different types. Likewise, it would be desirable
 to write once a generic function on a kind of package and have it operate on
 the many variations of packaging.

 An example of this idea is presented at
 the end of this section, as part of preliminary research.
 In particular, we demonstrate a novel form of generic programming,
 /package polymorphism/: A method is written against a generic notion of container
 and is then applied to derived notions
 ---such as the \texttt{Semigroup}$i$ forms from the previous section.

 *Extensiblity:*

 Systems tend to come with a pre-defined set of operations for built-in constructs;
 the user is left to utilise third-party pre-processing tools, for example, to
 provide extra-linguistic support for common repetitive scenarios they encounter.

 More concretely, a large number of proofs can be discharged by merely pattern
 matching on variables ---this works since the case analysis reduces the proof goal
 into a trivial reflexitivity obligation, for example. The number of cases can
 quickly grow thereby taking up space, which is unfortunate since the proof has
 very little to offer besides verifying the claim. In such cases, a pre-process,
 perhaps an ‚Äúeditor tactic‚Äù, could be utilised to produce the proof in an auxiliary
 file, and reference it in the current file.

 Perhaps more common is the renaming of package contents, by hand.
 For example, when a notion of preorder is defined with relation named ~_‚â§_~,
 one may rename it and all references to it by, say, ~_‚äë_~. Again, a pre-processor
 or editor-tactic could be utilised, but many simply perform the re-write by hand
 ---which is tedious, error prone, and obscures the generic rewriting method.

 It would be desirable to allow packages to be treated as first-class concepts
 that could be acted upon, in order to avoid third-party tools that obscure
 generic operations and leave them out of reach for the powerful typechecker of
 a dependently typed system.

 These features are desirable for working with modules, yet raise a number of
 immediate concerns. For example, uniformity may lead to ambiguous parsing,
 genericity may lead to inefficient execution, and extensibility borders on
 meta-programming thereby leaving the realm of types altogether.
 Possible limitations on these features may result in the thesis efforts
 to implement them in a dependently-typed system, such as Agda.

*** One-Item Checklist for a Candidate Solution

 # WK: 3.3: This section is actually good! ;-)

 An adequate module system for dependently-typed languages should make
 use of dependent-types as much as possible. As such, there is essentially
 one and only one primary goal for a module system to be considered
 reasonable for dependently-typed languages: Needless distinctions should be
 eliminated as much as possible.

 The ‚Äúwrite once, instantiate many‚Äù attitude is well-promoted in functional
 communities predominately for /functions/, but we will take this approach to
 modules as well, beyond the features of, e.g., *ML functors.
 With one package declaration, one should be able to mechanically
 derive data, record, typeclass, product, sum formulations, among many others.
 All operations on the generic package then should also apply to the particular
 package instantiations.

 This one goal for a reasonable solution has a number of important and difficult
 subgoals. The resulting system should be well-defined with a coherent semantic
 underpinning ---possibly being a conservative extension---; it should support the elementary uses
 of pedestrian module systems;
 the algorithms utilised need to be proven correct with a mechanical proof assistant,
 considerations for efficiency cannot be dismissed if the system is to be usable;
 the interface for modules should be as minimal as possible,
 and, finally, a large number of existing use-cases must be rendered tersely
 using the resulting system without jeopardising runtime performance in order to demonstrate its success.
 #
 # At least a convincing case must be made that overhead can be
 # ``compiled away''.

 During the research stage of the thesis, some of the sub-goals may be altered
 radically, dismissed altogether, or new ones brought forth due to implementation
 considerations. However, the one main goal will remain unchanged as it is how
 we have chosen to measure the minimal adequacy for a module system for rich
 settings that include dependent-types.
*** Preliminary Research

 The homogeneous treatment of structuring mechanisms is herein presented using a prototype
 developed using the user-friendly Emacs application framework by means of textual expansion,
 the details of which are largely uninteresting ---suffice it to say, the code is tremendously terse.
 In this section we demonstrates that packaging concepts differ only in their use, leading to a uniform
 syntax of which first-class records are an instance and so the resulting system is homoiconic in nature.
 We introduce fictitious syntax, mostly in red, with its intended Agda elaboration in blue
 ---the users write the red and expect it to behave like the blue; no ‚Äúcode generation‚Äù transpires.

 The reader is advised to remember that the value of a prototype is in the guidance it provides,
 not the implementation itself nor any of its design decisions ---such as using strings in meta-programming
 scenarios. In other words, for the reader, portions of this section may serve as an exercise in foresight and patience.
 ( A brief demonstration of the prototype may be viewed at https://www.youtube.com/watch?v=NYOOF9xKBz8 .)

 :Minimality:
 A prime guiding design decision is
 /try to avoid making any decisions, including unconscious restrictions, unless deemed necessary!/
 :End:

 The initiated reader will quickly notice that our package formers are just theory presentations
 ---a list of name-type pairs. The chosen phrasing is due to the target audience, DTL programmers.
 We are not committed to the name, but unlike the overloaded ‚Äòmodule‚Äô, ‚Äòpackage former‚Äô is a good
 new name without too many meanings. We have not provided full semantics for package formers, but
 we have provided concrete well-defined elaborations to communicate the intent: A package former
 is akin to a type former, it is ‚Äòincomplete‚Äô and does not define a concrete package until a certain
 tag is provided.
 It is part of the thesis effort to investigate which features of our proposed package formers
 break, or become limited, when considered with other language constructs.

 The uniformity in syntax reduces the variety of sub-languages in a dependently-typed language
 by eliminating needless distinctions for notions of containers. The first subsection below
 addresses syntactic similarity, whereas the second tackles computing similarity,
 and we conclude with a brief discussion on foundational concerns.

**** First Observation: Syntactic Similarity for Containers

 Since the prototypical notion of packaging is that of records,
 which are value terms, all, necessarily succeeding, notions of packaging
 ought to be treated uniformly as value types.
 Consequently, variations on packaging should only be signalled by necessary
 keywords, and otherwise should be syntactically indistinguishable.
 That is to say, a ‚Äòvariation‚Äô is a tag identifying what particular
 form of module is desired, such as ~datatype~ for an algebraic data type
 with the declared fields as constructors, or as ~record~ to yield a record structure
 with constituents being the declared fields.

 For example, just as ~List~ is a type-former, we may declare a ‚Äòpackage former‚Äô:
 {{{code(Our first package former)}}}
 #+begin_src haskell
 PackageFormer TermP (v : Variation) : Set where
    Var : Int ‚Üí TermP v
    Add : TermP v ‚Üí TermP v ‚Üí TermP v
  #+end_src

 Note that a package former is just a sequence of names with types and,
 as will be demonstrated later, optional default types.
 It requires a particular ‚Äúinterpretation‚Äù ---possibly user-defined---,
 to produce some notion of package. This is signalled by the ~Variation~
 type, which for brevity contains ~data, record, typeclass~, and a few more
 that we will meet below.

 For example, the ~data~ variation of packaging gives us a
 free data type.
 {{{code(Free data type: Terms are integer variables and addition of terms)}}}
 #+begin_src haskell
TermData = TermP data
{-
‚âÖ  data TermData : Set where
     Var : Int ‚Üí TermData
     Add : TermData ‚Üí TermData ‚Üí TermData
-}
 #+end_src
 In the comment above, we indicate how our fictitious syntax is intended to be elaborated
 into current Agda syntax. Besides syntax, induction principles are also derived:
 Our envisioned system would be able to derive simple, tedious, uninteresting concepts;
 leaving difficult, interesting, ones  for humans to solve.
 For this type, below is the dependently typed eliminator, which in a DTL, corresponds to an induction
 principle.
 {{{code(Free data types also come with an induction principle)}}}
 #+begin_src haskell
{-
   term-data-elim : ‚àÄ {‚Ñì} {R : TermData ‚Üí Set ‚Ñì}
          ‚Üí (base : (n : Int) ‚Üí R (Var n))
          ‚Üí (ind  : ‚àÄ {s t} ‚Üí R s ‚Üí R t ‚Üí R (Add s t))
          ‚Üí (t : TermData) ‚Üí R t

   term-data-elim base ind (Var n)   = base n
   term-data-elim base ind (Add s t) = ind rs rt
      where rs = term-data-elim base ind s
        rt = term-data-elim base ind t
-}
 #+end_src

 The type of the package former, for now, could simply be ~Set~
 ---c.f., the commented-out elaboration which declares ~TermData ‚à∂ Set~.
 However, if we permit a sufficiently small subtyping system, we
 may find it desirable to have the type of a package former be itself
 a package former! Moreover, if package former ~t~ has type package former ~t‚Ä≤~,
 then the user should be able to use ~t~ at the levels ~t ‚à∂ s~
 without too much overhead, where ~s~ is any subtype of ~t~ with ~Set~ being a minimal
 such subtype. These thoughts are hurried and it is the purpose of the thesis
 to investigate what is the appropriate route.

 It is often the case that one begins working with a ~record~ of useful semantic
 data, but then, say, for proof automation, may want to use the associated ~datatype~
 for syntax. The latter should be mechanically derivable, and this is what we aim
 provide with our package formers.
 We will not delve into the relationship between free data types and how, for example,
 their associated catamorphism is necessarily also an interpreter
 ---in the programming languages sense.
 The reader is invited to consult a reference cite:cats_logic_shulman.

 We shall not discuss polymorphism along variations, the ~v~ components above,
 as it is orthogonal to our immediate goals. For example, ~TermP~ could have a field typed
 {{{newline}}} \texttt{TermP (f v) ‚Üí TermP (g v) ‚Üí TermP v},
 where ~f~ and ~g~ are operations on variations.
 Nonetheless, this is a feature that one should be aware of.

 The remaining items instantiate package formers for the usual
 common uses. Including notions of records in item 1;
 an algorithmic sketch underlying the examples of item 1 is presented in item2;
 union types and external, second-class, modules in item 3;
 package former polymorphism in item 4;
 operating on package formers and inheritance in items 5 and 6; then discuss
 how package formers handle the diamond problem in item 7.
 Finally, we close in item 8 by discussing a problem not generally found
 in pedestrian languages and how it is solved using package formers.

***** The Generality of Package Formers ---Products

 To demonstrate the generality of the notion of package formers we shall demonstrate
 how other common forms could be ‚Äòderived‚Äô from the single declaration above.
 It is to be noted that for such a small example, such derived code may be taken for
 granted, however for much larger theories ---for example, a ‚Äúfield‚Äù comes with more than
 20 fields--- the ability to derive different perspectives in a consistent fashion
 is indispensable; especially when the package is refactored.
 More realistically, a symmetric rig groupoid uses about 212 coherence laws cite:rig_computation,
 for which case-splitting, to perform proofs, yields [[https://github.com/JacquesCarette/pi-dual][over 200 goals]] thereby making
 metaprogramming a tempting approach.

 :counting_field_componenets:
 field ‚âÖ ablean group ‚ü∂ Carrier, op, inv, unit, assoc, 2 unit-laws, 2 inverse-laws, comm-law ‚ü∂ 10 laws
       multiplicative monoid ‚ü∂ Carrier, op, unit, assoc, 2 unit-laws ‚ü∂ 6 laws
       the above two carries are identical  ‚ü∂ 1 law
       distributively laws   ‚ü∂ 2 laws
       integrity & div-op & non-zero division ‚ü∂ 3 laws

 Total ‚ü∂ 22 laws
 :end:

 # {{{code(Records; a magma with the integers)}}}
 {{{code(Records)}}}
 #+begin_src haskell
-- An instance of  TermRecord should have a carrier type
-- containing the integers, ‚ÄòVar‚Äô, and supports some binary operation, ‚ÄòAdd‚Äô.
TermRecord = TermP record
{-
‚âÖ   record TermRecord  : Set where
      field
    Carrier : Set
    Var     : Int ‚Üí Carrier
    Add     : Carrier ‚Üí Carrier ‚Üí Carrier
-}
 #+end_src
 In the previous  and following invocations, the name ~Carrier~ is a system internal, for now,
 and can easily be ~renamed~ ---as will be demonstrated later on.
 For now, we adhere to a single-sorted stance: Unless indicated otherwise, a ~Carrier~ will always
 be included. An example of a two-sorted algebraic structure, graphs, is demonstrated at the end of this subsection.

 Built-in names, such as ~Carrier~, are generally not ideal. For example, a machine may provide the
 names ~FourLeggedFeline~ and ~CommutativeIdempotentMonoid~ where a human may prefer ~Cat~ and ~JoinSemilattice~ instead.
 As such, the resulting system, would accept ‚Äòrenaming‚Äô functions to generate names. For now, we mostly limit
 such an approach for brevity.

 {{{code(Haskell-style typeclasses ---or Scala-like traits)}}}
 #+begin_src haskell
TermOn = TermP typeclass
{-
‚âÖ   record TermOn (Carrier : Set) : Set where
      field
    Var     : Int ‚Üí Carrier
    Add     : Carrier ‚Üí Carrier ‚Üí Carrier
-}
 #+end_src
 {{{code(A pair of functions \emph{on} a declared carrier type)}}}
 #+begin_src haskell
TermFunctionsOn = TermP tuples
{-
TermFunctionsOn : Set ‚Üí Set
TermFunctionsOn C = (Int ‚Üí C) √ó (C ‚Üí C ‚Üí C)
-}
 #+end_src
 {{{code(Or the carrier is existential)}}}
 #+begin_src haskell
TermFunctions = TermP Œ£
-- ‚âÖ  TermFunctions  =  Œ£ C ‚à∂ Set  ‚Ä¢  Œ£ Var : Int ‚Üí C  ‚Ä¢  (C ‚Üí C ‚Üí C)
 #+end_src

 Let's show a more intricate yet desirable use.
 {{{code(The interface of non-empty lists, with a dedicated list)}}}
 #+begin_src haskell
PointedSemigroup = TermP record hiding (Var) renaming (Add to _‚®æ_)
             field
               Id     : Carrier
               ‚®æ-assoc : ‚àÄ x y z ‚Üí x ‚®æ (y ‚®æ z) ‚â° (x ‚®æ y) ‚®æ z
{-
‚âÖ   record PointedSemigroup  : Set‚ÇÅ where
      field
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    ‚®æ-assoc : ‚àÄ x y z ‚Üí x ‚®æ (y ‚®æ z) ‚â° (x ‚®æ y) ‚®æ z
-}
 #+end_src

***** Algorithmically Obtaining Elaborated Types
 We have discussed how the generic package formers elaborate
 ---each blue comment indicates a standalone isomorphic Agda rendition---,
 as such it should be unsurprising that the constituents of a package former
 are dependently typed functions /consuming/ each concrete variation in
 its traditional fashion. Let's clarify this idea further.

 {{{code(Our example package former)}}}
 #+begin_src haskell
PackageFormer TermP (v : Variation) : Set where
   Var : Int ‚Üí TermP v
   Add : TermP v ‚Üí TermP v ‚Üí TermP v
 #+end_src

 The ‚Äòtype‚Äô of the first item, for example, is as follows
 ---where ~TermP v~ is rewritten using the above introduced names
 for the sake of clarity.
 {{{code(The types of a constituents of a package former)}}}
 #+begin_src haskell
Var : (v : Variation) ‚Üí Set

{- Datatype constructor -}
Var datatype   =  Int ‚Üí TermData
{- Dependent projection -}
Var record     =  (œÑ : TermRecord) ‚Üí Int ‚Üí TermRecord.Carrier œÑ
Var Œ£          =  (œÑ : TermFunctions) ‚Üí Int ‚Üí proj‚ÇÅ œÑ
{- Parameter of a constraint -}
Var typeclass  =  ‚àÄ{C} {{_ : TermOn C}} ‚Üí Int ‚Üí C
Var tuples     =  ‚àÄ{C} ‚Üí TermFunctionsOn C ‚Üí Int ‚Üí C
‚ãØ
 #+end_src

 An initial glance suggests that this is all ad-hoc; let us demonstrate that
 this is not the case. Suppose there were a method ~ùíØ~ to obtain the user-provided types of
 constituents; e.g., the given ~Var ‚à∂ Int ‚Üí TermP v~ is indistinguishable from {{{newline}}}  ~Var ‚à∂ ùíØ ‚ÄúVar‚Äù (TermP v)~.
 {{{code( Obtaining User-Provided Types ---Under the hood )}}}
 #+begin_src haskell
Constituent = String -- Draft idea, not ideal.

-- ‚ÄúA ‚ü®n‚ü©‚Üí B  ‚âà  A ‚Üí ‚ãØ ‚Üí A ‚Üí B‚Äù with n-many A's.
_‚ü®_‚ü©‚Üí_ : Set ‚Üí ‚Ñï ‚Üí Set ‚Üí Set
A ‚ü® zero   ‚ü©‚Üí B  =  B
A ‚ü® succ n ‚ü©‚Üí B  =  A ‚Üí (A ‚ü® n ‚ü©‚Üí B)

-- Constituents of package formers give rise to ‚ÄúSet ‚ü®n‚ü©‚Üí Set‚Äù functions.
ùíØ : {P : PackageFormer} ‚Üí Constituent P ‚Üí Set ‚ü® arity P ‚ü©‚Üí Set
ùíØ ‚ÄúVar‚Äù X  =  Int ‚Üí X
ùíØ ‚ÄúAdd‚Äù X  =  X ‚Üí X ‚Üí X
 #+end_src
 It is now trivial to reify the above prescription for ~Var~ in a uniformly fashion
 ---namely, ~Var = ùìâùìéùìÖùíÜ ‚ÄúVar‚Äù~.
 {{{code( Providing User-Facing Types ---Under the hood )}}}
 #+begin_src haskell
ùìâùìéùìÖùíÜ : Constituent ‚Üí Variation ‚Üí Set
ùìâùìéùìÖùíÜ c v@datatype  = ùíØ c (TermP v)
ùìâùìéùìÖùíÜ c v@record    = (œÑ : TermP v) ‚Üí ùíØ c ((TermP v).Carrier œÑ)
ùìâùìéùìÖùíÜ c v@Œ£         = (œÑ : TermP v) ‚Üí ùíØ c (proj‚ÇÅ œÑ)
ùìâùìéùìÖùíÜ c v@typeclass = ‚àÄ{C} {{_ : TermP v C}} ‚Üí ùíØ c C
ùìâùìéùìÖùíÜ c v@tuples    = ‚àÄ{C} ‚Üí TermP v C ‚Üí ùíØ c C
‚ãØ
 #+end_src
 For example, invoking this approach we find that ~Add~, on ~TermRecord~'s, is typed {{{newline}}}
 ~ùìâùìéùìÖùíÜ ‚ÄúAdd‚Äù record~, which may be rewritten as {{{newline}}}
 ~(œÑ ‚à∂ TermRecord) ‚Üí TermRecord.Carrier œÑ ‚Üí TermRecord.Carrier œÑ ‚Üí TermRecord.Carrier œÑ~.
 That is, as expected, ~Add~ on records consumes a record value then acts as a binary
 operation on the carrier of said record value. Likewise, we invite the reader
 to check that ~Add~ on algebraic datatype ~TermData~ is typed as a binary constructor.

 Users have access to the elaborated types.
 {{{code(Providing User-Facing Types)}}}
 #+begin_src haskell
 TermP.Var : ‚àÄ{v} ‚Üí ùìâùìéùìÖùíÜ ‚ÄúVar‚Äù v
 TermP.Add : ‚àÄ{v} ‚Üí ùìâùìéùìÖùíÜ ‚ÄúAdd‚Äù v
 #+end_src
 This is particularly useful when one wants to extract such types for re-use elsewhere.
 {{{code(Extracting a single ---possibly complicated--- signature)}}}
 #+begin_src haskell
ListBop = TermP.Add datatype ‚àò List
{-
‚âÖ  ListBop : Set ‚Üí Set
   ListBop C = (List C ‚Üí List C ‚Üí List C)
-}

ConstrainedBop : (Set ‚Üí Set) ‚Üí Set
ConstrainedBop constraint  = TermP.Add typeclass using constraint
{-
‚âÖ ConstrainedBop constraint  =  ‚àÄ{C} ‚Üí constraint C ‚Üí C ‚Üí C ‚Üí C

-- N.B., this would not elaborate without the ‚Äúusing‚Äù.
-- Semantically, ‚ÄúP.x y using z = (P.x y)[P v ‚âî z]‚Äù
-- ‚îÄthe ‚Äúv‚Äù appears from ‚Äú‚àÄ{v}‚Äù above.
-}

SetoidBop = TermP.Add record using Setoid
{-
‚âÖ SetoidBop : Setoid ‚Ñì‚ÇÄ ‚Ñì‚ÇÄ ‚Üí Set
  SetoidBop S = Setoid.Carrier C ‚Üí Setoid.Carrier C ‚Üí Setoid.Carrier C

-- N.B., this would not elaborate if ‚ÄúSectoid.Carrier‚Äù were undefiend.
-}
 #+end_src
 These examples open a flurry of problems.

 At this stage, it is sufficient to have observed what could possibly
 be performed and that it is not without burden.
 We will not attempt to clarify any problem nor propose any solution;
 the thesis effort will contend with these matters further.

***** The Generality of Package Formers ---Sums & Modules

 Thus far we have only discussed products; however
 the proposed general notion of containers should also produce sum types
 and be used in modules ---which are just packages.
 {{{code(At ‚Äúleast one‚Äù of the operations is desired on a declared carrier type)}}}
 #+begin_src haskell
TermFunctionsSumOn = TermP sum
-- ‚âÖ  TermFunctionsSumOn C  =  (Int ‚Üí C) ‚äé (C ‚Üí C ‚Üí C)
 #+end_src

 In general, this yields a disjoint collection of declarations
 where each declaration is itself a Œ£ consisting of the context necessary
 to ensure that the operations are well-defined.

 For modules,
 {{{code(Using our package former \emph{within} another package)}}}
 #+begin_src haskell
  PackageFormer MyDriver (t : TermP record renaming (Carrier to C)) : Set where ‚ãØ
-- ‚âÖ module MyDriver (t : TermRecord[Carrier ‚âî C]) where ‚ãØ
-- ‚âÖ module MyDriver (C : Set) (Var : Int ‚Üí C) (Add : C ‚Üí C ‚Üí C) where ‚ãØ
 #+end_src
 At least two ‚Äòfree‚Äô invocation notations ought to be supplied:
 1. ~MyDriver t~
 2. ~MyDriver type varOp addOp~

 Multifaceted invocations provide a common use case: No overhead to pack or unpack
 the constituents of a type former so the sole purpose of an invocation.
 However, the pragmatic feasibility of such an approach is unclear at this stage.

***** Novel Genericity: ‚ÄòPackage Polymorphism‚Äô

 We have a sufficient number of elaborations thus far to demonstrate
 that the notion of package formers is not without merit.
 It is now an appropriate moment to address an elephant in the room:
 /The phrase ~TermP v~ semantically refers to which type?/

 If ~v = datatype~ then ~TermP v~
 refers to the associated algebraic datatype.
 If ~v = record~, then there are at least two ways to interpret ~TermP v~:
 As either the record type or as the carrier of a record value.
 Likewise for other variations. For now, we settle with a monadic-like interpretation:
 We write ~do œÑ ‚Üê TermP v; ‚ãØ~ whenever we wish to refer to the underlying carrier of a concrete
 package former. Loosely put,
 {{{code(Syntax ---Under the hood )}}}
 #+begin_src haskell
do œÑ ‚Üê TermP v; b  ‚âà  v ‚ï± (Œª œÑ ‚Üí b)

v@datatype  ‚ï± f  =  f (TermP v)
v@record    ‚ï± f  =  ‚àÄ(œÑ : TermP v) ‚Üí f ((TermP v).Carrier œÑ)
v@Œ£         ‚ï± f  =  ‚àÄ(œÑ : TermP v) ‚Üí f (proj‚ÇÅ œÑ)
v@typeclass ‚ï± f  =  ‚àÄ{œÑ} {{_ : TermP v œÑ}} ‚Üí f œÑ
v@tuples    ‚ï± f  =  ‚àÄ{œÑ} ‚Üí TermP v œÑ ‚Üí f œÑ
 #+end_src
 The ‚Äòover‚Äô notation, ~_‚ï±_~, assumes ~f~ is a function acting on types;
 however, this is not necessary, if the ~‚àÄ~ were replaced with ~Œª~, then
 the result would be a term expression. This is yet another opportunity for investigation
 during the thesis effort. Moreover, there is the possibility of providing
 ‚Äúimplicit counterparts‚Äù to these variations,; e.g., for ~tuples~ one may want
 ~‚àÄ{œÑ} {_ ‚à∂ TermP v œÑ} ‚Üí f œÑ~ instead, which could be variation, say, ~tuples-imp~.
 Likewise, we may want notation ~do-Œ£~ to replace {{{newline}}} ~‚àÄ ‚ãØ ‚Üí ‚ãØ~ with ~Œ£ ‚ãØ ‚Ä¢ ‚ãØ~.

 Unsurprisingly, this approach subsumes our earlier typing elaboration: {{{newline}}}
 ~ùìâùìéùìÖùíÜ c v  = do œÑ ‚Üê TermP v; ùíØ c œÑ~.
 More concretely, for example, a notion of ‚Äòdepth‚Äô for terms may have type
 ~‚àÄ {v} ‚Üí  do œÑ ‚Üê TermP v; (œÑ ‚Üí ‚Ñï)~ ---a function
 that takes a package and yields a number.
 In the case of ~v = record~, such a function actually takes /two/
 items: The first being a record value, the second being an element of
 the carrier of that record value. In the case of ~v = typeclass~,
 the function takes an argument found by instance search. Likewise,
 for the remaining variations.

 Let us now turn to an example of a function operating on the above many, and all, variations of such packages.
 This example may appear contrived, yet the power of this form of polymorphism
 appears at the end of this subsection where one programs towards a /particular/
 interface and has the result /generalised/ to other variations
 ---a prime use case is to code against a typeclass representation and use the
 same methods on bundled records.
 {{{code(‚ÄúTimes Loop‚Äù: Iterate an action $n$ times. )}}}
 #+begin_src haskell
-- Suppose I have the following syntactic construction.
repeat : TermData ‚Üí ‚Ñï ‚Üí TermData
repeat t Zero      =  Var 0
repeat t (Succ n)  =  Add t (repeat t n)

-- Here is its semantic counterpart.
run : (œÑ : TermRecord) ‚Üí TermRecord.Carrier œÑ ‚Üí ‚Ñï ‚Üí TermRecord.Carrier œÑ
run œÑ t Zero      =  TermRecord.Var œÑ 0
run œÑ t (Succ n)  =  TermRecord.Add œÑ t (run œÑ t n)

-- Which is merely multiplication for the naturals.
_√ó_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
t √ó Zero     = Zero
t √ó (Succ n) = t + (t √ó n)
 #+end_src

 The first two are instances of a package former, and it is not diffcult to construe the naturals as the carrier of a package former.
 After which, we should be able to write one generic function, by writing according to the pacakge former as the interface.
 {{{code(‚ÄúTimes Loop‚Äù: Iterate an action $n$ times. )}}}
 #+begin_src haskell
instance
  ‚ÑïTerms : TermOn ‚Ñï
  ‚ÑïTerms = record {Var = Œª n ‚Üí 0; Add = _+_}

{- IsConsumer is defined below; ignore for now. -}
exp : ‚àÄ{v} {{_ : IsConsumer v}}  ‚Üí  do œÑ ‚Üê TermP v; œÑ ‚Üí ‚Ñï ‚Üí œÑ
exp t Zero     = Var 0
exp t (Succ n) = Add t (exp t n)
 #+end_src
 For example, we immediately obtain an instance for strings.
 {{{code(‚ÄúTimes Loop‚Äù: Iterate an action $n$ times. )}}}
 #+begin_src haskell
instance
  STerms : TermOn (List Char)
  STerms = record {Var = Œª n ‚Üí []; Add = _++_}

repeat-s = exp {v = typeclass}
{- Yields a whole family, which includes:

   repeat-s0 : {{TermOn (List Char)}} ‚Üí List Char ‚Üí ‚Ñï ‚Üí List Char
   repeat-s0 c Zero = []
   repeat-s0 c (Succ n) = c ++ repeat c n
-}
 #+end_src

 Now that's re-use! One function for many semantically distinct types.
 Notice that invoking ~exp~ on ~ListBop~ or ~TermFunctionsSumOn~ values is ill-typed
 since the mechanically verifiable constraint ~IsConsumer~ fails for those variations.
 Indeed, we may utilise a number of constraints on our package variations, such as
 the following.
 {{{code(Under the hood constraints)}}}
 #+begin_src haskell
data IsConsumer : Variation ‚Üí Set where
  Prod    : IsConsumer tuples
  DepProd : IsConsumer Œ£
  Data    : IsConsumer datatype
  Rec     : IsConsumer record
 #+end_src
 When a user defines a variation, they can signal whether it is a consumer or not.
 Likewise, one can indicate whether a variation should have ~Set~-valued operations
 on not. Note that a default mechanism could be implemented, but the user should
 continue to have the ability to enforce a particular discipline
 ---c.f., how ~C#~ allows the user to enforce the subtyping variance of a type former.
 {{{code(Under the hood constraints)}}}
 #+begin_src haskell
data HasConstructiveRelations : Variation ‚Üí Set where
  Prod    : HasConstructiveRelations tuples
  DepProd : HasConstructiveRelations Œ£
  Rec     : HasConstructiveRelations record
 #+end_src
 For example, ~data~ declarations cannot contain proofs of an arbitrary, but fixed, constructive relation
 without declaring it as a parameter to the type. Nonetheless, a user may want to be
 able to express syntactic statements about such proof terms
 ---say for proof automation--- and they should have the ability to toggle such
 a feature.

 A more important concern is the type of ~exp~: The phrase ~do œÑ ‚Üê TermP v; œÑ ‚Üí ‚Ñï ‚Üí œÑ~
 elaborates to different types according to the value of ~v~, whence to define ~exp~
 it seems necessary to actually pattern match on it to obtain a concrete type, which,
 for example, may contain more arguments. Case analysis on the possible packaging variations
 is far from ideal ---one might as well re-implement the definition only on the cases they
 want rather than all cases. The aim ---to be pursued further in the full thesis effort---
 is to invert the process: /Avoid case analysis in favour of a particularly convenient view./

 This is clarified best by referring to the current prototype language: Lisp.
 Since all data and methods in a lisp are essentially lists, when one prescribes
 how to project a value from a possibly nested datatype, then the same prescription
 essentially directs how to get to the location of that value and so we obtain
 /generic setters/. The following tiny example demonstrates this idea.
 {{{code(Generic Setters in Lisp)}}}
 #+begin_src emacs-lisp
(setq xs '("a" nil (x y z) 12))  ;; Heterogenous list of 4 items.
(cadar (cdaddr xs))              ;; ‚áí y
(setf (cadar (cdaddr xs)) 'woah) ;; xs ‚áí '("a" nil (x woah z) 12))
 #+end_src
 It is this flexibility that we aim to provide to users.
 They code not against a generic variation, but rather along one that
 is the most appropriate task at hand. We would hope that it would not
 be unrealistic to then mechanically derive the other forms from it.
 For example, suppose we wish to define retracts on magmas; rather than
 define the concept for each possible view, we define it once and obtain it
 for other views.
 {{{code(Example Algebra)}}}
 #+begin_src haskell
PackageFormer MagmaP (v : Variation) : Set where
  _‚®æ_ : MagmaP v ‚Üí MagmaP v ‚Üí MagmaP v

MagmaOn = MagmaP typeclass
AMagma  = MagmaP record
 #+end_src

 The ubiquity of magmas ---literally everywhere--- lends itself to recall that
 working with structure, possibly needless structure, may usurp the goals of
 proof cite:purposes_of_proof: No mathematician would naturally say
 /let M be an algebra on set C/ when it suffices to say /let M be an algebra/;
 yet it may be /convenient/ to phrase problems more elegantly when the carrier
 set is mentioned explicitly cite:packaging_mathematical_structures.
 On the other hand,
 having the carrier explicit for the sake of typeclass resolution
 relies on decidable type (non)equality; which may be resonable for a simplly
 typed language but for a DTL type normalisation generally requires non-trivial,
 non-constant, computation.
 Anyhow, as mentioned earlier, bundling data
 is akin to currying or nesting quantifiers, yet is vastly more expensive
 since library designers generally commit early to one form or another;
 in this case {{{newline}}} ~AMagma ‚âÖ Œ£ C : Set ‚Ä¢ MagmaOn C~
 and {{{newline}}}
 ~MagmaOn C ‚âÖ Œ£ M : AMagma ‚Ä¢ M.Carrier ‚â° C~.
 {{{code(Example Operation)}}}
 #+begin_src haskell
retract : ‚àÄ{S T} ‚Üí (f : S ‚Üí T) ‚Üí MagmaOn T ‚Üí MagmaOn S
retract f Tgt = record {_‚®æ_ = Œª x y ‚Üí f x ‚®æ f y} where open MagmaOn Tgt
 #+end_src
 Since ~MagmaOn = MagmaP v~ where ~v = typeclass~, we would ideally be able
 to derive the generic form ---possibly via case analysis.
 {{{code(Variation Generalisation)}}}
 #+begin_src haskell
retract-v : ‚àÄ{v}
      ‚Üí ‚àÄ {S T} (f : S ‚Üí T)
      ‚Üí  do   tgt ‚Üê MagmaP v; tgt ‚â° T  -- Intentionally no parens.
      ‚Üí (do-Œ£ src ‚Üê MagmaP v; src ‚â° S)
retract-v = ‚ãØ -- Unclear at this stage.
 #+end_src
 #  {{_ : HasCarrier v}}
 The record case could, semi-algorithmically, yield:
 {{{code(Verbose Record Case)}}}
 #+begin_src haskell
retract-v {record}  :  ‚àÄ {S T} (f : S ‚Üí T)
            ‚Üí  ‚àÄ (Tgt : AMagma) ‚Üí AMagma.Carrier Tgt ‚â° T
            ‚Üí  Œ£ (Src : AMagma) ‚Ä¢ AMagma.Carrier Src ‚â° S
retract-v {record} {S} {T} f Tgt refl =  record { Carrier = S
                        ;  _‚®æ_ = Œª x y ‚Üí f x ‚®æ f y }
                       , refl
                       where open AMagma Tgt
 #+end_src
 From a usability perspective the trivial proofs should not be present
 and so we need to algorithmically rewrite the above type to omit them, as follows.
 We would like to preserve the argument syntax, ~retract f Tgt~, that was originally declared.
 Unfortunately, for the record case, the type of ~f~ must refer to the types of the other magamas
 if we eliminate the trivial equalities. One possible workaround, as follows, is thus to simply provide
 a omit the tedious equality proofs since they can be found by instance search.
 {{{code(Usable Record Case)}}}
 #+begin_src haskell
retract-v {record}  :  ‚àÄ {S T} (f : S ‚Üí T)
            ‚Üí  ‚àÄ (Tgt : AMagma) ‚¶É_ : AMagma.Carrier Tgt ‚â° T ‚¶Ñ
            ‚Üí  proj‚ÇÅ (‚¶ÉŒ£‚¶Ñ Src : AMagma ‚Ä¢ AMagma.Carrier Src ‚â° S)
retract-v {record} f Tgt  = ‚ãØ

-- ‚Äú‚¶ÉŒ£‚¶Ñ (x : A) ‚Ä¢ B x‚Äù consists of a pair
-- where the second is found by instance search.
 #+end_src
 Notice that we also project at the end since we do not care about the tedious proof;
 nor should its existence be forced upon the user.

 Before we move on, there is particular reason we have deviated from our ~TermP~ example
 to the ~MagmaP~ concept. The ~datatype~ variation for ~MagmaP~ does not provide a way
 to speak of variables of the data type ---indeed ~MagmaP datatype~ has no closed terms,
 whence no terms at all. It is thus appropriate to now introduce a variation for
 syntactic terms /over/ some variable set which is then utilised by a mechanically
 derivable semantic function that is freely homomorphic.

 {{{code(From Syntax to Semantics)}}}
 #+begin_src haskell
MagmaTermsOn = MagmaP term-typeclass
{-
‚âÖ data MagmaTermsOn (Vars : Set) : Set where
    Var : Vars ‚Üí MagmaTermsOn Vars
    _‚®æ_  : MagmaTermsOn Vars ‚Üí MagmaTermsOn Vars ‚Üí MagmaTermsOn Vars

MagmaTermsOn-sem : ‚àÄ {v} {A}  ‚Üí  do œÑ ‚Üê MagmaP v;
                 (f : A ‚Üí œÑ) ‚Üí MagmaTermsOn A ‚Üí œÑ
MagmaTermsOn-sem {record} S f (Var x) = f x
MagmaTermsOn-sem {record} S f (l ‚®æ r)  = ll s‚®æ rr
  where _‚®æs_ = AMagma._‚®æ_ S
    ll = MagmaTermsOn-sem {record} S f l
    rr = MagmaTermsOn-sem {record} S f r
‚ãØ
-}
 #+end_src

 We will return to homomorphisms later on, for now it is important to notice
 that some variations may be useless ---as in the empty datatypes.
 There is also the opportunity to explore co-inductive datatypes.
***** Common Operations on Package Formers
 It is rather common in the record variation to have multiple instances being
 mentioned and it is desirable to refer to them with syntactically distinct yet appealing
 names ---such as using subscripts, primes, or other decoration. Moreover, a notion of
 homomorphism, structure-preservation, can usually be automatically inferred.

 Here we show what such declarations looks like, later we show that such things
 could be /user defined/.

 {{{code(An example package former)}}}
 #+begin_src haskell
PackageFormer TermRelP (v : Variation) : Set where
   Var : Int ‚Üí TermRelP v
   Add : TermRelP v ‚Üí TermRelP v ‚Üí TermRelP v
   Rel : TermRelP v ‚Üí TermRelP v ‚Üí Set  -- This time we have a relation as well.
 #+end_src
 {{{code(A prime-decorated package former)}}}
 #+begin_src haskell
Declare PackageFormer TermRelP (v : Variation) decorated (Œª x ‚Üí x ++ "‚Ä≤")
{-
‚âÖ PackageFormer TermRelP‚Ä≤ (v : Variation) : Set where
   Var‚Ä≤ : Int ‚Üí TermRelP‚Ä≤ v
   Add‚Ä≤ : TermRelP‚Ä≤ v ‚Üí TermRelP‚Ä≤ v ‚Üí TermRelP‚Ä≤ v
   Rel‚Ä≤ : TermRelP‚Ä≤ v ‚Üí TermRelP‚Ä≤ v ‚Üí Set

-- Coherence Meta-property: ‚àÄ v, d  ‚Ä¢  TermRelP v decorated d  ‚âÖ  TermRelP v
-}
 #+end_src
 {{{code(Structure preserving operations)}}}
 #+begin_src haskell
Declare Homomorphism TermRelP (v : Variation)
{-
‚âÖ PackageFormer TermRelP-Homomorphism (v : Variation) : Set where

    Src : TermRelP v   decorated  (Œª x ‚Üí x ++ "‚ÇÅ")
    Tgt : TermRelP v   decorated  (Œª x ‚Üí x ++ "‚ÇÇ")

    map : Src ‚Üí Tgt
    -- Elaborates to ‚ÄúCarrier Src ‚Üí Carrier Tgt‚Äù in ‚Äúrecord‚Äù variation.

    var_preservation : ‚àÄ n   ‚Üí map (Var‚ÇÅ n) ‚â° Var‚ÇÇ n
    add_preservation : ‚àÄ x y ‚Üí map (Add‚ÇÅ x y) ‚â° Add‚ÇÇ (map x) (map y)
    rel_preservation : ‚àÄ x y ‚Üí Rel‚ÇÅ x y ‚Üí Rel‚ÇÇ (map x) (map y)

NB: The ‚Äúdecorated‚Äù annotations are local to the package.
-}
 #+end_src

***** Inheritance & Defaults for Package Formers

 Things get a bit more interesting with multiple packaging,
 fields making use of dependent types, and of (multiple) default implementations.
 Besides defaults, a desirable feature of our envisioned system is the ability to lift definitional extensions
 into fields of the package, say for more efficient implementations.

 {{{code(Recall our example package former)}}}
 #+begin_src haskell
PackageFormer TermP (v : Variation) : Set where
   Var : Int ‚Üí TermP v
   Add : TermP v ‚Üí TermP v ‚Üí TermP v
 #+end_src

 {{{code(All the pieces of \texttt{TermP} but now with additionall new pieces)}}}
 #+begin_src haskell
PackageFormer PreOrderedTermP (v : Variation) : Set  inherits-from (TermP v) where
   Ord   : OrderedTermP v ‚Üí OrderedTermP v ‚Üí Set
   Refl  : ‚àÄ x ‚Üí Ord x x
   Trans : ‚àÄ x y z ‚Üí Ord x y ‚Üí Ord y z ‚Üí Ord x z

   -- Two default ‚Äòimplementations‚Äô

   default‚ÇÅ Ord x y                =  x ‚â° y
   default‚ÇÅ Refl  x                =  refl
   default‚ÇÅ Trans _ _ _ refl refl  =  refl

   default‚ÇÇ Ord x y                =  ‚ä§
   default‚ÇÇ Refl  x                =  tt
   default‚ÇÇ Trans _ _ _ _ _        =  tt
 #+end_src

 Notice how ‚Äúfree type‚Äù formation incorporates this new open-ended
 construct, ~Ord~, as a two-value holder. An alternative interpretation would
 be to eliminate it altogether from the elaborated data declaration.
 Anyhow, since we elaborate a relation as a pair former, proofs for
 such a relation cannot be included ---otherwise it's not a ‚Äúfree‚Äù type!
 {{{code(Derivied ADT from a package former with constructive relations)}}}
 #+begin_src haskell
PreOrderedTermData = PreOrderedTermP data
{-
‚âÖ  data PreOrderedTermData : Set where
     Var : Int ‚Üí OrderedTermData
     Add : PreOrderedTermData ‚Üí PreOrderedTermData ‚Üí PreOrderedTermData
     Ord : PreOrderedTermData ‚Üí PreOrderedTermData ‚Üí PreOrderedTermData

     -- No reflexitivity axiom on ‚ÄòOrd‚Äô, nor transitivity!
-}
 #+end_src
 {{{code(Using a ~default~ implementation)}}}
 #+begin_src haskell
PreOrderedTermData = PreOrderedTermP data with-default‚ÇÅ
{-
‚âÖ  data PreOrderedTermData : Set where
     Var : Int ‚Üí OrderedTermData
     Add : PreOrderedTermData ‚Üí PreOrderedTermData ‚Üí PreOrderedTermData

     -- No ‚ÄòOrd‚Äô construction, but instead a constructive relation and properties:

     Ord : PreOrderedTermData ‚Üí PreOrderedTermData ‚Üí Set
     Ord x y  =  x ‚â° y

     Refl  : ‚àÄ x ‚Üí Ord x x
     Refl  x  =  refl

     Trans : ‚àÄ x y z ‚Üí Ord x y ‚Üí Ord y z ‚Üí Ord x z
     Trans _ _ _ refl refl  =  refl
-}
 #+end_src
 The naming ~Ord, Refl, Trans~ could have been altered to refer to the newly declared data
 type, for simplicity we have avoided such a transformation.
 Moreover, we could reserve ~with-default‚ÇÄ~ to simply omit constructive relations from
 being reified as data constructors.

 {{{code(Keeping the axioms by using a record)}}}
 #+begin_src haskell
PreOrderedTermRecord = PreOrderedTermP record
{-
‚âÖ   record PreOrderedTermRecord : Set where
      field
    Carrier : Set
    Var     : Int ‚Üí Carrier
    Add     : Carrier ‚Üí Carrier ‚Üí Carrier
    Ord     : Carrier ‚Üí Carrier ‚Üí Set
    Refl    : ‚àÄ x ‚Üí Ord x x
    Trans   : ‚àÄ x y z ‚Üí Ord x y ‚Üí Ord y z ‚Üí Ord x z

     -- Notice that the reflexitivity & transitivity axioms are kept!
-}
 #+end_src
 Moreover, the default implementations means we also have the following
 declaration, where distinctions are made by the occurenace, or absence, of fields.
 {{{code(Defaults yield additional elaborations)}}}
 #+begin_src haskell
{-
    record PreOrderedTermRecord : Set where
      field
    Carrier : Set
    Var     : Int ‚Üí Carrier
    Add     : Carrier ‚Üí Carrier ‚Üí Carrier

      Ord     : Carrier ‚Üí Carrier ‚Üí Set
      Ord x y =  x ‚â° y

      Refl    : ‚àÄ x ‚Üí Ord x x
      Refl _ = refl

      Trans   : ‚àÄ x y z ‚Üí Ord x y ‚Üí Ord y z ‚Üí Ord x z
      Trans _ _ _ refl refl = refl
-}
 #+end_src
 Here is our first observation of a uniform presentation of packaging,
 where the ‚Äúintended use‚Äù differs: Whether we want axioms or not?

 Not only is the use amicable, but utilities written for the first elaboration
 effortlessly apply to instances of the second elaboration. Unfortunately,
 the relationship is not symmetric
 ---e.g., using the additional information provided by the default implementations,
  ~‚àÄ x y ‚Üí Ord x y ‚Üí Add x y ‚â° Add y x~ is provable for the latter but
 not the former. As such, there is need to be able to mark results applying
 to a subtype of a package former, or to eliminate such a desirable feature
 that reduces needless distinctions when applying utilties of the former to the
 latter. The thesis will provide a solution with a discussion of the alternatives
 and why they were not adopted.

***** Package Formers Dispense with The Diamond Problem

 Let's consider combining multiple containers.
 {{{code(A package former for unital magmas)}}}
 #+begin_src haskell
Package UnitalTermP (v : Variation) : Set inherits-from (TermP v) where
   unit : UnitalTermP v
   lid  : ‚àÄ x ‚Üí Add unit x ‚â° x
   rid  : ‚àÄ x ‚Üí Add x unit ‚â° x
 #+end_src
 # -- NB: Using ‚ÄúMaybe‚Äù, every ‚ÄúTermP record‚Äù can be converted into a ‚ÄúUnitalTermP record‚Äù.
 {{{code(Inheriting from multiple pacakage formers)}}}
 #+begin_src haskell
Package PreOrderedMonoid (v : Variation) : Set
      inherits-from (UnitalTermP v; PreOrderedTermP v)
  where
   associative : ‚àÄ x y z ‚Üí (Add x y) z ‚â° Add x (Add y z)
   monotone    : ‚àÄ x x' y y' ‚Üí Ord x x' ‚Üí Ord y y' ‚Üí Ord (Add x y) (Add x' y')
 #+end_src
 This package ought to be indistinguishable from the following, whence allowing tremendously flexible
 declarations and uses. In particular, there is no longer a need to distinguish between a hierarchical
 and a flattened perspective, since they are considered identical.
 {{{code(Equivalent backend representation)}}}
 #+begin_src haskell
Package PreOrderedMonoid (v : Variation) : Set where

   unitaltermp : UnitalTermP v
   preorderedtermp : PreOrderedTermP v

   associative : ‚àÄ x y z ‚Üí (Add x y) z ‚â° Add x (Add y z)
   monotone    : ‚àÄ x x' y y' ‚Üí Ord x x' ‚Üí Ord y y' ‚Üí Ord (Add x y) (Add x' y')

   -- From which sub-structure does the above ‚ÄúAdd‚Äù arise?
   --
   -- The ‚Äúrecord‚Äù and ‚Äútypeclass‚Äù variations elaborate with axioms declaring
   -- that identical names are indeed identical operations:
   carrier_coherence : unitaltermp.Carrier ‚â° preorderedtermp.Carrier
   var_coherence     : unitaltermp.Var     ‚â° preorderedtermp.Var
   add_coherence     : unitaltermp.Add     ‚â° preorderedtermp.Add
   --
   -- They also elaborate with default tedious implementations:
   carrier_coherence = refl; var_coherence = refl; add_coherence = refl

   -- Moreover, we can continue the ‚Äòdefault‚Äô implementation.
   default‚ÇÅ monotone _ _ _ _ refl refl = refl
   default‚ÇÇ monotone _ _ _ _ _ _       = tt
 #+end_src

***** Package Formers & Representational Shifts

 Let us close this section by demonstrating how this genericity can aid in
 ubiquitous representational shifts that appear rather often in dependently typed programming.
 In pedestrian languages, there are usually less ways to accomplish a task in
 dependently typed languages and so programming style is not of great concern.
 In contrast, in a DTL, a user could, for example, work over an abstract data type
 where a particular argument is fixed or where it is allowed to vary.
 The two approaches are a matter of style, but can lead to awkward situations.
 # The downside of the former is that we cannot vary, whereas in the latter

 # context shifting; Œª-introduction; ‚áí-theorem.
 #
 More concretely, we consider the bread and buffer of coding: Graphs.
 Without dependent types we can only speak about graphs /over/ a given vertex type,
 with dependent types we can speak about /a/ graph, irrespective of vertex type.
 The former is tantamount to the context ~Vertex ‚à∂ Type ‚ä¢ Edges ‚à∂ Vertex ‚Üí Vertex  ‚Üí Type~,
 and an empty assumption context ~‚ä¢ Vertex ‚à∂ Set, Edges ‚à∂ Vertex ‚Üí Vertex ‚Üí Type~
 for the latter.
 However, the latter form sometimes leads us into contexts where we have two
 graphs ~G~ and ~H~ for which we make the tedious constraint {{{newline}}} ~Vertex G ‚â° Vertex H~.
 It would be less clumsy to explicitly declare the two graphs to be /over/ the
 same vertex type.

 The previous paragraph mentioned a terse dependently-typed presentation of graphs,
 let us use the classic presentation as it may be more familiar to readers.
 {{{code(Graph package former)}}}
 #+begin_src haskell
PackageFormer GraphP (v : Variation) : Set where
  Vertex, Edges : Set
  src, tgt      : Edges ‚Üí Vertex

  -- The dependently typed notion of edges.
  derivied
    _‚ü∂_ : Vertex ‚Üí Vertex ‚Üí Set
    x ‚ü∂ y  =  Œ£ e : Edges  ‚Ä¢  src e ‚â° x  ‚àß  tgt e ‚â° y
 #+end_src

 {{{code(Graphs as records)}}}
 #+begin_src haskell
AGraph = GraphP record renaming (Carrier to ‚ÄúVertex‚Äù)
{-
‚âÖ   record AGraph : Set where
      field
    Vertex Edges : Set
    src    tgt   : Edges ‚Üí Vertex
-}

-- NB. The implicitly generated name ‚ÄúCarrier‚Äù has been identified with
-- the *declared* name ‚ÄúVertex‚Äù. This is acceptable since they have the same type.
-- Without the identification, the record elaboration would have provided a
-- third type field named ‚ÄúCarrier‚Äù.
 #+end_src
 {{{code(Parameterised graphs as typeclasses)}}}
 #+begin_src haskell
GraphOver = TermP typeclass renaming (Carrier to ‚ÄúVertex‚Äù)
{-
‚âÖ   record GraphOver (Vertex : Set) : Set where
       field
      Edges   : Set
      src tgt : Edges ‚Üí Vertex
-}
 #+end_src
 With these in hand, our goal is to replace the following first line with the second.
 However, since both types ~GraphOver~ and ~AGraph~ are declared as one liners,
 such a transition is a cheap as possible.
 #+begin_src haskell
(G H : AGraph) ‚Üí Vertex G ‚â° Vertex H ‚Üí ‚ãØ

(V : Set) ‚Üí (G H : GraphOver V) ‚Üí ‚ãØ
 #+end_src
 In order to /replace a semantic constraint with a syntactic constraint/
 the user simply need to use a /variant/ on packaging. Furthermore, we
 are ensured {{{newline}}} ~AGraph ‚âÖ Œ£ V ‚à∂ Set ‚Ä¢ GraphOver V~.

 Dependently-typed graphs are an curious structure. With a bit of renaming, and adding a few laws,
 we obtain a ‚Äòsetoid‚Äô --i.e., an undirected graph where every node has a self-loop, and paths
 correspond are essentially edges.
 {{{code(Setoid package former)}}}
 #+begin_src haskell
PackageFormer SetoidP (v : Variation) : Set where
  -- Graph structure
  Carrier : Set
  _‚âà_     : Carrier ‚Üí Carrier ‚Üí Set
  -- Properties
  refl  : ‚àÄ{e}     ‚Üí e ‚âà e
  sym   : ‚àÄ{d e}   ‚Üí e ‚âà d ‚Üí d ‚âà e
  trans : ‚àÄ{c d e} ‚Üí c ‚âà d ‚Üí d ‚âà e ‚Üí c ‚âà d
 #+end_src
 A non-dependently-typed ‚Äòsignature‚Äô of a structure is generally obtained by discarding the relational operators
 and all properties. For ~SetoidP~ one would immediately think the signature consists of just ~Carrier~.
 However, if we view it instead as undirected graphs with self-loops at each node and edge-transitivity, then
 one would say the signature is the vertices ~Carrier~ and the edges ~_‚âà_~. It is thus not clear when an item,
 ~_‚âà_~ or ~_‚ü∂_~, forms constructive proofs or provides a type family. As such, signature extraction thus requires
 a parameter identifying which elements constitute ‚Äòproof matter‚Äô ---then one simply filters a pacakge-former
 against this criterion to obtain the associated signature. More generally, this allows us to take an ~X~ structure
 and obtain may of its the associated views about where knowledge is consolidated cite:realms, including:
 #+BEGIN_SRC haskell
X         = ‚ü® Carrier; Operations; Properties ‚ü©     -- C.f., SetoidP
XOver C   = ‚ü® Operations; Properties ‚ü©
IsX C Ops = ‚ü® Properties ‚ü©
XSig      = ‚ü® Carrier; Operations‚ü©                  -- C.f., GraphP
 #+END_SRC
 Having the signature in hand, one can easily and mechanically generate many derivied concepts.
 For example, a ‚Äòhomomorphism‚Äô is a family of functions of the underlying sorts such that
 the given operations are preserved. Likewise, equality of homomorphisms is extensional equality of
 the underlying maps. One can then generate closed and open terms and their interpretation functions.
 With this approach to signature extraction, we can use the same algorithms
 for the production of, say homomorphisms or other constructs, on completely
 different algebraic structures, whether they be monoids or graphs.
 Moreover, this implies that concepts generally not considered for a class
 of algebras can easily be derived and experimented with; likewise for exploring
 new algebraic theories.
 These matters are an application, rather than a goal, of our envisioned system.

 :Neat_but_irrelevant:
 Sometimes constraints on an item can be derived, leaked by a signature.

 E.g., the signature of sets, on a carrier, leaks that the carrier necessary
 has decidable equality.
 :End:

 The curiosity of graphs is that they are one of the simplest /two-sorted/ structures
 and one of the most common in computing. Counter to intuition, existing packaging
 systems, namely canonical structures and typeclasses, are oriented toward having
 a distinct parameter: They cannot work well with multi-parameters; like classical
 single-sorted algebra. However, the both /aim to solve a usability problem:/
 /Having to spell out everything is too tedious./ Typeclasses are essentially dictionary look-up,
 having unicity as an issue. Whereas canonical structures require familiarity with how unifer works
 --we provide enough information to the unifer to find the desired structure-- but, in general,
 canonical structures do not scale. It is one of the thesis efforts to ensure the the unionised
 approach scales by a complex example with clear avenues of extension.

 It should be clear from these examples that package formers provide
 expectant generality, including the common uses one is mostly interested in.
 What about unexpected uses? What if a user wishes to utilise a representation
 we did not conceive of? They should be able to use the existing language to
 form it.
**** Second Observation: Computing Similarity for Containers

 By necessity of the first corollary, we are forced to utilise a uniform language
 between the varying notions of packaging thereby relegating their treatment
 to be a normal aspect of a language's core vernacular, rather than an extra-linguistic feature.
 The previous examples hint at possible issues regarding well-definedness of certain constructs.
 Moreover, we only elaborated on a few compositional operations,
 ~inherits-from, renaming, decorated~, yet users
 may well wish to utilise their own compositional schemes and so it is imperative that we allow
 them such a flexibility.
 Consequently, users ought to be able to define their own compositional mechanisms, thereby
 necessitating that they be able to manipulate package declarations themselves
 which in-turn forces the language to be somewhat homoiconic. Moreover, to avoid a hierarchy
 of languages, the facility for manipulating package declarations must itself be a part of
 the core language, rather than an extra-linguistic feature ---c.f., Coq's Ltac.

 In our envisioned setup, every ~PackageFormer~ declaration adds a clause to a special
 function,
 {{{code(Under the hood)}}}
 #+begin_src haskell
packageInfo : PackageFormer ‚Üí PackageInfo
packageInfo = ‚ü™compiler defined‚ü´
 #+end_src
 Where a ~PackageInfo~ consists of ~Name~, which is a list of parameter names and types, along with the name of the package former;
 and ~Declarations~, a list of name-type pairs whose last element is the target type.
 {{{code(PackageInfo: Just another package ---for ‚Äúsignatures‚Äù)}}}
 #+begin_src haskell
{- Draft: Lots of string manipulation, not ideal. -}
record PackageInfo : Set where
  field
    Name         : List (String √ó String) √ó String
    Declarations : List (String √ó List String)
--
-- This is just another package,
-- it incidentally happens to be the representation of packages!
 #+end_src

 #+RESULTS:
 #+begin_example
 <interactive>:6:5-16: error:
     Data constructor not in scope: Declarations

 <interactive>:6:20-23: error:
     Data constructor not in scope: List :: t0 -> [a]

 <interactive>:6:26-31: error: Data constructor not in scope: String

 <interactive>:6:33: error:
     Variable not in scope: (√ó) :: t1 -> t2 -> t0

 <interactive>:6:35-38: error:
     Data constructor not in scope: List :: t3 -> t2

 <interactive>:6:40-45: error: Data constructor not in scope: String
 #+end_example

 It is to be noted that there is no commitment to a string-based representation.
 It is only a prototype and the thesis will likely move to a better typed
 representation ---otherwise, we may run into too many problems of ill-formed
 package formers.

 {{{code(Recall our example package former)}}}
 #+begin_src haskell
PackageFormer TermP (v : Variation) : Set where
  Var : Int ‚Üí TermP v
  Add : TermP v ‚Üí TermP v ‚Üí TermP v
 #+end_src
 The above declaration provides, under the hood, the following clause to ~packageInfo~.
 {{{code(Under the hood)}}}
 #+begin_src haskell
packageInfo TermP = record { Name         = ["v", Variation] , "TermP"
               ; Declarations = [ ("Var", ["Int", "TermP v"])
                        , ("Add", ["TermP v", "TermP v", "TermP v"])
                        ]
               }
 #+end_src
 # Note the ‚Äòv‚Äô, whence String not Set in the defn of PackageInfo.

 We are now in a position to provide the semantics for the keyword ~Declare~,
 from the previous section. It takes a ~PackageInfo~ and declares a ~PackageFormer~.
 There should be a compile-time warning if such declarations are meaningless, ill-formed.

 For example, the previous {{{newline}}} ~Declare PackageFormer TermRelP (v ‚à∂ Variation) decorated (Œª x ‚Üí x ++ "‚Ä≤")~
 can thus be obtained by a user by defining ~decorated~ as an operation on packages!
 {{{code(User-defined composition scheme)}}}
 #+begin_src haskell
_decorated_ : PackageInfo ‚Üí (String ‚Üí String) ‚Üí PackageInfo
pk decorated f = record { Name         = bimap id f pk.Name
            ; Declarations = fmap (bimap f id) pk.Declarations
            }
 #+end_src

 To rectify the seemingly wild mixfix notions, we request from the compiler
 the following suitably general syntactic sugar.
 An operation, call it, ~altered-by~ of the type ~PackageInfo ‚Üí List PackageInfo ‚Üí List X ‚Üí PackageInfo~
 automatically obtains the syntactic sugar ~p altered-by (q0; ‚Ä¶; qk) with (f0; ...; fN)~ ---c.f., the ~inherits-from~ syntax above.

 # Woah! Look at how easy that was, no need to build it in!

 With such terse functional programs for forming composition schemes,
 there is no need to build much into the compiler.

 Users can define other similar operations, such as ~decorated-rounded~
 which replaces the first two binary relations' names with ~‚äÜ~ and ~‚äÇ~;
 or ~decorated-square~ to make the renamings ~‚äë~ and ~‚äè~.
 Additionally, such renames would propagate into any axioms or derived laws.
 Moreover, the flexibility to invoke such operations in complex ways allows for
 intricate renamings to be generated at tremendous scale without worry that
 future renames would need to be made if the orginal packages included new items.
 Numerous examples of such renaming transpire manually in the impressive
 RATH cite:RATH development, as well as in Agda's standard library.

 When working with multiple values of the same record type, for example,
 one encounters a usability problem: Refereeing to the constituents without being verbose.
 The simplest solution is to qualify each invocation, as in ~instance.field~, however this
 is rather cumbersome, inelegant, and is awkward for mixfix names. An alternative is to
 locally rename the fields according to a scheme reflecting their use. For example, in
 a produce construction of 5 items, the field names would be renamed to have a subscript number.
 In a setting of two instances, a user may instead prefer a primed and an undecorated version
 of field names. Thus far, by hand we have created these tedious subscript and primed renamings,
 with our envisioned systems, we need no longer worry about such boilerplate.

 In nearly the same fashion, a user could have defined the ~inherits-from~ compositional scheme.
 Such a scheme may assume that all identically named items have the same types, and crash otherwise.
 A user could define a better scheme that takes a renaming function, or another function to handle
 the crash, or simply omitt conflicting names altogether.
 The examples suggest that many commonly occurring compositional mechanisms cite:tpc
 can be directly provided by a library, rather than by a particular compiler
 ---this includes the ability to hide fragments, expose the largest well-defined fragment,
 and to combine packages along a given substructure.

 Rather than select what we think is best, we can simply provide the general mechanism to the
 library designer and allow them the freedom to provide their own schemes.

**** Next Steps

 Our brief examples demonstrate that the less design decisions about packaging
 made by language designers, the more general, applicable, and, most importantly, increased homogeneity
 in the resulting datatype language without becoming unityped but rather thanks to being dependently-typed.
 As mentioned in the previous section on existing approaches, one formalism for
 packages is that of theories and theory combinators; below we thus draw on some problems from theory combinators
 rendered toward packaging systems.

 We have mentioned that the ~record~ and ~typeclass~ perspectives solve the common requirement of
 structures sharing an identical field. Other than that, we have essentially only
 outlined a general mechanism for declaring packages and compositional schemes, but have not
 discussed which are the most common and most useful packaging combinators.
 It is also desirable to discuss the formal properties of such combinators
 ---if anything, to ensure they are sensible and behave as expected.
 Moreover, which combinators act as a basis for all packaging combinators?
 Whence their use ensures the resulting composition is well-formed
 and they could be targeted for optimisations.
 #  Soundness & Completeness proofs?

 To make our approach accessible, the generic package operations are brought to the user
 rather than baked into the compiler ---too great a distance for most users.
 The ~Declare~ syntax reifies ~PackageInfo~'s into package declarations, but we have not mentioned
 under what constraints it can actually provide compiler-time, or typechecking-time,
 errors of ill-formedness. Moreover, how (in)efficient is this process?
 Could it be extended to work on variable, runtime provided, declarations
 for refying packages? Perhaps there is a constraint that suffices for the most common cases?
 Moreover, having observable ~PackageInfo~'s being automatically generated for every package declaration
 renders representation hiding nearly moot.

 The proposed approach boarders on meta-programming.
 Can type erasure and other compiler-specific optimisations be brought into
 the homoiconic-like setting being pursued here?
 We have mentioned a few ‚Äòbuilt in‚Äô variations for packaging; can such a feature
 be liberated from the compiler and be bent to the users' will?
 We would need the ability to explain how a package elaborates.

 Tremendous flexibility is demanded from the back-end so as to ignore needless distinctions
 at the users' level. Whereas the practicality is promising, the feasibility of an
 implementation for such ambiguous parsing cite:ambiguous_parsing is unclear.
 It is also unclear what effects identifying syntactically distinct items
 has on, say, normalisation and propositional equality.

 The numerous claims and associaited bookkeeping of details pushes us into using a proof assistant, Agda.

 Our examples have been ‚Äòvariation‚Äô polymorphic;
 we have been even more generic by defining ~decorated~.
 What are the limits of programming genericity provided by our scheme?
 It would unsurprising if this approach yields
 the next 700 module systems.

** COMMENT OLD Why syntax                                      :Maybe_Delete:
   The archetype for records and termtypes ---algebraic data types--- are
   monoids. They describe untyped compositional structures, such as programs in
   dynamically type-checked language. In turn, their termtype is linked lists
   which reify a monoid value ---such as a program--- as a sequence of values
   ---i.e., a list of language instructions--- which ‚Äòevaluate‚Äô to the original
   value. The shift to syntax gives rise to evaluators, optimisers, and  constrained
   recursion-induction principles.
* TODO The Second Choice: PackageFormer

   # I'm trying to do things with one language, in a DTL, and about being first-class.
   # What I currently have is to approximate what it could look like.
   #
   # I'm not actually generating any external code.
   # It's all in the same language.

** COMMENT Why an editor extension? Why Lisp is reasonable?
** COMMENT Utility of a protottype?
** COMMENT Things learned from making a protottype?
     * Perhaps show the minimal code needed to get PF working; <= 300 lines?
     * Much more Lisp for implementing common grouping mechanisms; e.g., pushouts.
** COMMENT How usable is it?
** COMMENT What exotic notions of grouping mechanisms can be coded-up? Utilit!?
** COMMENT [Disadvantages of PackageFormer?
** COMMENT Comparision to other systems.

** TODO COMMENT Two
 Design patterns for theories become library methods! An interesting side-effect
 of having meta-primitives for packages is that traditional patterns for theories
 ‚Äîe.g., homomorphisms, syntax, interpretation functions‚Äî can now be codified as
 general re-usable methods.

** TODO One

 Think of a language that does not support currying and you need to have a
 function of 10 arguments that needs to support accepting any number of arguments
 less than 10, say for partial application. In such languages, one must utilise
 the builder design pattern, or quickly copy-paste the function 10 times,
 altering it slightly each time. In general, if such a function definition
 requires N lines and M forms of the function are needed, then nearly N √ó M lines
 of code are written manually.

** COMMENT Aim: /Scrap the Repetition/
  :PROPERTIES:
  :CUSTOM_ID: Aim---Scrap-the-Repetition-
  :END:

We're going to write a code generator in Lisp that is going to interpret
fictitious Agda code ---henceforth referred to as ‚Äú700 code‚Äù---
into currently legitimate Agda code.

For example, something like the following, henceforth referred to as ~test~:
#+NAME: test
#+BEGIN_Src agda :results replace :exports code
PackageFormer M-Set : Set‚ÇÅ where
   Scalar  : Set
   Vector  : Set
   _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
   ùüô       : Scalar
   _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)

Semantics     = M-Set record
Syntax        = M-Set data with tags (Scalar; Vector)
UntypedSyntax = M-Set data with identified carrier (Scalar; Vector)
ScalarSyntax  = M-Set data with identified carrier (Scalar)
Stream        = M-Set parameterised codata with identified carrier (Vector) renaming (_¬∑_‚ÇÅ to head; _¬∑_‚ÇÇ to tail)
VectorSyntax  = M-Set data with identified carrier (Vector) and variables (embed) from (Scalar)
NearMonoid    = M-Set record renaming (Scalar to Carrier; Vector to Carrier; _¬∑_ to _‚®æ_; _√ó_ to _‚®æ_)
#+END_Src

:Hide:
#+RESULTS: test
#+begin_example
PackageFormer M-Set : Set‚ÇÅ where
   Scalar  : Set
   Vector  : Set
   _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
   ùüô       : Scalar
   _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)

Semantics     = M-Set record
Syntax        = M-Set data with tags (Scalar; Vector)
UntypedSyntax = M-Set data with identified carrier (Scalar; Vector)
ScalarSyntax  = M-Set data with identified carrier (Scalar)
Stream        = M-Set parameterised codata with identified carrier (Vector) renaming (_¬∑_‚ÇÅ to head; _¬∑_‚ÇÇ to tail)
VectorSyntax  = M-Set data with identified carrier (Vector) and variables (embed) from (Scalar)
NearMonoid    = M-Set record renaming (Scalar to Carrier; Vector to Carrier; _¬∑_ to _‚®æ_; _√ó_ to _‚®æ_)
#+end_example

#
# The ‚Äú:results replace‚Äù is since we actually want the results of this
# block later on when using ‚Äútest‚Äù as a org-provided variable to org-src blocks.
:End:

:Hide_Needs_CcCvCb:
# Someplaces I want to use ‚Äòtest‚Äô without having it in the header, whence:
#+BEGIN_SRC emacs-lisp :var outsidetest = test :exports both :results none
(setq test outsidetest)
#+END_SRC
:End:

Will behave as if it were written:
#+BEGIN_Src agda
record Semantics : Set‚ÇÅ where
  field
    Scalar  : Set
    Vector  : Set
    _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
    ùüô       : Scalar
    _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
    leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
    assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)

data SyntaxTag : Set where Scalar Vector : SyntaxTag
data Syntax : SyntaxTag ‚Üí Set‚ÇÅ where
    _¬∑_     : Syntax Scalar ‚Üí Syntax Vector ‚Üí Syntax Vector
    ùüô       : Syntax Scalar
    _√ó_     : Syntax Scalar ‚Üí Syntax Scalar ‚Üí Syntax Scalar

data UntypedSyntax : Set‚ÇÅ where
    _¬∑_     : UntypedSyntax ‚Üí UntypedSyntax ‚Üí UntypedSyntax
    ùüô       : UntypedSyntax
    _√ó_     : UntypedSyntax ‚Üí UntypedSyntax ‚Üí UntypedSyntax

data ScalarSyntax : Set‚ÇÅ where
    ùüô       : ScalarSyntax
    _√ó_     : ScalarSyntax ‚Üí ScalarSyntax ‚Üí ScalarSyntax

{- Nutshell: Keep items ending in ‚ÄúStream Carrier‚Äù, then discard that ending,
         then form a subscripted version for each argument.
-}
record Stream (Carrier : Set) : Set‚ÇÅ where
  coinductive
  field
    head : Carrier
    tail : Stream Carrier

data VectorSyntax (Scalar : Set) : Set‚ÇÅ where
    embed   : Scalar ‚Üí VectorSyntax
    _¬∑_     : Scalar ‚Üí VectorSyntax ‚Üí VectorSyntax

record NearMonoid : Set‚ÇÅ where
  field
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    ùüô       : Carrier
    leftId  : {ùìã : Carrier}  ‚Üí  ùüô ‚®æ ùìã  ‚â°  ùìã
    assoc   : {a b : Carrier} {ùìã : Carrier} ‚Üí (a ‚®æ b) ‚®æ ùìã  ‚â°  a ‚®æ (b ‚®æ ùìã)
#+END_Src
This is a more than a <<<200% increase>>> in size; that is, our fictitious code will
save us a lot of repetition.

The above is ideal syntax: In Lisp fashion, we are not limiting our vision to what
we can currently be done. The actual syntax that is currently supported by this
program is surprisingly close to the above, with an occasional ~-~ or ~:~ inserted.
Just look at the following source file and resulting generated code!

{{{fold(package-former.agda)}}}
#+INCLUDE: "package-former.agda" src agda
{{{end-fold}}}

{{{fold(package-former-generated.agda)}}}
#+INCLUDE: "package-former-generated.agda" src agda
{{{end-fold}}}

Above is a sample source file which contains special comments that are picked up
by the prototype which then copy-paste-cuts to produce a generated file.
The above code is discussed below, in the user manual
---in fact, it's generated from the user-manual below.

 For this prototype, we have the following <<<constraints>>>:

1. The type of a PackageFormer is ~Set ‚Ñì~ where ~‚Ñì~ is the empty string
   or a parenthesised expression of type ~Level~.
   - Subscript levels are supported.

2. The ~where~ keyword appears on the same line as the ~PackageFormer~ key-phrase.

3. The name of the PackageFormer should not contain ~PackageFormer~ as a sub-identifier.

4. Each element of a PackageFormer spans only /one/ physical line.

There are many useful features outlined in the proposal, such as default
implementations, that we hope to include in the future. For now, we just want
something that works, is decently documented, and can be useful.

** COMMENT Contributions
  :PROPERTIES:
  :CUSTOM_ID: Contributions
  :END:
  # Motivation

*Current state of affairs:*

1. Expressive & extendable specification language for the library developer.
   - We demonstrate that our meta-primitives permit this below by demonstrating
     that ubiquitous module combinators can be easily formalised /and/ easily used.
   - E.g., from a theory we can derive its homomorphism type, signature, its termtype, etc;
     we generate useful constructions inspired from universal algebra.
   - An example of the freedom allotted by the extensible nature of the system is that
     combinators defined by library developers can, say, utilise auto-generated names
     when names are irrelevant, use ‚Äòclever‚Äô default names, and allow end-users to supply
     desirable names on demand.

2. Unobtrusive and a tremendously simple interface to the end user.
   - Once a library is developed using (the current implementation of) PackageFormers, the
     end user only needs to reference the resulting generated Agda, without any knowledge of the existence
     of PackageFormers.
     * Generated modules are necessarily ‚Äòflattened‚Äô for typechecking with Agda.
   - We demonstrate below how end-users can build upon a library by using /one line/ specifications,
     by showing over over 200 specifications of mathematical structures.

3. Efficient: Our current implementation processes over 200 specifications in ~3 seconds; yielding typechecked Agda code.
   - It is the typechecking that takes time.

4. Pragmatic: We demonstrate how common combinators can be defined for library developers, but also how they can
   be furnished with concrete syntax ---inspired by Agda's--- for use by end-users.

5. Minimal: The system is essentially invariant over the underlying type system; with the exception of
   the meta-primitive ~:waist~ which requires a dependent type theory to express ‚Äòunbundling‚Äô component fields as parameters.

6. Demonstrated expressive power /and/ use-cases.
   - Common boiler-plate idioms in the standard Agda library, and other places,
     are provided with terse solutions using the PackageFormer system.
     * E.g., automatically generating homomorphism types and wholesale renaming fields
       using a single function.
   - Over 200 modules are formalised as one-line specifications.

7. Immediately useable to end-users /and/ library developers.
   + We have provided a large library to experiment with
     ---thanks to the MathScheme group for providing an adaptable source file.
   + In the second part of the user manual, we show how to formulate module
     combinators using a simple and straightforward subset of Emacs Lisp ---a terse introduction is provided.

*Intuitively, the nature of the meta-primitives:*
1. A ~PackageFormer~ is a context, a signature, an essentially algebraic theory of Freyd, or a generalised algebraic theory of Cartmell.
   Moreover, it is tagged by some values for practical purposes; e.g., the kind of concrete realisation that is possible in Agda ---namely, ~record, data, module,~ or
   the abstract ~PackageFormer~.
2. A ‚Äòvariational‚Äô is a morphism between PackageFormers ---taking signatures to signatures.

   Built up from the grammar:
   #+BEGIN_SRC haskell :tangle no
ùìã ‚à∑=                   -- empty, identity, variational
   | ùìã ‚ü¥ ùìã            -- composition
   | :kind  ùìÄ          -- ùìÄ ‚àà {record, data, module, PackageFormer}
   | :waist ùìÉ          -- n ‚àà ‚Ñï, number of initial items to be considered as ‚Äòparameters‚Äô
   | :alter-elements ùíª -- f : List Elements ‚Üí List Elements
   #+END_SRC

   ~:alter-elements~ is a sledgehammer that may result in ill-formed signatures, but we leave it in the system due to its power.
   Instead, we recommend using the following derivied primitives for signature catenation, map, and filter:
   #+BEGIN_SRC haskell :tangle no
   | extended-by ds  -- Adjoin declarations ds, ‚Äúname : type‚Äù, to a PackageFormer
   | map         f   -- Alter each element by f : Element ‚Üí Element
   | generated   f   -- Keep the largest well-formed PackageFormer whose elements satisfy predicate f
#+END_SRC

   Why are these sufficient? The first homomorphism theorem of lists ---i.e., the fact that lists are free monoids---
   informs us that all well-behaved functions from a list monoid are determined as folds after maps. Since our signatures
   are essentially free monoids and the target of our functions are again the same free monoids, the fold is determined and only
   the map remains. We conjecture this is enough; we are not yet certain.

   Interestingly, we are mostly generic over the underlying type theory.

   #  Œì extended-by x‚ÇÄ:œÑ‚ÇÄ,‚Ä¶,x‚Çô:œÑ‚Çô  -- where Œì,x‚ÇÄ:œÑ‚ÇÄ,‚Ä¶,x‚Çñ‚Çã‚ÇÅ:œÑ‚Çñ‚Çã‚ÇÅ ‚ä¢ œÑ‚Çñ Type

   Since a ~PackageFormer~ corresponds to a signature, then these variationals
   ---at least the well-behaved ones--- correspond to signature morphisms.
   Great difficulty lies in providing semantics for ~alter-elements~; if
   we demand a well-typedness judgement, ‚Äú‚ä¢‚Äù, from our underlying type theory
   then we could define ~(x‚ÇÄ : œÑ‚ÇÄ, ‚Ä¶, x‚Çô ‚à∂ œÑ‚Çô) = Œì :alter-elements f~ to be well-typed iff
   ~f : List Elements ‚Üí List Elements~ and ~x‚ÇÄ:œÑ‚ÇÄ,‚Ä¶,x‚Çñ‚Çã‚ÇÅ:œÑ‚Çñ‚Çã‚ÇÅ ‚ä¢ œÑ‚Çñ Type~ for ~k : 0..n~;
   likewise if we admit defined constants in our contexts.

   :functorial_semantics:
Object-level Semantics -- ‚Äúfunctorial semantics‚Äù
- ‚ü¶_‚üß : PF ‚ü∂ |‚ÑÇ|
- ‚ü¶Empty‚üß = ()  -- the empty context
- ‚ü¶Œì extended-by Œî‚üß = ‚ü¶Œì‚üß ++ Œî
- ‚ü¶Œì :waist n‚üß = ???
- ‚ü¶Œì :kind k‚üß  = ???
- ‚ü¶Œì :map f‚üß   = map f ‚ü¶Œì‚üß
- ‚ü¶Œì :filter p‚üß = filter p ‚ü¶Œì‚üß
- ‚ü¶Œì A ‚ü¥ B‚üß = ‚ü¶ ‚ü¶Œì A‚üß B ‚üß -- get a context, then apply B to that.
:end:

3. We have a categorical structure consisting of PackageFormers as objects and those variationals that are signature morphisms.

*Research outcomes:*
1. Narrow down the meta-primitives that permit a variety of algorithms for generating universal
   algebra consructions ---the former being the kerneal which has application the latter.
2. Realise this for Agda, likely using an editor-extension.
3. Provide a semantics to the existing syntax.
4. Ensure the resulting semantics is consistent with that of Agda's.

| Any questions or feedback are welcome! |

** User Manual I: Simple Use of the System :ignore:
:PROPERTIES:
:header-args: :tangle "package-former-user-manual-i.agda"
:CUSTOM_ID: User-Manual
:END:

# If the previous section is unclear regarding the aims and uses of this prototype,
# please consult the pre-print [[../papers/gpce19_a_language_feature_to_unbundle_data_at_will.pdf][A Language Feature to Unbundle Data at Will]]
# or [[https://alhassy.github.io/next-700-module-systems/][the next 700 module systems proposal]].

Herein we demonstrate how to use this system from the perspective of /library designers/.
We use constructs that are discussed in the next section ---which are examples of how
users may extend the system to produce grouping mechanisms for any desired purpose.
The exposition here follows section 2 of the /Theory Presentation Combinators/ [cite:tpc]
paper, reiterating many the ideas therein.

The few constructs demonstrated in this section not only create new grouping mechanisms
from old ones, but also create maps from the new, child, presentations to the old parent
presentations. Maps between grouping mechanisms are sometimes called /views/.
For example, a theory extended by new declarations comes equipped with
a map that forgets the new declarations to obtain an instance of the original theory.
Such morphisms are tedious to write out, and our system provides them for free.
How? You, the user, can implement such features using our 5 meta-primitives
---but we have implemented a few for you as examples.

:Header:
#+BEGIN_SRC agda
module package-former-user-manual-i where
import Relation.Binary.PropositionalEquality as ‚â°; open ‚â° using (_‚â°_)

-- Run the following commands:
-- M-x load-file ENTER agda-next-700-module-systems.el
-- M-x agda-next-700-module-systems-mode
#+END_SRC
:End:

#+begin_center
It is important to clarify that *the purpose of this work is the development of a core kernel of meta-primitives for modules*. This section demonstrates the power and
expressivity of the meta-primitives by showcasing a series of ubiquitous combinators
/which may be defined using the meta-primitives and Lisp/. The section afterwards goes into the detail of how to *extend the system to build any desired operations on any notion of grouping mechanism*.
#+end_center

# As such, some of the definitions of combinators are biased or have some shortcomings:
# Our goal is to show the meta-primitives allow for such definitions, and to provide
# examples (mostly in the second part of the user manual) for users to build what they want.

** COMMENT Installation
   :PROPERTIES:
   :CUSTOM_ID: Installation
   :END:

{{{goal(Obtaining the system!)}}}

# Click here to obtain [[https://raw.githubusercontent.com/alhassy/next-700-module-systems-proposal/master/prototype/PackageFormer.el][PackageFormer.el]], place it somewhere, open an Agda file, execute
# ~M-x your/location/PackageFormer.el~, then enable the mode by executing ~M-x 700-mode~.

Add the following to the top of your Emacs configuration file, i.e., the ~~/.emacs~ file.
#+BEGIN_SRC emacs-lisp :tangle no
;; Connect to internet repositories for Emacs packages.
(require 'package)
(push '("melpa-stable" . "http://stable.melpa.org/packages/") package-archives)
(package-initialize)
(package-refresh-contents)

;; Obtain & setup installation interface.
(unless (package-installed-p 'use-package)
  (package-install 'use-package))
(require 'use-package)
(setq use-package-always-ensure t)

;; Necessary libraries for producing the prototype
(use-package s)                  ;; ‚ÄúThe long lost Emacs string manipulation library‚Äù.
(use-package dash)               ;; ‚ÄúA modern list library for Emacs‚Äù.
(use-package dash-functional)    ;; Function combinators; e.g., -partial/-cut, -const, -compose, -orfn & -andfn for generalised ‚àÉ/‚àÄ.
(use-package origami)            ;; Folding away regions of text.
(use-package hydra)              ;; Helpful menus.
(require 'subr-x)                ;; Extra Lisp functions; e.g., when-let.
;; Eye-candy
(use-package spacemacs-common
    :ensure spacemacs-theme
    :config (load-theme 'spacemacs-light t))

;; Next, obtain the Elisp file, load it, and attach it to Agda.
(shell-command (concat "curl "
    "https://raw.githubusercontent.com/alhassy/next-700-module-systems/master/prototype/agda-next-700-module-systems.el"
    ">> ~/.emacs.d/agda-next-700-module-systems.el"))
(load-file "~/.emacs.d/agda-next-700-module-systems.el")

;; Uncomment if you want this extenssion to ALWAYS be active on .agda files.
;; (add-hook 'agda2-mode-hook #'agda-next-700-module-systems-mode)

;; You likely have this in your ~/.emacs file already
(load-file (let ((coding-system-for-read 'utf-8))
                (shell-command-to-string "/usr/local/bin/agda-mode locate")))
#+END_SRC

When you enable ~agda-next-700-module-systems-mode~,

0. A menu-bar ~PackageFormers~ will be added.

1. It will allow you to temporarily disable and enable this new feature,
   as well as providing a help menu. Invoke ~M-x agda-next-700-module-systems-mode~ to toggle turning off this feature
   completely.

2. The string icon ~PackageFormer (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà~ is displayed in the mode line ---near the bottom of Emacs.

3. You may use ~C-c c-l~ as usual, but it will now recognise 700-comments and generate
   legitimate Agda code from them ---more on this later.

   - PackageFormer syntactical items are coloured green, PackageFormer names are
     coloured yellow, and their instantiation are simply bolded.
     # To update a coloured
     # item, simply save then ~revert-buffer~ (F5), then reload with ~C-c C-l~.

If you need any assistance, please contact me!

** Syntax
   :PROPERTIES:
   :CUSTOM_ID: Syntax
   :END:

{{{goal(Superficial glance at the system's syntax.)}}}

The prototype works by translating fictitious 700-syntax into legitimate Agda;
as follows:
#+BEGIN_SRC agda :tangle no
...agda code here...
{-700
       ...700-syntactical items here...
-}
...more agda code...
#+END_SRC
Since the first section provides an example source fragment with both 700-comments as well
as instantiations, we shall only enclose 700-syntax in 700-comments when it is surrounded
by other Agda code, and otherwise leave it free standing.

/We will provide full source listings at the end of discussions that only display fragments!/

 <<<700-syntax>>> is defined informally as follows:
#+BEGIN_EXAMPLE text
‚ü™700-syntax‚ü´    ::=  ‚ü™PackageFormer‚ü´ | ‚ü™Instantiation‚ü´ | ‚ü™Agda‚ü´

‚ü™PackageFormer‚ü´ ::= PackageFormer ‚ü™Identifier‚ü´ : Set (‚ü™level‚ü´) where
               ‚ü™newline-with-indentation‚ü´ ‚ü™Element‚ü´*

‚ü™Element‚ü´       ::=  ‚ü™Identifier‚ü´ : ‚ü™Any-Agda-Type‚ü´

‚ü™Instantiation‚ü´ ::= ‚ü™Identifier‚ü´ = ‚ü™Identifier‚ü´ ‚ü™VariationalClause‚ü´

‚ü™VariationalClause‚ü´ ::= [‚ü™Identifier‚ü´] (:key (value))* (‚ü¥ ‚ü™VariationalClause‚ü´)*
#+END_EXAMPLE

:Old:
#+BEGIN_EXAMPLE text
{- Only listing the currently implemented -}
‚ü™Variation‚ü´     ::= typeclass | data | record
‚ü™VOp‚ü´           ::=   renaming ‚ü™ToList‚ü´
            | unbundling ‚ü™‚Ñï‚ü´
            | exposing (‚ü™Semicolon-seperated-list-of-Identifiers‚ü´)
            | with     ‚ü™ToList‚ü´

‚ü™ToList‚ü´ ::= (‚ü™Identifier‚ÇÄ‚ü´ to ‚ü™Identifier‚ÇÄ‚ü´; ‚ãØ; ‚ü™Identifier‚Çô‚ü´ to ‚ü™Identifier‚Çô‚ü´) {- for any n : ‚Ñï -}
#+END_EXAMPLE
:End:

+ One derives many presentations of a grouping mechanism by what we call ‚Äòvariational clauses‚Äô.
  - In a 700-comment, one declares ‚Äòvariational‚Äô such as
     | ~ùí±-typeclass height = :kind record :level dec :waist-strings ("field") :waist height~   |

     These are functions whose names begin with ~ùí±-~, they may have arguments on the left-hand-side,
     and their right hand side may invoke any of the 5 meta-primitives
     ~kind, waist, waist-strings, level, alter-elements~ with any mixture of
     arguments and concrete values.

     # - These is limited Agda syntax support; in doubt, Lisp syntax is used.

     - To invoke a variational in an instantiation clause, arguments are not positional
       but instead are passed by name ---e.g., ~:key value~.

#   Note that package formation has been liberated from the backend and brought to the user
#   via our 5 meta-primitives: preamble, kind, waist, waist-strings, level, alter-elements.

+ Example uses of the variational clauses could be seen in the ~package-former.agda~ listing in the first section above.
** Extension
   :PROPERTIES:
   :CUSTOM_ID: Extension
   :END:

   The simplest situation is where the presentation of one theory is included, verbatim, in another.
   Concretely, consider ~Monoid~ and ~CommutativeMonoid~.

#+BEGIN_SRC agda
{-700
PackageFormer Monoid : Set‚ÇÅ where
   Carrier : Set
   _¬∑_     : Carrier ‚Üí Carrier ‚Üí Carrier
   assoc   : {x y z : Carrier} ‚Üí (x ¬∑ y) ¬∑ z  ‚â°  x ¬∑ (y ¬∑ z)
   ùïÄ       : Carrier
   leftId  : {x : Carrier} ‚Üí ùïÄ ¬∑ x  ‚â° x
   rightId : {x : Carrier} ‚Üí x ¬∑ ùïÄ  ‚â° x
   ùïÄ-unique : ‚àÄ {e} (lid : ‚àÄ {x} ‚Üí e ¬∑ x ‚â° x) (rid : ‚àÄ {x} ‚Üí x ¬∑ e ‚â° x) ‚Üí e ‚â° ùïÄ
   ùïÄ-unique lid rid = ‚â°.trans (‚â°.sym leftId) rid

PackageFormer CommutativeMonoid‚ÇÄ : Set‚ÇÅ where
   Carrier : Set
   _¬∑_     : Carrier ‚Üí Carrier ‚Üí Carrier
   assoc   : {x y z : Carrier} ‚Üí (x ¬∑ y) ¬∑ z  ‚â°  x ¬∑ (y ¬∑ z)
   ùïÄ       : Carrier
   leftId  : {x : Carrier} ‚Üí  ùïÄ ¬∑ x  ‚â° x
   rightId : {x : Carrier} ‚Üí  x ¬∑ ùïÄ  ‚â° x
   comm    : {x y : Carrier} ‚Üí  x ¬∑ y  ‚â°  y ¬∑ x
   ùïÄ-unique : ‚àÄ {e} (lid : ‚àÄ {x} ‚Üí e ¬∑ x ‚â° x) (rid : ‚àÄ {x} ‚Üí x ¬∑ e ‚â° x) ‚Üí e ‚â° ùïÄ
   ùïÄ-unique lid rid = ‚â°.trans (‚â°.sym leftId) rid
-}
#+END_SRC

As expected, the only difference is that ~CommutativeMonoid‚ÇÄ~ adds a ~comm~-utative axiom.
Thus, given ~Monoid~, it would be more economical to define:
#+BEGIN_SRC agda
{-700
CommutativeMonoid = Monoid extended-by "comm : {x y : Carrier} ‚Üí  x ¬∑ y  ‚â°  y ¬∑ x"
-}
#+END_SRC

Hovering over the left-hand-side gives a tooltip showing the resulting elaboration,
which is identical to ~CommutativeMonoid‚ÇÄ~ along with a forgetful operation üòÑ
The tooltip shows the /expanded/ version of the theory, which is
*what we want to specify but not what we want to enter manually*.
To obtain this specification of ~CommutativeMonoid~ in the current implementation
of Agda, one would likely declare a record with two fields ---one being a ~Monoid~
and the other being the commutativity constraint--- however, this _only_ gives
the appearance of the above specification for consumers; those who produce instances
of ~CommutativeMonoid~ are then _forced_ to know the particular hierarchy and must provide
a ~Monoid~ value first. It is a happy coincidence that our system alleviates such an issue.

Alternatively, we may reify the new syntactical items as concrete Agda supported ~record~-s as follows.
#+BEGIN_SRC agda
{-700
MonoidR            = Monoid ‚ü¥ record
CommutativeMonoidR = MonoidR extended-by "comm : {x y : Carrier} ‚Üí  x ¬∑ y  ‚â°  y ¬∑ x" ‚ü¥ record
-}

neato : CommutativeMonoidR ‚Üí MonoidR
neato = CommutativeMonoidR.toMonoidR
#+END_SRC

*‚ÄúTransport‚Äù*
It is important to notice that the /derived/ result ~ùïÄ-unique~, while proven in the setting of ~Monoid~,
is not only available via the morphism ~toMonoidR~ but is also available directly since it is also
a member of ~CommutativeMonoidR~.

As a teaser, here's how the ~extended-by~ variational is defined ---we leave the details of which
to the second part of the user manual.
{{{fold(Definition of extended-by)}}}
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(eval-and-compile
(cl-defun element-retract (parent es &key (new es) name contravariant)
  "Realise a list of elements as an Agda no-op record.

E.g., list ‚ÄúCarrier : Set; e : Carrier‚Äù
maps to the following element value.

      toParent : parent
      toParent = record {Carrier = Carrier; e = e}

See also ùí±-renaming, which may be useful to change ‚ÄòtoParent‚Äô.

NEW is a new updated version of ES, if any.

NAME is the name of the new retract element; by default it's ‚ÄútoParent‚Äù or ‚ÄúfromParent‚Äù
depending on whether CONTRAVARIANT is true or not.
"

  ;; the name of the newly defined PackageFormer ---which we may access using the special identifier ~$ùëõùëéùëöùëí~.
  (let* ((toParent (or (unless (equal t name) name) (format "%s%s" (if contravariant "from" "to") parent)))
         ;; NAME may be "t", but not the symbol t. This is useful in any ùí±artional that has an optional adjoin-retract
         ;; argument, which the user may set to be nil, t, or a string to obtain nothing, default name, and given name for the morphism; respectively.
        (œÑarg     (if contravariant (format "%s ‚Üí " parent) ""))
        (Œ¥var     (gensym)) ;; unique argument name to avoid accidental shawdowing of any ‚Äúe in es‚Äù.
        (Œ¥arg     (if contravariant (format "Œª %s ‚Üí " Œ¥var) ""))
        )
    (car (parse-elements (list
      (format "%s : let View X = X in %sView %s" toParent œÑarg (if contravariant $ùëõùëéùëöùëí parent))
      (format "%s = %srecord {%s}" toParent Œ¥arg

        (s-join ";"
        (loop for e  in es
              for e‚Ä≤ in new
              unless (or (s-contains-p "let View X = X" (element-type e)) ;; Ignore source view morphisms
                         (element-equations e))                           ;; Ignore ‚Äúderived‚Äù elements
              collect (if (not contravariant)
                          (format "%s = %s" (element-name e) (element-name e‚Ä≤))
                        (format "%s = %s.%s %s" (element-name e) parent (element-name e‚Ä≤) Œ¥var))))))))))

(ùí± extended-by ds (adjoin-retract t)
   = "Extend a given presentation by a list of ;-separated declarations.

      The resuling presentation has a ‚ÄútoX‚Äù retract method,
      where ‚ÄòX‚Äô is the parent presentation. To avoid this,
      set ADJOIN-RETRACT to be nil. To provide a preferred name for
      the morphism, then set ADJOIN-RETRACT to the desired string.
     "
     :alter-elements (Œª es ‚Üí (-concat es (parse-elements (mapcar #'s-trim (s-split ";" ds))) (when adjoin-retract (list (element-retract $ùëùùëéùëüùëíùëõùë° es :name adjoin-retract))))))
)
     #+END_SRC

#+RESULTS:
: ùí±-extended-by

{{{end-fold}}}

+ Simple exercise: Play with this setup to observe that ~extended-by~ is an idempotent operation.
+ Advanced exercise: Read the user manual, parts I and II, then produce a variational ~commuting~
  such that ~CommutativeMagma~ can be regained by ~Magma commuting "¬∑"~.

  See the ~flipping~ variational below.

Anyhow, notice that we may define ~GroupR~ ---a record-presentation of groups--- as an extension of ~MonoidR~
using a /single/ ~extended-by~ clause where the necessary items are separated by ~;~.
#+BEGIN_SRC agda
{-700
GroupR = MonoidR extended-by "_‚Åª¬π : Carrier ‚Üí Carrier; left‚Åª¬π : ‚àÄ {x} ‚Üí (x ‚Åª¬π) ¬∑ x ‚â° ùïÄ; right‚Åª¬π : ‚àÄ {x} ‚Üí x ¬∑ (x ‚Åª¬π) ‚â° ùïÄ" ‚ü¥ record
-}
#+END_SRC

A more fine grained approach may be as follows.
#+BEGIN_SRC agda
{-700
PackageFormer Empty : Set‚ÇÅ where {- No elements -}
Type  = Empty extended-by "Carrier : Set" :adjoin-retract nil ‚ü¥ record
Magma = Type  extended-by "_¬∑_ : Carrier ‚Üí Carrier ‚Üí Carrier" ‚ü¥ record
CommutativeMagma = Magma extended-by "comm : {x y : Carrier} ‚Üí  x ¬∑ y  ‚â°  y ¬∑ x" ‚ü¥ record
-}
#+END_SRC

** Defining a Concept Only Once
   :PROPERTIES:
   :CUSTOM_ID: Defining-a-Concept-Only-Once
   :END:

   From a library-designer's perspective, our definition of ~CommutativeMonoid~ has the commutativity property ‚Äòhard coded‚Äô into it.
   If we wish to speak of commutative magmas ---types with a single commutative operation--- we need to hard-code the property once again.
   If, at a later time, we wish to move from having arguments be implicit to being explicit then we need to track down every hard-coded
   instance of the property then alter them ---having them in-sync becomes an issue.

   Instead, the system lets us ‚Äòbuild upon‚Äô the ~extended-by~ combinator: We make an associative list of
   names and properties, then string-replace the meta-names /op, op‚Ä≤, rel/ with the provided user names.

#+BEGIN_SRC emacs-lisp  :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(ùí± postulating bop prop (using bop) (adjoin-retract t)
 = "Adjoin a property PROP for a given binary operation BOP.

   PROP may be a string: associative, commutative, idempotent, etc.

   Some properties require another operator or a relation; which may
   be provided via USING.

   ADJOIN-RETRACT is the optional name of the resulting retract morphism.
   Provide nil if you do not want the morphism adjoined.

   With this variational, a definition is only written once.
   "
   extended-by (s-replace "op" bop (s-replace "rel" using (s-replace "op‚Ä≤" using
    (pcase prop
     ("associative"   "assoc : ‚àÄ x y z ‚Üí op (op x y) z ‚â° op x (op y z)")
     ("commutative"   "comm  : ‚àÄ x y   ‚Üí op x y ‚â° op y x")
     ("idempotent"    "idemp : ‚àÄ x     ‚Üí op x x ‚â° x")
     ("involutive"    "inv   : ‚àÄ x     ‚Üí op (op x) ‚â° x") ;; assuming bop is unary
     ("left-unit"     "unitÀ° : ‚àÄ x y z ‚Üí op e x ‚â° e")
     ("right-unit"    "unit ≥ : ‚àÄ x y z ‚Üí op x e ‚â° e")
     ("distributiveÀ°" "distÀ° : ‚àÄ x y z ‚Üí op x (op‚Ä≤ y z) ‚â° op‚Ä≤ (op x y) (op x z)")
     ("distributive ≥" "dist ≥ : ‚àÄ x y z ‚Üí op (op‚Ä≤ y z) x ‚â° op‚Ä≤ (op y x) (op z x)")
     ("absorptive"    "absorp  : ‚àÄ x y  ‚Üí op x (op‚Ä≤ x y) ‚â° x")
     ("reflexive"     "refl    : ‚àÄ x y  ‚Üí rel x x")
     ("transitive"    "trans   : ‚àÄ x y z ‚Üí rel x y ‚Üí rel y z ‚Üí rel x z")
     ("antisymmetric" "antisym : ‚àÄ x y ‚Üí rel x y ‚Üí rel y x ‚Üí x ‚â° z")
     ("congruence"    "cong    : ‚àÄ x x‚Ä≤ y y‚Ä≤ ‚Üí rel x x‚Ä≤ ‚Üí rel y y‚Ä≤ ‚Üí rel (op x x‚Ä≤) (op y y‚Ä≤)")
     ;; (_ (error "ùí±-postulating does not know the property ‚Äú%s‚Äù" prop))
     )))) :adjoin-retract 'adjoin-retract)
#+END_SRC

#+RESULTS:
: ùí±-postulating

  We can extend this database of properties as needed with relative ease. Here is an example use along with its elaboration.
#+BEGIN_SRC agda
{-700
PackageFormer Magma : Set‚ÇÅ where
  Carrier : Set
  _¬∑_      : Carrier ‚Üí Carrier ‚Üí Carrier

RawRelationalMagma = Magma extended-by "_‚âà_ : Carrier ‚Üí Carrier ‚Üí Set" ‚ü¥ record

RelationalMagma    = RawRelationalMagma postulating "_¬∑_" "congruence" :using "_‚âà_" ‚ü¥ record
-}
#+END_SRC

#+BEGIN_SRC results-agda :tangle no
record RawRelationalMagma : Set‚ÇÅ where
    field Carrier       : Set
    field op        : Carrier ‚Üí Carrier ‚Üí Carrier
    toType      : let View X = X in View Type ; toType = record {Carrier = Carrier}
    field _‚âà_       : Carrier ‚Üí Carrier ‚Üí Set
    toMagma     : let View X = X in View Magma ;    toMagma = record {Carrier = Carrier;op = op}

record RelationalMagma : Set‚ÇÅ where
    field Carrier       : Set
    field op        : Carrier ‚Üí Carrier ‚Üí Carrier
    toType      : let View X = X in View Type ; toType = record {Carrier = Carrier}
    field _‚âà_       : Carrier ‚Üí Carrier ‚Üí Set
    toMagma     : let View X = X in View Magma ;    toMagma = record {Carrier = Carrier;op = op}
    field cong      : ‚àÄ x x‚Ä≤ y y‚Ä≤ ‚Üí _‚âà_ x x‚Ä≤ ‚Üí _‚âà_ y y‚Ä≤ ‚Üí _‚âà_ (op x x‚Ä≤) (op y y‚Ä≤)
    toRawRelationalMagma        : let View X = X in View RawRelationalMagma ;   toRawRelationalMagma = record {Carrier = Carrier;op = op;_‚âà_ = _‚âà_}
#+END_SRC

    + Regarding the idea that /‚Äúeach piece of mathematical knowledge should be formalized only once‚Äù,/
      see the paper [[https://inf.ug.edu.pl/~schwarzw/papers/mkm2010.pdf][On Duplication in Mathematical Repositories]].

    + The above Lisp serves as an accessible example of extending the system by users.
      - See this [[https://alhassy.github.io/ElispCheatSheet/][Elisp Cheat Sheet]] to get the basics of Lisp.

** Renaming
   :PROPERTIES:
   :CUSTOM_ID: Renaming
   :END:

   From an end-user perspective, our ~CommutativeMonoid~ has one flaw: Such monoids are
   frequently written /additively/ rather than multiplicatively. Such a change can be
   rendered conveniently:

#+BEGIN_SRC agda
{-700
AbealianMonoidR = CommutativeMonoidR renaming "_¬∑_ to _+_"
-}
#+END_SRC

   An Abealian monoid is /both/ a commutative monoid and also, simply, a monoid.
   The above declaration freely maintains these relationships: The resulting record
   comes with a new projection ~toCommutativeMonoidR~, and still has the inherited projection ~toMonoidR~.

   Since renaming and extension (including postulating) both adjoin retract morphisms, by default,
   we are lead to wonder how about the result of performing these operations in sequence ‚Äòon the fly‚Äô,
   rather than naming each application. Since ~P renaming X ‚ü¥ postulating Y~ comes with a retract ~toP~ via
   the renaming and another, distinctly defined, ~toP~ via the postulating, we have that the operations
   commute if /only/ the first permits the creation of a retract. Here's a concrete example:
#+BEGIN_SRC agda
{-700
IdempotentMagma  = Magma renaming "_¬∑_ to _‚äî_" ‚ü¥ postulating "_‚äî_" "idempotent"   :adjoin-retract nil ‚ü¥ record
-}
#+END_SRC

  These both elaborate to the same thing, up to order of constituents.

  It is important to realise that the renaming and postulating combinators are /user-defined/, and
  could have been defined without adjoining a retract by default; consequently, we would have unconditional
  commutativity of these combinators. You, as the user, can make these alternative combinators as follows:
#+BEGIN_SRC agda
{-700

ùí±-renaming‚Ä≤ by = renaming 'by :adjoin-retract nil

ùí±-postulating‚Ä≤ p bop (using) = postulating 'p 'bop :using 'using :adjoin-retract nil

-- Example use: We need the ‚Äúùí±-‚Äù in the declaration site, but not in use sites, as below.

IdempotentMagma‚Ä≥ = Magma postulating‚Ä≤ "_‚äî_" "idempotent" ‚ü¥ renaming‚Ä≤ "_¬∑_ to _‚äî_" ‚ü¥ record
-}
#+END_SRC

Super near stuff!

As expected, simultaneous renaming works too ^_^
#+BEGIN_SRC agda
{-700
PackageFormer Two : Set‚ÇÅ where
  Carrier : Set
  ùüò       : Carrier
  ùüô       : Carrier

TwoR = Two record ‚ü¥ renaming‚Ä≤ "ùüò to ùüô; ùüô to ùüò"
-}
#+END_SRC
~TwoR~ is just ~Two~ but as an Agda record, so it typechecks.

Finally, renaming is an invertible operation ---ignoring the adjoined retracts,
~Magma ≥ ≥~ is identical to ~Magma~.
#+BEGIN_SRC agda
{-700
Magma ≥  = Magma  renaming "_¬∑_  to op"
Magma ≥ ≥ = Magma ≥ renaming "op   to _¬∑_"
-}
#+END_SRC

Alternatively, ~renaming~ has an optional argument ~:adjoin-coretract~ which can be provided
with ~t~ to use a default name or provided with a string to use a desired name for
the inverse part of a projection, ~fromMagma~ below.
#+BEGIN_SRC agda
{-700
Sequential = Magma renaming "op to _‚®æ_" :adjoin-coretract t
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record Sequential : Set‚ÇÅ where
    field Carrier : Set
    field _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier

    toType : let View X = X in View Type
    toType = record {Carrier = Carrier}

    toMagma : let View X = X in View Magma
    toMagma = record {Carrier = Carrier;op = _‚®æ_}

    fromMagma : let View X = X in Magma ‚Üí View Sequential
    fromMagma = Œª g227742 ‚Üí record {Carrier = Magma.Carrier g227742;_‚®æ_ = Magma.op g227742}
#+END_SRC
We are using gensym's for Œª-arguments to avoid name clashes.

** Union (and intersection)
   :PROPERTIES:
   :CUSTOM_ID: Union
   :END:

But even with these features, given ~GroupR~, we would find ourselves writing:
#+BEGIN_SRC agda
{-700
CommutativeGroupR‚ÇÄ = GroupR extended-by "comm : {x y : Carrier} ‚Üí  x ¬∑ y  ‚â°  y ¬∑ x" ‚ü¥ record
-}
#+END_SRC

This is *problematic*: We lose the /relationship/ that every commutative group is a commutative monoid.
This is not an issue of erroneous hierarchical design: From ~Monoid~, we could orthogonally
add a commutativity property or inverse operation; ~CommutativeGroupR‚ÇÄ~ then closes this diamond-loop
by adding both features. The simplest way to share structure is to union two presentations:
#+BEGIN_SRC agda
{-700
CommutativeGroupR = GroupR union CommutativeMonoidR ‚ü¥ record
-}
#+END_SRC

The resulting record, ~CommutativeMonoidR~, comes with three derived fields
---~toMonoidR, toGroupR, toCommutativeMonoidR~--- that retain the results relationships
with its hierarchical construction.

This approach ‚Äúworks‚Äù to build a sizeable library, say of the order of 500 concepts, in
a fairly economical way [cite:tpc]. The union operation is an instance of a /pushout/
operation, which consists of 5 arguments ---three objects and two morphisms--- which may
be included into the ~union~ operation as optional keyword arguments.
The more general notion of pushout is required if we were to combine ~GroupR~ with ~AbealianMonoidR~,
which have non-identical syntactic copies of ~MonoidR~.

{{{fold(Definition of union & intersection -- Ignore for now)}}}
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(defun find-duplicates (list)
"Return a list that contains each element from LIST that occurs more than once.

Source: https://emacs.stackexchange.com/a/31449/10352"
  (--> list
       (-group-by #'identity it)
       (-filter (lambda (ele) (> (length ele) 2)) it)
       (mapcar #'car it)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(cl-defmacro alter-elements (elements variational &body rest)
  "Alter ELEMENTS using a given VARIATIONAL along with its arguments, REST.

   The result is a list of elements.

   This is essentially ‚Äú:alter-elements‚Äù but with the ability to work on the elements
   of **any** PackageFormer by using ‚Äú($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì pf)‚Äù.

   This method is only well-defined within the RHS of a variational, or instantiation, declaration.
   E.g., use it to alter elements in an ‚Äú:alter-elements‚Äù clause using a predefined variational;
   see ùí±-union and ùí±-intersect for sample uses.
  "
  `(funcall (cdr (assoc :alter-elements (,(ùí±- variational) ,@rest))) ,elements))
#+END_SRC

# Add to user manual, pt2
#
# Raw names as inputs: or just use (symbol-name 'it)
# ùí±-go it = :alter-elements (Œª _ ‚Üí (parse-elements (list (format "%s" 'it))))
# M = Magma go noice

#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(ùí± union pf (renaming‚ÇÅ "") (renaming‚ÇÇ "") (adjoin-retract‚ÇÅ t) (adjoin-retract‚ÇÇ t) (error-on-name-clashes t) (fix-conflict (Œª left right name ‚Üí (cons (format "%s-via-%s" name left)
                                                                                                                                                    (format "%s-via-%s" name right))))

 = "Union parent PackageFormer with given PF.

    Union the elements of the parent PackageFormer with those of
    the provided PF symbolic name, then adorn the result with two views:
    One to the parent and one to the provided PF.

    If an identifer is shared but has different types, then crash.

    ADJOIN-RETRACT·µ¢, for i : 1..2, are the optional names of the resulting morphisms.
    Provide nil if you do not want the morphisms adjoined.

    ERROR-ON-NAME-CLASHES toggles whether the program should crash if the PackageFormers
    have items with the same name but different types or definitions,
    or otherwise it should simply, and sliently, rename the conflicting names according to FIX-CONFLICT;
    a function that takes 3 string arguments and yields two, the former being the names of the PackageFormer arguments
    along with the conflicting name, and yiedling two new names.

    Also, ERROR-ON-NAME-CLASHES toggles whether the program should crash if retract
    names already exist, or otherwise it should simply silently not include clashing retract names.
    "
   :alter-elements (Œª es ‚Üí
     (let* ((p (symbol-name 'pf))
            (es‚ÇÅ (alter-elements es renaming renaming‚ÇÅ :adjoin-retract nil))
            (es‚ÇÇ (alter-elements ($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì p) renaming renaming‚ÇÇ :adjoin-retract nil))
            (es‚Ä≤ (-concat es‚ÇÅ es‚ÇÇ))
            (name-clashes (loop for n in (find-duplicates (mapcar #'element-name es‚Ä≤))
                                for e = (--filter (equal n (element-name it)) es‚Ä≤)
                                unless (--all-p (equal (car e) it) e)
                                collect e))
            (er‚ÇÅ (if (equal t adjoin-retract‚ÇÅ) (format "to%s" $ùëùùëéùëüùëíùëõùë°) adjoin-retract‚ÇÅ))
            (er‚ÇÇ (if (equal t adjoin-retract‚ÇÇ) (format "to%s" p)    adjoin-retract‚ÇÇ))
            )

      ;; Ensure no name clashes!
      (if error-on-name-clashes
          (if name-clashes
            (-let [debug-on-error nil]
              (error "%s = %s union %s \n\n\t\t ‚û© Error: Elements ‚Äú%s‚Äù conflict!\n\n\t\t\t%s"
                     $ùëõùëéùëöùëí $ùëùùëéùëüùëíùëõùë° p (element-name (caar name-clashes)) (s-join "\n\t\t\t" (mapcar #'show-element (car name-clashes))))))
        ;; Else handle clashes
        (loop for n in (mapcar #'element-name (apply #'-concat name-clashes))
              do (setq es‚ÇÅ (--map (map-name (Œª m ‚Üí (if (equal n m) (car (fix-conflict $ùëùùëéùëüùëíùëõùë° p n)) m)) it) es‚ÇÅ))
                 (setq es‚ÇÇ (--map (map-name (Œª m ‚Üí (if (equal n m) (cdr (fix-conflict $ùëùùëéùëüùëíùëõùë° p n)) m)) it) es‚ÇÇ)))
        (setq es‚Ä≤ (-concat es‚ÇÅ es‚ÇÇ)))

   ;; Are the retract names already present?
   (setq er‚ÇÅ (member er‚ÇÅ (mapcar #'element-name es‚Ä≤)))
   (setq er‚ÇÇ (member er‚ÇÇ (mapcar #'element-name es‚Ä≤)))
   (and (or er‚ÇÅ er‚ÇÇ) error-on-name-clashes
        (error "%s = %s union %s \n\n\t\t ‚û© Error: Element retract names ‚Äú%s/%s‚Äù conflict!\n\n\t\t\t%s"
                     $ùëõùëéùëöùëí $ùëùùëéùëüùëíùëõùë° p (car er‚ÇÅ) (car er‚ÇÇ) "Use ‚Äò:adjoin-retract·µ¢‚Äô for new names, or set ‚Äò:error-on-retract-name-clashes‚Äô to nil to silently avoid creating such retracts."))

   ;; return value
   (-concat
       es‚Ä≤
       (and adjoin-retract‚ÇÅ (not er‚ÇÅ) (list (element-retract $ùëùùëéùëüùëíùëõùë° es :new es‚ÇÅ :name adjoin-retract‚ÇÅ)))
       (and adjoin-retract‚ÇÇ (not er‚ÇÇ) (list (element-retract p     ($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì p) :new es‚ÇÇ :name adjoin-retract‚ÇÇ)))))))

#+END_SRC

#+RESULTS:
: map-name

#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(ùí± intersect pf (adjoin-retract‚ÇÅ t) (adjoin-retract‚ÇÇ t) (renaming‚ÇÅ "") (renaming‚ÇÇ "")
 = "Intersect parent PackageFormer with given PF.

  ‚Äúpf‚ÇÅ intersect pf‚ÇÇ :renaming‚ÇÅ f :renaming‚ÇÇ g‚Äù  ‚âÖ  f(pf‚ÇÅ) ‚à© g(pf‚ÇÇ)

  This is essentially the pullback:
  { (x, y) ‚àà pf‚ÇÅ √ó pf‚ÇÇ ‚ùô f x = g y }.

  Intersect the elements of the parent PackageFormer with those of
  the provided PF symbolic name, then adorn the result with two views
  from the result PackageFormer to the input PackageFormers.

  ADJOIN-RETRACT·µ¢, for i : 1..2, are the optional names of the resulting morphisms.
  Provide nil if you do not want the morphisms adjoined.
  "
 :alter-elements (Œª es ‚Üí
   (let* ((p (symbol-name 'pf))
          (es‚ÇÅ (alter-elements es renaming renaming‚ÇÅ :adjoin-retract nil))
          (es‚ÇÇ (alter-elements ($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì p) renaming renaming‚ÇÇ :adjoin-retract nil))
          (es‚Ä≤      (reverse (intersection
                               (--reject (element-contains "View" it) es‚ÇÅ) es‚ÇÇ
                               :key #'element-name :test #'string-equal)))
          ;; names not mentioned in the intersection.
          (dangling (set-difference (-concat es‚ÇÅ es‚ÇÇ) es‚Ä≤
                      :key #'element-name :test #'string-equal)))

  ;; drop the dangling names
  (setq es‚Ä≤ (-reject (Œª e ‚Üí (-some (Œª d ‚Üí (element-contains (element-name d) e)) dangling)) es‚Ä≤))

  ;; Get old names so as to adjoin the co-retracts; i.e., the projections with renaming.
  (setq es‚ÇÅ (alter-elements es‚Ä≤ rename (reify-to-list renaming‚ÇÅ :inverse t) :adjoin-retract nil))
  (setq es‚ÇÇ (alter-elements es‚Ä≤ rename (reify-to-list renaming‚ÇÇ :inverse t) :adjoin-retract nil))

   (-concat
       es‚Ä≤
       (when adjoin-retract‚ÇÅ (list (element-retract $ùëùùëéùëüùëíùëõùë° es‚Ä≤ :new es‚ÇÅ :name adjoin-retract‚ÇÅ :contravariant t)))
       (when adjoin-retract‚ÇÇ (list (element-retract p     es‚Ä≤ :new es‚ÇÇ :name adjoin-retract‚ÇÇ :contravariant t)))))))
#+END_SRC

{{{end-fold}}}

The pushout of $f : X ‚Üí A$ and $g : X ‚Üí B$ is, essentially, the disjoint sum of $A$ and $B$ where embedded elements
are considered ‚Äòindistinguishable‚Äô when the share the same origin in $X$ via the paths $f$ and $g$.
Unfortunately, the resulting ‚Äòindistinguishable‚Äô elements are actually distinguishable: They may be the /A/-name or the /B/-name
and a choice must be made as to which name is preferred since users actually want to refer to them later on.
Hence, to be useful for library construction, the pushout construction actually requires at least another input function
that provides canonical names to the supposedly ‚Äòindistinguishable‚Äô elements.

Since a ~PackageFormer~ is essentially just a /signature/ ---a collection of typed names---, we can make a ‚Äòpartial choice of
pushout‚Äô to reduce the number of arguments from 6 to 4 by letting the typed-names object $X$ be ‚Äòinferred‚Äô and encoding
the canonical names function into the operations $f$ and $g$.
The inputs functions $f, g$ are necessarily /signature morphisms/ ---mappings of names that preserve types--- and
so are simply lists associating names of $X$ to names of $A$ and $B$. If we instead consider $f‚Ä≤ : X‚Ä≤ ‚Üê A$ and
$g‚Ä≤ : X‚Ä≤ ‚Üê B$, in the /opposite direction/, then we may reconstruct a pushout by
setting $X$ to be common image of $f‚Ä≤, g‚Ä≤$, and set $f, g$ to be inclusions
In-particular, the full identity of $X‚Ä≤$ is not necessarily relevant for
the pushout reconstruction and so it may be omitted. Moreover, the issue of canonical names is resolved:
If $a ‚àà A$ is intended to be identified with $b ‚àà B$ such that the resulting element has $c$ as the chosen
canonical name, then we simply require $f‚Ä≤\, a = c = g‚Ä≤ \, b$.

At first, a pushout construction needs 5 inputs, to be practical it further needs a function for canonical names
for a total of 6 inputs. However, a pushout of $f : X ‚Üí A$ and $g : X ‚Üí B$ is intended to be the ‚Äòsmallest object $P$
that contains a copy of $A$ and of $B$ sharing the common substructure $X$‚Äô, and as such it outputs two functions
$inj‚ÇÅ : A ‚Üí P,\, inj‚ÇÇ : B ‚Üí P$ that inject the names of $A$ and $B$ into $P$.
If we realise $P$ as a record ---a type of models--- then the embedding functions are /reversed/, to obtain
projections $P ‚Üí A$ and $P ‚Üí B$: If we have a model of $P$, then we can forget some structure and rename
via $f$ and $g$ to obtain models of $A$ and $B$.
For the resulting construction to be useful, these names could be automated such as $toA : P ‚Üí A$ and $toB : P ‚Üí B$
but such a naming scheme does not scale ---but we shall use it for default names. As such, we need two more inputs
to the pushout construction so the names of the resulting output functions can be used later on.
/Hence, a practical choice of pushout needs 8 inputs!/

Using the above issue to reverse the directions of $f, g$ via $f‚Ä≤, g‚Ä≤$, we can infer the shared structure $X$
and the canonical name function. Likewise, by using $toChild : P ‚Üí Child$ default-naming scheme, we may omit
the names of the retract functions. If we wish to rename these retracts or simply omit them altogether,
we make the /optional/ arguments: Provide ~:adjoin-retract·µ¢ "new-function-name"~ to use a new name, or ~nil~ instead
of a string to omit the retract. Here are some examples of this construction of mine.

Here we provide all arguments, optional and otherwise.
#+BEGIN_SRC agda
{-700
TwoBinaryOps = Magma union Magma :renaming‚ÇÅ "op to _+_" :renaming‚ÇÇ "op to _√ó_"  :adjoin-retract‚ÇÅ "left" :adjoin-retract‚ÇÇ "right"
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record TwoBinaryOps : Set‚ÇÅ where
    field Carrier : Set
    field _+_     : Carrier ‚Üí Carrier ‚Üí Carrier

    toType : let View X = X in View Type
    toType = record {Carrier = Carrier}

    field _√ó_     : Carrier ‚Üí Carrier ‚Üí Carrier

    left : let View X = X in View Magma
    left = record {Carrier = Carrier;op = _+_}

    right : let View X = X in View Magma
    right = record {Carrier = Carrier;op = _√ó_}
#+END_SRC

Remember, /this particular user implementation/ realises ~X‚ÇÅ union X‚ÇÇ :renaming‚ÇÅ f‚Ä≤ :renaming‚ÇÇ g‚Ä≤~
as the pushout of the inclusions ~f‚Ä≤ X‚ÇÅ ‚à© g‚Ä≤ X‚ÇÇ ‚ü∂ X·µ¢~ where the source is the set-wise intersection of names.
Moreover, when either ~renaming·µ¢~ is omitted, it defaults to the identity function.

The next example is one of the reasons the construction is named ‚Äòunion‚Äô instead of ‚Äòpushout‚Äô:
It's idempotent, if we ignore the addition of the retract.
#+BEGIN_SRC agda
{-700
MagmaAgain   = Magma union Magma
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record MagmaAgain : Set‚ÇÅ where
    field Carrier : Set
    field op      : Carrier ‚Üí Carrier ‚Üí Carrier

    toType : let View X = X in View Type
    toType = record {Carrier = Carrier}

    toMagma : let View X = X in View Magma
    toMagma = record {Carrier = Carrier;op = op}
#+END_SRC

We may perform disjoint sums ---simply distinguish all the names of one of the input objects.
#+BEGIN_SRC agda
{-700
-- Magma‚Ä≤    = Magma primed  ‚ü¥ record
-- SumMagmas = Magma union Magma‚Ä≤ :adjoin-retract‚ÇÅ nil ‚ü¥ record
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record SumMagmas : Set‚ÇÅ where
    field Carrier  : Set
    field op       : Carrier ‚Üí Carrier ‚Üí Carrier

    toType         : let View X = X in View Type
    toType = record {Carrier = Carrier}

    field Carrier‚Ä≤ : Set
    field op‚Ä≤      : Carrier‚Ä≤ ‚Üí Carrier‚Ä≤ ‚Üí Carrier‚Ä≤

    toType‚Ä≤ : let View X = X in View Type
    toType‚Ä≤ = record {Carrier = Carrier‚Ä≤}

    toMagma : let View X = X in View Magma
    toMagma = record {Carrier = Carrier‚Ä≤;op = op‚Ä≤}

    toMagma‚Ä≤ : let View X = X in View Magma‚Ä≤
    toMagma‚Ä≤ = record {Carrier‚Ä≤ = Carrier‚Ä≤;op‚Ä≤ = op‚Ä≤}
#+END_SRC

A common scenario is extending a structure, say ~Magma~, into orthogonal directions, such as by making
it operation associative or idempotent, then closing the resulting diamond by combining them, to obtain
a semilattice. However, the orthogonal extensions may involve different names and so the resulting
semilattice presentation can only be formed via pushout; below are three ways to form it.
#+BEGIN_SRC agda
{-700
Semigroup          = Magma postulating "_¬∑_" "associative" ‚ü¥ record
-- IdempotentMagma = Magma renaming "_¬∑_ to _‚äî_" ‚ü¥ postulating "_‚äî_" "idempotent"  :adjoin-retract nil ‚ü¥ record

‚äî-SemiLattice     = Semigroup union IdempotentMagma :renaming‚ÇÅ "_¬∑_ to _‚äî_" ‚ü¥ record
¬∑-SemiLattice     = Semigroup union IdempotentMagma :renaming‚ÇÇ "_‚äî_ to _¬∑_" ‚ü¥ record
‚Üë-SemiLattice     = Semigroup union IdempotentMagma :renaming‚ÇÅ "_¬∑_ to _‚Üë_" :renaming‚ÇÇ "_‚äî_ to _‚Üë_" ‚ü¥ record
-}
#+END_SRC

Let's close with the classic example of forming a ring structure by combining two monoidal structures.
This example also serves to further showcasing how using ~ùí±-postulating~ can make for more granular, modular, developments.
#+BEGIN_SRC agda
{-700
Additive           = Magma renaming "_¬∑_ to _+_" ‚ü¥ postulating "_+_" "commutative"  :adjoin-retract nil ‚ü¥ record
Multiplicative     = Magma renaming "_¬∑_ to _√ó_" :adjoin-retract nil ‚ü¥ record
AddMult            = Additive union Multiplicative ‚ü¥ record
AlmostNearSemiRing = AddMult ‚ü¥ postulating "_√ó_" "distributiveÀ°" :using "_+_" ‚ü¥ record
-}
#+END_SRC
#+BEGIN_SRC results-agda :tangle no
record AlmostNearSemiRing : Set‚ÇÅ where
    field Carrier : Set
    field _+_     : Carrier ‚Üí Carrier ‚Üí Carrier

    toType : let View X = X in View Type
    toType = record {Carrier = Carrier}

    toMagma : let View X = X in View Magma
    toMagma = record {Carrier = Carrier;op = _+_}

    field comm       : ‚àÄ x y   ‚Üí _+_ x y ‚â° _+_ y x
    field _√ó_        : Carrier ‚Üí Carrier ‚Üí Carrier

    toAdditive : let View X = X in View Additive
    toAdditive = record {Carrier = Carrier;_+_ = _+_;comm = comm}

    toMultiplicative : let View X = X in View Multiplicative
    toMultiplicative = record {Carrier = Carrier;_√ó_ = _√ó_}

    field distÀ°      : ‚àÄ x y z ‚Üí _√ó_ x (_+_ y z) ‚â° _+_ (_√ó_ x y) (_√ó_ x z)
#+END_SRC

Following the reasoning for pushouts, we implement pullbacks in the same way with the same optional arguments.
Here's an example use:
#+BEGIN_SRC agda
{-700
Just-Carrier    = Additive intersect Multiplicative
Magma-yet-again = Additive intersect Multiplicative :renaming‚ÇÅ "_+_ to op" :renaming‚ÇÇ "_√ó_ to op"
-}
#+END_SRC
Moreover the absorptive law $X ‚à© (X ‚à™ Z) = X$ also holds for these operations:
~Additive intersect AddMult~ is just ~Additive~, when we ignore all adjoined retracts.

** Duality
   :PROPERTIES:
   :CUSTOM_ID: Duality
   :END:
Maps between grouping mechanisms are sometimes called /views/, which are essentially an internalisation of
of the /variationals/ in our system. Let's demonstrate an example of how dual concepts are
captured concretely in the system.

For example, the dual, or opposite, of a binary operation $_¬∑_$ is the operation $_¬∑·µí·µñ_$
defined by $x ¬∑·µí·µñ y ‚âî y ¬∑ x$.
Classically in Agda, duality is utilised as follows:
1. Define a module ~R _¬∑_~ for the desired concepts.
2. Define a shallow module ~R·µí·µñ _¬∑_~ that opens ~R _¬∑·µí·µñ_~ and renames the concepts in ~R~
   by the dual names.

   The RATH-Agda library performs essentially this approach, for example for obtaining ~UpperBounds~
   from ~LowerBounds~ in the context of a poset.

Unfortunately, this means that any record definitions in ~R~ must have its field names be
sufficiently generic to play /both/ roles as the original and the dual concept.
Admittedly, RATH-Agda's names are well-chosen; e.g., ~value, bound·µ¢, universal~
to denote a value that is a lower/upper bound of two given elements, satisfying
a lub/glb universal property. However, well-chosen names come at an upfront cost:
One must take care to provide sufficiently generic names and account for duality
at the outset, irrespective of whether one /currently/ cares about the dual or not; otherwise
when the dual is later formalised, then the names of the original concept must be refactored
throughout a library and its users.

Consider the following heterogeneous algebra.
#+BEGIN_SRC agda
{-700
PackageFormer LeftUnitalAction : Set‚ÇÅ where
  Scalar : Set
  Vector : Set
  _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
  ùüô       : Scalar
  leftId  : {x : Vector} ‚Üí ùüô ¬∑ x ‚â° x

-- Let's reify this as a valid Agda record declaration
LeftUnitalActionR  = LeftUnitalAction ‚ü¥ record
-}
#+END_SRC
Informally, one now ‚Äòdefines‚Äô a right unital action by duality, flipping the binary operation
and renaming ~leftId~ to be ~rightId~. Such informal parlance is in-fact nearly formally, as the following:
#+BEGIN_SRC agda
{-700
RightUnitalActionR = LeftUnitalActionR flipping "_¬∑_" :renaming "leftId to rightId" ‚ü¥ record
-}
#+END_SRC
Of-course the resulting representation is semantically identical to the previous one, and so it is
furnished with a ~to‚ãØ~ mapping:
#+BEGIN_SRC agda
forget : RightUnitalActionR ‚Üí LeftUnitalActionR
forget = RightUnitalActionR.toLeftUnitalActionR
#+END_SRC

Likewise for the RATH-Agda library's example from above, to define semi-lattice structures by duality:
#+BEGIN_SRC agda
import Data.Product as P

{-700
PackageFormer JoinSemiLattice : Set‚ÇÅ where
  Carrier : Set
  _‚äë_     : Carrier ‚Üí Carrier ‚Üí Set
  refl    : ‚àÄ {x} ‚Üí x ‚äë x
  trans   : ‚àÄ {x y z} ‚Üí x ‚äë y ‚Üí y ‚äë z ‚Üí x ‚äë z
  antisym : ‚àÄ {x y} ‚Üí x ‚äë y ‚Üí y ‚äë x ‚Üí x ‚â° y
  _‚äî_     : Carrier ‚Üí Carrier ‚Üí Carrier
  ‚äî-lub   : ‚àÄ {x y z} ‚Üí x ‚äë z ‚Üí y ‚äë z ‚Üí (x ‚äî y) ‚äë z
  ‚äî-lubÀò  : ‚àÄ {x y z}  ‚Üí (x ‚äî y) ‚äë z  ‚Üí x ‚äë z P.√ó y ‚äë z

JoinSemiLatticeR = JoinSemiLattice record
MeetSemiLatticeR = JoinSemiLatticeR flipping "_‚äë_" :renaming "_‚äî_ to _‚äì_; ‚äî-lub to ‚äì-glb"
-}
#+END_SRC
In this example, besides the map from meet semi-lattices to join semi-lattices, the types of
the dualised names, such as ~‚äì-glb~, are what one would expect were the definition written out explicitly:
#+BEGIN_SRC agda
module woah (M : MeetSemiLatticeR) where
  open MeetSemiLatticeR M

  nifty : ‚àÄ {x y z} ‚Üí z ‚äë x ‚Üí z ‚äë y ‚Üí z ‚äë (x ‚äì y)
  nifty = ‚äì-glb

  _ : let _‚äí_ = Œª x y ‚Üí y ‚äë x
      in ‚àÄ {x y z} ‚Üí x ‚äí y ‚Üí y ‚äí z ‚Üí x ‚äí z
  _ = trans
#+END_SRC

{{{fold(Definition of flipping -- Feel free to ignore until later)}}}
#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(defun flip-type (œÑ)
  "Given a binary operation's type, as a string, flip the first two types.

E.g., ‚ÄúA ‚Üí B ‚Üí C‚Äù becomes ‚ÄúB ‚Üí A ‚Üí C‚Äù.
  "
  (-let [ts (s-split "‚Üí" œÑ)]
   (s-join " ‚Üí " (list (nth 1 ts) (nth 0 ts) (nth 2 ts)))))
#+END_SRC

#+RESULTS:
: flip-type

:test:
(flip-type "A ‚Üí B ‚Üí C")
:end:

#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(defun flip (name op)
 "If element OP is named NAME, then flip its type; else leave it alone-ish.

If OP mentions NAME, then prefix its type with
‚Äúlet NAME = Œª x y ‚Üí NAME y x in‚Äù, which results in valid Agda
due to its identifier scoping rules.
"
 (cond ((equal name (element-name op))
               (map-type #'flip-type op))
       ((or (element-contains name op) (element-contains (s-replace "_" "" name) op))
               (-let [letin (format "let %s = Œª x y ‚Üí %s y x in " name name)]
                 (thread-last op
                   (map-type (Œª œÑ ‚Üí (concat letin œÑ)))
                   (map-equations (Œª eqs ‚Üí (--map (-let [ps (s-split "=" it)] (format "%s = %s %s" (car ps) letin (s-join "=" (cdr ps)))) eqs))))))
       (t op)))
#+END_SRC

#+RESULTS:
: flip

:tests:
(flip "_+_" (car (parse-elements '("_+_ : A ‚Üí B ‚Üí C"))))  ‚áí  _+_ : B ‚Üí A ‚Üí C
(flip "_+_" (car (parse-elements '("_‚äï_ : A ‚Üí B ‚Üí C"))))  ‚áí  _‚äï_ : A ‚Üí B ‚Üí C
(flip "_+_" (element-contains "_+_" (car (parse-elements '("val : C" "val = _+_ b c"))))
:end:

#+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref ùí±-user-man-pt-1 :noweb yes
(ùí± flipping name (renaming "")
 = "Flip a single binary operation, or predicate, NAME.

    Dual constructs usual require some identifiers to be renamed,
    and these may be supplied as a ‚Äú;‚Äù-separated ‚Äúto‚Äù-separated string list, RENAMING.

    There is no support for underscores; mixfix names must be given properly.
  "
    renaming 'renaming :adjoin-retract nil
 ‚ü¥ :alter-elements (Œª es ‚Üí
                      (let ((es‚Ä≤ (--map (flip name it) es)))
                        (-concat es‚Ä≤ (list (flip name (element-retract $ùëùùëéùëüùëíùëõùë° ($ùëíùëôùëíùëöùëíùëõùë°ùë†-ùëúùëì $ùëùùëéùëüùëíùëõùë°) :new es‚Ä≤)))))))
#+END_SRC

#+RESULTS:
: ùí±-flipping

{{{end-fold}}}

** Extracting Little Theories
   :PROPERTIES:
   :CUSTOM_ID: Extracting-Little-Theories
   :END:

The ~extended-by~ variational allows Agda users to easily employ the /tiny theories/ [cite:little_theories][mathscheme]
approach to library design: New structures are built from old ones by augmenting one concept at a time,
then one uses mixins such as ~union~, below, to obtain a complex structure.
This approach lets us write a program, or proof, in a context that only
provides what is /necessary/ for that program-proof and nothing more.
In this way, we obtain /maximal generality/ for re-use!
This approach can be construed as /The Interface Segregation Principle [design-patterns-solid]:
/No client should be forced to depend on methods it does not use./

#+BEGIN_SRC agda :tangle no
{-700
PackageFormer Empty : Set‚ÇÅ where {- No elements -}
Type  = Empty extended-by "Carrier : Set"
Magma = Type  extended-by "_¬∑_ : Carrier ‚Üí Carrier ‚Üí Carrier"
CommutativeMagma = Magma extended-by "comm : {x y : Carrier} ‚Üí  x ¬∑ y  ‚â°  y ¬∑ x"
-}
#+END_SRC

The cool thing here is that ~CommutativeMagma~ comes with ~toMagma, toType,~ and ~toEmpty~.

However, life is messy and sometimes one may hurriedly create a structure,
then later realise that they are being forced to depend on unused methods.
Rather than throw an ‚Äònot implemented‚Äô exception or leave them undefined,
we may use the ~keeping~ variational to extract the smallest well-formed
sub-PackageFormer that mentions a given list of identifiers.

For example, suppose we quickly formed ~Monoid~, from earlier, but later wished
to utilise other substrata. This is easily achieved with the following declarations.
#+BEGIN_SRC agda
{-700
Empty‚Ä≥        = Monoid keeping ""
Type‚Ä≥         = Monoid keeping "Carrier"
Magma‚Ä≥        = Monoid keeping "_¬∑_"
Semigroup‚Ä≥    = Monoid keeping "assoc"
PointedMagma‚Ä≥ = Monoid keeping "ùïÄ; _¬∑_"
-- ‚Ü™ Carrier; _¬∑_; ùïÄ
-}
#+END_SRC
Even better, we may go about deriving results ---such as theorems or algorithms---
in familiar settings, such as ~Monoid~, only to realise that they are more expressive
than necessary. Such an observation no longer need to be found by inspection, instead
it may be derived mechanically.
#+BEGIN_SRC agda
{-700
LeftUnitalMagma = Monoid keeping "ùïÄ-unique" ‚ü¥ record
-}
#+END_SRC
This expands to the following theory, minimal enough to derive ~ùïÄ-unique~.
#+BEGIN_SRC agda-results :tangle no
record LeftUnitalMagma : Set‚ÇÅ where

   field
     Carrier : Set
     _¬∑_     : Carrier ‚Üí Carrier ‚Üí Carrier
     ùïÄ       : Carrier
     leftId  : {x : Carrier} ‚Üí ùïÄ ¬∑ x  ‚â° x

   ùïÄ-unique     : ‚àÄ {e} (lid : ‚àÄ {x} ‚Üí e ¬∑ x ‚â° x) (rid : ‚àÄ {x} ‚Üí x ¬∑ e ‚â° x) ‚Üí e ‚â° ùïÄ
   ùïÄ-unique lid rid = ‚â°.trans (‚â°.sym leftId) rid
#+END_SRC

Surprisingly, in some sense, ~keeping~ let's us apply the interface segregation principle,
or ‚Äòlittle theories‚Äô, after the fact ---this is also known as [[https://en.wikipedia.org/wiki/Reverse_mathematics][reverse mathematics]].

** 200+ theories -- one line for each
   :PROPERTIES:
   :CUSTOM_ID: hundreds-of-theories
   :END:

   People should enter terse, readable, specifications that expand into useful,
   typecheckable, code that may be dauntingly larger in textual size.

 The following listing of structures was adapted from the source of a
 MathScheme library cite:tpc,mathscheme, which in turn was inspired by
 the web lists of [[http://math.chapman.edu/~jipsen/structures/doku.php][Peter Jipsen]] and [[http://home.utah.edu/~nahaj/logic/structures/][John Halleck]], and many others from
 Wikipedia and nlab. Totalling over 200 theories which elaborate into
 nearly 1500 lines of typechecked Agda, this demonstrates that our systems works;
 the 750% efficiency savings speak for themselves.

 {{{fold(200+ One Line Specfications)}}}
 #+INCLUDE: "math-scheme.agda" src agda :lines "20-258"
 {{{end-fold}}}

 {{{fold(~1500 Lines of Typechecked Agda)}}}
 #+INCLUDE: "math-scheme-generated.agda" src agda
 {{{end-fold}}}

 If anything, this elaboration demonstrates our tool as useful engineering result.
 The main novelty being the ability for library users to extend the collection
 of operations on packages, modules, and then have it immediately applicable to
 Agda, an executable programming language.

 Since the resulting expanded code is typechecked by Agda, we encountered a number
 of places where non-trivial assumptions accidentally got-by the MathScheme team;
 for example, in a number of places, an arbitrary binary operation occurred multiple
 times leading to ambiguous terms, since no associativity was declared.
 Even if there was an implicit associativity criterion, one would then expect
 multiple copies of such structures, one for each parenthesisation.
 Moreover, there were also certain semantic concerns about the design
 hierarchy that we think are out-of-place, but we chose to leave them as is
 ---e.g., one would think that a ‚Äúpartially ordered magma‚Äù would consist of
 a set, an order relation, and a binary operation that is monotonic in both arguments
 wrt to the given relation; however, ~PartiallyOrderedMagma~ instead comes with
 a single monotonicity axiom which is only equivalent to the two monotonicity
 claims in the setting of a monoidal operation.
 Nonetheless, we are grateful for the source file provided by the MathScheme team.
 # Indeed, monotonicity in the second argument cannot be proven from the given
 # law for the operation ‚Äúx ‚ü™ y = x‚Äù when ‚â§ is taken to be ‚âà, and we have 2 points.

 + Unlike other systems, ours does not come with a static set of module operators
   ---it grows dynamically, possibly by you, the user.

 We implore the readers to build upon our code of theories above by, for example,
 define the notion of homomorphism for every single one of the theories.
 Besides being tiresome, such a manual process is also error-prone.
 Instead, one can automatically derive this concept!
 ( The construction of such a variational is delegated to the more involved
 second part of the user manual. )

 Likewise, for other concepts from universal algebra ---which is useful to computer
 science in the setting of specifications.

** Summary of Sample Variationals Provided With The System
   :PROPERTIES:
   :CUSTOM_ID: Summary-of-Sample-Variationals-Provided-With-The-System
   :END:

   Below are some variationals that can be used immediately by a user ---no Lisp knowledge required.
   If you simply mention one of them in a comment, then load the file with ~C-c C-l~, then you may hover
   over them to see their full documentation. You may also look at the second part of the user manual
   below to see accompanying examples.

   | _Name_                 | _Description_                                                               |
   | ~record~               | Reify a PackageFormer as a valid Agda record.                             |
   | ~extended-by~          | ‚äô Extend a PackageFormer by a string-‚Äú;‚Äù-list of declaration.             |
   | ~keeping~              | ‚òÖ Largest well-formed PackageFormer consisting of a given list of elements.  |
   | ~union~                | ‚äô Union two PackageFormers into a new one, maintaining relationships.     |
   | ~flipping~             | ‚äô Dualise a binary operation or predicate.                                |
   | ~unbundling~           | Consider the first /N/ elements, which may have definitions, as parameters. |
   | ~data~                 | Reify a PackageFormer as a valid Agda algebraic data type.                |
   | ~open~                 | Reify a given PackageFormer as a parameterised Agda ‚Äúmodule‚Äù declaration. |
   | ~opening~              | ‚òÖ Open a record as a module exposing only the given names.                |
   | ~open-with-decoration~ | Open a record, exposing all elements, with a given decoration.            |
   | ~sorts~                | Keep only the types declared in a grouping mechanism.                     |
   | ~signature~            | Keep only the elements that target a sort, drop all else.                 |
   | ~rename~               | ‚äô Apply a ~Name ‚Üí Name~ function to the elements of a PackageFormer.        |
   | ~renaming~             | ‚äô ‚òÖ Rename elements using a list of ‚Äúto‚Äù-separated pairs.                 |
   | ~decorated~            | ‚äô Append all element names by a given string.                             |
   | ~codecorated~          | ‚äô Prepend all element names by a given string.                            |
   | ~primed~               | ‚äô Prime all element names.                                                |
   | ~subscripted·µ¢~         | ‚äô Append all element names by subscript ~i : 0..9~.                         |
   | ~hom~                  | Formulate the notion of homomorphism of parent PackageFormer algebras.    |

  + ‚òÖ :: Argument is a string of ‚Äú;‚Äù-separated items consisting of ‚Äúto‚Äù-separated pairs.

         - ~keeping~ has input being ‚Äú;‚Äù-separated string of proper names only.

  + ‚äô :: The resulting PackageFormer is furnished with an element ~toP : P; to P = record {old·µ¢ = new·µ¢}~
         where ~P~ is the name of the parent, or source, PackageFormer. This element provides a way to
         view the resulting child presentation as an instance of the original presentation.

         - If we dislike the ~toP~ naming, we can simply invoke ~renaming~.

         - Sometimes these ‚Äòmaps‚Äô are invertible; we leave it as an exercise to the interested reader
           to formulate ~toP‚Åª¬π~ in the variationals, when possible.

         - Invoke a variational with ~:adjoin-retract nil~ if you do not want this map to be added;
           or use ~t~ in-place of ~nil~ if you insist on it being added.

 Below are the *five meta-primitives* from which all variationals are borne, followed by a few others
 that are useful for extending the system by making your own grouping mechanisms and operations on them.
 Using these requires a small amount of Lisp, which is tersely reviewed in the second part of the user
 manual, below.
 | _Name_            | _Description_                                                          |
 | ~:waist~          | Consider the first /N/ elements as, possibly ill-formed, parameters.   |
 | ~:kind~           | Valid Agda grouping mechanisms: ~record, data, module~.                |
 | ~:level~          | The Agda level of a PackageFormer.                                   |
 | ~:alter-elements~ | Apply a ~List Element ‚Üí List Element~ function over a PackageFormer.   |
 | ~‚ü¥~               | Compose two variational clauses in left-to-right sequence.           |
 | ~map~             | ‚äô Map a ~Element ‚Üí Element~ function over a PackageFormer.             |
 | ~generated~       | Keep the sub-PackageFormer whose elements satisfy a given predicate. |

** COMMENT User Manual II: Extending the System
   :PROPERTIES:
   :header-args: :tangle "package-former.agda"
   :CUSTOM_ID: User-Manual-II--Extending-the-System
   :END:

 :Hide:
 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref std-ùí±-lib :noweb yes
(defvar ‚ôØstandard-variationals 10
  "The number of variationals exported with the PackageFormer system.")
 #+END_SRC
 :End:

 Herein we demonstrate how with a little bit of Lisp, one may create any desired form of
 grouping mechanism as well as operation between groupings.

 We begin with a brief review of Lisp basics such as list operations then immediately dive into
 creating an Agda module that contains our new user-defined constructs, within 700-comments.

*** COMMENT Substructure
    :PROPERTIES:
    :CUSTOM_ID: COMMENT-Substructure
    :END:
 [ ] A substructure is one where a subset of the carrier set of a
 structure itself carries the structure.

 {-  lisp
 ;;   f : A ‚Üí A ‚Üí A
 ;; ‚áí f-closure : ‚àÄ {x‚ÇÅ x‚ÇÇ} ‚Üí ‚Ñ¨ x‚ÇÅ ‚Üí ‚Ñ¨ x‚ÇÇ ‚Üí ‚Ñ¨ (f x‚ÇÅ x‚ÇÇ)
 ;;
 ;; (predicate-closure (car (parse-elements '("f : A ‚Üí A ‚Üí A"))))
 ;;
 (defun predicate-closure (e)
 (let* ((indices (number-sequence 1 (1- (length (s-split "‚Üí" (element-type e))))))
        (args (s-join " " (--map (format "x%s" it) indices))))
   (concat (s-replace "_" "" (element-name e))
           "-closure : "
           (unless (s-blank-p args)
             (format "‚àÄ {%s} ‚Üí %s ‚Üí "
               args
               (s-join " ‚Üí " (--map (format "‚Ñ¨ x%s" it) indices))))
     (format "‚Ñ¨ (%s.%s ùíú %s)"
       $ùëùùëéùëüùëíùëõùë°
       (element-name e)
       args))))

 (ùí± substructure carrier
 = "C.f. ùí±-data ^_^"
  :alter-elements (Œª es ‚Üí
     (thread-last es
       (--filter (s-contains? carrier (target (element-type it))))
       (mapcar #'predicate-closure)
       (cons (format "‚Ñ¨ : %s.%s ùíú ‚Üí Set" $ùëùùëéùëüùëíùëõùë° carrier))
       (cons (format "ùíú : %s" $ùëùùëéùëüùëíùëõùë°))
       parse-elements)))
 -}

 {-700
 SubMonoid = MonoidR substructure "Carrier" ‚ü¥ record
 -}
*** Lisp Interface
    :PROPERTIES:
    :CUSTOM_ID: Lisp-Interface
    :END:
 {{{goal(Summary of useful functions for programming variationals.)}}}

    # Need to explain that a PackageFormer element is a structure consisting of a qualifier, name, type, and list of equational clauses.
    # Then, need to tersely summarise the operations, projections & maps, on these items.

    + A ~PackageFormer~ is nothing more than a list of elements.
    + An ~element~ is a record of 4 items: A qualifier, a name, a type, and
      a list of equational clauses for that name.

   Below are functions that will be used in subsequent subsections in order to form user-defined
   variationals. Consult these tables as necessary and look at an [[https://alhassy.github.io/ElispCheatSheet/][Elisp Cheat Sheet]], if need be.

   + *Elements*

     Let ‚Ñ∞ denote one of ~qualifier, name, type, equations~ in the following list of useful functions.

     | ~(make-element ùìÜ ùìÉ ùìâ ‚ÑØ)~      | An ~element~ value is formed.                                |
     | ~(element-‚Ñ∞ e)~               | Project component ‚Ñ∞ from element ~e~.                        |
     | ~(map-‚Ñ∞ f e)~                 | Return a copy of ~e~ with component ‚Ñ∞ updated by function ~f~. |
     | ~(element-replace old new e)~ | Replace all string occurances of ~old~ by ~new~ in element ~e~.  |

   + *Lists*

     | ~(list x‚ÇÄ ‚Ä¶ x‚Çô)~            | Form a list of elements ~x·µ¢~.                    |
     | ~(car xs)~                  | Obtain first element of list ~xs~.               |
     | ~(cdr xs)~                  | Obtain all but first element of ~xs~.            |
     | ~(cons x xs)~               | Form a new list with car ~x~ and cdr ~xs~.         |
     | ~(mapcar (Œª it ‚Üí ‚ãØit‚ãØ) xs)~ | Map the given function on ~xs.~                  |
     | ~(--map (‚ãØit‚ãØ) xs)~         | Map the /implicit/ function ~(Œª it ‚Üí ‚ãØit‚ãØ)~ on ~xs~. |
     | ~(-cons* x‚ÇÄ ‚Ä¶ x‚Çô xs)~       | ~(cons x‚ÇÄ (cons x‚ÇÅ (‚ãØ (cons x‚Çô xs))))~.          |
     |                           |                                                |

   + *Strings*

     | ~(concat s‚ÇÄ ‚Ä¶ s‚Çô)~      | Concatenate strings ~s·µ¢~.                                                 |
     | ~(s-replace old new s)~ | Replace all string occurrences of ~old~ by ~new~ in string ~e~.               |
     | ~(rename-mixfix f op)~  | Rename string ~op~ according to function ~f~ by ‚Äòleaping over‚Äô underscores. |
     |                       | E.g., ~f, op = (Œª x ‚Üí (concat x "‚Ä≤")), _‚äï_  ‚áí _‚äï‚Ä≤_~.                        |

   {{{goal(*You can always see the documentation of an item with ~C-h o~!*)}}}

*** User Manual Header
    :PROPERTIES:
    :CUSTOM_ID: User-Manual-Header
    :END:
 {{{goal(A literate programming approach to a user manual.)}}}

    In order for our manual's examples to be up-to-date, we will take a literate approach
    to producing them. Namely, the Agda code here is ‚Äòtangled‚Äô from this prose into an Agda
    file which can then be checked by an Agda process. Whence, this file is the de-facto source.

    Let's start-off with a usual Agda header:
 #+BEGIN_SRC agda
{- This loads the PackageFormer metaprogram; press C-x C-e after the closing ‚Äú)‚Äù below.                 -}
{- (progn (load-file "~/.emacs.d/agda-next-700-module-systems.el") (agda-next-700-module-systems-mode)) -}

module package-former where

open import package-former-generated
open import Level
open import Data.Bool
open import Data.List using (List; _‚à∑_; []; foldr)
import Relation.Binary.PropositionalEquality as ‚â°; open ‚â° using (_‚â°_)

{- Let's ensure content of User Manual part I actually type checkes -}
{- Feel free to comment this line out. -}
import package-former-user-manual-i
 #+END_SRC
 #
 # Strip away the 700 annotations with:
 # (progn (700-bare-bones) (find-file "Testing_Bare.agda"))

 To make the resulting Agda file somewhat self-contained, in case anyone wishes to read that
 or load it into Agda and play with it, let's add a blurb.
 #+BEGIN_SRC agda
{-
0. There are a number of common use-cases.
1. We can handle all of them & more, since we're extensible.
  - Mention the Lean & Coq, as well as the Agda, repeated fragments.
2. The resulting setup is pragmatic: It is unobtrusive in the
   traditional Agda coding style in that it happens in the background.
3. It fills a particular need; the desire to avoid repetitious code.
-}
 #+END_SRC

 Before getting to the meat of things, it is important to note that comments
 begun with ~{-~ /and/ followed by a space are treated as usual Agda comments,
 whereas those /without/ a following space such as ~{-700~ and ~{-lisp~ are picked-up
 by our meta-program.

 For example, having no space between ‚Äú{-‚Äù and ‚Äúlisp‚Äù would cause the following block to be executed
 as a Lisp form.
 #+BEGIN_SRC agda
{- lisp
(message-box "Hello")
(message-box "World")
-}
 #+END_SRC

 Alternatively, here is the PackageFormer for M-Sets from the introduction.
 It is a useful example since it is multi-sorted.
 #+BEGIN_SRC agda
{-700
PackageFormer M-Set : Set‚ÇÅ where
   Scalar  : Set
   Vector  : Set
   _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
   ùüô       : Scalar
   _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
-}
 #+END_SRC
 Let us also introduce a slightly more syntactically-involved example:
 *A PackageFormer with equations.* The equations, /depending on our perspective,/
 ---i.e., the variational invoked--- may be thought of as:
 + Derived elements; e.g., in a record, they are a definitional extension
   and for an ADT, they are methods defined on the constructors.
 + Coherence constraints; e.g., in a record, we may interpret an equation ~ùìÅ = ùìá~
   as an additional axiom ~‚àÄ {‚ãØ} ‚Üí ‚Ñì ‚â° ùìá~ ---e.g., when a user may supply an efficient definition
   of ~ùìÅ~ but is constrained to have a particular behaviour ~ùìá~.
 + Rewrite rules; e.g., in an ADT, an equation may simply act as an alias and is to be used
   in rewriting the remainder of the ADT declaration.
 + Ignored components; e.g., in a record, we may ignore the equations altogether
   and lift the associated names into being fields ---e.g., ~_‚âà_~ would usually be lifted into
   a field and its stringent implementation via ~_‚â°_~ is used as a motivating or simplifying factor.

 #+BEGIN_SRC agda
{-700
PackageFormer MonoidP : Set‚ÇÅ where

    -- A few declarations
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)

    -- We have a setoid-like structure; with a default implementation
    _‚âà_   : Carrier ‚Üí Carrier ‚Üí Set
    _‚âà_   = _‚â°_
    ‚®æ-cong : ‚àÄ {x y x‚Ä≤ y‚Ä≤} ‚Üí x ‚âà x‚Ä≤ ‚Üí  y ‚âà y‚Ä≤ ‚Üí (x ‚®æ y) ‚âà (x‚Ä≤ ‚®æ y‚Ä≤)
    ‚®æ-cong = Œª{ ‚â°.refl ‚â°.refl ‚Üí ‚â°.refl}

    -- For now only one item in a declaration;
    -- namely ‚ÄúLid‚Äù & ‚ÄúRid‚Äù cannot be declared in one line.
    Lid : Carrier ‚Üí Carrier
    Lid x = Id ‚®æ x
    Rid : Carrier ‚Üí Carrier
    Rid x = x ‚®æ Id

    -- Agda permits pure, non-pattern-matching, equations between ‚Äúfields‚Äù in a record.
    concat : List Carrier ‚Üí Carrier
    concat = foldr _‚®æ_ Id

    -- More declarations
    leftId  : ‚àÄ {x : Carrier} ‚Üí (Id ‚®æ x) ‚âà x
    rightId : ‚àÄ {x : Carrier} ‚Üí Rid x ‚âà x

    -- Since there are no more pure declarations, ‚Äúfields‚Äù, subsequent equations
    -- may use pattern matching.

    Id¬≤ : (Id ‚®æ Id) ‚âà Id
    Id¬≤ = rightId

    concat‚Çö : List Carrier ‚Üí Carrier
    concat‚Çö []       = Id
    concat‚Çö (x ‚à∑ xs) = x ‚®æ concat‚Çö xs
-}
 #+END_SRC

 Notice that there is no particular segregation of declarations and equations.
 Simply: A declaration may /optionally/ have an associated equation; however
 once an equation uses pattern matching then all subsequent declarations must also
 have equations ---this is a constraint of the current Agda implementation---;
 as such, the equation for ~‚®æ-cong~ uses Agda's pattern-matching-Œª.

 :not_yet_implemented:
 TODO: implement support for literate blocks

 The ~{-700 ‚ãØ -}~ approach may be acceptable to those writing ~.agda~ files,
 but those who write ~.lagda~ files may find themselves often having
 ~\begin{code} {-700 ‚ãØ -} \end{code}~ which is rather clunky.
 Instead, they may simply write ~\begin{700} ‚ãØ \end{700}~ and similarly for ~lisp~.

 | Henceforth, we omit the comment delimiters. |

 For example, here is our earlier PackageFormer of ~M-Set~'s declared in full.
 ,#+BEGIN_SRC agda :tangle no
 PackageFormer M-Set : Set‚ÇÅ where
    Scalar  : Set
    Vector  : Set
    _¬∑_     : Scalar ‚Üí Vector ‚Üí Vector
    ùüô       : Scalar
    _√ó_     : Scalar ‚Üí Scalar ‚Üí Scalar
    leftId  : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
    assoc   : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
 #+END_SRC
 :end:

*** Empty Variationals
    :PROPERTIES:
    :CUSTOM_ID: Empty-Variationals
    :END:
    :PROPERTIES:

    :END:
 {{{goal(A summary of the key features of ùí±ariationals)}}}

    The simplest user definable variational is the empty one:
 #+BEGIN_SRC agda
{-700
-- Variational with empty right hand side.
ùí±-identity =
-}
         #+END_SRC

    The prefix ~ùí±-~ signals to the Elisp meta-program that this particular equation is intended
    to be a variational and should be /loaded into Emacs/ as such. Indeed, you may view the documentation
    and /elaborated/ Lisp of this definition using ~C-h o RET ùí±-identity~.

    *Remember*: The prefix ~ùí±-~ only occurs at the definition site, the call site omits it.
    Why? We have augmented the Emacs system with a new functional definition, and the ùí±-
    serves as a namespace delimiter.

    Indeed, we may now perform the following invocation ---within 700-comments.

         #+BEGIN_SRC agda
{-700
MonoidP‚Å±·µà = MonoidP identity
-}
         #+END_SRC

  Loading the meta-program using Agda's usual ~C-c C-l~ lets us
  hover over ~MonoidP‚Å±·µà~ to see its elaboration is precisely that of ~MonoidP~.

  /Moreover/, to be useful, all variationals
  have tooltips showing their user-defined documentation.
  If we hover over ~identity~, we are informed that it is undocumented.
  User documentation is optional and may appear immediately following the ~=~, as follows.
 #+BEGIN_SRC agda
{-700
ùí±-no-op = "This is the do-nothing variational"
-}
         #+END_SRC

 We may substitute equals-for-equals:
         #+BEGIN_SRC agda
{-700
-- No variational clauses needed!
MonoidP‚Å∞  = MonoidP
-}
         #+END_SRC

 Doing nothing is meaningful with respect to a composition operation.
 Momentarily, ‚Äú‚ü¥‚Äù is forwards composition: We ‚Äòthread‚Äô the ~Pf~ through the variationals ~v·µ¢~ in order.

         #+BEGIN_SRC agda
{-700
-- Identity of composition ‚ü¥
MonoidP·∂ú = MonoidP ‚ü¥
-}
 #+END_SRC

 | Operationally: ~Pf ‚ü¥ v  ‚âà  Pf v ‚ü¥  ‚âà  Pf v~ |

 We may also augment a variational with positional and (optional) keyword arguments that have default values.
 The keyword arguments along with their default value, /if any/, are enclosed in parenthesis.
 #+BEGIN_SRC agda
{-700
ùí±-test positional (keyword 3) another = "I have two mandatory arguments and one keyword argument"

Monoid-test = MonoidP ‚ü¥ test "positional arg‚ÇÅ" "positional arg‚ÇÇ" :keyword 25
-}
 #+END_SRC

 We are not doing anything with the arguments here; we shall return to this in later subsections.

*** ‚á® Errors
    :PROPERTIES:
    :CUSTOM_ID: --Errors
    :END:
    :PROPERTIES:

    :END:
   Even though this is a prototype, we wish it to be useful to ourselves and to others
   ---especially those who take a quick glance, think they got it, and try things out only to not have them work
   immediately. As such, we have implemented a cute little error-reporting system.
   | If you try to load, ~C-c C-l~, but your 700-syntax is wrong, you get an immediate error explaining why ‚ô•‚Äø‚ô• |

   For example, suppose we accidentally wrote ~tester~ instead of ~test~, which we defined
   at the end of the previous section, as in the following.
   ( The space before ~700~ is so that this crashing block is not in effect. )
 #+BEGIN_SRC agda
{-   700
ùí±-whoops  = tester 1 2 :keyword 3
-}
 #+END_SRC
   When we try to load our Agda file the Agda process is interrupted and we are warned:
 #+BEGIN_SRC text :tangle no
700: Did you mistype a variational‚Äôs name: ‚Äútester‚Äù is not defined.

    ‚á®	whoops = tester 1 2 :keyword 3
    ‚á®	Use the PackageFormer menu to see which variationals are defined.
 #+END_SRC
   The 700 system informs us of our fault in ‚Äúquotes‚Äù, suggests a solution,
   and points to the offending declaration hierarchy. Neato (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

   The ‚Äúquotes‚Äù help, in this case, when there are multiple variationals being
   invoked in a clause.

   Of-course, we do not attempt to cover all possible errors ---e.g., wrong number
   of arguments or division by zero--- instead relying on Emacs Lisp's native
   error mechanism.

*** Records and Meta-Primitives ~:kind~ & ~:alter-elements~
    :PROPERTIES:
    :CUSTOM_ID: Records-and-Meta-Primitives---kind------alter-elements-
    :END:
    Let's begin with the simplest thing: Realising these fictitious ‚ÄòPackageFormers‚Äô as records.

    An Agda ‚Äòrecord‚Äô is just a PackageFormer where the qualifier ~PackageFormer~ has been
    replaced with ~record~ and each element is qualified by Agda keyword ~field~.
    We may declare this particular configuration using the meta-primitives
    ~:kind~ and ~:alter-elements~, as follows.
 #+BEGIN_SRC agda
{-700
ùí±-record‚ÇÄ = :kind record :alter-elements (Œª es ‚Üí (--map (map-qualifier (Œª _ ‚Üí "field") it) es))
-}
 #+END_SRC

    *Huh?*
    The ~:kind~ part was already explained, the ~:alter-elements~ is the powerhouse of our system.
    It takes a function with argument being the list of PackageFormer elements, ~es~,
    then we perform a functorial list map where each element is implicitly referred to as ~it~.
    Then the map function is to alter the qualifier of an element by replacing it with the string ~"field"~.
    In Agda syntax this corresponds to: ~Œª es ‚Üí map (Œª it ‚Üí (map-qualifier (Œª _ ‚Üí "field") it)) es~.
    \\
    Notice that the Agda form and Lisp form are only one outer parenthesis off from each other ---Lisp is easy!

    | /The ~:key value~ syntax is inspired from Lisp/ |

    Unsurprisingly, we have elected to name this grouping mechanism configuration as ~ùí±-record~.
    Let's try it out.
 #+BEGIN_src agda
{-700
M-Set-Record = M-Set record‚ÇÄ
-}
 #+END_SRC

    The system picks this up, looks up ~M-Set~ which was defined in the first section earlier,
    looks up the variational ~record~, then runs that configuration to generate:
 #+BEGIN_SRC results-agda :tangle no
{- M-Set-Record = M-Set record‚ÇÄ -}
record M-Set-Record : Set‚ÇÅ where
   field Scalar     : Set
   field Vector     : Set
   field _¬∑_        : Scalar ‚Üí Vector ‚Üí Vector
   field ùüô      : Scalar
   field _√ó_        : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId     : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc      : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
 #+END_src

   Nothing too remarkable; the keyword ~field~ has been inserted and the rewrite ~PackageFormer ‚Ü¶ record~
   has been performed. The above is the /exact/ generated result of the system ---the comment indicates
   the source of this generated code.

*** Equation Accommodating Record Variational
    :PROPERTIES:
    :CUSTOM_ID: Equation-Accommodating-Record-Variational
    :END:

   Since record formation is a variational that is likely to be used often, it is sensible to document it
   ---which in turn is attached to all occurences of the variational name via tooltips.
   Moreover, let's strengthen it to accomodate PackageFormers with equations.
 #+BEGIN_SRC agda
{-lisp
(ùí± record‚ÇÅ (discard-equations nil)
 = "Reify a variational as an Agda ‚Äúrecord‚Äù.
    Elements with equations are construed as
    derivatives of fields  ---the elements
    without any equations--- by default, unless
    DISCARD-EQUATIONS is provided with a non-nil value.
   "
  :kind record
  :alter-elements
    (Œª es ‚Üí
      (thread-last es
      ;; Keep or drop eqns depending on ‚Äúdiscard-equations‚Äù
      (--map
        (if discard-equations
            (map-equations (Œª _ ‚Üí nil) it)
            it))
      ;; Unless there's equations, mark elements as fields.
      (--map (map-qualifier
        (Œª _ ‚Üí (unless (element-equations it)
               "field")) it)))))
-}
 #+END_SRC

    Unlike ~ùí±-identity~ from a previous section, we have decided to split this definition into multiple
    lines by enclosing it in ~{-lisp ‚ãØ -~}~. Such blocks may contain arbitrary Lisp to be executed and so
    all contents must be Lisp forms ---notice the ~ùí±-‚ãØ~ from ~700~-blocks has been *exchanged* for
    a parenthesised (~ùí± ‚ãØ)~ within ~lisp~-blocks.

    Let's try this out.

    First, using only the default value ---which doesn't discard equations.
 #+BEGIN_SRC agda
{-700
Monoid-Record-derived = MonoidP record‚ÇÅ
-}
 #+END_SRC
 #+BEGIN_SRC results-agda :tangle no
record Monoid-Record-derived : Set‚ÇÅ where
    field Carrier       : Set
    field _‚®æ_       : Carrier ‚Üí Carrier ‚Üí Carrier
    field Id        : Carrier
    field assoc     : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    _‚âà_     : Carrier ‚Üí Carrier ‚Üí Set ; _‚âà_   = _‚â°_
    ‚®æ-cong      : ‚àÄ {x y x‚Ä≤ y‚Ä≤} ‚Üí x ‚âà x‚Ä≤ ‚Üí  y ‚âà y‚Ä≤ ‚Üí (x ‚®æ y) ‚âà (x‚Ä≤ ‚®æ y‚Ä≤) ;  ‚®æ-cong = Œª{ ‚â°.refl ‚â°.refl ‚Üí ‚â°.refl}
    Lid     : Carrier ‚Üí Carrier ;   Lid x = Id ‚®æ x
    Rid     : Carrier ‚Üí Carrier ;   Rid x = x ‚®æ Id
    concat      : List Carrier ‚Üí Carrier ;  concat = foldr _‚®æ_ Id
    field leftId        : ‚àÄ {x : Carrier} ‚Üí (Id ‚®æ x) ‚âà x
    field rightId       : ‚àÄ {x : Carrier} ‚Üí Rid x ‚âà x
    Id¬≤     : (Id ‚®æ Id) ‚âà Id ;  Id¬≤ = rightId
    concat‚Çö     : List Carrier ‚Üí Carrier ;  concat‚Çö []       = Id ; concat‚Çö (x ‚à∑ xs) = x ‚®æ concat‚Çö xs
 #+END_SRC
    Second, discarding equations and lifting all elements into ~field~-s.
 #+BEGIN_SRC agda
{-700
Monoid-Record-field = MonoidP record‚ÇÅ :discard-equations t
-}
 #+END_SRC
 #+BEGIN_SRC results-agda :tangle no
record Monoid-Record-cons : Set‚ÇÅ where
    field Carrier       : Set
    field _‚®æ_       : Carrier ‚Üí Carrier ‚Üí Carrier
    field Id        : Carrier
    field assoc     : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    field _‚âà_       : Carrier ‚Üí Carrier ‚Üí Set
    field ‚®æ-cong        : ‚àÄ {x y x‚Ä≤ y‚Ä≤} ‚Üí x ‚âà x‚Ä≤ ‚Üí  y ‚âà y‚Ä≤ ‚Üí (x ‚®æ y) ‚âà (x‚Ä≤ ‚®æ y‚Ä≤)
    field Lid       : Carrier ‚Üí Carrier
    field Rid       : Carrier ‚Üí Carrier
    field concat        : List Carrier ‚Üí Carrier
    field leftId        : ‚àÄ {x : Carrier} ‚Üí (Id ‚®æ x) ‚âà x
    field rightId       : ‚àÄ {x : Carrier} ‚Üí Rid x ‚âà x
    field Id¬≤       : (Id ‚®æ Id) ‚âà Id
    field concat‚Çö       : List Carrier ‚Üí Carrier
 #+END_SRC

 Let's also codify the converse operation of marking a grouping mechanism abstract to avoid elaboration.
 #+BEGIN_SRC emacs-lisp emacs-lisp :tangle "variationals.tmp" :noweb-ref std-ùí±-lib :noweb yes
(ùí± PackageFormer = "Mark a grouping mechanism as abstract, so that it is NOT elaborated into concrete Agda." :kind PackageFormer)
 #+END_SRC

*** A Coherent Equation Accommodating Record Variational
    :PROPERTIES:
    :CUSTOM_ID: A-Coherent-Equation-Accommodating-Record-Variational
    :END:

    Yet another option to handling equations is to drop the names that have
    equations associated with them. To tackle such a scenario
    requires the remaining elements to be well-defined and so requires ‚Äúthe largest sub-PackageFormer‚Äù.

    Coherent relationships are just graphs in disguise, so let's abstract away the details and solve
    a graph-theoretic problem. In ~{-lisp ‚ãØ -}~ blocks we may have arbitrary Emacs Lisp code and so include
    the following ---which has a large number of shortcomings, but the aim is a simple demonstration of Lisp
    code for the Agda user, not to be robust Lisp code. The name, <<<graph-map>>>, may not be ideal but it seems good enough, for now.
 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb-ref std-ùí±-lib :noweb yes
;; p ‚âà symptom; f ‚âà medicine; adj ‚âà neighbouring dependency
;;
(cl-defun graph-map (p f adj xs &optional keep-only-marked)
  "Map the nodes XS satisfying P by F along adjacency ADJ.
<<docs('graph-map)>>"
  (let* (;; Using -map instead of -filter since nodes may become
         ;; sickly later on, position matters.
         (sickly (-map p xs))
         ;; Obtain the items that are currently ‚Äòsickly‚Äô.
         (get-sickly (lambda ()
                       (--filter it (--zip-with (when it other) sickly xs))))
         ;; infected x  ‚â° x has a sickly neighbour
         (infected (Œª x ‚Üí (--any (funcall adj x it) (funcall get-sickly)))))

     ;; Propogate sickness.
     (loop for _ in xs
           do (loop for x in xs
                    for i from 0
                    do (when (funcall infected x) (setf (nth i sickly) t))))

     ;; Apply medication to sickly elements only.
     (--filter it (--map (if (-contains-p (funcall get-sickly) it)
                (funcall f it)
                (unless keep-only-marked it))
            xs))))
 #+END_SRC

 Here's how this works ---the following is what the incantation
 above ~<<docs('graph-map)>>~ refers to, and the reader may ignore all ~<<‚Ä¶>>~
 as they are a backend ‚Äòliterate programming‚Äô utility.

 #+name: graph-map
 - F is performed on nodes satisfying P,
   all neighbours are then considered to satisfy P
   and the process repeats recursively.

 -  E.g., nodes exhibiting symptoms P are given medicine F,
   and their sickness spreads to their neighbours who in turn
   become ill thereby requiring medication, and the process continues.

 - ADJ is a binary relation denoting adjacency.
   + (adj x y)  ‚âà  ‚Äúx depends on, or is a neighbour, of y.‚Äù

 - For example, a graph of 10 nodes, with an edge between multiples;
   where nodes 3, 4, 5 are initally ill.

   #+BEGIN_SRC emacs-lisp :tangle no
   (graph-map (Œª x ‚Üí (-contains-p '(3 4 5) x))
              (Œª x ‚Üí (format "medicated-%s" x))
              (Œª x y ‚Üí (zerop (mod x y)))
              '(1 2 3 4 5 6 7 8 9 10))
  ‚áí
    (1 2 medicated-3 medicated-4 medicated-5 medicated-6 7
       medicated-8 medicated-9 medicated-10)
   #+END_SRC

 Testing this graph-theoretic solution for our setting shows it to be a reasonable fit.
 #+BEGIN_SRC emacs-lisp :tangle no
;; Example: Dropping the implementations of the first 2 items.
(setq i -1)
(graph-map (Œª _ ‚Üí (incf i) (< i 2))
           (Œª x ‚Üí (map-equations (Œª _ ‚Üí nil) x))
           ;; x depends on y  ‚â°  x mentions y in its type or equations.
           (Œª x y ‚Üí (s-contains? (s-replace "_" " " (element-name y)) (s-join " " (cons (element-type x) (element-equations x)))))
           (parse-elements '("A : Set" "_‚âà_ : A ‚Üí A ‚Üí Set" "_‚âà_ = _‚â°_" "easy : ‚àÄ {x} ‚Üí x ‚âà x" "easy = refl"
                             "another : ‚àÄ {x} ‚Üí Set" "another = easy" "by : Set‚ÇÅ" "by = Set"))))
‚áí
  A       : Set
  eq      : A ‚Üí A ‚Üí Set    ;; implementation dropped
  easy    : ‚àÄ {x} ‚Üí x ‚âà x  ;; ditto, since it depends on ‚âà's implementation
  another : ‚àÄ {x} ‚Üí Set    ;; ditto, since it depends on easy's implementation
  by      : Set‚ÇÅ
  by      = Set‚ÇÅ
 #+END_SRC

 Let's introduce a dedicated form for ~element~ values:
 #+name: --graph-map
 - Mark elements in a given list, and recursively mark all those that depend on
   them.  Return the list of elements with the marked ones being altered.

 - MARK and ALTER are expressions mentioning IT, a value of ELEMENTS,
   and so are implicit functional expressions.

 - Only the MARKED elements are kept.
 #+BEGIN_SRC emacs-lisp  :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(cl-defmacro --graph-map (mark alter elements &optional (keep-only-marked t))
  "Recursively ALTER and MARK elements and their dependents.
<<docs('--graph-map)>>"
  `(graph-map (Œª it ‚Üí ,mark)
              (Œª it ‚Üí ,alter)
              ;; x depends on y  ‚â°  x mentions y, with all or no undescores,
              ;;                    in its type or equations.
              (Œª x y ‚Üí
                 (or (s-contains? (s-replace "_" " " (element-name x))
                                  (s-join " " (cons (element-type y)
                                                    (element-equations y))))
                     (s-contains? (element-name x)
                                  (s-join " " (cons (element-type y)
                                                    (element-equations y))))))
              ,elements ,keep-only-marked))
 #+END_SRC

 Now the previous example may be invoked as:
 #+BEGIN_SRC emacs-lisp :tangle no
(setq i -1)
(--graph-map (progn (incf i) (< i 3))
             (map-equations (Œª _ ‚Üí nil) it)
             (parse-elements '("A : Set" "_‚âà_ : A ‚Üí A ‚Üí Set" "_‚âà_ = _‚â°_"
                               "easy : ‚àÄ {x} ‚Üí x ‚âà x" "easy = refl"
                               "another : ‚àÄ {x} ‚Üí Set" "another = easy" "by : Set‚ÇÅ" "by = Set"))))
 #+END_SRC

 With these pieces in hand, let's form
 #+BEGIN_SRC  emacs-lisp  :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± record (discard-equations nil) (and-names nil)
 = "Reify a variational as an Agda ‚Äúrecord‚Äù.

    By default, elements with equations are construed as
    derivatives of fields  ---the elements
    without any equations.

    ‚á® DISCARD-EQUATIONS is nil by default.
      If provided with a non-nil value, equations are dropped indiscriminately.

    ‚á® AND-NAMES is nil by default and only takes
      effect when DISCARD-EQUATIONS is active.
      If provided with a non-nil value, names with
      equations are dropped altogether; but some may be kept
      if they are needed for some fields to be well-defined.
   "
  :kind record
  :alter-elements
    (Œª es ‚Üí
      (thread-last es

      (funcall (Œª es‚Ä≤ ‚Üí (if (not discard-equations) es‚Ä≤
               (--map (map-equations (-const nil) (map-qualifier (-const (when (element-equations it) 'eqns)) it)) es‚Ä≤))))

      (funcall (Œª es‚Ä≤ ‚Üí (if (not and-names) es‚Ä≤
        (--graph-map (not (equal 'eqns (element-qualifier it))) it es‚Ä≤))))

      ;; Unless there's equations, mark elements as fields.
      (--map (map-qualifier
        (Œª _ ‚Üí (unless (element-equations it)
               "field")) it)))))
 #+END_SRC
 :old:
   :alter-elements
     (Œª es ‚Üí (thread-last es
               ;; Keep or drop eqns depending on ‚Äúdiscard-equationals‚Äù.
               (--filter (if and-names (not (element-equations it)) it))
               (--map (if discard-equations (map-equations (-const nil) it) it))
               ;; Unless there's equations, mark all remaining elements as fields.
               (--graph-map t (map-qualifier (-const (unless (element-equations it) "field")) it)))))
 :end:
 We can obtain the previous variationals ~rcord·µ¢~ as well as new presentations.
 #+BEGIN_SRC agda
{-700
Monoid-Record-derived-again  = MonoidP record
Monoid-Record-derived-again2 = MonoidP record :and-names t
Monoid-Record-field-again    = MonoidP record :discard-equations t
Monoid-Record-no-equationals = MonoidP record :discard-equations t :and-names t
-}
 #+END_SRC
 The last form yields:
 #+BEGIN_SRC results-agda :tangle no
record Monoid-Record-no-equationals : Set‚ÇÅ where
    field Carrier       : Set
    field _‚®æ_       : Carrier ‚Üí Carrier ‚Üí Carrier
    field Id        : Carrier
    field assoc     : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
 #+END_SRC

*** Typeclasses ---Parameterised Records--- and Meta-Primitives ~:waist~ & ~:level~
    :PROPERTIES:
    :CUSTOM_ID: Typeclasses----Parameterised-Records----and-Meta-Primitives---waist------level-
    :END:

     We mentioned the <<<‚Äúwaist‚Äù>>> before, but what is it exactly?
     I propose that the difference between ‚Äòfield‚Äô and ‚Äòparameter‚Äô
     is an illusion ---as is that of ‚Äòinput‚Äô and ‚Äòoutput‚Äô when one
     considers relations rather than deterministic functions.

     For example, let's alter the previous variation declaration to
     lift the waist up 2 positions.
 #+BEGIN_src agda
{-700
ùí±-typeclass-attempt = record ‚ü¥ :waist 2
-}
         #+END_SRC

    Notice we have avoided repeating the definition of the ~record~ variational from
    earlier by making use of composition. More on it later, but it suffices to say
    that above we could replace ~record ‚ü¥~ with the exact text of ~ùí±-record = ‚ãØ~ right-hand-side
    and all would continue work.

    Trying this out, below, one notices that the first two elements of the PackageFormer have been lifted
    into being parameters, while the rest have been construed as fields.
        #+BEGIN_SRC agda
{-700
M-Set-TypeClass = M-Set typeclass-attempt
-}
                    #+END_SRC
                    #+BEGIN_SRC results-agda :tangle no
record M-Set-TypeClass (Scalar : Set) (Vector : Set) : Set‚ÇÅ where
   field _¬∑_        : Scalar ‚Üí Vector ‚Üí Vector
   field ùüô      : Scalar
   field _√ó_        : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId     : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc      : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
 #+END_src

    While this typechecks according to Agda standards, it is not ideal to human
    standards since the level of the resulting package is larger than necessary.
    The meta-primitive ~:level~ allows us to ~inc~-rement or ~dec~-crement the
    current level of a PackageFormer, so we may instead define:
 #+BEGIN_src agda
{-700
ùí±-typeclass‚ÇÇ = record ‚ü¥ :waist 2 :level dec
MonoidT‚ÇÇ      = MonoidP typeclass‚ÇÇ
-}
         #+END_SRC

         #+BEGIN_SRC results-agda :tangle no
record MonoidT‚ÇÇ (Carrier : Set) (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier) : Set where
    field Id        : Carrier
    field assoc     : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    field leftId        : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    field rightId       : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
         #+END_SRC

   # Unlike records, typeclasses scream to have an argument: The height of the waist.
   # Variationals may have arguments and we will cover this issue in a later subsection
   # in preference to continuing our purview of the meta-primitives.

   For fun, here are a few more to play with:
 #+BEGIN_SRC agda
{-700
MonoidT‚ÇÉ         = MonoidP record ‚ü¥ :waist 3 :level dec
-- MonoidT‚ÇÉ-again   = MonoidP ‚ü¥ record ‚ü¥ unbundling 3
M-Set-Typeclass‚ÇÇ = M-Set record ‚ü¥ typeclass‚ÇÇ
-}
 #+END_SRC

 In particular, the last example suggest that our composition is idempotent, but this is clearly not the case.
 Indeed, here's a pretty alternative to the meta-primitive ~:waist~ that is not ‚ü¥-idempotent
 but is in-fact a homomorphism: ~unbundling n ‚ü¥ unbundling m ‚âà unbundling (n + m)~.
 #+BEGIN_SRC lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± unbundling n
 = "Make the first N elements as parameters to the PackageFormer.

    Any elements in above the waist line have their equations dropped.
    As such, unbundling is not invertible.
   "
   :waist n
   :alter-elements (Œª es ‚Üí
     (-let [i 0]
       (--graph-map (progn (incf i) (<= i n))
                    (map-equations (-const nil) it)
                    es))))
 #+END_SRC
 ( The graph-map operation was defined in the previous section. )

 Incidentally, this solves the problem of lifting the waist to include elements with equations.
 #+BEGIN_SRC agda
{-700
-- Ill-formed in Agda: A defintion is not a parameter!
MonoidP-Typeclass‚ÇÖ = MonoidP :waist 5
-}
     #+END_SRC

     #+BEGIN_SRC results-agda :tangle no
{- Kind ‚ÄúPackageFormer‚Äù does not correspond  to a concrete Agda type.
{- MonoidP-Typeclass‚ÇÖ = MonoidP :waist 5 -}
PackageFormer MonoidP-Typeclass‚ÇÖ (Carrier : Set) (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier) (Id : Carrier) (assoc : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)) (_‚âà_ : Carrier ‚Üí Carrier ‚Üí Set ; _‚âà_ = _‚â°_) : Set‚ÇÅ where
    ‚®æ-cong      : ‚àÄ {x y x‚Ä≤ y‚Ä≤} ‚Üí x ‚âà x‚Ä≤ ‚Üí  y ‚âà y‚Ä≤ ‚Üí (x ‚®æ y) ‚âà (x‚Ä≤ ‚®æ y‚Ä≤) ;  ‚®æ-cong = Œª{ ‚â°.refl ‚â°.refl ‚Üí ‚â°.refl}
    Lid     : Carrier ‚Üí Carrier ;   Lid x = Id ‚®æ x
    Rid     : Carrier ‚Üí Carrier ;   Rid x = x ‚®æ Id
    concat      : List Carrier ‚Üí Carrier ;  concat = foldr _‚®æ_ Id
    leftId      : ‚àÄ {x : Carrier} ‚Üí (Id ‚®æ x) ‚âà x
    rightId     : ‚àÄ {x : Carrier} ‚Üí Rid x ‚âà x
    Id¬≤     : (Id ‚®æ Id) ‚âà Id ;  Id¬≤ = rightId
    concat‚Çö     : List Carrier ‚Üí Carrier ;  concat‚Çö []       = Id ; concat‚Çö (x ‚à∑ xs) = x ‚®æ concat‚Çö xs -}
 #+END_SRC

 #+BEGIN_SRC agda
{-700
MonoidT‚ÇÖ = MonoidP ‚ü¥ unbundling 5 ‚ü¥ record
-}
     #+END_SRC
     #+BEGIN_SRC results-agda :tangle no
record MonoidT‚ÇÖ (Carrier : Set) (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier) (Id : Carrier) (assoc : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)) (_‚âà_ : Carrier ‚Üí Carrier ‚Üí Set) : Set‚ÇÅ where
    field ‚®æ-cong        : ‚àÄ {x y x‚Ä≤ y‚Ä≤} ‚Üí x ‚âà x‚Ä≤ ‚Üí  y ‚âà y‚Ä≤ ‚Üí (x ‚®æ y) ‚âà (x‚Ä≤ ‚®æ y‚Ä≤)
    field Lid       : Carrier ‚Üí Carrier
    field Rid       : Carrier ‚Üí Carrier
    field concat        : List Carrier ‚Üí Carrier
    field leftId        : ‚àÄ {x : Carrier} ‚Üí (Id ‚®æ x) ‚âà x
    field rightId       : ‚àÄ {x : Carrier} ‚Üí Rid x ‚âà x
    field Id¬≤       : (Id ‚®æ Id) ‚âà Id
    field concat‚Çö       : List Carrier ‚Üí Carrier
 #+END_SRC

  :smile:

*** Primed Decoration and ~rename-mixfix~
    :PROPERTIES:
    :CUSTOM_ID: Primed-Decoration-and--rename-mixfix-
    :END:

     When we have two occurrences of a structure, we may want one of them to be decorated
     say with a prime so as to disambiguate them easily rather than have to qualify all
     of their components.

 #+BEGIN_src agda
{-700
-- Intentionally erroenous attempt.
ùí±-primed-attempt = :alter-elements (Œª es ‚Üí (--map (map-name (Œª n ‚Üí (rename-mixfix (Œª np ‚Üí (concat np "‚Ä≤")) n)) it) es))

-- M-Set‚Ä≤-attempt = M-Set record ‚ü¥ primed-attempt
-}
 #+END_SRC

 #+BEGIN_SRC results-agda :tangle no
record M-Set‚Ä≤-attempt : Set‚ÇÅ where
   field Scalar‚Ä≤        : Set
   field Vector‚Ä≤        : Set
   field _¬∑‚Ä≤_       : Scalar ‚Üí Vector ‚Üí Vector
   field ùüô‚Ä≤     : Scalar
   field _√ó‚Ä≤_       : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId‚Ä≤        : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc‚Ä≤     : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
{- This is crashing Agda code; as expected. Working improvements below. -}
 #+END_src

    There are number of issues to address.

    1. The system comes with a Lisp methods ~map-name~ and ~map-type~ that yield the name and type part,
       respectively, of a PackageFormer element.

    2. The ~:key value~ pairs have legitimate Lisp for the ~value~ positions.

       The basics of list processing, such as maps/filters/folds, with Lisp suffice for a rich
       inventory of possible configurations. Moreover, the functional nature of such higher-order
       functions ought to be familiar to any Agda coder [[https://www.phrases.org.uk/meanings/worth-ones-salt.html][worth their salt]].

       Here's a terse tutorial rendered as an [[https://alhassy.github.io/ElispCheatSheet/][Elisp Cheat Sheet]].

    3. One would expect catenating a prime to the mixfix name ~_√ó_~ would yield ~_√ó_‚Ä≤~ but above
       it yielded ~_√ó‚Ä≤_~. Indeed, the former would yield confusing expressions of the form
       ~1 √ó 2 ‚Ä≤~ whereas the latter permits ~1 √ó‚Ä≤ 2~. It is with this pragmatic usage that
       ~rename-mixfix~ performs a rewrite to a name by jumping over the Agda mixfix marker, ~_~,
       if it occurs at the start or end of a name.

       As an additional example, the name
       ~_‚âà_‚à∂_~, under the above scheme, would have rewritten to ~_‚âà_‚à∂‚Ä≤_~ thereby
       allowing terms such as ~x ‚âà y ‚à∂ A  ‚Üí  f x ‚âà f y ‚à∂‚Ä≤ B~ ---a elegant way to
       express that, say, ~f~ is a setoid homomorphism.
       If the prime scheme were instead a prepend, we would have obtained the name
       ~_‚Ä≤‚âà_‚à∂_~.

    # Notice that the generated code is commented out: The current type of the package
    # is not an admissible construct in Agda.

    # Moreover, if we try to instantiate this package further, say as in    ~M‚Ä≤ = M-Set‚Ä≤-attempt record~

    Notice that
    we have fields such as ~ùüô‚Ä≤ : Scalar~
    whose type is a free variable: ~Scalar~ no longer refers to any field.
    As such, the above code is ill-typed.
    The solution then is to /propagate/ any changes a name has down to its siblings.
    We will return to this later in the form of a ~map~ variational.

**** COMMENT primer
     :PROPERTIES:
     :CUSTOM_ID: COMMENT-primer
     :END:
    Indeed, /propagating the name changes:/
 #+BEGIN_SRC agda
{-lisp
(ùí± primer = :alter-elements (lambda (es)
   (let* ((esnew es)
         ;; Let's try to accomodate for names with underscores
         (names_ (--map (element-name it) es))
         (names  (--map (s-replace "_" "" it) names_))
         (oldies (append names names_)))

     (loop for old in oldies
           for new in (--map (rename-mixfix (Œª n ‚Üí (concat n "‚Ä≤")) it) oldies)
           do
           (setq esnew (--map (element-replace old new it) esnew)))

     ;; return value
     esnew)))
-}
 #+END_SRC

 Then, for example:
 #+BEGIN_SRC agda
{-700
MR‚Ä≤ = M-Set record ‚ü¥ primer
-}
         #+END_SRC

         #+BEGIN_SRC results-agda :tangle no
record MR‚Ä≤ : Set‚ÇÅ where
   field Scalar‚Ä≤        : Set
   field Vector‚Ä≤        : Set
   field _¬∑‚Ä≤_       : Scalar‚Ä≤ ‚Üí Vector‚Ä≤ ‚Üí Vector‚Ä≤
   field ùüô‚Ä≤     : Scalar‚Ä≤
   field _√ó‚Ä≤_       : Scalar‚Ä≤ ‚Üí Scalar‚Ä≤ ‚Üí Scalar‚Ä≤
   field leftId‚Ä≤        : {ùìã : Vector‚Ä≤}  ‚Üí  ùüô‚Ä≤ ¬∑‚Ä≤ ùìã  ‚â°  ùìã
   field assoc‚Ä≤     : {a b : Scalar‚Ä≤} {ùìã : Vector‚Ä≤} ‚Üí (a √ó‚Ä≤ b) ¬∑‚Ä≤ ùìã  ‚â°  a ¬∑‚Ä≤ (b ¬∑‚Ä≤ ùìã)
 #+END_SRC

 :maybe_not:
    Since 700-declarations must be single lines, we are forced to have something like
    the following ---which you are not expected to understand, but it serves as a nice
    comparison and motivation for the alternative approach below.
 #+BEGIN_SRC results-agda :tangle no
{-700

ùí±-primed‚Çó‚Çë‚Çú = :alter-elements (lambda (fs) (-as-> (-unzip (--zip-with `(,other  ,(format "let %s = %s in " (get-name it) (get-name other))) fs (--map (map-name (concat name "‚Ä≤") it) fs))) yup (--zip-with (map-type (concat (s-join "" it) type) other) (-inits (cadr yup)) (car yup))))

MonoidR‚Ä≤   =  MonoidP record ‚ü¥ primed‚Çó‚Çë‚Çú
-}

record MonoidR‚Ä≤ : Set‚ÇÅ where
  field
    Carrier‚Ä≤ : Set
    _‚®æ‚Ä≤_ : let Carrier = Carrier‚Ä≤ in Carrier ‚Üí Carrier ‚Üí Carrier
    Id‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in Carrier
    assoc‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in let Id = Id‚Ä≤ in ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in let Id = Id‚Ä≤ in let assoc = assoc‚Ä≤ in ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId‚Ä≤ : let Carrier = Carrier‚Ä≤ in let _‚®æ_ = _‚®æ‚Ä≤_ in let Id = Id‚Ä≤ in let assoc = assoc‚Ä≤ in let leftId = leftId‚Ä≤ in ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x

 #+END_SRC
 :End:

*** First-class PackageFormers
    :PROPERTIES:
    :CUSTOM_ID: First-class-PackageFormers
    :END:

    The previous example caused an Agda typechecking error, however if we do not
    invoke the ~record~ variational then the result is a non-Agda syntactical item
    which can only be the subject of further alteration via PackageFormer combinators.
 #+BEGIN_src agda
{-700
M-Set‚Ä≤-attempt-raw = M-Set primed-attempt
-}
         #+END_SRC

         #+BEGIN_SRC results-agda :tangle no
{- Kind ‚ÄúPackageFormer‚Äù does not correspond  to a concrete Agda type.
PackageFormer M-Set‚Ä≤-attempt-raw : Set‚ÇÅ where
   Scalar‚Ä≤      : Set
   Vector‚Ä≤      : Set
   _¬∑‚Ä≤_     : Scalar ‚Üí Vector ‚Üí Vector
   ùüô‚Ä≤       : Scalar
   _√ó‚Ä≤_     : Scalar ‚Üí Scalar ‚Üí Scalar
   leftId‚Ä≤      : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   assoc‚Ä≤       : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã) -}
 #+END_src

     This is interesting: We have not generated a concrete ---legitimate Agda construct---
     but instead yielded a new abstract grouping mechanism which may be instantiated later on,
     whenever desired.

     Likewise, we have already declared ~M-Set-Record = M-Set record~ and now we may apply
     our priming variational.
     #+BEGIN_src results-agda :tangle no
{- M-Set-Record‚Ä≤ = M-Set-Record primed-attempt -}
record M-Set-Record‚Ä≤ : Set‚ÇÅ where
   field Scalar‚Ä≤        : Set
   field Vector‚Ä≤        : Set
   field _¬∑‚Ä≤_       : Scalar ‚Üí Vector ‚Üí Vector
   field ùüô‚Ä≤     : Scalar
   field _√ó‚Ä≤_       : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId‚Ä≤        : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc‚Ä≤     : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
 #+END_src

     | /We may apply  variationals even to concrete Agda packaging constructs!/ |

     Of-course, we may simply want to obtain ~M-Set-Record‚Ä≤~ without having first
     to define ~M-Set-Record~, and so we may use the variational composition operator ~‚ü¥~.

 #+BEGIN_src results-agda :tangle no
{- M-Set-Record‚Ä≤ = M-Set record ‚ü¥ primed-attempt -}
record M-Set-Record‚Ä≤ : Set‚ÇÅ where
   field Scalar‚Ä≤        : Set
   field Vector‚Ä≤        : Set
   field _¬∑‚Ä≤_       : Scalar ‚Üí Vector ‚Üí Vector
   field ùüô‚Ä≤     : Scalar
   field _√ó‚Ä≤_       : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId‚Ä≤        : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc‚Ä≤     : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
 #+END_src

    Since the ~record~ and ~primed~ configurations are ‚Äòdisjoint‚Äô, they commute
    with respect to composition. The reader may want to confirm the following identifications:
 #+BEGIN_SRC agda :tangle no
      M-Set-Record‚Ä≤
   ‚âà  M-Set record ‚ü¥ primed-attempt
   ‚âà  M-Set primed-attempt ‚ü¥ record
   ‚âà  M-Set‚Ä≤ record
   ‚âà  M-Set-Record primed-attempt
 #+END_SRC

 It is important to remember that these primed perspectives do /not/ typecheck in Agda due to the free-variable
 issue mentioned earlier. We are only demonstrating composition, ~‚ü¥~, in this section; in a later section we
 fix-up ~primed~.

*** Variationals with Arguments ---~map, rename, [co]decorated, subscripted·µ¢, renaming~
    :PROPERTIES:
    :CUSTOM_ID: Variationals-with-Arguments-----map--rename---co-decorated--subscripted·µ¢--renaming-
    :END:

     Thus far our variationals have been nullary, let's consider otherwise.

     For example, let's add arguments to the typeclass variational from earlier.
     :Not_now:
     An issue with this is that it may decrement the level too much; e.g., try it with
     no args given to M-Set.
     #+BEGIN_SRC lisp :tangle no
(ùí± typeclass (height 1) (level 'dec)
  = "Expose the first element and decrese the package's level ---c.f. Haskell typeclass.

     The optional keywords HEIGHT and LEVEL may be used to expose any number of
     elements and possibly increment the level, respectively.
    "
    record ‚ü¥ :waist height :level level)
     #+END_SRC
     :End:
     #+BEGIN_src agda
{-700
ùí±-typeclass height (level 'dec) = record ‚ü¥ :waist height :level level
M-Set2-Typeclass‚ÇÉ = M-Set typeclass 3 :level 'inc
M-Set0-Typeclass‚ÇÉ = M-Set typeclass 3
-}
         #+END_SRC

         #+BEGIN_SRC results-agda :tangle no
record M-Set2-Typeclass‚ÇÉ (Scalar : Set) (Vector : Set) (_¬∑_ : Scalar ‚Üí Vector ‚Üí Vector) : Set‚ÇÇ where
   field ùüô      : Scalar
   field _√ó_        : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId     : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc      : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)

record M-Set0-Typeclass‚ÇÉ (Scalar : Set) (Vector : Set) (_¬∑_ : Scalar ‚Üí Vector ‚Üí Vector) : Set where
   field ùüô      : Scalar
   field _√ó_        : Scalar ‚Üí Scalar ‚Üí Scalar
   field leftId     : {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc      : {a b : Scalar} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
 #+END_src

    + Argument come before the ~=~ in a variational's definition and
      the may be used as if they were constants on the right-hand side.
      0. Above we introduced the named arguments ~height~ and ~level~.
      1. The first is positional, and the second is a keyword argument
         with /default/ value being a decrement value.
      2. We then passed the /argument/ ~level~ to the /meta-primitive/ ~:level~.

    + Invocation of variationals has positional arguments first then named arguments afterwards.
      One supplies a named argument in the form ~:argument-name the-value~ ---this is Lisp-inspired syntax.

      Consequently, order is irrelevant for named arguments.

      - Supplying ~:key value~ pairs where the ~key~ is not a named argument of
        the variational yields a error message indicating the allowable keys.

    # ‚û± If an argument is not supplied or its value is unacceptable, the cute
    # error-reporting mechanism is activated ---as is the case with other
    # pertinent aspects of loading such declarations.

    Let's code up the priming operation as a reusable pattern ---call it ~map~.
 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(eval-and-compile
(ùí± map elements (support-mixfix-names nil) (adjoin-retract nil) (adjoin-coretract nil)
   = "Apply function ELEMENTS that acts on PackageFormer elements,
      then propogate all new name changes to subsequent elements.

      There is minimal support for mixfix names, but it may be
      ignored by setting SUPPORT-MIXFIX-NAMES to be nil.

      When ADJOIN-RETRACT is non-nil, we adjoin a ‚Äúrecord {old·µ¢ = name·µ¢}‚Äù
      view morphism; i.e., record translation.

      Clauses ‚Äúf = f‚Äù are considered to occur only in views, record translations,
      and so only the RHS occurance is updated to a new name.
      C.f. the definition of element-retract.
      "
     :alter-elements (lambda (es)

    (let* ((es‚Ä≤    (mapcar elements es))
           (names  (mapcar #'element-name es))
           (names‚Ä≤ (mapcar #'element-name es‚Ä≤)))

      ;; Replace all occurances of old names with corresponding new ones.
      (loop for old in names
            for new in names‚Ä≤
            do (setq es‚Ä≤ (--map (element-replace old new it :support-mixfix-names support-mixfix-names :avoid-altering-names (equal new (element-name it))) es‚Ä≤)))
            ;; E.g., With ‚Äúelements = Œª x ‚Ü¶ x‚Ä≤‚Äù, a name ‚Äúop‚Äù goes to ‚Äúop‚Ä≤‚Äù, such a name-change should propogate everywhere including in old names ‚Äúop-some-property‚Äù,
            ;; to obtain ‚Äúop‚Ä≤-some-property‚Äù, but we should not propogate it to the newely named element ‚Äúop‚Ä≤‚Äù thereby accidentally obtaining ‚Äúop‚Ä≤‚Ä≤‚Äù.

     ;; return value
     (-concat es‚Ä≤ (when adjoin-retract (list (element-retract $ùëùùëéùëüùëíùëõùë° es :new es‚Ä≤ :name adjoin-retract)))
                  (when adjoin-coretract (list (element-retract $ùëùùëéùëüùëíùëõùë° es‚Ä≤ :new es :name adjoin-coretract :contravariant t)))))))
)
 #+END_SRC

 #+RESULTS:
 : ùí±-map

   This is a prototype; ideally the variational definition would be rendered in
   Agda code. Rather than using functional combinators such as
   ~unzip, map, zip-with~, for diversity, we used imperative constructs.

 Important observations include:

 1. The Lisp code lives in a ~{-lisp ‚ãØ -}~ block.

 2. 700-comments have single-line ~ùí±-name args = rhs~, whereas lisp-blocks
    have multi-line ~(ùí± name args = rhs)~ ---the dash after the ùí± is gone and outer-most
    parenthesis are added.

 3. To provide minimal accommodation for mixfix names, we simply remove the
    Agda argument indicator ‚Äò_‚Äô when performing rewrites.

    E.g., Agda let's you
    declare a name such as ~_‚äï_~ and use it without mentioning the underscore
    as in ~x ‚äï y~ and so the rename ~_‚äï_ ‚Ü¶ _‚äï‚Ä≤_~ would have no effect since ~_‚äï_~
    does not occur as a substring in ~x ‚äï y~, whence the need to ignore the underscores.

 Trying it out:
 #+BEGIN_SRC agda
{-700
MRùïè    = M-Set record ‚ü¥ map (Œª e ‚Üí (map-name (Œª n ‚Üí (rename-mixfix (Œª x ‚Üí (concat x "ùïè")) n)) e))
-}
         #+END_SRC
 #+BEGIN_SRC results-agda :tangle no
record MRùïè : Set‚ÇÅ where
   field Scalarùïè        : Set
   field Vectorùïè        : Set
   field _¬∑ùïè_       : Scalarùïè ‚Üí Vectorùïè ‚Üí Vectorùïè
   field ùüôùïè     : Scalarùïè
   field _√óùïè_       : Scalarùïè ‚Üí Scalarùïè ‚Üí Scalarùïè
   field leftIdùïè        : {ùìã : Vectorùïè}  ‚Üí  ùüôùïè ¬∑ùïè ùìã  ‚â°  ùìã
   field assocùïè     : {a b : Scalarùïè} {ùìã : Vectorùïè} ‚Üí (a √óùïè b) ¬∑ùïè ùìã  ‚â°  a ¬∑ùïè (b ¬∑ùïè ùìã)
 #+END_SRC

 Now for some useful corollaries.
 # For diversity, we render these in lisp-blocks.
 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± rename f (support-mixfix-names t) (adjoin-retract t)
  =  "Rename elements using a string-to-string function F acting on names.

      There is minimal support for mixfix names, which may be ignored
      by setting SUPPORT-MIXFIX-NAMES to be nil.

      When ADJOIN-RETRACT is non-nil, we adjoin a ‚Äúrecord {old·µ¢ = name·µ¢}‚Äù
      view morphism; i.e., record translation.
     "
     map (Œª e ‚Üí (map-name (Œª n ‚Üí (rename-mixfix f n (not 'support-mixfix-names))) e))
         :support-mixfix-names 'support-mixfix-names
         :adjoin-retract 'adjoin-retract)
 #+END_SRC

 Let's try this out.
 #+BEGIN_SRC agda
{-700
MRùï™    = M-Set-Record rename (Œª n ‚Üí (concat n "ùï™"))
MR-oh  = M-Set-Record rename (Œª n ‚Üí (pcase n ("Scalar" "S") ("ùüô" "Œµ") (else else)))
-}
 #+END_SRC
 #+BEGIN_SRC results-agda :tangle no
record MRùï™ : Set‚ÇÅ where
   field Scalarùï™        : Set
   field Vectorùï™        : Set
   field _¬∑ùï™_       : Scalarùï™ ‚Üí Vectorùï™ ‚Üí Vectorùï™
   field ùüôùï™     : Scalarùï™
   field _√óùï™_       : Scalarùï™ ‚Üí Scalarùï™ ‚Üí Scalarùï™
   field leftIdùï™        : {ùìã : Vectorùï™}  ‚Üí  ùüôùï™ ¬∑ùï™ ùìã  ‚â°  ùìã
   field assocùï™     : {a b : Scalarùï™} {ùìã : Vectorùï™} ‚Üí (a √óùï™ b) ¬∑ùï™ ùìã  ‚â°  a ¬∑ùï™ (b ¬∑ùï™ ùìã)


{- MR-oh  = M-Set record ‚ü¥ rename (Œª n ‚Üí (pcase n ("Scalar" "S") ("ùüô" "Œµ") (else else))) -}
record MR-oh : Set‚ÇÅ where
   field S      : Set
   field Vector     : Set
   field _¬∑_        : S ‚Üí Vector ‚Üí Vector
   field Œµ      : S
   field _√ó_        : S ‚Üí S ‚Üí S
   field leftId     : {ùìã : Vector}  ‚Üí  Œµ ¬∑ ùìã  ‚â°  ùìã
   field assoc      : {a b : S} {ùìã : Vector} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
                         #+END_SRC

 We would expect it to be common to prefix and suffix symbols, so let's make
 variationals for these patterns.
 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± decorated by
  = "Rename all elements by suffixing string BY to them."
     rename (Œª name ‚Üí (concat name by)))

(ùí± co-decorated by
  = "Rename all elements by prefixing string BY to them."
     rename (Œª name ‚Üí (concat by name)))

(ùí± primed
  = "All elements are renamed with a postfix prime."
    decorated "‚Ä≤")
 #+END_SRC

 Likewise, for the casing approach, let's make a ‚Äúto list‚Äù.
 For now, such lists are necessarily enclosed in double-quotes.

 #+name: reify-to-list
 - Given a string of ‚Äú;‚Äù-separated items consisting of ‚Äúto‚Äù-separated pairs,
   interpret it as a Lisp function where ‚Äúto‚Äù-pairs denote mapping clauses.

 - E.g., ‚Äúx‚ÇÄ to y‚ÇÄ; ‚Ä¶; x‚Çô to y‚Çô‚Äù becomes the function sending value x·µ¢ to y·µ¢,
   and behaves as the identity function otherwise unless OTHERWISE is provided,
   in which case it acts as a fallback.

 - Concretely:
   #+BEGIN_SRC emacs-lisp :tangle no
      (reify-to-list "1 to x; 2 to y; p to q")
    ‚âà (Œª arg ‚Üí (pcase arg ("1" "x") ("2" "y") ("p" "q") (otherwise otherwise)))
   #+END_SRC

 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
;; Neato: (reify-to-list "x‚ÇÄ; ‚ãØ; x‚Çô" nil) ‚áí (Œª x ‚Ü¶ If ‚àÉ i ‚Ä¢ x ‚âà x·µ¢ then "" else nil)
;; KEY is a function applied to the input argument /before/ casing on LHS ‚Ü¶ RHS names.
;; INVERSE means to interpret clauses ‚Äúx to y‚Äù as mappings ‚Äúy ‚Ü¶ x‚Äù.
   (cl-defun reify-to-list (str &key (otherwise 'otherwise) (key #'identity) inverse)
   "Transform ‚Äúto list‚Äù STR with default OTHERWISE into a Lisp function.
<<docs('reify-to-list)>>"
   (let (clauses)
     (thread-last str
       (s-split ";")
       (--map (s-split " to " it))
       (--map (list (s-trim (car it)) (s-trim (or (cadr it) "")))) ;; accomodate empty str.
       (funcall (Œª cs ‚Üí (if inverse (--map (-rotate 1 it) cs) cs)))
       (-cons* 'pcase `(,key arg))
       (setq clauses))
     `(lambda (arg) ,(append clauses `((otherwise ,otherwise))))))

;; (reify-to-list "a to b; c to d" :inverse t) ;; neato!

(ùí± renaming by  (adjoin-retract nil) (adjoin-coretract nil)
= "Rename elements using BY, a ‚Äú;‚Äù-separated string of ‚Äúto‚Äù-separated pairs.

      Unlike ‚Äòrename‚Äô, this variational permits simultaneous renaming.
      Moreover, when the to-list is 1-to-1, we have a constructible bijection
      via ADJOIN-CORETRACT.

      When ADJOIN-RETRACT is non-nil, we adjoin a ‚Äúrecord {old·µ¢ = name·µ¢}‚Äù
      view morphism; i.e., record translation.
      Likewise for ADJOIN-CORETRACT results in the inverse morphism,
      ‚Äúrecord {name·µ¢ = old·µ¢}‚Äù.
"

   :alter-elements (Œª es ‚Üí

   ;; Function factorisation lol
(when nil
a ‚Üí b‚Ä≤; b ‚Üí a; c ‚Üí c‚Ä≤
a ‚Üí b‚Ä≤; b ‚Üí NEW[a] ‚Üí a; c ‚Üí c‚Ä≤
)

   (let* ((tos   (s-split ";" by))
          (to-s (--map (s-split "to" it) tos))
          (trim (Œª x ‚Üí (if x (s-trim x) ""))) ;; Trim if non-nil, else empty string
          (srcs (mapcar trim (mapcar #'car to-s)))
          (tgts (mapcar trim (mapcar #'cadr to-s)))
          (eek (intersection srcs tgts :test #'string-equal))
          es‚Ä≤
          freshies
          (injective-naming (s-join " ; " (--map (s-join " to " it)
(loop for x in srcs
      for y in tgts
      for fresh = (if (member y eek) (caar (push (cons (rename-mixfix (-const (format "%s" (gensym))) y) y) freshies)) y)
      collect (list x fresh)))))

          (collision-naming (s-join " ; " (--map (s-join " to " it)
(loop for (fresh . y) in freshies
      collect (list fresh y))))))

  (setq es‚Ä≤ (alter-elements es  map (Œª e ‚Üí (map-name (-partial (reify-to-list injective-naming)) e))))
  (setq es‚Ä≤ (alter-elements es‚Ä≤ map (Œª e ‚Üí (map-name (-partial (reify-to-list collision-naming)) e))))

  ;; return value
  (-concat es‚Ä≤ (when adjoin-retract (list (element-retract $ùëùùëéùëüùëíùëõùë° es :new es‚Ä≤ :name adjoin-retract)))
               (when adjoin-coretract (list (element-retract $ùëùùëéùëüùëíùëõùë° es‚Ä≤ :new es :name adjoin-coretract :contravariant t)))))))
 #+END_SRC

 #+RESULTS:
 : ùí±-renaming

 :OLD_renaming:
 #+BEGIN_SRC emacs-lisp :tangle no
(ùí± renaming by (adjoin-retract t) (adjoin-coretract nil)
  = "Rename elements using BY, a ‚Äú;‚Äù-separated string of ‚Äúto‚Äù-separated pairs.

      There is minimal support for mixfix names, which may be ignored
      by setting SUPPORT-MIXFIX-NAMES to be nil.

      When ADJOIN-RETRACT is non-nil, we adjoin a ‚Äúrecord {old·µ¢ = name·µ¢}‚Äù
      view morphism; i.e., record translation.
      Likewise for ADJOIN-CORETRACT results in the inverse morphism,
      ‚Äúrecord {name·µ¢ = old·µ¢}‚Äù.
"
  map (Œª e ‚Üí (map-name (Œª n ‚Üí (funcall (reify-to-list by) n)) e))
         :adjoin-retract adjoin-retract
         :adjoin-coretract adjoin-coretract
         )
 #+END_SRC
 :END:
 #+RESULTS:
 : ùí±-renaming

 It is common in Agda to provide ‚Äúto‚Äù-lists, so we've provide a variant that supports those
 instead of forcing users to produce functions explicitly.

 We may also prefer writing ~subscripted·µ¢~ rather than ~decorated "·µ¢"~.
 With a bit of Lisp meta-programming, we can generate these variationals.
 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(defun to-subscript (n)
  "Associate digit N with its subscript.

If N ‚àà 0..9, then yield ‚Çô, else N."

  (or (nth n '("‚ÇÄ" "‚ÇÅ" "‚ÇÇ" "‚ÇÉ" "‚ÇÑ" "‚ÇÖ" "‚ÇÜ" "‚Çá" "‚Çà" "‚Çâ")) n))

;; Let's make a family of variationals.
(loop for i from 0 to 9
      for ·µ¢    = (to-subscript i)
      for docs = (format "Subscript all elementes by suffixing them with %s." i)
      do (eval `(ùí± ,(intern (format "subscripted%s" ·µ¢)) = ,docs decorated ,·µ¢)))
 #+END_SRC

 Here are some example uses.
 #+BEGIN_SRC agda
{-700
-- MR‚ÇÅ‚ÇÇ   = M-Set-Record decorated "‚ÇÅ" ‚ü¥ decorated "‚ÇÇ" :adjoin-retract nil
the-MR = M-Set-Record co-decorated "the-"
-- MR‚ÇÉ‚ÇÑ   = M-Set-Record subscripted‚ÇÉ ‚ü¥ subscripted‚ÇÑ :adjoin-retract nil
MR‚Çú‚Çí   = M-Set-Record renaming "Scalar to S; Vector to V; ¬∑ to nice"
NearMonoid = M-Set-Record renaming "Scalar to Carrier; Vector to Carrier; ¬∑ to √ó"
-}
 #+END_SRC
 #+BEGIN_SRC results-agda :tangle no
{- MR‚ÇÅ‚ÇÇ   = M-Set record ‚ü¥ decorated "‚ÇÅ" ‚ü¥ decorated "‚ÇÇ" -}
record MR‚ÇÅ‚ÇÇ : Set‚ÇÅ where
   field Scalar‚ÇÅ‚ÇÇ       : Set
   field Vector‚ÇÅ‚ÇÇ       : Set
   field _¬∑‚ÇÅ‚ÇÇ_      : Scalar‚ÇÅ‚ÇÇ ‚Üí Vector‚ÇÅ‚ÇÇ ‚Üí Vector‚ÇÅ‚ÇÇ
   field ùüô‚ÇÅ‚ÇÇ        : Scalar‚ÇÅ‚ÇÇ
   field _√ó‚ÇÅ‚ÇÇ_      : Scalar‚ÇÅ‚ÇÇ ‚Üí Scalar‚ÇÅ‚ÇÇ ‚Üí Scalar‚ÇÅ‚ÇÇ
   field leftId‚ÇÅ‚ÇÇ       : {ùìã : Vector‚ÇÅ‚ÇÇ}  ‚Üí  ùüô‚ÇÅ‚ÇÇ ¬∑‚ÇÅ‚ÇÇ ùìã  ‚â°  ùìã
   field assoc‚ÇÅ‚ÇÇ        : {a b : Scalar‚ÇÅ‚ÇÇ} {ùìã : Vector‚ÇÅ‚ÇÇ} ‚Üí (a √ó‚ÇÅ‚ÇÇ b) ¬∑‚ÇÅ‚ÇÇ ùìã  ‚â°  a ¬∑‚ÇÅ‚ÇÇ (b ¬∑‚ÇÅ‚ÇÇ ùìã)

{- the-MR = M-Set record ‚ü¥ co-decorated "the-" -}
record the-MR : Set‚ÇÅ where
   field the-Scalar     : Set
   field the-Vector     : Set
   field _the-¬∑_        : the-Scalar ‚Üí the-Vector ‚Üí the-Vector
   field the-ùüô      : the-Scalar
   field _the-√ó_        : the-Scalar ‚Üí the-Scalar ‚Üí the-Scalar
   field the-leftId     : {ùìã : the-Vector}  ‚Üí  the-ùüô the-¬∑ ùìã  ‚â°  ùìã
   field the-assoc      : {a b : the-Scalar} {ùìã : the-Vector} ‚Üí (a the-√ó b) the-¬∑ ùìã  ‚â°  a the-¬∑ (b the-¬∑ ùìã)

{- MR‚ÇÉ‚ÇÑ   = M-Set record ‚ü¥ subscripted‚ÇÉ ‚ü¥ subscripted‚ÇÑ -}
record MR‚ÇÉ‚ÇÑ : Set‚ÇÅ where
   field Scalar‚ÇÉ‚ÇÑ       : Set
   field Vector‚ÇÉ‚ÇÑ       : Set
   field _¬∑‚ÇÉ‚ÇÑ_      : Scalar‚ÇÉ‚ÇÑ ‚Üí Vector‚ÇÉ‚ÇÑ ‚Üí Vector‚ÇÉ‚ÇÑ
   field ùüô‚ÇÉ‚ÇÑ        : Scalar‚ÇÉ‚ÇÑ
   field _√ó‚ÇÉ‚ÇÑ_      : Scalar‚ÇÉ‚ÇÑ ‚Üí Scalar‚ÇÉ‚ÇÑ ‚Üí Scalar‚ÇÉ‚ÇÑ
   field leftId‚ÇÉ‚ÇÑ       : {ùìã : Vector‚ÇÉ‚ÇÑ}  ‚Üí  ùüô‚ÇÉ‚ÇÑ ¬∑‚ÇÉ‚ÇÑ ùìã  ‚â°  ùìã
   field assoc‚ÇÉ‚ÇÑ        : {a b : Scalar‚ÇÉ‚ÇÑ} {ùìã : Vector‚ÇÉ‚ÇÑ} ‚Üí (a √ó‚ÇÉ‚ÇÑ b) ¬∑‚ÇÉ‚ÇÑ ùìã  ‚â°  a ¬∑‚ÇÉ‚ÇÑ (b ¬∑‚ÇÉ‚ÇÑ ùìã)

{- MR‚Çú‚Çí = M-Set record ‚ü¥ renaming "Scalar to S; Vector to V; ¬∑ to nice" -}
record MR‚Çú‚Çí : Set‚ÇÅ where
   field S      : Set
   field V      : Set
   field _nice_     : S ‚Üí V ‚Üí V
   field ùüô      : S
   field _√ó_        : S ‚Üí S ‚Üí S
   field leftId     : {ùìã : V}  ‚Üí  ùüô nice ùìã  ‚â°  ùìã
   field assoc      : {a b : S} {ùìã : V} ‚Üí (a √ó b) nice ùìã  ‚â°  a nice (b nice ùìã)

{- NearMonoid = M-Set record ‚ü¥ renaming "Scalar to Carrier; Vector to Carrier; ¬∑ to √ó" -}
record NearMonoid : Set‚ÇÅ where
   field Carrier        : Set
   field _√ó_        : Carrier ‚Üí Carrier ‚Üí Carrier
   field ùüô      : Carrier
   field leftId     : {ùìã : Carrier}  ‚Üí  ùüô √ó ùìã  ‚â°  ùìã
   field assoc      : {a b : Carrier} {ùìã : Carrier} ‚Üí (a √ó b) √ó ùìã  ‚â°  a √ó (b √ó ùìã)
 #+END_SRC

 Some observations are in order:

 0. Example ~M‚ÇÅ‚ÇÇ~ demonstrates that composition, ‚ü¥, is sequential from left to right.
    That is, ‚Äú‚ü¥‚Äù is just forwards composition: We thread the given PackageFormer
    through the variationals ~v·µ¢~ in order. Operationally:

    | Pf v‚ÇÄ ‚ü¥ ‚ãØ ‚ü¥ v‚Çô ‚âà ((Pf v‚ÇÄ) v‚ÇÅ) ‚ãØ) v‚Çô |
    | Pf ‚ü¥ v  ‚âà  Pf v ‚ü¥  ‚âà  Pf v          |

    Note: In the concrete syntax, parenthesisation is not permitted.

 1. Notice that the ~NearMonoid~ example demonstrates multiplicity of PackageFormer elements is irrelevant.
    That is, elements are algebraically a free monoid with the axiom ~xs ‚äï ys ‚äï xs ‚âà xs ‚äï ys~.

 2. *Notice that we wanted  Agda-style renaming via ~to~-lists, so we simply code that up!*
    This is so cool: We can just extend the system with whatever pattern we prefer!
    No more bending to the will of language designers! More power to the user!

    For example, we can codify the previous ~NearMonoid~ scheme into a top-level pattern.
 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(defun is-sort (element)
  "Check whether the target of ELEMENT‚Äôs type is ‚ÄòSet‚Äô."
  (s-contains? "Set" (target (element-type element))))
  ;; Method ‚Äòtarget‚Äô is defined in the next subsection, on ADTs.

(ùí± single-sorted with-sort
  = "Replace all nullary sorts with the provided WITH-SORT string
     as the name of the new single sort, the universe of discourse."
    map (Œª e ‚Üí (if (is-sort e) (map-name (Œª _ ‚Üí with-sort) e) e)))
 #+END_SRC

    Then the previous PackageFormer can be obtained with:
    Note that the following differs from ~NearMonoid~ since it has two binary operations:
    Our new variational one alters the number and name of sorts, not other elements.
 #+BEGIN_SRC agda
{-700
NearMonoid¬π = M-Set-Record single-sorted "Carrier"
-}
 #+END_SRC
 #+BEGIN_SRC results-agda :tangle no
record NearMonoid¬π : Set‚ÇÅ where
   field Carrier        : Set
   field _¬∑_        : Carrier ‚Üí Carrier ‚Üí Carrier
   field ùüô      : Carrier
   field _√ó_        : Carrier ‚Üí Carrier ‚Üí Carrier
   field leftId     : {ùìã : Carrier}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã
   field assoc      : {a b : Carrier} {ùìã : Carrier} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã)
 #+END_SRC

 *Exercise:*
 Write a variational ~remove-sorts~ that strips out all sorts from a PackageFormer.
 If elements depend on sorts, as they normally do, then one must remove them as well;
 ignore this for now, and we shall return to subgenerated PackageFormers later on.
*** Forming Syntax and the Special ~$ùëõùëéùëöùëí~ Variable
    :PROPERTIES:
    :CUSTOM_ID: Forming-Syntax-and-the-Special---ùëõùëéùëöùëí--Variable
    :END:

   |  /Records provide a semantics, what if we want the syntax?/ |

 Since ~data~ declarations consist of constructors, whose target type necessarily
 begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.
 To do so, we use the helper function ~target~ which takes a declaration ~name : type0 ‚Üí ‚ãØ ‚Üí typeN~ and yields ~typeN~.

 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(defun target (thing)
  "Return final type mentioned in THING, a string declaration.

Given a type-name ‚Äò[name :] œÑ‚ÇÄ ‚Üí ‚ãØ ‚Üí œÑ‚Çô‚Äô, yield ‚ÄòœÑ‚Çô‚Äô;
the ‚Äòname‚Äô porition is irrelevant."
  (car (-take-last 1 (s-split "‚Üí" thing))))
 #+END_SRC

 With this in hand, a ~data~ presentation requires a designated ~carrier~ which is used to
 keep only those elements that target it. Finally, as data constructor must target the
 type being defined, we alter the filtered elements by changing every instance of the
 carrier name with the name of the newly defined PackageFormer ---which we may access
 using the special identifier ~$ùëõùëéùëöùëí~. In a ~lisp~ block, we formalise this algorithm as follows.
 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± data carrier
  = "Reify as an Agda ‚Äúdata‚Äù type.

     Only elements targeting CARRIER are kept.
    "
    :kind  data
    :level dec
    :alter-elements (lambda (es)
      (thread-last es
        (--filter (s-contains? carrier (target (element-type it))))
        (--map (map-type (Œª œÑ ‚Üí (s-replace carrier $ùëõùëéùëöùëí œÑ)) it)))))
 #+END_SRC

 For example:
 #+BEGIN_SRC agda
{-   700
ScalarTerm = M-Set data "Scalar"
-}
 #+END_SRC
 #+BEGIN_SRC results-agda :tangle no
data ScalarTerm : Set where
   ùüô        : ScalarTerm
   _√ó_      : ScalarTerm ‚Üí ScalarTerm ‚Üí ScalarTerm
 #+END_SRC

 Again:
 The meta-primitive ~:alter-elements~ is instructed to map over those
 elements ~e~ that contain the ~carrier~ in their ~target~ type
 by replacing the given ~carrier~ with the newly-minted ~$ùëõùëéùëöùëí~ of
 the grouping mechanism being constructed. Those that do not
 contain the given ~carrier~ in their target type are filtered out.

 Notice that ~$ùëõùëéùëöùëí~ is a special variable that refers to the newly defined PackageFormer's name.
 - It is written using ~\Mi~ with Agda input; e.g., ~\Min~ gives ~ùëõ~.
 - The ‚Äò$‚Äô is intended to further mark the special nature of this variable.

*** COMMENT TODO: another adt example
    :PROPERTIES:
    :CUSTOM_ID: COMMENT-TODO--another-adt-example
    :END:
    :PROPERTIES:

    :END:
 *Important*: Notice that, in the second example above,
 #+BEGIN_SRC results-agda :tangle no
{- ScalarSyntax = M-Set primer ‚ü¥ data :carrier "Scalar‚Ä≤" -}
data ScalarSyntax : Set where
   ùüô‚Ä≤ : ScalarSyntax
   _√ó‚Ä≤_ : ScalarSyntax ‚Üí ScalarSyntax ‚Üí ScalarSyntax
 #+END_src
 the name of the carrier is ~Scalar‚Ä≤~ since we changed the
 PackageFormer to prime all elements, including the ~Scalar~, element.
 #+BEGIN_SRC results-agda  :tangle no
{- No = M-Set primer ‚ü¥ data :carrier "Scalar" -}
data No : Set where
   ùüô‚Ä≤ : No‚Ä≤
   _√ó‚Ä≤_ : No‚Ä≤ ‚Üí No‚Ä≤ ‚Üí No‚Ä≤

{- Crashes since type No‚Ä≤ is not defined! -}
 #+END_SRC

 mention these:

    + [ ] Interpretation functions from termtypes to recordtypes ---which give terms meaning.
          - [ ] With an environment argument for open termtypes.
    + [ ] Staged terms and partial evaluators

*** Subpackages with ~generated, sorts, signature~
    :PROPERTIES:
    :CUSTOM_ID: Subpackages-with--generated--sorts--signature-
    :END:

     A common grouping operation is to zoom-in to the minimal well-formed
     package that contains only certain specified elements. For example,
     in our ~M-Set~ grouping, we may want to keep only ~ùüô~ but to be well-defined
     we are forced to also keep the elements on which it depends ---namely, ~Scalar~.

     In particular, the following naive approach only works if the elements are
     independent of one another ---which is rarely the case for Agda users.
 #+BEGIN_SRC emacs-lisp  :tangle no
;; cute, but too brutish.
(ùí± generated by = :alter-elements (lambda (es) (-filter by es)))
 #+END_SRC

     The coherent scheme is straightforward to implement.
     For clarity, rather than efficiency,
     the algorithm below forms a list ~yeses~ of the elements that should be kept
     then traverses the elements list, adding all elements needed to ensure that list
     is coherent. Moreover, for generality, we consider a predicate rather than an explicit
     listing of items to be retained.
 #+BEGIN_SRC  emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± generated by
  = "Keep the largest well-formed PackageFormer whose elements satisfy BY.

     BY is a predicate on elements.
    "
    :alter-elements (Œª es ‚Üí (--graph-map (funcall by it) it es)))

 #+END_SRC
 :OLD:
 #+BEGIN_SRC  emacs-lisp :tangle no
(ùí± generated by
  = "Keep the largest well-formed PackageFormer whose elements satisfy BY.

     BY is a predicate on elements.
    "
    :alter-elements  (lambda (fs)
      (let* ( (yeses (--map (funcall by it) fs))
              (get-yeses (lambda () (--filter it (--zip-with (if it other) yeses fs))))
              (in-yeses (lambda (e)
                          (--any
                           (s-contains? (s-replace "_" " " (element-name e)) (element-type it))
                           (funcall get-yeses)))))

        (loop for _ in fs do
              (loop for f in fs
                    for i from 0
                    do ;; when f in yess, set f to be yes.
                    (when (funcall in-yeses f) (setf (nth i yeses) t))))

        (funcall get-yeses))))
 #+END_SRC
 :END:

 Here's an immediate application: Obtaining the types declared in a grouping mechanism.
 #+BEGIN_SRC emacs-lisp  :tangle  "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± sorts
 = "Obtaining the types declared in a grouping mechanism.

   For now, only base types; i.e., items targeting ‚ÄúSet‚Äù.
   "
   generated (Œª e ‚Üí (s-contains? "Set" (target (element-type e)))))
 #+END_SRC
 #+BEGIN_SRC agda
{-700
M-Set-Sorts = M-Set record ‚ü¥ sorts
-}
     #+END_SRC
     #+BEGIN_SRC results-agda :tangle no
record M-Set-Sorts : Set‚ÇÅ where
   field Scalar     : Set
   field Vector     : Set
 #+END_SRC

 We can even obtain a sub-signature wholesale:
 #+BEGIN_SRC agda
{-700
MonoidSignature = M-Set-Record generated (Œª e ‚Üí (and (s-contains? "Scalar" (element-type e)) (not (s-contains? "Vector" (element-type e)))))
-}
     #+END_SRC
     #+BEGIN_SRC results-agda :tangle no
record MonoidSignature : Set‚ÇÅ where
   field Scalar     : Set
   field ùüô      : Scalar
   field _√ó_        : Scalar ‚Üí Scalar ‚Üí Scalar
 #+END_SRC

 This pattern of having a lawless grouping seems sufficiently desirable that we may
 codify it.
 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(defun targets-a-sort (element)
  "Check whether the given ELEMENT targets a sort.

The sorts considered refer to those of the *current* PacakgeFormer."
  (--any (s-contains? it (target (element-type element)))
         (-map #'element-name (-filter #'is-sort $ùëíùëôùëíùëöùëíùëõùë°ùë†))))

(ùí± signature
  = "Keep only the elements that target a sort, drop all else."
    generated (Œª e ‚Üí (targets-a-sort e)))
 #+END_SRC

 Here's an example.
 #+BEGIN_SRC agda
{-700
MonSig = M-Set-Record signature
-}
     #+END_SRC

     #+BEGIN_SRC results-agda :tangle no
record MonSig : Set‚ÇÅ where
   field Scalar     : Set
   field Vector     : Set
   field _¬∑_        : Scalar ‚Üí Vector ‚Üí Vector
   field ùüô      : Scalar
   field _√ó_        : Scalar ‚Üí Scalar ‚Üí Scalar
 #+END_SRC

    Neato! Those were some nifty applications!

    For practicality, let's also introduce a more concrete syntax
    analogous to that of ~renaming~:
    # Magma = Monoid generated (Œª e ‚Üí (equal "__¬∑__" (element-name e)))
 #+BEGIN_SRC emacs-lisp  :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± keeping those
  = "Keep THOSE elements, a ‚Äú;‚Äù-separated string of proper names,
    along with the elements that ensure THOSE is well-defined.
 "
    generated (reify-to-list those :otherwise nil :key #'element-name))
 #+END_SRC

*** Shallow Renaming with Agda's ~open ‚ãØ public ‚ãØ renaming ‚ãØ~
    :PROPERTIES:
    :CUSTOM_ID: Shallow-Renaming-with-Agda-s--open---public---renaming---
    :END:
     The previous approach to renaming altered field names literally which is not
     desirable when one only wants to refer to field names of multiple instances
     of the same record ---e.g., when forming homomorphisms.

     A common pattern in Agda is then to open the record and perform the desired
     shallow renames. This pattern is so common that the standard library is [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Structures.html#2757][littered]]
     with instances of it.
     We can codify the pattern as a method rather than as a
     manual technique.

     Let's go from zero to one-hundred ---again: There's a Lisp Cheat Sheet that should
     have been consulted at one point.

     Zero: A module where the elements are all parameters.
 #+BEGIN_SRC agda
{-700
ùí±-empty-module = :kind module :level none :waist 999
Neato = M-Set empty-module
-}

{- A module where the elements are all parameters -}
open Neato using ()
 #+END_SRC

 #+BEGIN_SRC results-agda :tangle no
module Neato (Scalar : Set) (Vector : Set) (_¬∑_ : Scalar ‚Üí Vector ‚Üí Vector) (ùüô : Scalar) (_√ó_ : Scalar ‚Üí Scalar ‚Üí Scalar) (leftId : {ùìã : Vector} ‚Üí ùüô ¬∑ ùìã ‚â° ùìã) (assoc : ‚àÄ {a b ùìã} ‚Üí (a √ó b) ¬∑ ùìã ‚â° a ¬∑ (b ¬∑ ùìã)) where
 #+END_SRC

    One-hundred: A one-parameter module where elements may be renamed.
 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± open with (avoid-mixfix-renaming nil)
  =
    "Reify a given PackageFormer as a *parameterised* Agda ‚Äúmodule‚Äù declaration.

     WITH is a renaming, string to string, function that is applied to the parent record that will
     be opened and reexported as a module.

     AVOID-MIXFIX-RENAMING is optional; by default renaming ‚Äújumps over‚Äù underscores,
     but providing a non-nil value for this argument leaves underscores alone.
     It is a matter of having, say, default ‚Äú_‚äï‚Çô_‚Äù versus ‚Äú_‚äï_‚Çô‚Äù.

     The resulting module has a parameter, whose name is irrelevant but is
     of the form ‚ÄúArgùíπùíπùíπùíπ‚Äù for some digits ùíπ in order to minimise clash with
     any user-defined names.

     Besides the addition of a new parameter, all element qualifiers are discarded.
    "
    :kind module
    :level none
    :waist 1
    :alter-elements  (lambda (fs)
      (let ((kind "{! !}") (‚Ñõ (format "Ar%s" (gensym))))
        (cons (make-element :name ‚Ñõ :type $ùëùùëéùëüùëíùëõùë°)
          (--map (let ((name (if avoid-mixfix-renaming (with (element-name it)) (rename-mixfix with (element-name it)))))
            (make-element :name name
                          :type (format "let open %s %s in %s" $ùëùùëéùëüùëíùëõùë° ‚Ñõ (element-type it))
                          :equations (list (format "%s = %s.%s %s" name $ùëùùëéùëüùëíùëõùë° (element-name it) ‚Ñõ)))) fs)))))
 #+END_SRC

   Notice that we do not need any ~open ‚ãØ public~ since all elements are top-level.
   We are not making using of Agda's renaming facility. An example may clarify this observation.
   #+BEGIN_SRC agda
{-700
M-Set-R = M-Set record
M-Set-R‚ÇÅ = M-Set-R ‚ü¥ open (Œª x ‚Üí (concat x "‚ÇÅ"))
-}
 #+END_SRC

 #+BEGIN_SRC results-agda :tangle no
module M-Set-R‚ÇÅ (Arg6926 : M-Set-R) where
   Scalar‚ÇÅ      : let open M-Set-R Arg6926 in Set ; Scalar‚ÇÅ = M-Set-R.Scalar Arg6926
   Vector‚ÇÅ      : let open M-Set-R Arg6926 in Set ; Vector‚ÇÅ = M-Set-R.Vector Arg6926
   _¬∑‚ÇÅ_     : let open M-Set-R Arg6926 in Scalar ‚Üí Vector ‚Üí Vector ;    _¬∑‚ÇÅ_ = M-Set-R._¬∑_ Arg6926
   ùüô‚ÇÅ       : let open M-Set-R Arg6926 in Scalar ;  ùüô‚ÇÅ = M-Set-R.ùüô Arg6926
   _√ó‚ÇÅ_     : let open M-Set-R Arg6926 in Scalar ‚Üí Scalar ‚Üí Scalar ;    _√ó‚ÇÅ_ = M-Set-R._√ó_ Arg6926
   leftId‚ÇÅ      : let open M-Set-R Arg6926 in {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã ;    leftId‚ÇÅ = M-Set-R.leftId Arg6926
   assoc‚ÇÅ       : let open M-Set-R Arg6926 in ‚àÄ {a b ùìã} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã) ; assoc‚ÇÅ = M-Set-R.assoc Arg6926
   #+END_SRC

   In-case you've skipped over the above source documentation for ~open~, it's time to read it.

   Notice that a module opening depends on a record, whence the first declaration of ~M-Set-R~.

   #+begin_center
    These kind of open-renamings are so common that the tedium
    is actually acceptable by most users ---it shouldn't be
    and now it no longer has to be that way.
   #+end_center

   It is common in Agda to provide ‚Äúto‚Äù-lists, so let's provide a variant that supports those
   instead of forcing users to produce functions explicitly.
   #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± opening with
  = "Open a record as a module exposing only the names mentioned in WITH.

    WITH is a string of ‚Äú;‚Äù-separated items consisting of ‚Äúto‚Äù-separated pairs.
    "
    open (Œª x ‚Üí (funcall (reify-to-list with :otherwise "_") x)) :avoid-mixfix-renaming t)

    ;; Alternatively, we could have used ‚Äòtrash‚Äô names,
    ;; something like (format "%s" (gensym)), instead of "_".
   #+END_SRC

     #+BEGIN_SRC agda
{-700
M-Set-R-SV = M-Set-R opening "Scalar to S; Vector to V"
-}
     #+END_SRC
 This opens the ~M-Set-R~ record *exposing only* ~S~ and ~V~ ---the rest are ignored using Agda's ~_~ mechanism.
     #+BEGIN_SRC results-agda :tangle no
module M-Set-R-SV (Arg6933 : M-Set-R) where
   S        : let open M-Set-R Arg6933 in Set ; S = M-Set-R.Scalar Arg6933
   V        : let open M-Set-R Arg6933 in Set ; V = M-Set-R.Vector Arg6933
   _        : let open M-Set-R Arg6933 in Scalar ‚Üí Vector ‚Üí Vector ;    _ = M-Set-R._¬∑_ Arg6933
   _        : let open M-Set-R Arg6933 in Scalar ;  _ = M-Set-R.ùüô Arg6933
   _        : let open M-Set-R Arg6933 in Scalar ‚Üí Scalar ‚Üí Scalar ;    _ = M-Set-R._√ó_ Arg6933
   _        : let open M-Set-R Arg6933 in {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã ;    _ = M-Set-R.leftId Arg6933
   _        : let open M-Set-R Arg6933 in ‚àÄ {a b ùìã} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã) ; _ = M-Set-R.assoc Arg6933
 #+END_SRC

 After simplifying the ~let~-expressions, this module definition is equivalent to the following
 ---the types of which may be seen with Agda's ~C-c C-o~ call.
 #+BEGIN_SRC agda :tangle no
module M-Set-R-SV (Arg : M-Set-R) where
  S : (Arg : M-Set-R) ‚Üí Set ; S = M-Set-R.Scalar Arg
  V : (Arg : M-Set-R) ‚Üí Set ; V = M-Set-R.Vector Arg
 #+END_SRC

 Let's provide an even more common feature: Opening records with a decoration.
 For example, when we have two algebraic structures, we might want the first to be subscripted with ‚ÇÅ
 and the second with ‚ÇÇ ---this is different than ~subscripted·µ¢~ from above, which produces a /new/ record
 rather than opening it with renames.
 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± open-with-decoration ddd
  = "Open a record, exposing all elements, with decoration DDD.

    DDD is a string.
   "
   open (Œª x ‚Üí (concat x ddd)))
 #+END_SRC

 Here's an example.
 #+BEGIN_SRC results-agda
{-700
M-Set-R‚Ä≤ = M-Set-R open-with-decoration "‚Ä≤"
-}
                           #+END_SRC

                           #+BEGIN_SRC results-agda  :tangle no
module M-Set-R‚Ä≤ (Arg6938 : M-Set-R) where
   Scalar‚Ä≤      : let open M-Set-R Arg6938 in Set ; Scalar‚Ä≤ = M-Set-R.Scalar Arg6938
   Vector‚Ä≤      : let open M-Set-R Arg6938 in Set ; Vector‚Ä≤ = M-Set-R.Vector Arg6938
   _¬∑‚Ä≤_     : let open M-Set-R Arg6938 in Scalar ‚Üí Vector ‚Üí Vector ;    _¬∑‚Ä≤_ = M-Set-R._¬∑_ Arg6938
   ùüô‚Ä≤       : let open M-Set-R Arg6938 in Scalar ;  ùüô‚Ä≤ = M-Set-R.ùüô Arg6938
   _√ó‚Ä≤_     : let open M-Set-R Arg6938 in Scalar ‚Üí Scalar ‚Üí Scalar ;    _√ó‚Ä≤_ = M-Set-R._√ó_ Arg6938
   leftId‚Ä≤      : let open M-Set-R Arg6938 in {ùìã : Vector}  ‚Üí  ùüô ¬∑ ùìã  ‚â°  ùìã ;    leftId‚Ä≤ = M-Set-R.leftId Arg6938
   assoc‚Ä≤       : let open M-Set-R Arg6938 in ‚àÄ {a b ùìã} ‚Üí (a √ó b) ¬∑ ùìã  ‚â°  a ¬∑ (b ¬∑ ùìã) ; assoc‚Ä≤ = M-Set-R.assoc Arg6938
 #+END_SRC

   Neato petito :smile:

 #+begin_center
 It is important to observe that ‚Äòopenings‚Äô are lossy:
 They lose the types of the declarations and so cannot be used further to construct
 new pacaking mechanisms. They are a terminal construction.
 #+end_center

   In the next section, we make use of such openings to actually produce
   homomorphism constructions.

 #  For now, let's show how /functions are PackageFormers./

*** Automatically deriving homomorphism definitions ‚ô•‚Äø‚ô•
    :PROPERTIES:
    :CUSTOM_ID: Automatically-deriving-homomorphism-definitions
    :END:

     The definition of ‚Äústructure preservation‚Äù is, nearly always, mechanical to
     formulate and that's just what we shall do to avoid having to write it out
     by hand ever again ---which the [[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Morphism.html#586][current approach]] in the Agda standard library.

     :Illuminating_yet_overkill_to-subscript_defn:
 #+BEGIN_SRC emacs-lisp  :tangle no
(defun to-subscript (n)
  "Subscript numbers ùìÉ have hex-codes #x208ùìÉ,
   we realise the codes as characters to obtain the subscripts.

   This is preferable to casing:
  (pcase i (0 ‚Äú‚ÇÄ‚Äù) (1 ‚Äú‚ÇÅ‚Äù) (2 ‚Äú‚ÇÇ‚Äù) ‚ãØ)

  When ‚Äòn‚Äô ‚àâ 0..9 an error message halts execution.
  "

  (when (or (< n 0) (> n 9))
    (error "to-subscript: n must be in 0..9"))

  (thread-last
    (format "#x208%s" n)
    (read-from-string)
    car
    (format "%c")))
 #+END_SRC
     :End:

     The idea is not too complicated:
     1. Suppose you have an operation ~_¬∑_ : Scalar ‚Üí Vector ‚Üí Vector~.
     2. Suppose you have a numbering of the sorts; e.g., ~sort‚ÇÅ = Scalar, sort‚ÇÇ = Vector~.
     3. Form functions ~map·µ¢ : sort·µ¢ ‚Üí sort·µ¢‚Ä≤~
     4. Include implicit arguments in the type: ~{x‚ÇÅ : Scalar} ‚Üí {x‚ÇÇ : Vector} ‚Üí Vector~.
     5. The target type ~Vector = sort‚ÇÇ~ means we need to apply ~map‚ÇÇ~ to the expression
        formed from the operation's name along with the arguments.
        - The left hand side is thus ~map‚ÇÇ (_¬∑_ x‚ÇÅ x‚ÇÇ)~.
     6. For the right hand side, we use the target-space's name, say ~_¬∑‚Ä≤_~,
        along with ~map·µ¢~ applied to ~x·µ¢~ for each ~i~ mentioned in the type.

     7. The result:
        ~pres-¬∑ : {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÇ : Vector} ‚Üí   map‚ÇÇ (_¬∑_ x‚ÇÅ x‚ÇÇ)   ‚â°   _¬∑‚Ä≤_ (map‚ÇÅ x‚ÇÅ) (map‚ÇÇ x‚ÇÇ)~.
       :RoughIdea:
     ‚áí  _¬∑_ : sort‚ÇÅ ‚Üí sort‚ÇÇ ‚Üí sort‚ÇÇ
     ‚áí pres-¬∑ : {x‚ÇÅ : sort‚ÇÅ} {x‚ÇÇ : sort‚ÇÇ}
          ‚Üí   form source expression:  x‚ÇÅ ¬∑ x‚ÇÇ
            ‚áí form target expression: map‚ÇÅ x‚ÇÇ ¬∑‚Ä≤ map‚ÇÇ x‚ÇÇ
            ‚áí equate them using target sort's map:  map‚ÇÇ (x‚ÇÅ ¬∑ x‚ÇÇ) ‚â° map‚ÇÅ x‚ÇÇ ¬∑‚Ä≤ map‚ÇÇ x‚ÇÇ
     :End:

     First, we need a helper that forms the preservation formulae.
     For example:
 #+BEGIN_SRC emacs-lisp  :tangle no
(show-element (homify (make-element :name "_¬∑_" :type "Scalar ‚Üí Vector ‚Üí Vector")
                      '( ("Scalar" . 4) ("Vector" . 1))))
‚áí
  pres-¬∑ : {x‚ÇÑ : Scalar} ‚Üí {x‚ÇÅ : Vector}
         ‚Üí map‚ÇÅ (_¬∑_ x‚ÇÑ x‚ÇÅ)   ‚â°   _¬∑‚Ä≤_ (map‚ÇÑ x‚ÇÑ) (map‚ÇÅ x‚ÇÅ)
 #+END_SRC

     With this as a specification, in a ~lisp~ block:
 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(defun homify (element sort)
  "Given a typed name, produce the associating ‚Äúpreservation‚Äù formula.

E.g.,
  _¬∑_    : Scalar ‚Üí Vector ‚Üí Vector
  pres-¬∑ : {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÇ : Vector} ‚Üí map‚ÇÇ (x‚ÇÅ ¬∑ x‚ÇÇ) = map‚ÇÅ x‚ÇÅ ¬∑‚Ä≤ map‚ÇÇ x‚ÇÇ


Type œÑ gets variable x·µ¢ provided (i, œÑ) ‚àà SORT;
likewise we think of map·µ¢ : œÑ ‚Üí œÑ‚Ä≤.
Notice that the target name is primed, ‚Äú¬∑‚Ä≤‚Äù

ELEMENT is the typed-name and SORT is the alist of numbered sorts."
  (letf* ((sorts     (mapcar #'car sort))
          (index     (Œª it ‚Üí (to-subscript (cdr (assoc it sort)))))

          (tn‚Üí       (s-split " ‚Üí " (element-type element)))
          (arg-count (1- (length tn‚Üí)))

          (all-indicies  (mapcar index
                                 (--filter (member (s-trim it) sorts) tn‚Üí)))
          (indicies  (-drop-last 1 all-indicies))
          (tgt-idx   (car (-take-last 1 all-indicies)))

          (op        (element-name element))
          (args      (--map (concat "x" it) indicies))
          (lhs       (format "map%s (%s %s)" tgt-idx op (s-join " " args)))

          (op‚Ä≤       (rename-mixfix (lambda (n) (concat n "‚Ä≤")) op))
          (map-args  (--map (format "(map%s x%s)" it it) indicies))
          (rhs       (format "%s %s" op‚Ä≤ (s-join " " map-args)))

          (target    (format "  %s   ‚â°   %s" lhs rhs)))

    ;; Change the target type.
    (setq tn‚Üí (--map (when (assoc it sort)
                       (format "{x%s : %s}" (funcall index it) it)) tn‚Üí))
    (setf (nth arg-count tn‚Üí) target)

    ;; Stick it all together, with an updated name.
    (make-element
     :name (format "pres-%s" (s-replace "_" "" (element-name element)))
     :type (s-join " ‚Üí " tn‚Üí))))
 #+END_SRC

     Then, we form the variational as follows ---also in a ~lisp~ block.
 #+BEGIN_SRC emacs-lisp :tangle "variationals.tmp" :noweb yes :noweb-ref std-ùí±-lib
(ùí± hom
  = "Formulate the notion of homomorphism of $ùëùùëéùëüùëíùëõùë° algebras.

     ‚û© $ùëùùëéùëüùëíùëõùë° must be an existing record type used in the resulting formulation.
    "
    record ‚ü¥
    :waist 2
    :alter-elements (lambda (es)

      (let (maps eqns sorts (ùíÆùìáùí∏ "Src") (ùíØ‚Ñäùìâ "Tgt"))

        ;; Construct the map·µ¢ : sort·µ¢ ‚Üí sort·µ¢‚Ä≤; keeping track of (sort . i) pairs.
        (loop for e in es
              for i from 1
         do
           (when (is-sort e)
             (push (cons (element-name e) i) sorts)
             (push (make-element
                      :qualifier "field"
                      :name (format "map%s" (to-subscript i))
                      :type (format "%s ‚Üí %s‚Ä≤" (element-name e) (element-name e)))
                   maps))

            (when (and (targets-a-sort e) (not (is-sort e)))
              (push (homify e sorts) eqns)))

      ;; Ensure we have a source and target space as elements.
      (-cons*
       (make-element :qualifier "field" :name ùíÆùìáùí∏ :type $ùëùùëéùëüùëíùëõùë°)
       (make-element :qualifier "field" :name ùíØ‚Ñäùìâ :type $ùëùùëéùëüùëíùëõùë°)
       (--map
        (map-type (Œª œÑ ‚Üí (format "let open %s %s; open %s‚Ä≤ %s in %s"
                                 $ùëùùëéùëüùëíùëõùë° ùíÆùìáùí∏ $ùëùùëéùëüùëíùëõùë° ùíØ‚Ñäùìâ œÑ))
                  (map-qualifier (Œª _ ‚Üí "field") it))
        (reverse (-concat eqns maps)))))))
 #+END_SRC

     Here are two examples. *Note* that the latter allows us to /rename/ the ~map·µ¢~ as we
     wish ---which may be preferable to extending the variational to accommodate for new
     names.

 #+BEGIN_SRC agda
{-700
Algebra  = M-Set record
Algebra‚Ä≤ = Algebra open-with-decoration "‚Ä≤"
Hom  = Algebra hom
Hom¬≤ = Algebra hom ‚ü¥ renaming "map‚ÇÅ to scalar; pres-ùüô to unity" :adjoin-retract nil
-}

_ : {Src Tgt : Algebra} ‚Üí Hom¬≤ Src Tgt ‚Üí Algebra.Scalar Src ‚Üí Algebra.Scalar Tgt
_ = Hom¬≤.scalar
 #+END_SRC

 #+BEGIN_SRC results-agda :tangle no
{- Hom  = Algebra hom -}
record Hom (Src : Algebra) (Tgt : Algebra) : Set‚ÇÅ where
   field map‚ÇÅ       : let open Algebra Src; open Algebra‚Ä≤ Tgt in Scalar ‚Üí Scalar‚Ä≤
   field map‚ÇÇ       : let open Algebra Src; open Algebra‚Ä≤ Tgt in Vector ‚Üí Vector‚Ä≤
   field pres-¬∑     : let open Algebra Src; open Algebra‚Ä≤ Tgt in {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÇ : Vector} ‚Üí   map‚ÇÇ (_¬∑_ x‚ÇÅ x‚ÇÇ)   ‚â°   _¬∑‚Ä≤_ (map‚ÇÅ x‚ÇÅ) (map‚ÇÇ x‚ÇÇ)
   field pres-ùüô     : let open Algebra Src; open Algebra‚Ä≤ Tgt in   map‚ÇÅ (ùüô )   ‚â°   ùüô‚Ä≤
   field pres-√ó     : let open Algebra Src; open Algebra‚Ä≤ Tgt in {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÅ : Scalar} ‚Üí   map‚ÇÅ (_√ó_ x‚ÇÅ x‚ÇÅ)   ‚â°   _√ó‚Ä≤_ (map‚ÇÅ x‚ÇÅ) (map‚ÇÅ x‚ÇÅ)


{- Hom¬≤ = Algebra hom ‚ü¥ renaming "map‚ÇÅ to scalar; pres-ùüô to unity" -}
record Hom¬≤ (Src : Algebra) (Tgt : Algebra) : Set‚ÇÅ where
   field scalar     : let open Algebra Src; open Algebra‚Ä≤ Tgt in Scalar ‚Üí Scalar‚Ä≤
   field map‚ÇÇ       : let open Algebra Src; open Algebra‚Ä≤ Tgt in Vector ‚Üí Vector‚Ä≤
   field pres-¬∑     : let open Algebra Src; open Algebra‚Ä≤ Tgt in {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÇ : Vector} ‚Üí   map‚ÇÇ (_¬∑_ x‚ÇÅ x‚ÇÇ)   ‚â°   _¬∑‚Ä≤_ (scalar x‚ÇÅ) (map‚ÇÇ x‚ÇÇ)
   field unity      : let open Algebra Src; open Algebra‚Ä≤ Tgt in   scalar (ùüô )   ‚â°   ùüô‚Ä≤
   field pres-√ó     : let open Algebra Src; open Algebra‚Ä≤ Tgt in {x‚ÇÅ : Scalar} ‚Üí {x‚ÇÅ : Scalar} ‚Üí   scalar (_√ó_ x‚ÇÅ x‚ÇÅ)   ‚â°   _√ó‚Ä≤_ (scalar x‚ÇÅ) (scalar x‚ÇÅ)
 #+END_SRC

   This is so cool (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

   We leave it to the reader to derive other constructs from a theory presentation.
   Examples can be found in these [[https://alhassy.github.io/next-700-module-systems/papers/JC_Program_Generation_Talk_IFIP.pdf][Metaprogramming Agda]] slides:
   Homomorphism equality, application to carrier elements, isomorphisms,
   isomorphisms where only one direction needs to preserve the structure
   and an automatically derivable proof that the other direction is also
   structure preserving, endomorphism and automorphism types, kernels,
   product & sum & other categorical types.

   + Challenge ::
       Design a scheme to produce simple Cartesian products from a given theory.

     1. The only variable to this problem is an arbitrary record, say it is ~M~.

        For this exercise to be tractable, assume ~M~ consists of declarations
        of sort symbols, function symbols, and nullary (non-implication) equations
        which may have implicit arguments.

     2. Ensure you understood the definition of the homomorphism scheme above.
     3. Mimic the homomorphism scheme to produce a typed ~Prod~ where ~Prod A‚ÇÄ A‚ÇÅ~
        consists of a ~M~ value, say ~P~, and two homomorphisms ~Hom P A·µ¢~.
     4. Write a Lisp code that produces a function ~MakeProduct : (A‚ÇÄ A‚ÇÅ : M) ‚Üí Prod A‚ÇÄ A‚ÇÅ~.

        - The projection morphisms are straightforward.
        - Every /n/-ary function ~f~ could be defined by ~f‚Çö = zip‚Çô f‚ÇÄ f‚ÇÅ~.
        - Every equation ~e~ could be defined by ~e‚Çö = cong‚ÇÇ _,_ e‚ÇÄ e‚ÇÅ~.

     5. If you have actually attempted this, then go on to include the remaining
        artefacts to make the construction an actual categorical product.

*** COMMENT Currying for Datatypes
    :PROPERTIES:
    :CUSTOM_ID: COMMENT-Currying-for-Datatypes
    :END:
    :PROPERTIES:

    :END:

    :Lisp_code_that_generates_the_code_for_this_subsection:
 #+BEGIN_SRC emacs-lisp :var monoid = monoid :exports both :results replace :wrap "src results-agda"
(let* ((variationals nil) (instantiations-remaining nil)
       (vs (pf--load-variationals (s-join "\n" '(
      "ùí±-identity = "
      "ùí±-record  = :kind record :waist-strings (\"field\")"
      "ùí±-whoops  = :kind recorder :waist-strings (\"field\")"
      "ùí±-typeclass-attempt  = :kind record :waist-strings (\"field\") :waist 2"
      "ùí±-typeclass‚ÇÇ  = :kind record :waist-strings (\"field\") :waist 2 :level dec"
      "ùí±-primed-record = :kind record :waist-strings (\"field\") :alter-elements (Œª f ‚Üí (map-name (concat name \"‚Ä≤\") f))"
      "ùí±-primed = :alter-elements (Œª f ‚Üí (map-name (concat name \"‚Ä≤\") f))"
      "ùí±-typeclass height level = :kind record :waist-strings (\"field\") :waist height :level level"
; TODO:   ; "ùí±-renamed with = :alter-elements (Œª e ‚Üí (map-name (funcall with name) e))"
      "ùí±-data-with carrier = :kind data :level dec :alter-elements (Œª f ‚Üí (if (s-contains? carrier (target (get-type f))) (map-type (s-replace carrier $ùëõùëéùëöùëí type) f) \"\"))"
      ))))
       (pf (load-package-former (second (get-children "PackageFormer" monoid)))))

  (--map (load-instance-declaration it)
    '(

      ; TODO: "M-Set-PF = M-Set identity :waist 2" ;; nope.

      ; "Monoid-Record = Monoid record"
      ; "Monoid-Classical = Monoid typeclass :height (1) :level (dec)"
       "MonoidOp = Monoid typeclass :height (2) :level (dec)"
      ; "M-Set-Record = M-Set whoops"
      ; "M-Set-Typeclass = M-Set typeclass-attempt"
      ; "M-Set-Typeclass‚ÇÇ = M-Set typeclass‚ÇÇ"
      ; "M-Set-Record‚Ä≤ = M-Set primed-record"
      ; "M-Set‚Ä≤ = M-Set primed"
      ; "M-Set-Record‚Ä≤ = M-Set-Record primed"
      ; "M-Set-Record‚Ä≤ = M-Set-Record record ‚ü¥ primed"
      ; "M-Set-Typeclass‚ÇÉ = M-Set-Record typeclass :height (3) :level (dec) :comment (why hello there)"

      ; TODO: "M-Set‚ÇÅ = M-Set renamed :with ((Œª x ‚Üí x))"

      ; "ScalarSyntax = M-Set data-with :carrier (\"Scalar\")"
      ))

  (reify-instances)
)
 #+END_SRC

 #+RESULTS:

 :End:

 Suppose you're a Haskell programmer and want to have multiple monoid instances for the Booleans.
 You may make isomorphic copies of the Booleans, say ~And~ and ~Any~, and implement the desired instance
 for each. What about if you want a Monoid instance but insist only that the unit be ~false~, what do you do then?

 With this prototype, you expose the carrier and the operation in the first case, and expose the identity in the second case.
 Moreover, you only write the definition of monoid once, leading to our motto:
 #+BEGIN_CENTER
 /Write once, derive many!/
 #+END_CENTER

 Here's a formalisation of monoids:
 #+NAME: monoid
 #+BEGIN_SRC agda :results replace :wrap "src results-agda"
PackageFormer Monoid : Set‚ÇÅ where
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
 #+END_SRC
 :Hide:
 #+RESULTS: monoid
 #+BEGIN_src results-agda
PackageFormer Monoid : Set‚ÇÅ where
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
 #+END_src
 :End:

 We regain the Haskell-style typeclass definition with the following declaration:
 #+BEGIN_SRC agda
 Monoid-Classical = Monoid typeclass :height (1) :level (dec)
 #+END_SRC
 Loading the script, with ~C-c C-l~ as usual, produces a generated file that elaborate this definition as follows:
 #+BEGIN_SRC results-agda
record Monoid-Classical (Carrier : Set) : Set where
  field
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
 #+END_SRC
 Notice that a name ~Carrier~ has been lifted to being a parameter instead of a field.
 This is the result of the ~:height~ argument to the ~typeclass~ variational defined
 in the previous subsection.

 :TODO_FIXME:
 We could use the letter ~m~ in-place of ~Carrier~, as is done in Haskell, as follows.
 #+BEGIN_SRC agda
 Monoid-m = Monoid typeclass renaming (Carrier to m)
 #+END_SRC
 Which propagates ~Carrier = m~ into the fields. The propagation is necessary
 if we were, for example, to rename ~_‚®æ_ to _‚äï_~ ---otherwise we would need to parse
 mixfix applications of this operator, as in ~assoc~!
 #+BEGIN_SRC agda
record Monoid-m (m : Set) : Set where
  field
    _‚®æ_     : let Carrier = m in m ‚Üí m ‚Üí m
    Id      : let Carrier = m in m
    assoc   : let Carrier = m in ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : let Carrier = m in ‚àÄ {x : let Carrier = m in m} ‚Üí Id ‚®æ x ‚â° x
    rightId : let Carrier = m in ‚àÄ {x : let Carrier = m in m} ‚Üí x ‚®æ Id ‚â° x
 #+END_SRC
 :END:

 Since Agda supports ‚Äònamed instances‚Äô, the Haskeller's first problem is solved. However, we demonstrate
 an alternative solution that will allow us to solve the second problem in a fashion that current Agda
 can only awkwardly approximate.

 For example, with the current setup, we may go about requesting multiple monoid instances for the Booleans:
 #+BEGIN_SRC agda
open Monoid-Classical using () renaming (_‚®æ_ to Op)

yuck-one :  (X Y : Classical ùîπ)
     ‚Üí  Op X  ‚â° _‚àß_  ‚Üí  Op Y  ‚â° _‚à®_
     ‚Üí  Set
yuck-one = ???
 #+END_SRC

 The following declaration lets us ‚Äòuncurry‚Äô the first ~N = 2~ elements
 from the field-position to the parameter-position.
 #+BEGIN_SRC agda
MonoidOp = Monoid typeclass :height (2) :level (dec)
 #+END_SRC

 This then yields:
 #+BEGIN_src results-agda
record MonoidOp (Carrier : Set) (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier) : Set where
  field
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
 #+END_src

 Which let's us solve the first problem elegantly as so:
 #+BEGIN_SRC agda
first-problem : MonoidOp ùîπ _‚àß_  ‚Üí  MonoidOp ùîπ _‚à®_  ‚Üí Set
first-problem = ???
 #+END_SRC

 Neato ^_^ Short and sweet.

 Now for the second problem. Rather than forming a new data-type,
 we hoist up the ~Id~-entity field as a parameter.
 | ~TODO: Write this section~ |

 #+BEGIN_SRC agda
 MonoidId = Monoid record exposing (Carrier; Id)
 #+END_SRC
 Which results in:
 #+BEGIN_SRC agda
record MonoidId (Carrier : Set) (Id : Carrier) : Set where
  field
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
 #+END_SRC

 Resulting in the solution type:
 #+BEGIN_SRC agda
second-problem-okay : (X Y : MonoidId ùîπ false) ‚Üí Set
second-problem-okay = ???
 #+END_SRC
 However, this too can get tedious if we wish to only consider monoids
 with unit ~false~. In that case, we /treat/ the fields as if they where
 manifest fields and instantiate them to form a new type.
 #+BEGIN_SRC agda
{-700 Monoid-false = Monoid record with (Carrier to ùîπ; Id to false) -}

record Monoid-false : Set where
  field
    _‚®æ_     : ùîπ ‚Üí ùîπ ‚Üí ùîπ
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftfalse  : ‚àÄ {x : ùîπ} ‚Üí false ‚®æ x ‚â° x
    rightfalse : ‚àÄ {x : ùîπ} ‚Üí x ‚®æ false ‚â° x

second-problem-better : (X Y : Monoid-false) ‚Üí Set
second-problem-better = ???
 #+END_SRC

 The full source of this discussion is as follows.
 {{{fold(CaseStudy.agda)}}}
 #+INCLUDE: "CaseStudy.agda" src agda
 {{{end-fold}}}

*** regular expression tests                                         :ignore:
    :PROPERTIES:
    :CUSTOM_ID: regular-expression-tests
    :END:
    :Hide:
    Names may involve (Emacs) regular expression operators such as [],+,*,?, etc.
 #+BEGIN_SRC agda
{-700
-- regular expression test --

crazy-name-[]-+-\-^-*-? = M-Set extended-by "_+_ : Scalar; _*_ : Vector; ^ : Set; [_] : Set" :adjoin-retract nil ‚ü¥ record

PackageFormer MagmaP : Set‚ÇÅ where
  Carrier : Set
  op      : Carrier ‚Üí Carrier ‚Üí Carrier

Magma = MagmaP ‚ü¥ record

Pointed   = Magma extended-by "e : let Carrier = Carrier in Carrier" ‚ü¥ record
Additive+ = Pointed renaming "op to _+_; e to O; Carrier to C" ‚ü¥ record
Additive√ó = Additive+ renaming "_+_ to _√ó_"

crazy-name-test  = Pointed map (Œª e ‚Üí (map-name (Œª n ‚Üí (concat n "/crazy-name-[]-+-\-^-*-?")) e)) ‚ü¥ record
crazy-name-test2 = crazy-name-test map (Œª e ‚Üí (map-name (Œª n ‚Üí (concat n "+2")) e)) ‚ü¥ record
-}
 #+END_SRC
    :End:
* TODO The Third Choice: Contexts
** COMMENT Why PackageFormer is not enough.
** COMMENT Discuss Agda macros ---need to be self-contained.
** COMMENT Motivate the need for a practical syntax.
** COMMENT The reason it's a "do it yourself" system is that the semantics, >>=,
     can be tweaked easily for other forms of grouping besides Pi/Sigma ;-)
** COMMENT Current limitations; e.g., lack of termination/positivity of certain constructs;
     or how termtype generation requires the ADT carrier to be the first element
     of the sequence/context, whereas a DAG interpretation of Contexts would be better?
** COMMENT How does this compare with PF?
** COMMENT What are the benefits of Context?
** COMMENT Concrete problems its usage can solve.

** COMMENT Abstract                                                  :ignore:

   #+begin_abstract org
   Can parameterised records and algebraic datatypes be derived from one
   pragmatic declaration?

   Record types give a universe of discourse, parameterised record types fix
   parts of that universe ahead of time, and algebraic datatypes give us
   first-class syntax, whence evaluators and optimisers.

   The answer is in the affirmative. Besides a practical
   shared declaration interface, which is extensible in the language,
   we also find that common data structures correspond to simple theories.
 #+end_abstract

  \maketitle

** COMMENT Context Examples Header                                 :noexport:

 #+begin_src agda  :tangle Context_examples.agda
-- Agda version 2.6.0.1
-- Standard library version 1.2

module Context_Examples where

open import Context

open import Data.Product
open import Level renaming (zero to ‚Ñì‚ÇÄ; suc to ‚Ñìsuc)
open import Relation.Binary.PropositionalEquality hiding ([_])
open import Data.Empty
open import Relation.Nullary
open import Data.Nat
open import Function using (id)
open import Data.Bool renaming (Bool to ùîπ)
open import Data.Sum

open import Data.List
import Data.Unit as Unit
open import Reflection hiding (name; Type) renaming (_>>=_ to _>>=‚Çò_)

 #+end_src

** Introduction

   All too often, when we program, we write the same information two or more
   times in our code, in different guises.  For example, in Haskell, we
   may write a class, a record to reify that class, and an algebraic type
   to give us a syntax for programs written using that class.  In proof
   assistants, this tends to get worse rather than better, as parametrized
   records give us a means to ``stage'' information.  From here on, we will
   use Agda cite:Norell-2007 for our examples.

   Concretely, suppose we have two monoids ~(M‚ÇÅ, _‚®æ‚ÇÅ_, Id‚ÇÅ)~ and ~(M‚ÇÇ, _‚®æ‚ÇÇ_, Id‚ÇÇ)~,
   if we know @@latex:\!\!\footnote{ The propositional equality $M_1 \equiv M_2$ means the $M·µ¢$ are convertible with each
  other when all free variables occurring in the $M·µ¢$ are instantiated,
  and otherwise are not necessarily identical.
  A stronger equality operator cannot be expressed in Agda.} @@
   that src_agda[:exports code]{ceq : M‚ÇÅ ‚â° M‚ÇÇ} then it is ‚Äúobvious‚Äù that
   src_agda[:exports code]{Id‚ÇÇ ‚®æ‚ÇÇ (x ‚®æ‚ÇÅ Id‚ÇÅ) ‚â° x} for all
   ~x : M‚ÇÅ~. However, as written, this does not type-check.  This is because
   ~_‚®æ‚ÇÇ_~ expects elements of ~M‚ÇÇ~ but has been given an element of ~M‚ÇÅ~.
   Because we have ~ceq~ in hand, we can use ~subst~ to transport things around.
   The resulting formula, shown as the type of ~claim~ below,
 then typechecks, but is hideous.
   ``$\mathsf{subst}$ hell'' only gets worse.  Below, we use pointed magmas for brevity,
   as the problem is the same.
 :Header:
   #+begin_src agda
open import Relation.Binary.PropositionalEquality
open import Function
 #+end_src
 :End:
 # 87 words ;; M-x count-words
 #+begin_src agda
record Magma‚ÇÄ : Set‚ÇÅ where
  field
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id     : Carrier

module Awkward-Formulation (A B : Magma‚ÇÄ)
    (ceq : Magma‚ÇÄ.Carrier A ‚â° Magma‚ÇÄ.Carrier B)
    where
      open Magma‚ÇÄ A renaming (Id to Id‚ÇÅ; _‚®æ_ to _‚®æ‚ÇÅ_)
      open Magma‚ÇÄ B renaming (Id to Id‚ÇÇ; _‚®æ_ to _‚®æ‚ÇÇ_)

      claim : ‚àÄ x ‚Üí Id‚ÇÇ ‚®æ‚ÇÇ subst id ceq (x ‚®æ‚ÇÅ Id‚ÇÅ) ‚â° subst id ceq x
      claim = {!!}
      {- ‚Äú{!!}‚Äù stands for a ‚Äúhole‚Äù in Agda,
         needing replacement by an expression -}
 #+end_src
 It should not be this difficult to state a trivial fact.  We could make
 things artifically prettier by defining ~coe~ to be ~subst id ceq~
 without changing the heart of the matter.  But if
 ~Magma‚ÇÄ~ is the definition used in the library we are using, we are
 stuck with it, if we want to be compatible with other work.

 Ideally, we would prefer to be able to express that the carriers are
 shared ‚Äúon the nose‚Äù, which can be done as follows:
 #  69 words
 #+begin_src agda
record Magma‚ÇÅ (Carrier : Set) : Set where
  field
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id     : Carrier

module Nicer
    (M : Set)    {- The shared carrier -}
    (A B : Magma‚ÇÅ M)
    where
      open Magma‚ÇÅ A renaming (Id to Id‚ÇÅ; _‚®æ_ to _‚®æ‚ÇÅ_)
      open Magma‚ÇÅ B renaming (Id to Id‚ÇÇ; _‚®æ_ to _‚®æ‚ÇÇ_)

      claim : ‚àÄ x ‚Üí Id‚ÇÇ ‚®æ‚ÇÇ (x ‚®æ‚ÇÅ Id‚ÇÅ) ‚â° x
      claim = {!!}
   #+end_src
   This is the formulation we expected, without noise. Thus it seems that it
   would be better to expose the carrier. But, before long, we'd find a different
   concept, such as homomorphism, which is awkward in this way, and cleaner
   using the first approach.  These two approaches are called
   \emph{bundled} and \emph{unbundled} respectively cite:typeclasses_for_maths.

   The definitions of homomorphism themselves (see below) is not so different,
   but the definition of composition already starts to be quite unwieldly.
 :Hom·µ¢:
 #+begin_src agda
-- 63 words
record Hom‚ÇÄ (A B : Magma‚ÇÄ) : Set where
  open Magma‚ÇÄ A renaming (Carrier to M‚ÇÅ; Id to Id‚ÇÅ; _‚®æ_ to _‚®æ‚ÇÅ_)
  open Magma‚ÇÄ B renaming (Carrier to M‚ÇÇ; Id to Id‚ÇÇ; _‚®æ_ to _‚®æ‚ÇÇ_)
  field
    mor   : M‚ÇÅ ‚Üí M‚ÇÇ
    ‚®æ-cong : ‚àÄ x y ‚Üí mor (x ‚®æ‚ÇÅ y) ‚â° mor x ‚®æ‚ÇÇ mor y
    Id-cong : mor Id‚ÇÅ ‚â° Id‚ÇÇ

-- 65 words
record Hom‚ÇÅ {M‚ÇÅ M‚ÇÇ : Set} (A : Magma‚ÇÅ M‚ÇÅ) (B : Magma‚ÇÅ M‚ÇÇ) : Set where
  open Magma‚ÇÅ A renaming (Id to Id‚ÇÅ; _‚®æ_ to _‚®æ‚ÇÅ_)
  open Magma‚ÇÅ B renaming (Id to Id‚ÇÇ; _‚®æ_ to _‚®æ‚ÇÇ_)
  field
    mor    : M‚ÇÅ ‚Üí M‚ÇÇ
    ‚®æ-cong : ‚àÄ x y ‚Üí mor (x ‚®æ‚ÇÅ y) ‚â° mor x ‚®æ‚ÇÇ mor y
    ‚®æ-id   : mor Id‚ÇÅ ‚â° Id‚ÇÇ
 #+end_src
 :End:
 # 32 words vs 22 words
 #+begin_src agda
record Hom‚ÇÄ (A B : Magma‚ÇÄ) : Set where ‚ãØ
record Hom‚ÇÅ {M‚ÇÅ M‚ÇÇ : Set} (A : Magma‚ÇÅ M‚ÇÅ) (B : Magma‚ÇÅ M‚ÇÇ) : Set where ‚ãØ

composition‚ÇÄ : ‚àÄ {A B C} ‚Üí Hom‚ÇÄ A B ‚Üí Hom‚ÇÄ B C ‚Üí Hom‚ÇÄ A C
composition‚ÇÄ = {!!}

composition‚ÇÅ : ‚àÄ {M‚ÇÅ M‚ÇÇ M‚ÇÉ} {A : Magma‚ÇÅ M‚ÇÅ} {B : Magma‚ÇÅ M‚ÇÇ} {C : Magma‚ÇÅ M‚ÇÉ}
             ‚Üí Hom‚ÇÅ A B ‚Üí Hom‚ÇÅ B C ‚Üí Hom‚ÇÅ A C
composition‚ÇÅ = {!!}
 #+end_src

 #+latex: \noindent
 So not only are there no general rules for when to bundle or not, it is
 in fact guaranteed that any given choice will be sub-optimal for certain
 applications.  Furthermore, these types are equivalent, as we can
 ``pack away'' an exposed piece,
 e.g., src_agda[:exports code]{Monoid‚ÇÄ ‚âÖ Œ£ M ‚à∂ Set ‚Ä¢ Monoid‚ÇÅ M}.
 The developers of the Agda standard library cite:agda_std_lib have chosen to
 expose all types and function symbols while bundling up the proof obligations
 at one level, and also provide a fully bundled form as a wrapper.
 This is also the method chosen in Lean cite:Hales-blog-post, and in Coq
 cite:typeclasses_for_maths.

 While such a choice is workable, it is still not optimal. There are
 bundling variants that are unavailable, and would be more convenient for
 certain applications.

   #+latex: \noindent

 We will show an automatic technique for unbundling data at will; thereby
 resulting in /bundling-independent representations/ and in /delayed unbundling/.
 Our contributions are to show:
   1. Languages with sufficiently powerful type systems and meta-programming can
      conflate record and term datatype declarations into one practical
      interface. In addition, the contents of these grouping mechanisms
      may be function symbols as well as propositional invariants ---an example
      is shown at the end of Section [[sec:monadic-notation]].
      We identify the problem and the subtleties in shifting between
      representations in Section [[sec:problems]].

   2. Parameterised records can be obtained on-demand from non-parameterised
      records @@latex:\hbox{@@(Section [[sec:monadic-notation]]) @@latex:}@@.
      - As with ~Magma‚ÇÄ~, the traditional approach cite:coq_cat_experiences to
        unbundling a record requires the use of transport along propositional
        equalities, with trivial ~refl~-exivity proofs. In Section
        [[sec:monadic-notation]], we develop a combinator, ~_:waist_~, which removes
        the boilerplate necessary at the type specialisation location as well as
        at the instance declaration location.

   3. Programming with fixed-points of unary type constructors can be made
      as simple as programming with term datatypes (Section
      [[sec:termtypes-as-fixedpoints]]).

   4. Astonishingly, we mechanically regain ubiquitous data structures such as ~‚Ñï,
      Maybe, List~ as the term datatypes of simple pointed and monoidal theories
      (Section [[sec:free-datatypes]]).

   As an application, in Section [[sec:related-works]] we show that the resulting
   setup applies as a semantics for a declarative pre-processing tool that accomplishes the
   above tasks.

   For brevity, and accessibility, a number of definitions are elided and only
   @@latex: \dbox{dashed pseudo-code}@@ is presented in the paper, with the
   understanding that such functions need to be extended homomorphically over all
   possible term constructors of the host language.  Enough is shown to
   communicate the techniques and ideas, as well as to make the resulting library
   usable.  The details, which users do not need to bother with, can be found in
   the appendices.
** The Problems
   <<sec:problems>>

 There are a number of problems, with the number of parameters being exposed
 being the pivotal concern. To exemplify the distinctions at the type level as
 more parameters are exposed, consider the following approaches to formalising a
 dynamical system ---a collection of states, a designated start state, and a
 transition function.

 #+begin_src agda  :tangle Context_examples.agda
record DynamicSystem‚ÇÄ : Set‚ÇÅ where
  field
    State : Set
    start  : State
    next   : State ‚Üí State

record DynamicSystem‚ÇÅ (State : Set) : Set where
  field
    start : State
    next  : State ‚Üí State

record DynamicSystem‚ÇÇ (State : Set) (start : State) : Set where
  field
    next : State ‚Üí State
 #+end_src

 #+latex: \noindent
 Each =DynamicSystem·µ¢= is a type constructor of =i=-many arguments;
 but it is the types of these constructors that provide insight
 into the sort of data they contain:
 | Type           | Kind                      |
 |----------------+---------------------------|
 | =DynamicSystem‚ÇÄ= | =Set‚ÇÅ=                      |
 | =DynamicSystem‚ÇÅ= | =Œ† X ‚à∂ Set ‚Ä¢ Set=           |
 | =DynamicSystem‚ÇÇ= | =Œ† X ‚à∂ Set ‚Ä¢ Œ† x ‚à∂ X ‚Ä¢ Set= |
 :AgdaCheckedEvidence:
     #+begin_src agda  :tangle Context_examples.agda
_ : Set‚ÇÅ
_ = DynamicSystem‚ÇÄ

_ : Œ† X ‚à∂ Set ‚Ä¢ Set
_ = DynamicSystem‚ÇÅ

_ : Œ† X ‚à∂ Set ‚Ä¢ Œ† x ‚à∂ X ‚Ä¢ Set
_ = DynamicSystem‚ÇÇ
 #+end_src
 :End:

 # Below: (The \" here is a ``trema'', not an ``Umlaut''.)
 #+latex: \noindent
 We shall refer to the concern of moving from a record to a parameterised record
 as *the unbundling problem* cite:packaging_mathematical_structures. For example,
 moving from the /type/ ~Set‚ÇÅ~ to the /function type/ @@latex:\quad@@ src_agda[:exports code]{Œ† X ‚à∂ Set ‚Ä¢ Set}
 @@latex:\quad@@ gets us from
 ~DynamicSystem‚ÇÄ~ to something resembling ~DynamicSystem‚ÇÅ~, which we arrive at if we
 can obtain a /type constructor/ @@latex:\quad@@ src_agda[:exports code]{Œª X ‚à∂ Set
 ‚Ä¢ ‚ãØ}. @@latex:$\,$@@
 We shall refer to the latter change
 as @@latex: \emph{re\"{\i}fication}@@ since the result is more concrete: It can
 be applied. This transformation will be
 denoted by ~Œ†‚ÜíŒª~. To clarify this subtlety, consider the following forms of the
 polymorphic identity function. Notice that $\mathsf{id}·µ¢$ /exposes/ =i=-many details at the
 type level to indicate the sort of data it consists of. However, notice that ~id‚ÇÄ~ is
 a type of functions whereas $\mathsf{id}‚ÇÅ$ is a function on types. Indeed, the latter
 two are derived from the first one: $\mathsf{id}_{i + 1} \,=\, Œ†\!\!‚Üí\!\!Œª\, \mathsf{id}·µ¢$
 These identities are true by ~refl~-exivity ---see Appendix [[sec:identity-funcs]].
 #+begin_src agda  :tangle Context_examples.agda
id‚ÇÄ : Set‚ÇÅ
id‚ÇÄ = Œ† X ‚à∂ Set ‚Ä¢ Œ† e ‚à∂ X ‚Ä¢ X

id‚ÇÅ : Œ† X ‚à∂ Set ‚Ä¢ Set
id‚ÇÅ = Œª (X : Set) ‚Üí Œ† e ‚à∂ X ‚Ä¢ X

id‚ÇÇ : Œ† X ‚à∂ Set ‚Ä¢ Œ† e ‚à∂ X ‚Ä¢ Set
id‚ÇÇ = Œª (X : Set) (e : X) ‚Üí X
 #+end_src

 #+latex: \noindent
 Of course, there is also the need for descriptions of values, which leads to term datatypes. We shall refer to the shift from record types to algebraic
 data types as *the termtype problem*.
 Our aim is to obtain all of these notions ---of ways to group data together---
 from a single user-friendly context declaration, using monadic notation.

 :Ignore:
 Mark: Maybe a note that State = DSTerms‚ÇÄ in the first one? Whereas DSTerms·µ¢ ‚àà State for i = 1,2.
 #+begin_src agda  :tangle Context_examples.agda
data DSTerms‚ÇÄ : Set where
  start : DSTerms‚ÇÄ
  next  : DSTerms‚ÇÄ ‚Üí DSTerms‚ÇÄ

data DSTerms‚ÇÅ (State : Set) : Set where
  start : State ‚Üí DSTerms‚ÇÅ State
  next  : DSTerms‚ÇÅ State ‚Üí DSTerms‚ÇÅ State

data DSTerms‚ÇÇ (State : Set) (start : State) : Set where
  next : DSTerms‚ÇÇ State start ‚Üí DSTerms‚ÇÇ State start
 #+end_src

 Yet another way to encode dynamical systems would be by their syntax, as it
 would be desirable when serialising them ---i.e., to obtain first-class
 descriptions of dynamical system values.


 Notice that the first algebraic data type is isomorphic to ~‚Ñï~, whereas the
 remaining two are isomorphic to ~State √ó ‚Ñï~ which keeps track of how many =next=
 steps are necessary until a =State= value is reached ---this may be called
 =Eventually State=.
 The ~DSTerms·µ¢~ share the same pattern of kind exposure as the ~DynamicSystem·µ¢~ types.

 AgdaCheckedEvidence
 #+begin_src agda  :tangle Context_examples.agda
_ : Set
_ = DSTerms‚ÇÄ

_ : Œ† X ‚à∂ Set ‚Ä¢ Set
_ = DSTerms‚ÇÅ

_ : Œ† X ‚à∂ Set ‚Ä¢ Œ† x ‚à∂ X ‚Ä¢ Set
_ = DSTerms‚ÇÇ
 #+end_src
 :End:

 # +latex: \noindent

** Monadic Notation
   <<sec:monadic-notation>>

   There is little use in an idea that is difficult to use in practice.  As such,
   we conflate records and termtypes by starting with an ideal syntax they would
   share, then derive the necessary artefacts that permit it. Our choice of
   syntax is monadic do-notation
   \cite{DBLP:journals/iandc/Moggi91,DBLP:conf/haskell/MarlowJKM16}:

 #+begin_src agda :tangle no
DynamicSystem : Context ‚Ñì‚ÇÅ
DynamicSystem = do State ‚Üê Set
                   start ‚Üê State
                   next  ‚Üê (State ‚Üí State)
                   End
 #+end_src
  #+latex: \noindent
  Here ~Context, End~, and the underlying monadic bind operator are unknown.  Since
  we want to be able to /expose/ a number of fields at will, we may take ~Context~ to
  be types indexed by a number denoting exposure.  Moreover, since records are
  product types, we expect there to be a recursive definition whose base case
  will be the identity of products, the unit type ~ùüô~ ---which corresponds to ~‚ä§~ in
  the Agda standard library and to ~()~ in Haskell.

  #+latex: {\renewcommand{\arraystretch}{1.3}
  #+name: elaborations
  #+caption: Elaborations of DynamicSystem at various exposure levels
 | Exposure |   | Elaboration                                                 |
 |----------+---+-------------------------------------------------------------|
 |        0 |   | =Œ£ State ‚à∂ Set  ‚Ä¢ Œ£ start ‚à∂ X  ‚Ä¢ Œ£ next ‚à∂ State ‚Üí State  ‚Ä¢ ùüô= |
 |        1 |   | =Œ† State ‚à∂ Set  ‚Ä¢ Œ£ start ‚à∂ X  ‚Ä¢ Œ£ next ‚à∂ State ‚Üí State  ‚Ä¢ ùüô= |
 |        2 |   | =Œ† State ‚à∂ Set  ‚Ä¢ Œ† start ‚à∂ X  ‚Ä¢ Œ£ next ‚à∂ State ‚Üí State  ‚Ä¢ ùüô= |
 |        3 |   | =Œ† State ‚à∂ Set  ‚Ä¢ Œ† start ‚à∂ X  ‚Ä¢ Œ† next ‚à∂ State ‚Üí State  ‚Ä¢ ùüô= |
 #+latex: }

 #+latex: \noindent
 With these elaborations of ~DynamicSystem~ to guide the way, we resolve
 two of our unknowns.
 #+begin_src agda :tangle no
{- ‚ÄúContexts‚Äù are exposure-indexed types -}
Context = Œª ‚Ñì ‚Üí ‚Ñï ‚Üí Set ‚Ñì

{- Every type can be used as a context -}
‚Äµ_ : ‚àÄ {‚Ñì} ‚Üí Set ‚Ñì ‚Üí Context ‚Ñì
‚Äµ S = Œª _ ‚Üí S

{- The ‚Äúempty context‚Äù is the unit type -}
End : ‚àÄ {‚Ñì} ‚Üí Context ‚Ñì
End = ‚Äµ ùüô
 #+end_src

 #+latex: \noindent
 It remains to identify the definition of the underlying bind operation ~>>=~.
 Usually, for a type constructor ~m~, bind is typed src_agda[:exports code]{‚àÄ {X Y : Set} ‚Üí m X ‚Üí (X ‚Üí
 m Y) ‚Üí m Y}. It allows one to ‚Äúextract an ~X~-value for later use‚Äù in the ~m Y~
 context. Since our ~m = Context~ is from levels to types, we need to slightly
 alter bind's typing.
 #+begin_src agda :tangle no
_>>=_ : ‚àÄ {a b}
      ‚Üí (Œì : Context a)
      ‚Üí (‚àÄ {n} ‚Üí Œì n ‚Üí Context b)
      ‚Üí Context (a ‚äç b)
(Œì >>= f) zero    = Œ£ Œ≥ ‚à∂ Œì 0 ‚Ä¢ f Œ≥ 0
(Œì >>= f) (suc n) = Œ† Œ≥ ‚à∂ Œì n ‚Ä¢ f Œ≥ n
 #+end_src
 #+latex: \noindent
 The definition here accounts for the current exposure index: If zero, we have
 /record types/, otherwise /function types/. Using this definition, the above
 dynamical system context would need to be expressed using the lifting quote operation.

 #+latex: \begin{quotation}\scalebox{0.92}[1]{
 src_agda[:exports code]{‚Äµ Set >>= Œª State ‚Üí ‚Äµ State >>= Œª start ‚Üí ‚Äµ (State ‚Üí
 State) >>= Œª next ‚Üí End}
 #+latex: }\end{quotation}
  #+begin_src agda :tangle no
{- or -}
do State ‚Üê ‚Äµ Set
   start ‚Üê ‚Äµ State
   next  ‚Üê ‚Äµ (State ‚Üí State)
   End
 #+end_src
 # See page 275.
 #+latex: \noindent
 Interestingly cite:Bird_2009,DBLP:conf/hopl/HudakHJW07, use of ~do~-notation in
 preference to bind, ~>>=~, was suggested by John Launchbury in 1993 and was first
 implemented by Mark Jones in Gofer.  Anyhow, with our goal of practicality in
 mind, we shall ‚Äúbuild the lifting quote into the definition‚Äù of bind:
 #+ATTR_LaTeX: :placement [!htpb]
 #+caption: Semantics: Context do-syntax is interpreted as Œ†-Œ£-types
 #+begin_src agda :tangle no
_>>=_ : ‚àÄ {a b}
      ‚Üí (Œì : Set a)  -- Main difference
      ‚Üí (Œì ‚Üí Context b)
      ‚Üí Context (a ‚äç b)
(Œì >>= f) zero    = Œ£ Œ≥ ‚à∂ Œì ‚Ä¢ f Œ≥ 0
(Œì >>= f) (suc n) = Œ† Œ≥ ‚à∂ Œì ‚Ä¢ f Œ≥ n
 #+end_src
 #+LATEX_HEADER: \usepackage{placeins}
 #+latex: \FloatBarrier
 # The FloatBarrier stops floats (figures are floats) from jumping over them. I
 # will need to look into passing [tbh] options to figures from org mode further.

 :Ignore:
 Using the definition of bind, we can elaborate
 #+begin_center
 #+begin_export latex
 \dashbox{\texttt{DynamicSystem 0 = Œ£ State ‚à∂ Set  ‚Ä¢ Œ£ start ‚à∂ State  ‚Ä¢ Œ£ next ‚à∂
 State ‚Üí State  ‚Ä¢ ùüô}}
 #+end_export
 #+end_center
 :End:

 #+latex: \noindent
 With this definition, the above declaration ~DynamicSystem~ typechecks.  However,
 ~DynamicSystem ùíæ ‚âá DynamicSystem·µ¢~, instead $\mathsf{DynamicSystem}\, ùíæ$ are ‚Äúfactories‚Äù: Given
 =i=-many arguments, a product value is formed. What if we want to /instantiate/ some
 of the factory arguments ahead of time?
 #+begin_src agda :tangle no
ùí©‚ÇÄ : DynamicSystem 0   {- See the elaborations in Table 1 -}
ùí©‚ÇÄ = ‚Ñï , 0 , suc , tt

ùí©‚ÇÅ : DynamicSystem 1
ùí©‚ÇÅ = Œª State ‚Üí ??? {- Impossible to complete if ‚ÄúState‚Äù is empty! -}

{- ‚ÄúInstantiaing‚Äù X to be ‚Ñï in ‚ÄúDynamicSystem 1‚Äù -}
ùí©‚ÇÅ‚Ä≤ : let State = ‚Ñï in Œ£ start ‚à∂ State  ‚Ä¢ Œ£ s ‚à∂ (State ‚Üí State)  ‚Ä¢ ùüô
ùí©‚ÇÅ‚Ä≤ = 0 , suc , tt
 #+end_src
 #+latex: \noindent
 It seems what we need is a method, say ~Œ†‚ÜíŒª~, that takes a ~Œ†~-type and transforms it
 into a ~Œª~-expression.  One could use a universe, an algebraic type of codes
 denoting types, to define ~Œ†‚ÜíŒª~. However, one can no longer then easily use
 existing types since they are not formed from the universe's constructors,
 thereby resulting in duplication of existing types via the universe
 encoding. This is  neither practical nor pragmatic.

 As such, we are left with pattern matching on the language's type formation
 primitives as the only reasonable approach. The method ~Œ†‚ÜíŒª~ is thus a
 macro @@latex: \!\!\footnote{A \emph{macro} is a function that manipulates the
 abstract syntax trees of the host language. In particular, it may take an
 arbitrary term, shuffle its syntax to provide possibly meaningless terms or
 terms that could not be formed without pattern matching on the possible
 syntactic constructions.  An up to date and gentle introduction to reflection in
 Agda can be found at \citep{gentle-intro-to-reflection} }@@ that acts on the
 syntactic term representations of types.  Below is main transformation ---the
 details can be found in Appendix [[sec:pi-to-lambda]].
 #+begin_center
 #+begin_export latex
 \dbox{\texttt{Œ†‚ÜíŒª (Œ† a ‚à∂ A ‚Ä¢ œÑ) = (Œª a ‚à∂ A ‚Ä¢ œÑ)}}
 #+end_export
 #+end_center
 #+latex: \noindent
 That is, we walk along the term tree replacing occurrences of ~Œ†~ with ~Œª~. For
 example,
  #+latex: {\renewcommand{\arraystretch}{1.3}
 #+begin_src agda :tangle no
  Œ†‚ÜíŒª (Œ†‚ÜíŒª (DynamicSystem 2))
‚â°{- Definition of DynamicSystem at exposure level 2 -}
  Œ†‚ÜíŒª (Œ†‚ÜíŒª (Œ† X ‚à∂ Set ‚Ä¢ Œ† s ‚à∂ X  ‚Ä¢ Œ£ n ‚à∂ X ‚Üí X  ‚Ä¢ ùüô))
‚â°{- Definition of Œ†‚ÜíŒª -}
  Œ†‚ÜíŒª (Œª X ‚à∂ Set ‚Ä¢ Œ† s ‚à∂ X  ‚Ä¢ Œ£ n ‚à∂ X ‚Üí X  ‚Ä¢ ùüô)
‚â°{- Homomorphy of Œ†‚ÜíŒª -}
  Œª X ‚à∂ Set ‚Ä¢ Œ†‚ÜíŒª (Œ† s ‚à∂ X  ‚Ä¢ Œ£ n ‚à∂ X ‚Üí X  ‚Ä¢ ùüô)
‚â°{- Definition of Œ†‚ÜíŒª -}
  Œª X ‚à∂ Set ‚Ä¢ Œª s ‚à∂ X  ‚Ä¢ Œ£ n ‚à∂ X ‚Üí X  ‚Ä¢ ùüô
 #+end_src
 #+latex: }

 #+latex: \noindent
 For practicality, ~_:waist_~ is a macro (defined in Appendix [[sec:waist]]) acting on contexts that repeats ~Œ†‚ÜíŒª~ a number of
 times in order to lift a number of field components to the parameter level.
 #+latex: \vspace{1em}
 #+begin_center latex
 #+begin_export latex
 \dbox{\parbox{0.3\textwidth}{%

 \texttt{œÑ :waist n  =  Œ†‚ÜíŒª‚Åø (œÑ n)}

 \texttt{f‚Å∞   x  \hspace{2.55em}    =  x}

 \texttt{f‚Åø‚Å∫¬π x  \hspace{1.4em}    =  f‚Åø (f x)}

 }}
 #+end_export
 #+end_center

 #+latex: \vspace{1em}\noindent
 We can now ‚Äúfix arguments ahead of time‚Äù. Before such demonstration, we need to
 be mindful of our practicality goals: One declares a grouping mechanism with
 ~do ‚Ä¶ End~, which in turn has its instance values constructed with ~‚ü® ‚Ä¶ ‚ü©~.
 #+begin_src agda :tangle no
-- Expressions of the form ‚Äú‚ãØ , tt‚Äù may now be written ‚Äú‚ü® ‚ãØ ‚ü©‚Äù
infixr 5 ‚ü® _‚ü©
‚ü®‚ü© : ‚àÄ {‚Ñì} ‚Üí ùüô {‚Ñì}
‚ü®‚ü© = tt

‚ü® : ‚àÄ {‚Ñì} {S : Set ‚Ñì} ‚Üí S ‚Üí S
‚ü® s = s

_‚ü© : ‚àÄ {‚Ñì} {S : Set ‚Ñì} ‚Üí S ‚Üí S √ó (ùüô {‚Ñì})
s ‚ü© = s , tt
 #+end_src
 #+latex: \noindent
 The following instances of grouping types demonstrate how information moves from
 the body level to the parameter level.
 #+BEGIN_SRC agda
ùí©‚Å∞ : DynamicSystem :waist 0
ùí©‚Å∞ = ‚ü® ‚Ñï , 0 , suc ‚ü©

ùí©¬π : (DynamicSystem :waist 1) ‚Ñï
ùí©¬π = ‚ü® 0 , suc ‚ü©

ùí©¬≤ : (DynamicSystem :waist 2) ‚Ñï 0
ùí©¬≤ = ‚ü® suc ‚ü©

ùí©¬≥ : (DynamicSystem :waist 3) ‚Ñï 0 suc
ùí©¬≥ = ‚ü®‚ü©
 #+END_SRC
 #+latex: \noindent
 Using ~:waist ùíæ~ we may fix the first ~ùíæ~-parameters ahead of time.  Indeed, the
 type @@latex:\newline@@ src_agda[:exports code]{(DynamicSystem :waist 1) ‚Ñï} is /the type of dynamic
 systems over carrier ‚Ñï/, whereas @@latex:\newline@@ src_agda[:exports code]{(DynamicSystem :waist 2)
 ‚Ñï 0} is /the type of dynamic systems over carrier ‚Ñï and start state 0/.

 Examples of the need for such on-the-fly unbundling can be found in numerous
 places in the Haskell standard library. For instance, the standard libraries cite:data_monoid
 have two isomorphic copies of the integers, called ~Sum~ and ~Product~, whose reason
 for being is to distinguish two common monoids: The former is for /integers with
 addition/ whereas the latter is for /integers with multiplication/.
 An orthogonal solution would be to use contexts:
 #+begin_src agda :tangle Context_examples.agda
Monoid : ‚àÄ ‚Ñì ‚Üí Context (‚Ñìsuc ‚Ñì)
Monoid ‚Ñì = do Carrier ‚Üê Set ‚Ñì
              _‚äï_     ‚Üê (Carrier ‚Üí Carrier ‚Üí Carrier)
              Id      ‚Üê Carrier
              leftId  ‚Üê ‚àÄ {x : Carrier} ‚Üí x ‚äï Id ‚â° x
              rightId ‚Üê ‚àÄ {x : Carrier} ‚Üí Id ‚äï x ‚â° x
              assoc   ‚Üê ‚àÄ {x y z} ‚Üí (x ‚äï y) ‚äï z  ‚â°  x ‚äï (y ‚äï z)
              End {‚Ñì}
 #+end_src
 #+latex: \noindent
 With this context, (~Monoid ‚Ñì‚ÇÄ :waist 2) M ‚äï~ is the type of monoids over
 /particular/ types ~M~ and /particular/ operations ~‚äï~.  Of-course, this is orthogonal,
 since traditionally unification on the carrier type ~M~ is what makes typeclasses
 and canonical structures cite:coq_canonical_tutorial useful for ad-hoc
 polymorphism.

 # since Haskell's use-case is for canonical typeclasses, which utilise unification
 # on the carrier type ~M~ to find instance implementations.

** Termtypes as Fixed-points
   <<sec:termtypes-as-fixedpoints>>

   We have a practical monadic syntax for possibly parameterised record types
   that we would like to extend to termtypes. Algebraic data types are a means to
   declare concrete representations of the least fixed-point of a functor; see
   cite:DBLP:journals/jfp/Swierstra08 for more on this idea.  In particular, the
   description language ~ùîª~ for dynamical systems, below, declares concrete
   constructors for a fixpoint of a certain functor ~F~; i.e., ~ùîª ‚âÖ Fix F~ where:
   #+begin_src agda :tangle no
data ùîª : Set where
    startD : ùîª
    nextD  : ùîª ‚Üí ùîª

F : Set ‚Üí Set
F = Œª (D ‚à∂ Set) ‚Üí ùüô ‚äé D

data Fix (F : Set ‚Üí Set) : Set where
  Œº : F (Fix F) ‚Üí Fix F
 #+end_src
 #+latex: \noindent
  The problem is whether we can derive ~F~ from ~DynamicSystem~.
  Let us attempt a quick calculation
  sketching the necessary transformation steps (informally expressed via ``$\Rightarrow$''):
 # Avoid overfull \hboxes. E.g., \scalebox{0.9}[1]{The whole comments}
 # +name: termtypes-guide
 # +caption: Guide to termtypes
 #+BEGIN_SRC agda :tangle no
  do S ‚Üê Set; s ‚Üê S; n ‚Üê (S ‚Üí S); End
‚áí{- Use existing interpretation to obtain a record. -}
  Œ£ S : Set ‚Ä¢ Œ£ s : S ‚Ä¢ Œ£ n : (S ‚Üí S) ‚Ä¢ ùüô
‚áí{- Pull out the carrier, ‚Äú:waist 1‚Äù,
    to obtain a type constructor using ‚ÄúŒ†‚ÜíŒª‚Äù. -}
  Œª S : Set ‚Ä¢ Œ£ s : S ‚Ä¢ Œ£ n : (S ‚Üí S) ‚Ä¢ ùüô
‚áí{- Termtype constructors target the declared type,
    so only their sources matter. E.g., ‚Äòs : S‚Äô is a
    nullary constructor targeting the carrier ‚ÄòS‚Äô.
    This introduces ùüô types, so any existing
    occurances are dropped via ùüò. -}
  Œª S : Set ‚Ä¢ Œ£ s : ùüô ‚Ä¢ Œ£ n : S ‚Ä¢ ùüò
‚áí{- Termtypes are sums of products. -}
  Œª S : Set ‚Ä¢       ùüô   ‚äé     S  ‚äé ùüò
‚áí{- Termtypes are fixpoints of type constructors. -}
  Fix (Œª X ‚Ä¢ ùüô ‚äé S)  -- i.e., ùîª
  #+END_SRC
 #+latex: \noindent
  Since we may view an algebraic data-type as a fixed-point of the functor
   obtained from the union of the sources of its constructors, it suffices to
   treat the fields of a record as constructors, then obtain their sources, then
   union them.  That is, since algebraic-datatype constructors necessarily target
   the declared type, they are determined by their sources.  For example,
   considered as a unary constructor ~op : A ‚Üí B~ targets the termtype ~B~ and
   so its source is ~A~.
   The details on the operations ~‚áä, Œ£‚Üí‚äé~, and ~sources~
   characterised by the pseudocode below can be found in appendices
   [[sec:decreasing-de-brujin]], [[sec:sigma-to-sum]], and [[sec:sources]], respectively.
   It suffices to know that ~Œ£‚Üí‚äé~ rewrites dependent-sums into disjoint sums,
   which requires the second argument to lose its reference to the first argument
   which is accomplished by ~‚áä~; further details can be found in the appendices.
 #+latex: \vspace{1em}
 #+begin_center latex
 #+begin_export latex
 \dbox{\parbox{0.71\textwidth}{%

 \texttt{‚áä œÑ = ‚Äúreduce all de Bruijn indices within œÑ by 1‚Äù}

 \vspace{1em}
 \texttt{Œ£‚Üí‚äé (Œ£ a ‚à∂ A ‚Ä¢ Ba) = A ‚äé Œ£‚Üí‚äé (‚áä Ba)}

 \vspace{0.5em}
 \texttt{sources (Œª x ‚à∂ (Œ† a ‚à∂ A ‚Ä¢ Ba) ‚Ä¢ œÑ) = (Œª x ‚à∂ A ‚Ä¢ sources œÑ)}

 \texttt{sources (Œª x ‚à∂ A \hspace{5.9em} ‚Ä¢ œÑ) = (Œª x ‚à∂ ùüô ‚Ä¢ sources œÑ)}

 \vspace{0.5em}
 \texttt{termtype œÑ = Fix (Œ£‚Üí‚äé (sources œÑ))}

 }}
 #+end_export
 #+end_center

 #+latex: \vspace{1em}\noindent
 It is instructive to work through the process of how ~ùîª~ is obtained from ~termtype~
 in order to demonstrate that this approach to algebraic data types
 is practical.
 #+begin_src agda :tangle no
ùîª = termtype (DynamicSystem :waist 1)

-- Pattern synonyms for more compact presentation
pattern startD  = Œº (inj‚ÇÅ tt)       -- : ùîª
pattern nextD e = Œº (inj‚ÇÇ (inj‚ÇÅ e)) -- : ùîª ‚Üí ùîª
 #+end_src
 #+latex: \noindent
 With these  src_agda[:exports code]{pattern} declarations, we can actually use the more meaningful names
 ~startD~ and ~nextD~ when pattern matching, instead of the seemingly daunting
 Œº-~inj~-ections.  For instance, we can immediately see that the natural numbers
 act as the description language for dynamical systems:
 #+begin_src agda :tangle no
to : ùîª ‚Üí ‚Ñï
to startD    = 0
to (nextD x) = suc (to x)

from : ‚Ñï ‚Üí ùîª
from zero    = startD
from (suc n) = nextD (from n)
 #+end_src

 #+latex: \noindent
 Readers whose language does not have src_agda[:exports code]{pattern} clauses
 need not despair.  With the macro
 #+begin_center latex
 @@latex:\dbox{\texttt{Inj n x = Œº (inj‚ÇÇ ‚Åø (inj‚ÇÅ x))}}@@
 #+end_center
 we may define src_agda[:exports code]{startD = Inj 0 tt} and
 src_agda[:exports code]{nextD e = Inj 1 e} ---that is, constructors of termtypes
 are particular injections into the possible summands that the termtype consists
 of.  Details on this macro may be found in appendix [[sec:inj-macro]].

** Free Datatypes from Theories
   <<sec:free-datatypes>>

 Astonishingly, useful programming datatypes arise from termtypes of theories
 (contexts). That is, if a parameterised context src_agda[:exports code]{ùíû : Set
 ‚Üí Context ‚Ñì‚ÇÄ} is given, then
 #+begin_src agda
‚ÑÇ = Œª X ‚Üí termtype (ùíû X :waist 1)
 #+end_src
 #+latex: \noindent
 can be used to form ‚Äòfree, lawless, ùíû-instances‚Äô. For instance, earlier we
 witnessed that the termtype of dynamical systems is essentially the natural
 numbers.
 #+label: theories-data-structures
 #+caption: Data structures as free theories
 | Theory             | Termtype     |
 |--------------------+--------------|
 | Dynamical Systems  | ‚Ñï            |
 | Pointed Structures | Maybe        |
 | Monoids            | Binary Trees |

 :Ignore:
 Similarly, by starting at ‚Äútheories of
 pointed sets over a given set Œû‚Äù, the resulting termtype is the ~Maybe~
 type constructor ---another instructive exercise to the reader: Show that ~‚Ñô ‚âÖ Maybe~.
 #+begin_src agda :tangle no
PointedOver  : Set ‚Üí Context (‚Ñìsuc ‚Ñì‚ÇÄ)
PointedOver Œû    = do Carrier ‚Üê Set ‚Ñì‚ÇÄ
                      point   ‚Üê Carrier
                      embed   ‚Üê (Œû ‚Üí Carrier)
                      End

‚Ñô : Set ‚Üí Set
‚Ñô X = termtype (PointedOver X :waist 1)

-- Pattern synonyms for more compact presentation
pattern nothingP = Œº (inj‚ÇÅ tt)       -- : ‚Ñô
pattern justP e  = Œº (inj‚ÇÇ (inj‚ÇÅ e)) -- : ‚Ñô ‚Üí ‚Ñô
 #+end_src
 :End:

  # In addition, the contents of these grouping mechanisms
   #    may be function symbols as well as propositional invariants ---an example
    #   is shown at the end of [[sec:monadic-notation]].


 # We present the setup
 # and leave it as an instructive exercise to the reader to present a
 # bijective pair of functions between =ùïÑ= and =TreeSkeleton=.

 #+latex: \vspace{-1.5em}\noindent
 The final entry in Table 2 is a well known correspondence that we
 can now not only formally express, but also prove to be true.
 :Hide:
 #+begin_src agda :tangle Context_examples.agda
module termtype[Monoid]‚âÖTreeSkeleton where
       #+end_src
 :End:
       #+begin_src agda :tangle Context_examples.agda
  ùïÑ : Set
  ùïÑ = termtype (Monoid ‚Ñì‚ÇÄ :waist 1)
  {- i.e., Fix (Œª X ‚Üí ùüô      -- Id, nil leaf
                 ‚äé X √ó X √ó ùüô -- _‚äï_, branch
                 ‚äé ùüò         -- invariant leftId
                 ‚äé ùüò         -- invariant rightId
                 ‚äé X √ó X √ó ùüò -- invariant assoc
                 ‚äé ùüò)        -- the ‚ÄúEnd {‚Ñì}‚Äù
  -}

  -- Pattern synonyms for more compact presentation
  pattern emptyM      = Œº (inj‚ÇÇ (inj‚ÇÅ tt))               -- : ùïÑ
  pattern branchM l r = Œº (inj‚ÇÅ (l , r , tt))            -- : ùïÑ ‚Üí ùïÑ ‚Üí ùïÑ
  pattern absurdM a   = Œº (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÇ a))))  -- absurd values of ùüò

  data TreeSkeleton : Set where
    empty  : TreeSkeleton
    branch : TreeSkeleton ‚Üí TreeSkeleton ‚Üí TreeSkeleton
 #+end_src
 #+latex: \noindent
 Using Agda's Emacs interface, we may interactively
 case-split on values of =ùïÑ= until the declared patterns appear, then we associate them
 with the constructors of ~TreeSkeleton~.
 #+begin_src agda  :tangle Context_examples.agda
  to : ùïÑ ‚Üí TreeSkeleton
  to emptyM        = empty
  to (branchM l r) = branch (to l) (to r)
  to (absurdM (inj‚ÇÅ ()))
  to (absurdM (inj‚ÇÇ ()))

  from : TreeSkeleton ‚Üí ùïÑ
  from empty        = emptyM
  from (branch l r) = branchM (from l) (from r)
 #+end_src
 #+latex: \noindent
 That these two operations are inverses is easily demonstrated.
 #+begin_src agda  :tangle Context_examples.agda
  from‚àòto : ‚àÄ m ‚Üí from (to m) ‚â° m
  from‚àòto emptyM        = refl
  from‚àòto (branchM l r) = cong‚ÇÇ branchM (from‚àòto l) (from‚àòto r)
  from‚àòto (absurdM (inj‚ÇÅ ()))
  from‚àòto (absurdM (inj‚ÇÇ ()))

  to‚àòfrom : ‚àÄ t ‚Üí to (from t) ‚â° t
  to‚àòfrom empty        = refl
  to‚àòfrom (branch l r) = cong‚ÇÇ branch (to‚àòfrom l) (to‚àòfrom r)
 #+end_src

 #+latex: \noindent
 Without the src_agda[:exports code]{pattern} declarations the result would
 remain true, but it would be quite difficult to believe in the correspondence
 without a machine-checked proof.

 To obtain a data structure over some ‚Äòvalue type‚Äô Œû, one must start with
 ‚Äútheories containing a given set Œû‚Äù. For example, we could begin with the
 theory of abstract collections, then obtain lists as the associated termtype.
 :Hide:
 #+begin_src agda  :tangle Context_examples.agda
module termtype[Collection]‚âÖList where
 #+end_src
 :End:
 #+begin_src agda :tangle Context_examples.agda
  Collection : ‚àÄ ‚Ñì ‚Üí Context (‚Ñìsuc ‚Ñì)
  Collection ‚Ñì = do Elem    ‚Üê Set ‚Ñì
                    Carrier ‚Üê Set ‚Ñì
                    insert  ‚Üê (Elem ‚Üí Carrier ‚Üí Carrier)
                    ‚àÖ       ‚Üê Carrier
                    End {‚Ñì}

  ‚ÑÇ : Set ‚Üí Set
  ‚ÑÇ Elem = termtype ((Collection ‚Ñì‚ÇÄ :waist 2) Elem)

  pattern _::_ x xs = Œº (inj‚ÇÅ (x , xs , tt))
  pattern  ‚àÖ        = Œº (inj‚ÇÇ (inj‚ÇÅ tt))
 #+end_src
 #+latex: \newpage
 #+begin_src agda  :tangle Context_examples.agda
  to : ‚àÄ {E} ‚Üí ‚ÑÇ E ‚Üí List E
  to (e :: es) = e ‚à∑ to es
  to ‚àÖ         = []
 #+end_src

 It is then little trouble to show that ~to~ is invertible.  We invite the readers
 to join in on the fun and try it out themselves!
 :Hide:
 #+begin_src agda  :tangle Context_examples.agda
  from : ‚àÄ {E} ‚Üí List E ‚Üí ‚ÑÇ E
  from []       = ‚àÖ
  from (x ‚à∑ xs) = x :: from xs

  to‚àòfrom : ‚àÄ {E} (xs : List E) ‚Üí to (from xs) ‚â° xs
  to‚àòfrom []       = refl
  to‚àòfrom (x ‚à∑ xs) = cong (x ‚à∑_) (to‚àòfrom xs)

  from‚àòto : ‚àÄ {E} (e : ‚ÑÇ E) ‚Üí from (to e) ‚â° e
  from‚àòto (e :: es) = cong (e ::_) (from‚àòto es)
  from‚àòto ‚àÖ         = refl
 #+end_src
 :End:

** Related Works
   <<sec:related-works>>

   Surprisingly, conflating parameterised and non-parameterised record types
   with termtypes /within a language in a practical fashion/ has not been done before.

   The PackageFormer cite:DBLP:conf/gpce/Al-hassyCK19,alhassy_thesis_proposal
   editor extension reads contexts ---in nearly the same notation as ours---
   enclosed in dedicated comments, then generates and imports Agda code from them
   seamlessly in the background whenever typechecking happens. The framework
   provides a fixed number of meta-primitives for producing arbitrary notions of
   grouping mechanisms, and allows arbitrary Emacs Lisp cite:10.5555/229872 to be
   invoked in the construction of complex grouping mechanisms.

   #+caption: Comparing the in-language Context mechanism with the PackageFormer editor extension
   |                          | PackageFormer      | Contexts             |
   |--------------------------+--------------------+----------------------|
   | Type of Entity           | Preprocessing Tool | Language Library     |
   | Specification Language   | Lisp + Agda        | Agda                 |
   | Well-formedness Checking | ‚ùå               | ‚úì                    |
   | Termination Checking     | ‚úì                  | ‚úì                    |
   | Elaboration Tooltips     | ‚úì                  | ‚ùå                 |
   | Rapid Prototyping        | ‚úì                  | ‚úì (Slower)           |
   | Usability Barrier        | None               | None                 |
   | Extensibility Barrier    | Lisp               | Weak Metaprogramming |

   The PackageFormer paper cite:DBLP:conf/gpce/Al-hassyCK19 provided the syntax
   necessary to form useful grouping mechanisms but was shy on the semantics of
   such constructs.  We have chosen the names of our combinators to closely match
   those of PackageFormer's with an aim of furnishing the mechanism with
   semantics by construing the syntax as semantics-functions; i.e., we have a
   shallow embedding of PackageFormer's constructs as Agda entities:

 #+caption: Contexts as a semantics for PackageFormer constructs
 | Syntax          | Semantics                    |
 |-----------------+------------------------------|
 | ~PackageFormer~   | ~Context~                      |
 | ~:waist~          | ~:waist~                       |
 | ~‚ü¥~               | Forward function application |
 | ~:kind~           | ~:kind~, see below             |
 | ~:level~          | Agda built-in                |
 | ~:alter-elements~ | Agda macros                  |

 # Moreover, it is nearly as readable
 #  and is a library method, rather than an editor extension.

 PackageFormer's ~_:kind_~ meta-primitive dictates how an abstract grouping
 mechanism should be viewed in terms of existing Agda syntax.  However, unlike
 PackageFormer, all of our syntax consists of legitimate Agda terms.
 Since language syntax is being manipulated,
 we are forced to implement the ~_:kind_~ meta-primitive as a macro
 ---further details can be found in Appendix [[sec:kind]].
 #+begin_src agda :tangle no
data Kind : Set where
  ‚Äµrecord    : Kind
  ‚Äµtypeclass : Kind
  ‚Äµdata      : Kind
 #+end_src
 #+latex: \vspace{1em}
 #+begin_center latex
 #+begin_export latex
 \dbox{\parbox{0.47\textwidth}{%

 \texttt{ùíû :kind ‚Äµrecord    = ùíû 0}

 \texttt{ùíû :kind ‚Äµtypeclass = ùíû :waist 1}

 \texttt{ùíû :kind ‚Äµdata      = termtype (ùíû :waist 1)}

 }}
 #+end_export
 #+end_center

 #+latex: \vspace{0.5em}\medbreak\noindent
 We did not expect to be able to define a full Agda implementation of the semantics of
 PackageFormer's
 syntactic constructs due to Agda's rather constrained metaprogramming mechanism.
 However, it is important to note that PackageFormer's Lisp extensibility
 expedites the process of trying out arbitrary grouping mechanisms ---such as
 partial-choices of pushouts and pullbacks along user-provided assignment
 functions--- since it is all either string or symbolic list manipulation. On the
 Agda side, using contexts, it would require substantially more effort due to the
 limited reflection mechanism and the intrusion of the stringent type system.

 :Ignore:
 For PackageFormer, we have implemented its primitives ~:waist~ and ~:kind~, the
 other core meta-primitives are ~_‚ü¥_~ and ~:alter-elements~. The former is a
 syntactic form of function application, ~x ‚ü¥ f ‚âà f x~, which we already have by
 juxtaposition in Agda. The latter, however, is a ‚Äúhammer‚Äù that alters the
 constituents of a grouping mechanism in an arbitrary fashion using the entire
 power of Emacs Lisp ---which includes a large portion of Common Lisp.  We have
 currently presented a partial semantics of PackageFormer's syntactic entities by
 presenting them here as semantic functions on contexts.
 :End:

** Conclusion

 # In addition, the contents of these grouping mechanisms
  #    may be function symbols as well as propositional invariants ---an example
   #   is shown at the end of [[sec:monadic-notation]].

 Starting from the insight that related grouping mechanisms could be unified, we
 showed how related structures can be obtained from a single declaration using a
 practical interface. The resulting framework, based on contexts, still captures
 the familiar record declaration syntax as well as the expressivity of usual
 algebraic datatype declarations ---at the minimal cost of using src_agda[:exports code]{pattern}
 declarations to aide as user-chosen constructor names.  We believe that our
 approach to using contexts as general grouping mechanisms /with/ a practical
 interface are interesting contributions.

 We used the focus on practicality to guide the design of our context interface,
 and provided interpretations both for the rather intuitive ‚Äúcontexts are
 name-type records‚Äù view, and for the novel ‚Äúcontexts are fixed-points‚Äù view for
 termtypes.  In addition, to obtain parameterised variants, we needed to
 explicitly form ‚Äúcontexts whose contents are over a given ambient context‚Äù
 ---e.g., contexts of vector spaces are usually discussed with the understanding
 that there is a context of fields that can be referenced--- which we did using
 the name binding machanism of ~do~-notation. These relationships are summarised in
 the following table.

 #+caption: Contexts embody all kinds of grouping mechanisms
 | Concept            | Concrete Syntax                       | Description            |
 |--------------------+---------------------------------------+------------------------|
 | Context            | =do S ‚Üê Set; s ‚Üê S; n ‚Üê (S ‚Üí S); End=   | ‚Äúname-type pairs‚Äù      |
 |--------------------+---------------------------------------+------------------------|
 | Record Type        | =Œ£ S ‚à∂ Set ‚Ä¢ Œ£ s ‚à∂ S ‚Ä¢ Œ£ n ‚à∂ S ‚Üí S ‚Ä¢ ùüô= | ‚Äúbundled-up data‚Äù      |
 | Function Type      | =Œ† S ‚Ä¢ Œ£ s ‚à∂ S ‚Ä¢ Œ£ n ‚à∂ S ‚Üí S ‚Ä¢ ùüô=       | ‚Äúa type of functions‚Äù  |
 | Type constructor   | =Œª S ‚Ä¢ Œ£ s ‚à∂ S ‚Ä¢ Œ£ n ‚à∂ S ‚Üí S ‚Ä¢ ùüô=       | ‚Äúa function on types‚Äù  |
 | Algebraic datatype | ~data ùîª : Set where s : ùîª; n : ùîª ‚Üí ùîª~   | ‚Äúa descriptive syntax‚Äù |
 #+latex: \FloatBarrier
 # The FloatBarrier stops floats (figures are floats) from jumping over them. I
 # will need to look into passing [tbh] options to figures from org mode further.

 To those interested in exotic ways to group data together ---such as,
 mechanically deriving product types and homomorphism types of theories---
 we offer an interface that is extensible using Agda's reflection mechanism.
 In comparison with, for example, special-purpose preprocessing tools, this
 has obvious advantages in accessibility and semantics.

 To Agda programmers, this offers a standard interface for grouping mechanisms
 that had been sorely missing, with an interface that is so familiar that there
 would be little barrier to its use. In particular, as we have shown, it acts as
 an in-language library for exploiting relationships between free theories and
 data structures.  As we have only presented the high-level definitions of the
 core combinators, leaving the Agda-specific details to the appendices, it is
 also straightforward to translate the library into other dependently-typed
 languages.

** COMMENT Introduction via graphs

 In dependently-typed programming languages, such as Agda
 cite:Norell-2007,agda_overview, there is a tendency to define concepts
 repeatedly along syntactic constructs provided by the language.  In particular,
 one bundles up related data into a record structure, then considers the need to
 expose some of the fields as parameters and so provides a parameterised record
 construction, then for the need to have a description language for terms of
 these record types, one forms an associated algebraic datatype.  For example, we
 may form a type ~Monoid‚ÇÄ~ of monoids, which consists of a type along with an
 operation and some laws, but may want ~Monoid‚ÇÅ M ‚äï~ to speak of monoids over
 /particular/ types ~M~ and particular operations ~‚äï~ ---the latter is handled, say in
 the Haskell standard library, by having isomorphic copies of types for each
 binary operation, such as ~Sum ‚âÖ Prod ‚âÖ Int~ for the classical additive and
 multiplicative monoidal structures on integers.  This is the problem we are
 solving: /How can parameterised records and their associated algebraic datatypes
 be obtained from a core declaration?/

 The humblest notion of a grouping mechanism is described by a pair type ~A √ó B √ó
 C~, usually later values depend on earlier values and so we have the
 dependent-pair type src_agda[:exports code]{Œ£ a ‚à∂ A ‚Ä¢ Œ£ b ‚à∂ B a ‚Ä¢ Œ£ C a b}. The kind of these types is
 ~Set‚ÇÅ~, the type of small types. If we wish to speak of groupings where ~a ‚à∂ A~ is
 /fixed/, then we must lift it from being a /field/ component to being a /parameter/,
 thereby arriving at the /function/ ~Œª a ‚à∂ A ‚Ä¢ Œ£ b ‚à∂ B a ‚Ä¢ Œ£ C a b~ which has /type/ ~Œ† a ‚à∂
 A ‚Ä¢ Set~. Similarly, we may expose ~b~ as a parameter to further indicate the
 possible grouping structure.

 | Grouping Description          |   | Kind                      |
 |-------------------------------+---+---------------------------|
 | =Œ£ a ‚à∂ A ‚Ä¢ Œ£ b ‚à∂ B a ‚Ä¢ Œ£ C a b= |   | ~Set~                       |
 | =Œª a ‚à∂ A ‚Ä¢ Œ£ b ‚à∂ B a ‚Ä¢ Œ£ C a b= |   | ~Œ† a ‚à∂ A ‚Ä¢ Set~             |
 | =Œª a ‚à∂ A ‚Ä¢ Œª b ‚à∂ B a ‚Ä¢ Œ£ C a b= |   | ~Œ† a ‚à∂ A ‚Ä¢ Œ† b ‚à∂ B a ‚Ä¢ Set~ |

 At each step, we ‚Äúpull out‚Äù more information at the kind level; at first we have
 a ~Set~, an opaque grouping mechanism, then we obtain a ~Œ† a ‚à∂ A ‚Ä¢ Set~ which is a
 grouping mechanism that somehow makes use of an ~A~-value.

 1. *Type constructor reification Œ†‚ÜíŒª:* Function /types/ like ~Œ† a ‚à∂ A ‚Ä¢ Set~ cannot be
    applied since they are not functions, so how do we get to ~Œª a : A ‚Ä¢ Set~?

    + Œª-terms are values of Œ†-types, but in general there is no natural
      construction to transform a type into one of its values.

    + Given ~œÑ = Œ† (X : Set) ‚Ä¢ ‚ãØ : Set‚ÇÅ~, we want ~Œ†‚ÜíŒª œÑ = Œª (X : Set) ‚Ä¢ ‚ãØ : Œ† (X :
      Set) ‚Ä¢ Set~; the former's type states it to be a =Set‚ÇÅ=, a grouping mechanism of
      which we know nothing, whereas the latter's type indicates it to be a
      parameterised grouping mechanism. Since ~Œ†‚ÜíŒª œÑ~ can be applied and is thus more
      concrete, we call ~Œ†‚ÜíŒª~ a reification combinator.

 2. *Unbundling* cite:packaging_mathematical_structures:
    How do we go from ~Set~ to ~Œ† a ‚à∂ A ‚Ä¢ Set~?

    A function from function-types to functions-on-types necessarily requires a
    way to pattern match on the possible type constructions in a language.

    Perhaps an example will clarify the issue. The ubiquitous graph structure
    is contravariant in its collection of vertices. Recall that a multi-graph, or
    quiver, is a collection of vertices along with a collection of edges between
    any two vertices; here's the traditional record form:
    #+begin_src agda
Graph  : Context ‚Ñì‚ÇÅ
Graph  = do Vertex ‚Üê Set
            Edges  ‚Üê (Vertex ‚Üí Vertex ‚Üí Set)
            End {‚Ñì‚ÇÄ}
 #+end_src

    Using the record form, it is akward to phrase contravariance, which simply
    ‚Äúrelabels the vertices‚Äù. Even worse, the awkward phrasing only serves to
    ensure certain constraints hold ---which are reified at the value level via
    the uninsightful ~refl~-exivity proof.
    #+begin_src agda
comap‚ÇÄ : ‚àÄ {A B : Set}
      ‚Üí (f : A ‚Üí B)
      ‚Üí Œ£ G ‚à∂ Graph :kind ‚Äµrecord ‚Ä¢ Field 0 G ‚â° B
      ‚Üí Œ£ G ‚à∂ Graph :kind ‚Äµrecord ‚Ä¢ Field 0 G ‚â° A
comap‚ÇÄ {A} {B} f (‚ü® .B , edgs ‚ü© , refl) = (A , (Œª a‚ÇÅ a‚ÇÇ ‚Üí edgs (f a‚ÇÅ) (f a‚ÇÇ)) , tt) , refl
        #+end_src
    /Without redefining graphs/, we can phrase the definition at the typeclass
    level ---i.e., records parameterised by the vertices. This form is not only
    clearer and easier to implement at the value-level, it also makes it clear
    that we are ‚Äúpulling back‚Äù the vertex type and so have also shown graphs are
    closed under reducts.
        #+begin_src agda
-- Way better and less awkward!
comap : ‚àÄ {A B : Set}
     ‚Üí (f : A ‚Üí B)
     ‚Üí (Graph :kind ‚Äµtypeclass) B
     ‚Üí (Graph :kind ‚Äµtypeclass) A
comap f ‚ü® edgs ‚ü©‚ÇÅ = ‚ü® (Œª a‚ÇÅ a‚ÇÇ ‚Üí edgs (f a‚ÇÅ) (f a‚ÇÇ)) ‚ü©‚ÇÅ
    #+end_src

    Later we show how to form ~Context~, its do-notation, and the ~:kind~ mechanism
    which shifts between records, typeclasses, and algebraic datatypes.

    It is important to note that we are using the word ‚Äòtypeclass‚Äô as an
    abbreviation for ‚Äúparameterised record‚Äù. In particular, we have no support
    for the traditional unification algorithm that makes typeclasses and
    canonical structures cite:coq_canonical_tutorial useful for ad-hoc
    polymorphism.
 # eval  : A √ó (A ‚Üí B) ‚Üí B
 # curry : (A √ó B ‚Üí C) ‚Üí (A ‚Üí (B ‚Üí C))
 # #
 # Œ† a ‚à∂ A ‚Ä¢ (Œ† f ‚à∂ (Œ† x ‚à∂ A ‚Ä¢ B x)) ‚Ä¢ B a
 # Œ† f ‚à∂ (Œ† p ‚à∂ (Œ† x ‚à∂ A ‚Ä¢ B x) ‚Ä¢ C p) ‚Ä¢ Œ† a ‚à∂ A ‚Ä¢ Œ† b ‚à∂ B a ‚Ä¢ C (a, b)
 # Œ† f ‚à∂ Set ‚Ä¢ (Œ† x ‚à∂ A ‚Ä¢ Set)

 We shall outline how this can be achieved in dependently-typed languages which
 have support for reflection. Our target language will be Agda, but the ideas
 easily transfer to other languages. In particular, the resulting in-language
 syntax we obtain is rather close to the existing Agda record syntax for
 declarations and Agda constructor tuples for instances.  In the next section, we
 begin by way of a more concrete example of a grouping mechanism, then we take a
 goal-driven approach to building the necessarily apparatus for a clean
 imperative-like declaration notation, then we conclude with a brief discussion
 on how the resulting framework can act as a simple theory for the Agda
 PackageFormer editor extension cite:DBLP:conf/gpce/Al-hassyCK19 ---which solves
 the =Monoid·µ¢= problem mentioned earlier.

 In order to be language-agnostic and underscore the ideas, we shall present the
 core definitions along with Agda-checked examples. Details can be read at the
 following URL in a literate and reproducible fashion
 cite:DBLP:conf/europar/StanisicL14.
 # Details are left to an
 # appendix(?) or can be read below (MA: Haven't decided yet):
 | =https://github.com/alhassy/next-700-module-systems/tree/master/prototype= |

** COMMENT OLD Abstract                                                      :ignore:
   CLOSED: [2020-03-02 Mon 16:00]

   #+begin_abstract org
   Folklore has held that any ‚Äòsemantic unit‚Äô is essentially a type-theoretic
   context ---this includes, for example, records and algebraic datatypes.  We
   provide foundation for such an observation.

   We show that languages with a sufficiently powerful type system and reflection
   mechanism permit a /single declaration interface/ for functions, records, type
   classes, type constructors, and algebraic data types. Moreover, the interface
   is monadic and thus actually practical to use.

   Along the way, we solve the bundling problem: Record fields can be lifted to
   parameters as needed. Traditionally, unbundling a record requires the use of
   transport along propositional equalities, with trivial ~refl~-exivity proofs.
   The ~:waist~ approach presented here removes the boilerplate necessary at the
   type specialisation location as well as at the instance declaration location.

   An application of our setup will be to provide a semantics for the
   PackageFormer editor extension, which realises the aforementioned folklore
   observation by providing users with meta-primitives for making modules to
   allow arbitrary grouping mechanisms to be derived, such as obtaining the
   homomorphism type of a given record.
 #+end_abstract

  \maketitle

* COMMENT Conclusion
** What we have done
** How it is useful to others, now.

** Intro :ignore:
   :PROPERTIES:
   :CUSTOM_ID: conclusion
   :END:

 As already discussed,
 more often than not a module system is an afterthought secondary citizen
 whose primary purpose is to act as a namespace delimiter
 ---e.g., C#'s ~namespace~ construct---
 while relatively more effort is given to their abstraction encapsulation
 counterpart, e.g., C#'s ~class~'es.
 Some languages' module systems blend both namespace management and
 implementation hiding, e.g., as in the Haskell programming language.
 Other languages such as OCaml take modules even further: Not only are modules
 used for namespace organisation and datatype abstraction, but they can also be
 passed around as values for manipulation as if they were nothing special, thereby
 collapsing the distinction between record constructs and organisational constructs.

 The proposed research is to build upon the existing state of module
 systems and develop an extension to a compiler to substantiate our claims,
 and to ultimately discover new semantical relationships between programming
 language constructs in a dependently typed setting with modules as first-class
 citizens. This involves redesigning and enhancing existing module systems
 to take into account dependent types as well as producing rewrite theorems
 to ensure acceptable performance times.

 Intended outcomes include:
   1. A clean module system for DTLs
      + Dependent types blur many distinctions therefore rendering certain
        traditional programming constructs as inter-derivable and so only
        a minimal amount need be supported directly, while the rest can be
        defined within the extended type theory we will be creating.
        Since modules are records, which are
        one-field algebraic data types, and we can form sums of modules, it
        would not be surprising if first-class modules suffice for arbitrary data type
        definitions.

        # syntactic sugar ‚âà pre-processing

   2. /Utility Objectives/: A variety of use-cases contrasting the resulting system with previous
      approaches. In particular, the system should:

      + Reduce amount of ‚Äònoise‚Äô necessary for working with grouping mechanisms in a number of ways.
      + It should be easy and elegant to use and, possibly, to extend.
   3. A module system that enables rather than inhibits (or worse) efficiency.
      + Currently Agda modules, for example, are sugar for extra functional parameters
        and so all implicit sharing in modules is lost at compilation time.
      + Deeply nested, deeply tagged, operations could be costly and so being apply
        to /soundly/ flatten modules and /soundly/ extract operations and results
        is a necessity when speed is concerned ---moreover, this needs to be mechanical and succinct if it is to be useful.
   4. Demonstrate that module features usually requiring meta-programming can be brought
      to the data-value level.
      + Names and types, for example, in a module should be accessible
        and alterable. For example, we can obtain a rig by combining two instances
        of a monoid module where we would rename the fields of one, or both, of them.
      + Thereby relegating abstract syntax tree and programs-as-strings manipulations
        to the edges of the computing environment.

 Most importantly, we intend to implement our theory to obtain
 validation that it ‚Äúworks‚Äù!

 # It goes without saying, these are preliminary goals, as the outcomes are likely to
 # change and evolve multiple times as the research is carried out.
** COMMENT OLD COMMENT Next Steps                              :Maybe_Delete:

   We have shown how a bit of reflection allows us to have a compact, yet
   practical, one-stop-shop notation for records, typeclasses, and algebraic
   data types. There are a number of interesting directions to pursue:

   + How to write a function working homogeneously over one variation and having
     it lift to other variations.
     - Recall the ~comap~ from the introductory section was written over
       ~Graph :kind ‚Äµtypeclass~; how could that particular implementation
        be massaged to work over ~Graph :kind ùìÄ~ for any ~ùìÄ~.

   + The current implementation for deriving termtypes presupposes only one
     carrier set positioned as the first entity in the grouping mechanism.
     - How do we handle multiple carriers or choose a carrier from an arbitrary
       position or by name? =PackageFormer= handles this by comparing names.

   + How do we lift properties or invariants, simple ~‚â°~-types that ‚Äòdefine‚Äô
     a previous entity to be top-level functions in their own right?

 Lots to do, so little time.
* COMMENT appendix marker :ignore:
\appendix

:Musa:
The appendix marker must occur before the section on appendices.
:End:

* COMMENT Appendices
#+latex_header: \usepackage[toc,page]{appendix}

# Appendices are for the details, and so have a smaller font.
#+LaTeX: \setminted[agda]{fontsize=\footnotesize}

Below is the entirety of the Context library discussed in the paper proper.

#+begin_src agda :tangle Context.agda
-- Agda version 2.6.0.1
-- Standard library version 1.2

module Context where
#+end_src

Also included are unit tests, evidence for claims made in the paper proper, and
a brief case-study on graphs to demonstrate some features of the Context library
that are necessary for practical use, such as field projections, but which did
not receive attention in the paper proper.

** Imports
#+begin_src agda :tangle Context.agda
open import Level renaming (_‚äî_ to _‚äç_; suc to ‚Ñìsuc; zero to ‚Ñì‚ÇÄ)
open import Relation.Binary.PropositionalEquality
open import Relation.Nullary

open import Data.Nat
open import Data.Fin  as Fin using (Fin)
open import Data.Maybe  hiding (_>>=_)

open import Data.Bool using (Bool ; true ; false)
open import Data.List as List using (List ; [] ; _‚à∑_ ; _‚à∑ ≥_; sum)

‚Ñì‚ÇÅ   = Level.suc ‚Ñì‚ÇÄ
#+end_src

** Quantifiers Œ†‚à∂‚Ä¢/Œ£‚à∂‚Ä¢ and Products/Sums

  We shall using Z-style quantifier notation cite:10.5555/235337 in which the
  quantifier dummy variables are separated from the body by a large bullet.

  In Agda, we use ~\:~ to obtain the ‚Äúghost colon‚Äù since standard colon ~:~ is an
  Agda operator.

  Even though Agda provides ~‚àÄ (x : œÑ) ‚Üí fx~ as a built-in syntax for Œ†-types, we
  have chosen the Z-style one below to mirror the notation for Œ£-types, which
  Agda provides as src_agda[:exports code]{record} declarations.  In the paper
  proper, in the definition of bind, the subtle shift between Œ£-types and
  Œ†-types is easier to notice when the notations are so similar that only the
  quantifier symbol changes.

#+begin_src agda :tangle Context.agda
open import Data.Empty using (‚ä•)
open import Data.Sum
open import Data.Product
open import Function using (_‚àò_)

Œ£‚à∂‚Ä¢ : ‚àÄ {a b} (A : Set a) (B : A ‚Üí Set b) ‚Üí Set _
Œ£‚à∂‚Ä¢ = Œ£

infix -666 Œ£‚à∂‚Ä¢
syntax Œ£‚à∂‚Ä¢ A (Œª x ‚Üí B) = Œ£ x ‚à∂ A ‚Ä¢ B

Œ†‚à∂‚Ä¢ : ‚àÄ {a b} (A : Set a) (B : A ‚Üí Set b) ‚Üí Set _
Œ†‚à∂‚Ä¢ A B = (x : A) ‚Üí B x

infix -666 Œ†‚à∂‚Ä¢
syntax Œ†‚à∂‚Ä¢ A (Œª x ‚Üí B) = Œ† x ‚à∂ A ‚Ä¢ B

record ‚ä§ {‚Ñì} : Set ‚Ñì where
  constructor tt

ùüô = ‚ä§ {‚Ñì‚ÇÄ}
ùüò = ‚ä•
#+end_src
#+latex: \noindent
** Reflection

We form a few metaprogramming utilities we would have expected to be in the
standard library.

#+begin_src agda :tangle Context.agda
import Data.Unit as Unit
open import Reflection hiding (name; Type) renaming (_>>=_ to _>>=‚Çò_)
#+end_src

Before continuing, there are a few difficulties about Agda's metaprogramming
capabilities that should be mentioned:
1. Even when recursion is on structurally smaller terms of abstract syntax
   trees, termination cannot be automatically deduced. As such, we request Agda
   to believe us that certain definitions are terminating.
2. Since Agda macros cannot be recursive ---possibly due to issues of
   termination--- an idiom we use to define a recursive operation on terms then
   wrap that in Agda's typechecking monad to form macros.
3. Sometimes, no matter how explicit we make certain affairs, macro invocations
   will complain about being unable to infer certain details. As a workaround,
   we type any declaration involving a macro invocation before using it
   ---inference is difficult in dependently-typed settings and even worse in the
   presence of metaprogramming.

*** Single argument application
#+begin_src agda :tangle Context.agda
_app_ : Term ‚Üí Term ‚Üí Term
(def f args) app arg‚Ä≤ = def f (args ‚à∑ ≥ arg (arg-info visible relevant) arg‚Ä≤)
(con f args) app arg‚Ä≤ = con f (args ‚à∑ ≥ arg (arg-info visible relevant) arg‚Ä≤)
{-# CATCHALL #-}
tm app arg‚Ä≤ = tm
#+end_src

#+latex: \noindent
Notice that we maintain existing applications:
| ~quoteTerm (f x) app quoteTerm y~ | ‚âà | ~quoteTerm (f x y)~ |

*** Reify ‚Ñï term encodings as ‚Ñï values
#+begin_src agda :tangle Context.agda
to‚Ñï : Term ‚Üí ‚Ñï
to‚Ñï (lit (nat n)) = n
{-# CATCHALL #-}
to‚Ñï _ = 0
#+end_src
*** The Length of a Term
#+begin_src agda :tangle Context.agda
arg-term : ‚àÄ {‚Ñì} {A : Set ‚Ñì} ‚Üí (Term ‚Üí A) ‚Üí Arg Term ‚Üí A
arg-term f (arg i x) = f x

{-# TERMINATING #-}
length‚Çú : Term ‚Üí ‚Ñï
length‚Çú (var x args)      = 1 + sum (List.map (arg-term length‚Çú ) args)
length‚Çú (con c args)      = 1 + sum (List.map (arg-term length‚Çú ) args)
length‚Çú (def f args)      = 1 + sum (List.map (arg-term length‚Çú ) args)
length‚Çú (lam v (abs s x)) = 1 + length‚Çú x
length‚Çú (pat-lam cs args) = 1 + sum (List.map (arg-term length‚Çú ) args)
length‚Çú (Œ†[ x ‚à∂ A ] Bx)   = 1 + length‚Çú Bx
{-# CATCHALL #-}
-- sort, lit, meta, unknown
length‚Çú t = 0
#+end_src
#+latex: \noindent
Here is an example use:
#+begin_src agda :tangle Context.agda
_ : length‚Çú (quoteTerm (Œ£ x ‚à∂ ‚Ñï ‚Ä¢ x ‚â° x)) ‚â° 10
_ = refl
#+end_src

*** Decreasing de Brujin Indices
<<sec:decreasing-de-brujin>>
Given a quantification ~(‚äï x ‚à∂ œÑ ‚Ä¢ fx)~, its body ~fx~ may refer to a free variable
~x~.  If we decrement all de Bruijn indices ~fx~ contains, then there would be no
reference to ~x~.

#+begin_src agda :tangle Context.agda
var-dec‚ÇÄ : (fuel : ‚Ñï) ‚Üí Term ‚Üí Term
var-dec‚ÇÄ zero t  = t
-- Let's use an ‚Äúimpossible‚Äù term.
var-dec‚ÇÄ (suc n) (var zero args)      = def (quote ‚ä•) []
var-dec‚ÇÄ (suc n) (var (suc x) args)   = var x args
var-dec‚ÇÄ (suc n) (con c args)         = con c (map-Args (var-dec‚ÇÄ n) args)
var-dec‚ÇÄ (suc n) (def f args)         = def f (map-Args (var-dec‚ÇÄ n) args)
var-dec‚ÇÄ (suc n) (lam v (abs s x))    = lam v (abs s (var-dec‚ÇÄ n x))
var-dec‚ÇÄ (suc n) (pat-lam cs args)    = pat-lam cs (map-Args (var-dec‚ÇÄ n) args)
var-dec‚ÇÄ (suc n) (Œ†[ s ‚à∂ arg i A ] B) = Œ†[ s ‚à∂ arg i (var-dec‚ÇÄ n A) ] var-dec‚ÇÄ n B
{-# CATCHALL #-}
-- sort, lit, meta, unknown
var-dec‚ÇÄ n t = t
#+end_src
#+latex: \noindent
In the paper proper, ~var-dec~ was mentioned once under the name ~‚áä~.
#+begin_src agda :tangle Context.agda
var-dec : Term ‚Üí Term
var-dec t = var-dec‚ÇÄ (length‚Çú t) t
#+end_src
#+latex: \noindent
Notice that we made the decision that ~x~, the body of ~(‚äï x ‚Ä¢ x)~, will reduce to ~ùüò~,
the empty type. Indeed, in such a situation the only Debrujin index cannot be
reduced further. Here is an example:
#+begin_src agda :tangle Context.agda
_ : ‚àÄ {x : ‚Ñï} ‚Üí var-dec (quoteTerm x) ‚â° quoteTerm ‚ä•
_ = refl
#+end_src

** Context Monad
#+begin_src agda :tangle Context.agda
Context = Œª ‚Ñì ‚Üí ‚Ñï ‚Üí Set ‚Ñì

infix -1000 ‚Äµ_
‚Äµ_ : ‚àÄ {‚Ñì} ‚Üí Set ‚Ñì ‚Üí Context ‚Ñì
‚Äµ S = Œª _ ‚Üí S

End : ‚àÄ {‚Ñì} ‚Üí Context ‚Ñì
End = ‚Äµ ‚ä§

End‚ÇÄ = End {‚Ñì‚ÇÄ}

_>>=_ : ‚àÄ {a b}
      ‚Üí (Œì : Set a)  -- Main diference
      ‚Üí (Œì ‚Üí Context b)
      ‚Üí Context (a ‚äç b)
(Œì >>= f) ‚Ñï.zero  = Œ£ Œ≥ ‚à∂ Œì ‚Ä¢ f Œ≥ 0
(Œì >>= f) (suc n) = (Œ≥ : Œì) ‚Üí f Œ≥ n
#+end_src

** ‚ü®‚ü© Notation

# As mentioned, grouping mechanisms are declared with ~do ‚Ä¶ End~, and instances of
# them are constructed using ~‚ü® ‚Ä¶ ‚ü©~.
#+begin_src agda :tangle Context.agda
-- Expressions of the form ‚Äú‚ãØ , tt‚Äù may now be written ‚Äú‚ü® ‚ãØ ‚ü©‚Äù
infixr 5 ‚ü® _‚ü©
‚ü®‚ü© : ‚àÄ {‚Ñì} ‚Üí ‚ä§ {‚Ñì}
‚ü®‚ü© = tt

‚ü® : ‚àÄ {‚Ñì} {S : Set ‚Ñì} ‚Üí S ‚Üí S
‚ü® s = s

_‚ü© : ‚àÄ {‚Ñì} {S : Set ‚Ñì} ‚Üí S ‚Üí S √ó ‚ä§ {‚Ñì}
s ‚ü© = s , tt
#+end_src

** DynamicSystem Context
#+begin_src agda  :tangle Context_examples.agda
DynamicSystem : Context (‚Ñìsuc Level.zero)
DynamicSystem = do X ‚Üê Set
                   z ‚Üê X
                   s ‚Üê (X ‚Üí X)
                   End {Level.zero}

-- Records with ùìÉ-Parameters, ùìÉ : 0..3
A B C D : Set‚ÇÅ
A = DynamicSystem 0 -- Œ£ X ‚à∂ Set  ‚Ä¢ Œ£ z ‚à∂ X  ‚Ä¢ Œ£ s ‚à∂ X ‚Üí X  ‚Ä¢ ‚ä§
B = DynamicSystem 1 --  (X ‚à∂ Set) ‚Üí Œ£ z ‚à∂ X  ‚Ä¢ Œ£ s ‚à∂ X ‚Üí X  ‚Ä¢ ‚ä§
C = DynamicSystem 2 --  (X ‚à∂ Set)    (z ‚à∂ X) ‚Üí Œ£ s ‚à∂ X ‚Üí X  ‚Ä¢ ‚ä§
D = DynamicSystem 3 --  (X ‚à∂ Set)    (z ‚à∂ X) ‚Üí  (s ‚à∂ X ‚Üí X) ‚Üí ‚ä§

_ : A ‚â° (Œ£ X ‚à∂ Set  ‚Ä¢ Œ£ z ‚à∂ X  ‚Ä¢ Œ£ s ‚à∂ (X ‚Üí X)  ‚Ä¢ ‚ä§) ; _ = refl
_ : B ‚â° (Œ† X ‚à∂ Set  ‚Ä¢ Œ£ z ‚à∂ X  ‚Ä¢ Œ£ s ‚à∂ (X ‚Üí X)  ‚Ä¢ ‚ä§) ; _ = refl
_ : C ‚â° (Œ† X ‚à∂ Set  ‚Ä¢ Œ† z ‚à∂ X  ‚Ä¢ Œ£ s ‚à∂ (X ‚Üí X)  ‚Ä¢ ‚ä§) ; _ = refl
_ : D ‚â° (Œ† X ‚à∂ Set  ‚Ä¢ Œ† z ‚à∂ X  ‚Ä¢ Œ† s ‚à∂ (X ‚Üí X)  ‚Ä¢ ‚ä§) ; _ = refl

stability : ‚àÄ {n} ‚Üí   DynamicSystem (3 + n)
                   ‚â° DynamicSystem  3
stability = refl

B-is-empty : ¬¨ B
B-is-empty b = proj‚ÇÅ( b ‚ä•)

ùí©‚ÇÄ : DynamicSystem 0
ùí©‚ÇÄ = ‚Ñï , 0 , suc , tt

ùí© : DynamicSystem 0
ùí© = ‚ü® ‚Ñï , 0 , suc ‚ü©

B-on-‚Ñï : Set
B-on-‚Ñï = let X = ‚Ñï in Œ£ z ‚à∂ X  ‚Ä¢ Œ£ s ‚à∂ (X ‚Üí X)  ‚Ä¢ ‚ä§

ex : B-on-‚Ñï
ex = ‚ü® 0 , suc ‚ü©
#+end_src

** Œ†‚ÜíŒª
   <<sec:pi-to-lambda>>
#+begin_src agda :tangle Context.agda
Œ†‚ÜíŒª-helper : Term ‚Üí Term
Œ†‚ÜíŒª-helper (pi  a b)         = lam visible b
Œ†‚ÜíŒª-helper (lam a (abs x y)) = lam a (abs x (Œ†‚ÜíŒª-helper y))
{-# CATCHALL #-}
Œ†‚ÜíŒª-helper x = x

macro
  Œ†‚ÜíŒª : Term ‚Üí Term ‚Üí TC Unit.‚ä§
  Œ†‚ÜíŒª tm goal = normalise tm >>=‚Çò Œª tm‚Ä≤ ‚Üí unify (Œ†‚ÜíŒª-helper tm‚Ä≤) goal
#+end_src

** ~id·µ¢‚Çä‚ÇÅ ‚âà Œ†‚ÜíŒª id·µ¢~
<<sec:identity-funcs>>
   #+begin_src agda  :tangle Context_examples.agda
_ : id‚ÇÅ ‚â° Œ†‚ÜíŒª id‚ÇÄ
_ = refl

_ : id‚ÇÇ ‚â° Œ†‚ÜíŒª id‚ÇÅ
_ = refl
#+end_src
** ~_:waist_~
<<sec:waist>>
   #+begin_src agda :tangle Context.agda
waist-helper : ‚Ñï ‚Üí Term ‚Üí Term
waist-helper zero t    = t
waist-helper (suc n) t = waist-helper n (Œ†‚ÜíŒª-helper t)

macro
  _:waist_ : Term ‚Üí Term ‚Üí Term ‚Üí TC Unit.‚ä§
  _:waist_ t ùìÉ goal =      normalise (t app ùìÉ)
                      >>=‚Çò Œª t‚Ä≤ ‚Üí unify (waist-helper (to‚Ñï ùìÉ) t‚Ä≤) goal
#+end_src

** DynamicSystem :waist ùíæ
#+begin_src agda  :tangle Context_examples.agda
A‚Ä≤ : Set‚ÇÅ
B‚Ä≤ : ‚àÄ (X : Set) ‚Üí Set
C‚Ä≤ : ‚àÄ (X : Set) (x : X) ‚Üí Set
D‚Ä≤ : ‚àÄ (X : Set) (x : X) (s : X ‚Üí X) ‚Üí Set

A‚Ä≤ = DynamicSystem :waist 0
B‚Ä≤ = DynamicSystem :waist 1
C‚Ä≤ = DynamicSystem :waist 2
D‚Ä≤ = DynamicSystem :waist 3

ùí©‚Å∞ : A‚Ä≤
ùí©‚Å∞ = ‚ü® ‚Ñï , 0 , suc ‚ü©

ùí©¬π : B‚Ä≤ ‚Ñï
ùí©¬π = ‚ü® 0 , suc ‚ü©

ùí©¬≤ : C‚Ä≤ ‚Ñï 0
ùí©¬≤ = ‚ü® suc ‚ü©

ùí©¬≥ : D‚Ä≤ ‚Ñï 0 suc
ùí©¬≥ = ‚ü®‚ü©
#+end_src
#+latex: \noindent
It may be the case that ~Œì 0 ‚â° Œì :waist 0~ for every context Œì.
#+begin_src agda  :tangle Context_examples.agda
_ : DynamicSystem 0 ‚â° DynamicSystem :waist 0
_ = refl
#+end_src

** Field projections
#+begin_src agda :tangle Context.agda
Field‚ÇÄ : ‚Ñï ‚Üí Term ‚Üí Term
Field‚ÇÄ zero c    = def (quote proj‚ÇÅ) (arg (arg-info visible relevant) c ‚à∑ [])
Field‚ÇÄ (suc n) c = Field‚ÇÄ n (def (quote proj‚ÇÇ) (arg (arg-info visible relevant) c ‚à∑ []))

macro
  Field : ‚Ñï ‚Üí Term ‚Üí Term ‚Üí TC Unit.‚ä§
  Field n t goal = unify goal (Field‚ÇÄ n t)
#+end_src

An example usage can be found below in the setting of graphs.

** Termtypes

Using the guiding calculation outlined in the paper proper
we shall form ~D·µ¢~ for each stage in the calculation.
*** Stage 1: Records
#+begin_src agda  :tangle Context_examples.agda
D‚ÇÅ = DynamicSystem 0

1-records : D‚ÇÅ ‚â° (Œ£ X ‚à∂ Set ‚Ä¢ Œ£ z ‚à∂ X ‚Ä¢ Œ£ s ‚à∂ (X ‚Üí X) ‚Ä¢ ‚ä§)
1-records = refl
#+end_src
*** Stage 2: Parameterised Records
#+begin_src agda  :tangle Context_examples.agda
D‚ÇÇ = DynamicSystem :waist 1

2-funcs : D‚ÇÇ ‚â° (Œª (X : Set) ‚Üí Œ£ z ‚à∂ X ‚Ä¢ Œ£ s ‚à∂ (X ‚Üí X) ‚Ä¢ ‚ä§)
2-funcs = refl
#+end_src

*** Stage 3: Sources
<<sec:sources>>
Let's begin with an example to motivate the definition of ~sources~.
    #+begin_src agda  :tangle Context.agda
_ :   quoteTerm (‚àÄ {x : ‚Ñï} ‚Üí ‚Ñï)
    ‚â° pi (arg (arg-info hidden relevant) (quoteTerm ‚Ñï)) (abs "x" (quoteTerm ‚Ñï))
_ = refl
#+end_src
#+latex: \noindent
We now form two sources-helper utilities, although we suspect they could be
combined into one function.
#+begin_src agda :tangle Context.agda
sources‚ÇÄ : Term ‚Üí Term
-- Otherwise:
sources‚ÇÄ (Œ†[ a ‚à∂ arg i A ] (Œ†[ b ‚à∂ arg _ Ba ] Cab)) =
    def (quote _√ó_) (vArg A
                    ‚à∑ vArg (def (quote _√ó_)
                                (vArg (var-dec Ba)
                                     ‚à∑ vArg (var-dec (var-dec (sources‚ÇÄ Cab))) ‚à∑ []))
                    ‚à∑ [])
sources‚ÇÄ (Œ†[ a ‚à∂ arg (arg-info hidden _) A ] Ba) = quoteTerm ùüò
sources‚ÇÄ (Œ†[ x ‚à∂ arg i A ] Bx) = A
{-# CATCHALL #-}
-- sort, lit, meta, unknown
sources‚ÇÄ t = quoteTerm ùüô

{-# TERMINATING #-}
sources‚ÇÅ : Term ‚Üí Term
sources‚ÇÅ (Œ†[ a ‚à∂ arg (arg-info hidden _) A ] Ba) = quoteTerm ùüò
sources‚ÇÅ (Œ†[ a ‚à∂ arg i A ] (Œ†[ b ‚à∂ arg _ Ba ] Cab)) = def (quote _√ó_) (vArg A ‚à∑
  vArg (def (quote _√ó_) (vArg (var-dec Ba)
                             ‚à∑ vArg (var-dec (var-dec (sources‚ÇÄ Cab))) ‚à∑ [])) ‚à∑ [])
sources‚ÇÅ (Œ†[ x ‚à∂ arg i A ] Bx) = A
sources‚ÇÅ (def (quote Œ£) (‚Ñì‚ÇÅ ‚à∑ ‚Ñì‚ÇÇ ‚à∑ œÑ ‚à∑ body))
    = def (quote Œ£) (‚Ñì‚ÇÅ ‚à∑ ‚Ñì‚ÇÇ ‚à∑ map-Arg sources‚ÇÄ œÑ ‚à∑ List.map (map-Arg sources‚ÇÅ) body)
-- This function introduces ùüôs, so let's drop any old occurances a la ùüò.
sources‚ÇÅ (def (quote ‚ä§) _) = def (quote ùüò) []
sources‚ÇÅ (lam v (abs s x))     = lam v (abs s (sources‚ÇÅ x))
sources‚ÇÅ (var x args) = var x (List.map (map-Arg sources‚ÇÅ) args)
sources‚ÇÅ (con c args) = con c (List.map (map-Arg sources‚ÇÅ) args)
sources‚ÇÅ (def f args) = def f (List.map (map-Arg sources‚ÇÅ) args)
sources‚ÇÅ (pat-lam cs args) = pat-lam cs (List.map (map-Arg sources‚ÇÅ) args)
{-# CATCHALL #-}
-- sort, lit, meta, unknown
sources‚ÇÅ t = t
#+end_src
#+latex: \noindent
We now form the macro and some unit tests.
#+begin_src agda :tangle Context.agda
macro
  sources : Term ‚Üí Term ‚Üí TC Unit.‚ä§
  sources tm goal = normalise tm >>=‚Çò Œª tm‚Ä≤ ‚Üí unify (sources‚ÇÅ tm‚Ä≤) goal

_ : sources (‚Ñï ‚Üí Set) ‚â° ‚Ñï
_ = refl

_ : sources (Œ£ x ‚à∂ (‚Ñï ‚Üí Fin 3) ‚Ä¢ ‚Ñï) ‚â° (Œ£ x ‚à∂ ‚Ñï ‚Ä¢ ‚Ñï)
_ = refl

_ : ‚àÄ {‚Ñì : Level} {A B C : Set}
  ‚Üí sources (Œ£ x ‚à∂ (A ‚Üí B) ‚Ä¢ C) ‚â° (Œ£ x ‚à∂ A ‚Ä¢ C)
_ = refl

_ : sources (Fin 1 ‚Üí Fin 2 ‚Üí Fin 3) ‚â° (Œ£ _ ‚à∂ Fin 1 ‚Ä¢ Fin 2 √ó ùüô)
_ = refl

_ : sources (Œ£ f ‚à∂ (Fin 1 ‚Üí Fin 2 ‚Üí Fin 3 ‚Üí Fin 4) ‚Ä¢ Fin 5)
  ‚â° (Œ£ f ‚à∂ (Fin 1 √ó Fin 2 √ó Fin 3) ‚Ä¢ Fin 5)
_ = refl

_ : ‚àÄ {A B C : Set} ‚Üí sources (A ‚Üí B ‚Üí C) ‚â° (A √ó B √ó ùüô)
_ = refl

_ : ‚àÄ {A B C D E : Set} ‚Üí sources (A ‚Üí B ‚Üí C ‚Üí D ‚Üí E)
                        ‚â° Œ£ A (Œª _ ‚Üí Œ£ B (Œª _ ‚Üí Œ£ C (Œª _ ‚Üí Œ£ D (Œª _ ‚Üí ‚ä§))))
_ = refl
#+end_src
#+latex: \noindent
Design decision: Types starting with implicit arguments are /invariants/, not /constructors/.
#+begin_src agda :tangle Context.agda
-- one implicit
_ : sources (‚àÄ {x : ‚Ñï} ‚Üí x ‚â° x) ‚â° ùüò
_ = refl

-- multiple implicits
_ : sources (‚àÄ {x y z : ‚Ñï} ‚Üí x ‚â° y) ‚â° ùüò
_ = refl
#+end_src
#+latex: \noindent
The third stage can now be formed.
#+begin_src agda  :tangle Context_examples.agda
D‚ÇÉ = sources D‚ÇÇ

3-sources : D‚ÇÉ ‚â° Œª (X : Set) ‚Üí Œ£ z ‚à∂ ùüô ‚Ä¢ Œ£ s ‚à∂ X ‚Ä¢ ùüò
3-sources = refl
#+end_src
*** Stage 4: ~Œ£‚Üí‚äé~ --Replacing Products with Sums
    <<sec:sigma-to-sum>>
#+begin_src agda :tangle Context.agda
{-# TERMINATING #-}
Œ£‚Üí‚äé‚ÇÄ : Term ‚Üí Term
Œ£‚Üí‚äé‚ÇÄ (def (quote Œ£) (ùíΩ‚ÇÅ ‚à∑ ùíΩ‚ÇÄ ‚à∑ arg i A ‚à∑ arg i‚ÇÅ (lam v (abs s x)) ‚à∑ []))
  =  def (quote _‚äé_) (ùíΩ‚ÇÅ ‚à∑ ùíΩ‚ÇÄ ‚à∑ arg i A ‚à∑ vArg (Œ£‚Üí‚äé‚ÇÄ (var-dec x)) ‚à∑ [])
-- Interpret ‚ÄúEnd‚Äù in do-notation to be an empty, impossible, constructor.
Œ£‚Üí‚äé‚ÇÄ (def (quote ‚ä§) _) = def (quote ‚ä•) []
 -- Walk under Œª's and Œ†'s.
Œ£‚Üí‚äé‚ÇÄ (lam v (abs s x)) = lam v (abs s (Œ£‚Üí‚äé‚ÇÄ x))
Œ£‚Üí‚äé‚ÇÄ (Œ†[ x ‚à∂ A ] Bx) = Œ†[ x ‚à∂ A ] Œ£‚Üí‚äé‚ÇÄ Bx
{-# CATCHALL #-}
Œ£‚Üí‚äé‚ÇÄ t = t

macro
  Œ£‚Üí‚äé : Term ‚Üí Term ‚Üí TC Unit.‚ä§
  Œ£‚Üí‚äé tm goal = normalise tm >>=‚Çò Œª tm‚Ä≤ ‚Üí unify (Œ£‚Üí‚äé‚ÇÄ tm‚Ä≤) goal
#+end_src
Unit tests:
#+begin_src agda :tangle Context.agda
_ : Œ£‚Üí‚äé (Œ† X ‚à∂ Set ‚Ä¢ (X ‚Üí X))     ‚â° (Œ† X ‚à∂ Set ‚Ä¢ (X ‚Üí X)); _ = refl
_ : Œ£‚Üí‚äé (Œ† X ‚à∂ Set ‚Ä¢ Œ£ s ‚à∂ X ‚Ä¢ X) ‚â° (Œ† X ‚à∂ Set ‚Ä¢ X ‚äé X)  ; _ = refl
_ : Œ£‚Üí‚äé (Œ† X ‚à∂ Set ‚Ä¢ Œ£ s ‚à∂ (X ‚Üí X) ‚Ä¢ X) ‚â° (Œ† X ‚à∂ Set ‚Ä¢ (X ‚Üí X) ‚äé X)  ; _ = refl
_ : Œ£‚Üí‚äé (Œ† X ‚à∂ Set ‚Ä¢ Œ£ z ‚à∂ X ‚Ä¢ Œ£ s ‚à∂ (X ‚Üí X) ‚Ä¢ ‚ä§ {‚Ñì‚ÇÄ}) ‚â° (Œ† X ‚à∂ Set ‚Ä¢ X ‚äé (X ‚Üí X) ‚äé ‚ä•)
_ = refl
#+end_src
#+latex: \vspace{0.5em}
#+begin_src agda  :tangle Context_examples.agda
D‚ÇÑ = Œ£‚Üí‚äé D‚ÇÉ

4-unions : D‚ÇÑ ‚â° Œª X ‚Üí ùüô ‚äé X ‚äé ùüò
4-unions = refl
#+end_src

# See above regarding macro ‚Äúvar-dec‚Äù
# #
# What happens if a occurs in Ba? Point out that in the cases that work
# or are relevant, a does not occur in Ba, and the elimination of one binder
# makes one application of \downarrow\downarrow necessary.

*** Stage 5: Fixpoint and proof that ~ùîª ‚âÖ ‚Ñï~

    Since we want to define algebraic data-types as fixed-points, we are led
    inexorably to using a recursive type that fails to be positive.

    #+begin_src agda :tangle Context.agda
{-# NO_POSITIVITY_CHECK #-}
data Fix {‚Ñì} (F : Set ‚Ñì ‚Üí Set ‚Ñì) : Set ‚Ñì where
  Œº : F (Fix F) ‚Üí Fix F
#+end_src

#+begin_src agda  :tangle Context_examples.agda
module termtype[DynamicSystem]‚âÖ‚Ñï where

  ùîª = Fix D‚ÇÑ

  -- Pattern synonyms for more compact presentation
  pattern zeroD  = Œº (inj‚ÇÅ tt)       -- : ùîª
  pattern sucD e = Œº (inj‚ÇÇ (inj‚ÇÅ e)) -- : ùîª ‚Üí ùîª

  to : ùîª ‚Üí ‚Ñï
  to zeroD    = 0
  to (sucD x) = suc (to x)

  from : ‚Ñï ‚Üí ùîª
  from zero    = zeroD
  from (suc n) = sucD (from n)

  to‚àòfrom : ‚àÄ n ‚Üí to (from n) ‚â° n
  to‚àòfrom zero    = refl
  to‚àòfrom (suc n) = cong suc (to‚àòfrom n)

  from‚àòto : ‚àÄ d ‚Üí from (to d) ‚â° d
  from‚àòto zeroD    = refl
  from‚àòto (sucD x) = cong sucD (from‚àòto x)
#+end_src

*** ~termtype~ and ~Inj~ macros
<<sec:inj-macro>>

We summarise the stages together into one macro:
~‚Äútermtype : UnaryFunctor ‚Üí Type‚Äù~.
#+begin_src agda :tangle Context.agda
macro
  termtype : Term ‚Üí Term ‚Üí TC Unit.‚ä§
  termtype tm goal =
                normalise tm
           >>=‚Çò Œª tm‚Ä≤ ‚Üí unify goal (def (quote Fix) ((vArg (Œ£‚Üí‚äé‚ÇÄ (sources‚ÇÅ tm‚Ä≤))) ‚à∑ []))
 #+end_src
#+latex: \noindent
It is interesting to note that in place of ~pattern~ clauses, say for languages
that do not support them, we would resort to ‚Äúfancy injections‚Äù.
#+begin_src agda :tangle Context.agda
Inj‚ÇÄ : ‚Ñï ‚Üí Term ‚Üí Term
Inj‚ÇÄ zero c    = con (quote inj‚ÇÅ) (arg (arg-info visible relevant) c ‚à∑ [])
Inj‚ÇÄ (suc n) c = con (quote inj‚ÇÇ) (vArg (Inj‚ÇÄ n c) ‚à∑ [])

-- Duality!
-- ùíæ-th projection: proj‚ÇÅ ‚àò (proj‚ÇÇ ‚àò ‚ãØ ‚àò proj‚ÇÇ)
-- ùíæ-th injection:  (inj‚ÇÇ ‚àò ‚ãØ ‚àò inj‚ÇÇ) ‚àò inj‚ÇÅ

macro
  Inj : ‚Ñï ‚Üí Term ‚Üí Term ‚Üí TC Unit.‚ä§
  Inj n t goal = unify goal ((con (quote Œº) []) app (Inj‚ÇÄ n t))
#+end_src
#+latex: \noindent
With this alternative, we regain the ‚Äúuser chosen constructor names‚Äù for ~ùîª~:
:Hide:
#+begin_src agda  :tangle Context_examples.agda
ùîª = termtype (DynamicSystem :waist 1)
    #+end_src
:End:
    #+begin_src agda :tangle Context_examples.agda
startD : ùîª
startD = Inj 0 (tt {‚Ñì‚ÇÄ})

nextD‚Ä≤ : ùîª ‚Üí ùîª
nextD‚Ä≤ d = Inj 1 d
 #+end_src

** The ~_:kind_~ meta-primitive
<<sec:kind>>
   #+begin_src agda :tangle Context.agda
data Kind : Set where
  ‚Äµrecord    : Kind
  ‚Äµtypeclass : Kind
  ‚Äµdata      : Kind

macro
  _:kind_ : Term ‚Üí Term ‚Üí Term ‚Üí TC Unit.‚ä§
  _:kind_ t (con (quote ‚Äµrecord) _)    goal = normalise (t app (quoteTerm 0))
                      >>=‚Çò Œª t‚Ä≤ ‚Üí unify (waist-helper 0 t‚Ä≤) goal
  _:kind_ t (con (quote ‚Äµtypeclass) _) goal = normalise (t app (quoteTerm 1))
                      >>=‚Çò Œª t‚Ä≤ ‚Üí unify (waist-helper 1 t‚Ä≤) goal
  _:kind_ t (con (quote ‚Äµdata) _) goal = normalise (t app (quoteTerm 1))
                      >>=‚Çò Œª t‚Ä≤ ‚Üí normalise (waist-helper 1 t‚Ä≤)
                      >>=‚Çò Œª t‚Ä≥ ‚Üí unify goal (def (quote Fix)
                                                  ((vArg (Œ£‚Üí‚äé‚ÇÄ (sources‚ÇÅ t‚Ä≥))) ‚à∑ []))
  _:kind_ t _ goal = unify t goal
#+end_src

#+latex: \noindent
Informally, ~_:kind_~ behaves as follows:
#+begin_src agda :tangle no
ùíû :kind ‚Äµrecord    = ùíû :waist 0
ùíû :kind ‚Äµtypeclass = ùíû :waist 1
ùíû :kind ‚Äµdata      = termtype (ùíû :waist 1)
#+end_src

** COMMENT Example: ~termtype PointedSet ‚âÖ ùüô~
   #+begin_src agda  :tangle Context_examples.agda
One  : Context (‚Ñìsuc ‚Ñì‚ÇÄ)
One      = do Carrier ‚Üê Set ‚Ñì‚ÇÄ
              point  ‚Üê Carrier
              End {‚Ñì‚ÇÄ}

ùïÜùïüùïñ : Set
ùïÜùïüùïñ = termtype (One :waist 1)

view‚ÇÅ : ùïÜùïüùïñ ‚Üí ùüô
view‚ÇÅ emptyM = tt
#+end_src
** COMMENT The Termtype of Graphs is Vertex Pairs
From simple graphs (relations) to a syntax about them:
One describes a simple graph by presenting edges as pairs of vertices!
#+begin_src agda  :tangle Context_examples.agda
PointedOver‚ÇÇ  : Set ‚Üí Context (‚Ñìsuc ‚Ñì‚ÇÄ)
PointedOver‚ÇÇ Œû    = do Carrier ‚Üê Set ‚Ñì‚ÇÄ
                       relation ‚Üê (Œû ‚Üí Œû ‚Üí Carrier)
                       End {‚Ñì‚ÇÄ}

‚Ñô‚ÇÇ : Set ‚Üí Set
‚Ñô‚ÇÇ X = termtype (PointedOver‚ÇÇ X :waist 1)

pattern _‚áå_ x y = Œº (inj‚ÇÅ (x , y , tt))

view‚ÇÇ : ‚àÄ {X} ‚Üí ‚Ñô‚ÇÇ X ‚Üí X √ó X
view‚ÇÇ (x ‚áå y) = x , y
#+end_src

** COMMENT No ‚Äòconstants‚Äô, whence a type of inifinitely branching terms
#+begin_src agda :tangle Context.agda
PointedOver‚ÇÉ  : Set ‚Üí Context (‚Ñì‚ÇÄ)
PointedOver‚ÇÉ Œû    = do relation ‚Üê (Œû ‚Üí Œû ‚Üí Œû)
                       End {‚Ñì‚ÇÄ}

‚Ñô‚ÇÉ : Set
‚Ñô‚ÇÉ = termtype (Œª X ‚Üí PointedOver‚ÇÉ X 0)
#+end_src

** COMMENT ‚Ñô‚ÇÇ again!
#+begin_src agda :tangle Context.agda
PointedOver‚ÇÑ  : Context (‚Ñìsuc ‚Ñì‚ÇÄ)
PointedOver‚ÇÑ       = do Œû ‚Üê Set
                        Carrier ‚Üê Set ‚Ñì‚ÇÄ
                        relation ‚Üê (Œû ‚Üí Œû ‚Üí Carrier)
                        End {‚Ñì‚ÇÄ}

-- The current implementation of ‚Äútermtype‚Äù only allows for one ‚ÄúSet‚Äù in the body.
-- So we lift both out; thereby regaining ‚Ñô‚ÇÇ!

‚Ñô‚ÇÑ : Set ‚Üí Set
‚Ñô‚ÇÑ X = termtype ((PointedOver‚ÇÑ :waist 2) X)

pattern _‚áå_ x y = Œº (inj‚ÇÅ (x , y , tt))

case‚ÇÑ : ‚àÄ {X} ‚Üí ‚Ñô‚ÇÑ X ‚Üí Set‚ÇÅ
case‚ÇÑ (x ‚áå y) = Set

-- Claim: Mention in paper.
--
--    P‚ÇÅ : Set ‚Üí Context = Œª Œû ‚Üí do ‚ãØ End
-- ‚âÖ  P‚ÇÇ :waist 1
-- where P‚ÇÇ : Context = do Œû ‚Üê Set; ‚ãØ End
#+end_src

** COMMENT ‚Ñô‚ÇÑ again -- indexed unary algebras; i.e., ‚Äúactions‚Äù
#+begin_src agda :tangle Context.agda
PointedOver‚Çà  : Context (‚Ñìsuc ‚Ñì‚ÇÄ)
PointedOver‚Çà       = do Index     ‚Üê Set
                        Carrier   ‚Üê Set
                        Operation ‚Üê (Index ‚Üí Carrier ‚Üí Carrier)
                        End {‚Ñì‚ÇÄ}

‚Ñô‚Çà : Set ‚Üí Set
‚Ñô‚Çà X = termtype ((PointedOver‚Çà :waist 2) X)

pattern _¬∑_ x y = Œº (inj‚ÇÅ (x , y , tt))

view‚Çà : ‚àÄ {I} ‚Üí ‚Ñô‚Çà I ‚Üí Set‚ÇÅ
view‚Çà (i ¬∑ e) = Set
#+end_src

** COMMENT Other experiments
#+begin_src agda :tangle Context.agda
{- Yellow:

PointedOver‚ÇÖ  : Context (‚Ñìsuc ‚Ñì‚ÇÄ)
PointedOver‚ÇÖ   = do One ‚Üê Set
                    Two ‚Üê Set
                    Three ‚Üê (One ‚Üí Two ‚Üí Set)
                    End {‚Ñì‚ÇÄ}

‚Ñô‚ÇÖ : Set ‚Üí Set‚ÇÅ
‚Ñô‚ÇÖ X = termtype ((PointedOver‚ÇÖ :waist 2) X)
-- Fix (Œª Two ‚Üí One √ó Two)

pattern _‚à∑‚ÇÖ_ x y = Œº (inj‚ÇÅ (x , y , tt))

case‚ÇÖ : ‚àÄ {X} ‚Üí ‚Ñô‚ÇÖ X ‚Üí Set‚ÇÅ
case‚ÇÖ (x ‚à∑‚ÇÖ xs) = Set

-}

--------------------------------------------------------------------------------

{-- Dependent sums

PointedOver‚ÇÜ  : Context ‚Ñì‚ÇÅ
PointedOver‚ÇÜ = do Sort ‚Üê Set
                  Carrier ‚Üê (Sort ‚Üí Set)
                  End {‚Ñì‚ÇÄ}

‚Ñô‚ÇÜ : Set‚ÇÅ
‚Ñô‚ÇÜ = termtype ((PointedOver‚ÇÜ :waist 1) )
-- Fix (Œª X ‚Üí X)

-}

--------------------------------------------------------------------------------

-- Distinuighed subset algebra

open import Data.Bool renaming (Bool to ùîπ)

{-
PointedOver‚Çá  : Context (‚Ñìsuc ‚Ñì‚ÇÄ)
PointedOver‚Çá       = do Index ‚Üê Set
                        Is    ‚Üê (Index ‚Üí ùîπ)
                        End {‚Ñì‚ÇÄ}

-- The current implementation of ‚Äútermtype‚Äù only allows for one ‚ÄúSet‚Äù in the body.
-- So we lift both out; thereby regaining ‚Ñô‚ÇÇ!

‚Ñô‚Çá : Set ‚Üí Set
‚Ñô‚Çá X = termtype (Œª (_ : Set) ‚Üí (PointedOver‚Çá :waist 1) X)
-- ‚Ñô‚ÇÅ X ‚âÖ X

pattern _‚áå_ x y = Œº (inj‚ÇÅ (x , y , tt))

case‚Çá : ‚àÄ {X} ‚Üí ‚Ñô‚Çá X ‚Üí Set
case‚Çá {X} (Œº (inj‚ÇÅ x)) = X

-}

--------------------------------------------------------------------------------

{-
PointedOver‚Çâ  : Context ‚Ñì‚ÇÅ
PointedOver‚Çâ       = do Carrier ‚Üê Set
                        End {‚Ñì‚ÇÄ}

-- The current implementation of ‚Äútermtype‚Äù only allows for one ‚ÄúSet‚Äù in the body.
-- So we lift both out; thereby regaining ‚Ñô‚ÇÇ!

‚Ñô‚Çâ : Set
‚Ñô‚Çâ = termtype (Œª (X : Set) ‚Üí (PointedOver‚Çâ :waist 1) X)
-- ‚âÖ ùüò ‚âÖ Fix (Œª X ‚Üí ùüò)
-}

#+end_src
** COMMENT ~Fix Id~
#+begin_src agda :tangle Context.agda
PointedOver‚ÇÅ‚ÇÄ  : Context ‚Ñì‚ÇÅ
PointedOver‚ÇÅ‚ÇÄ       = do Carrier ‚Üê Set
                         next    ‚Üê (Carrier ‚Üí Carrier)
                         End {‚Ñì‚ÇÄ}

-- The current implementation of ‚Äútermtype‚Äù only allows for one ‚ÄúSet‚Äù in the body.
-- So we lift both out; thereby regaining ‚Ñô‚ÇÇ!

‚Ñô‚ÇÅ‚ÇÄ : Set
‚Ñô‚ÇÅ‚ÇÄ = termtype (Œª (X : Set) ‚Üí (PointedOver‚ÇÅ‚ÇÄ :waist 1) X)
-- Fix (Œª X ‚Üí X), which does not exist.

#+end_src

** TODO COMMENT What about the meta-language's parameters?

 Besides ~:waist~, another way to introduce parameters into a context grouping
 mechanism is to use the language's existing utility of parameterising a context
 by another type ---as was done earlier in ~PointedOver~.

 For example, a pointed set needn't necessarily be termined with ~End~.
 #+begin_src agda
PointedSet : Context ‚Ñì‚ÇÅ
PointedSet = do Carrier ‚Üê Set
                point   ‚Üê Carrier
                End {‚Ñì‚ÇÅ}
 #+end_src
 We instead form a grouping consisting of a single type and a value of that type,
 along with an instance of the parameter type =Œû=.
 #+begin_src agda
PointedPF : (Œû : Set‚ÇÅ) ‚Üí Context ‚Ñì‚ÇÅ
PointedPF Œû = do Carrier ‚Üê Set
                 point   ‚Üê Carrier
                 ‚Äµ Œû
 #+end_src
 Clearly ~PointedPF ùüô ‚âà PointedSet~, so we have a more generic grouping mechanism.
 The natural next step is to consider other parameters such as ~PointedSet~
 in-place of =Œû=.
 :AgdaCheckedEvidence:
 #+begin_src agda
_ : ‚àÄ {n} ‚Üí PointedPF ùüô n ‚â° PointedSet n
_ = refl
 #+end_src
 :End:
 #+begin_src agda
-- Convenience names
PointedSet·µ£ = PointedSet        :kind ‚Äµrecord
PointedPF·µ£  = Œª Œû ‚Üí PointedPF Œû :kind ‚Äµrecord

-- An extended record type: Two types with a point of each.
TwoPointedSets = PointedPF·µ£ PointedSet·µ£

_ :   TwoPointedSets
    ‚â° ( Œ£ Carrier‚ÇÅ ‚à∂ Set ‚Ä¢ Œ£ point‚ÇÅ ‚à∂ Carrier‚ÇÅ
      ‚Ä¢ Œ£ Carrier‚ÇÇ ‚à∂ Set ‚Ä¢ Œ£ point‚ÇÇ ‚à∂ Carrier‚ÇÇ ‚Ä¢ ùüô)
_ = refl

-- Here's an instance
one : PointedSet :kind ‚Äµrecord
one = ùîπ , false , tt

-- Another; a pointed natural extended by a pointed bool,
-- with particular choices for both.
two : TwoPointedSets
two = ‚Ñï , 0 , one
 #+end_src
 More generally, /record *structure* can be dependent on values:/
 #+begin_src agda
_PointedSets : ‚Ñï ‚Üí Set‚ÇÅ
zero  PointedSets = ùüô
suc n PointedSets = PointedPF·µ£ (n PointedSets)

_ :   4 PointedSets
    ‚â° (Œ£ Carrier‚ÇÅ ‚à∂ Set ‚Ä¢ Œ£ point‚ÇÅ ‚à∂ Carrier‚ÇÅ
      ‚Ä¢ Œ£ Carrier‚ÇÇ ‚à∂ Set ‚Ä¢ Œ£ point‚ÇÇ ‚à∂ Carrier‚ÇÇ
      ‚Ä¢ Œ£ Carrier‚ÇÉ ‚à∂ Set ‚Ä¢ Œ£ point‚ÇÉ ‚à∂ Carrier‚ÇÉ
      ‚Ä¢ Œ£ Carrier‚ÇÑ ‚à∂ Set ‚Ä¢ Œ£ point‚ÇÑ ‚à∂ Carrier‚ÇÑ ‚Ä¢ ùüô)
_ = refl
 #+end_src
 Using traditional grouping mechanisms, it is difficult to create the family of
 types =n PointedSets= since the number of fields, $2 √ó n$, depends on $n$.

 It is interesting to note that the termtype of ~PointedPF~ is the same as the
 termtype of ~PointedOver~, the ~Maybe~ type constructor!
 #+begin_src agda :tangle no
PointedD : (X : Set) ‚Üí Set‚ÇÅ
PointedD X = termtype (PointedPF (Lift _ X) :waist 1)

-- Pattern synonyms for more compact presentation
pattern nothingP = Œº (inj‚ÇÅ tt)
pattern justP x  = Œº (inj‚ÇÇ (lift x))

casingP : ‚àÄ {X} (e : PointedD X)
        ‚Üí (e ‚â° nothingP) ‚äé (Œ£ x ‚à∂ X ‚Ä¢ e ‚â° justP x)
casingP nothingP  = inj‚ÇÅ refl
casingP (justP x) = inj‚ÇÇ (x , refl)
 #+end_src

** COMMENT Example: Vector Spaces

 Consider the signature of vector spaces ~V~ over a field ~F~.
 #+begin_src agda  :tangle Context_examples.agda
VecSpcSig : Context ‚Ñì‚ÇÅ
VecSpcSig = do F   ‚Üê Set
               V   ‚Üê Set
               ùüò   ‚Üê F
               ùüô   ‚Üê F
               _+_ ‚Üê (F ‚Üí F ‚Üí F)
               o   ‚Üê V
               _*_ ‚Üê (F ‚Üí V ‚Üí V)
               _¬∑_ ‚Üê (V ‚Üí V ‚Üí F)
               End‚ÇÄ
 #+end_src
 We can expose ~V~ and ~F~ so that they can be varied.
 #+begin_src agda :tangle Context_examples.agda
VSInterface : (Field Vectors : Set) ‚Üí Set
VSInterface F V = (VecSpcSig :waist 2) F V
 #+end_src

 We conjecture that the terms over such vector space signatures
 are similar to lists (vectors) consisting of elements (field scalars),
 but we also have two additional nullary constructors, a pairing constructor,
 and a branching constructor. That is, we have a structure amalgamating
 both lists and binary trees.
 #+begin_src agda :tangle Context_examples.agda
data ‚Ñùùïöùïüùïò (Scalar : Set) : Set where
  zero‚Çõ : ‚Ñùùïöùïüùïò Scalar
  one‚Çõ  : ‚Ñùùïöùïüùïò Scalar
  plus‚Çõ : Scalar ‚Üí Scalar ‚Üí ‚Ñùùïöùïüùïò Scalar
  zero·µ• : ‚Ñùùïöùïüùïò Scalar
  prod  : Scalar ‚Üí ‚Ñùùïöùïüùïò Scalar ‚Üí ‚Ñùùïöùïüùïò Scalar
  dot   : ‚Ñùùïöùïüùïò Scalar ‚Üí ‚Ñùùïöùïüùïò Scalar ‚Üí ‚Ñùùïöùïüùïò Scalar
 #+end_src

 We confirm this claim by relying on the mechanical approach to forming term
 types, then witnessing a view between the two.
 #+begin_src agda :tangle Context_examples.agda
VSTerm : (Field : Set) ‚Üí Set
VSTerm = Œª F ‚Üí termtype ((VecSpcSig :waist 2) F)
{- ‚âÖ  Fix (Œª X ‚Üí ùüô     -- Representation of additive unit, zero
               ‚äé ùüô     -- Representation of multiplicative unit, one
               ‚äé F √ó F -- Pair of scalars to be summed
               ‚äé ùüô     -- Representation of the zero vector
               ‚äé F √ó X -- Pair of arguments to be scalar-producted
               ‚äé X √ó X -- Pair of vectors to be dot-producted
-}

-- Convenience synonyms for more compact presentation & meaningful names
pattern ùüò‚Çõ         = Œº (inj‚ÇÅ tt)
pattern ùüô‚Çõ         = Œº (inj‚ÇÇ (inj‚ÇÅ tt))
pattern _+‚Çõ_ x y   = Œº (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÅ (x , (y , tt)))))
pattern ùüò·µ•         = Œº (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÅ tt))))
pattern _*·µ•_ x xs  = Œº (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÅ (x , (xs , tt)))))))
pattern _¬∑·µ•_ xs ys = Œº (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÇ (inj‚ÇÅ (xs , (ys , tt))))))))
 #+end_src

 Now the view: It simply associated constructors of the same shape, recursively.
 #+begin_src agda :tangle Context_examples.agda
view : ‚àÄ {F} ‚Üí VSTerm F ‚Üí ‚Ñùùïöùïüùïò F
view ùüò‚Çõ         = zero‚Çõ
view ùüô‚Çõ         = one‚Çõ
view (x +‚Çõ y)   = plus‚Çõ x y
view ùüò·µ•         = zero·µ•
view (x *·µ• xs)  = prod x (view xs)
view (xs ¬∑·µ• ys) = dot (view xs) (view ys)
 #+end_src

 Neato.

** Example: Graphs in Two Ways

  There are two ways to implement the type of graphs in the
  dependently-typed language Agda: Having the vertices be a parameter or having
  them be a field of the record. Then there is also the syntax for graph vertex
  relationships. Suppose a library designer decides to work with fully bundled
  graphs, ~Graph‚ÇÄ~ below, then a user decides to write the function ~comap~, which
  relabels the vertices of a graph, using a function ~f~ to transform vertices.

:Hide:
#+begin_src agda
data ùîæùï£ùïíùï°ùïô (Vertex : Set) : Set where
  ‚ü®_,_‚ü©‚Çõ : Vertex ‚Üí Vertex ‚Üí ùîæùï£ùïíùï°ùïô Vertex
#+end_src
:End:

#+begin_src agda :tangle Context_examples.agda
record Graph‚ÇÄ : Set‚ÇÅ where
  constructor ‚ü®_,_‚ü©‚ÇÄ
  field
    Vertex : Set
    Edges : Vertex ‚Üí Vertex ‚Üí Set

open Graph‚ÇÄ

comap‚ÇÄ : {A B : Set}
       ‚Üí (f : A ‚Üí B)
       ‚Üí (Œ£ G ‚à∂ Graph‚ÇÄ ‚Ä¢ Vertex G ‚â° B)
       ‚Üí (Œ£ H ‚à∂ Graph‚ÇÄ ‚Ä¢ Vertex H ‚â° A)
comap‚ÇÄ {A} f (G , refl) = ‚ü® A , (Œª x y ‚Üí Edges G (f x) (f y)) ‚ü©‚ÇÄ , refl
#+end_src
  #+latex: \noindent
  Since the vertices are packed away as components of the records, the only way
  for ~f~ to refer to them is to awkwardly refer to seemingly arbitrary types,
  only then to have the vertices of the input graph ~G~ and the output graph ~H~ be
  constrained to match the type of the relabelling function ~f~.  Without the
  constraints, we could not even write the function for ~Graph‚ÇÄ~.  With such an
  importance, it is surprising to see that the occurrences of the constraint
  obligations are uninsightful ~refl~-exivity proofs.

  What the user would really want is to unbundle ~Graph‚ÇÄ~ at will, to expose the
  first argument, to obtain ~Graph‚ÇÅ~ below. Then, in stark contrast, the
  implementation ~comap‚ÇÅ~ does not carry any excesses baggage at the type level
  nor at the implementation level.
#+latex: \newpage
  #+begin_src agda  :tangle Context_examples.agda
record Graph‚ÇÅ (Vertex : Set) : Set‚ÇÅ where
  constructor ‚ü®_‚ü©‚ÇÅ
  field
    Edges : Vertex ‚Üí Vertex ‚Üí Set

comap‚ÇÅ : {A B : Set}
       ‚Üí (f : A ‚Üí B)
       ‚Üí Graph‚ÇÅ B
       ‚Üí Graph‚ÇÅ A
comap‚ÇÅ f ‚ü® edges ‚ü©‚ÇÅ = ‚ü® (Œª x y ‚Üí edges (f x) (f y)) ‚ü©‚ÇÅ
  #+end_src
  #+latex: \noindent
  With ~Graph‚ÇÅ~, one immediately sees that the ~comap~ operation ‚Äúpulls back‚Äù the
    vertex type. Such an observation for ~Graph‚ÇÄ~ is not as easy; requiring
    familiarity with quantifier laws such as the one-point rule and quantifier
    distributivity.

** Example: Graphs with Delayed Unbundling
The ubiquitous graph structure
    is contravariant in its collection of vertices. Recall that a multi-graph, or
    quiver, is a collection of vertices along with a collection of edges between
    any two vertices; here's the traditional record form:
    #+begin_src agda  :tangle Context_examples.agda
Graph  : Context ‚Ñì‚ÇÅ
Graph  = do Vertex ‚Üê Set
            Edges  ‚Üê (Vertex ‚Üí Vertex ‚Üí Set)
            End {‚Ñì‚ÇÄ}
 #+end_src

    Using the record form, it is awkward to phrase contravariance, which simply
    ‚Äúrelabels the vertices‚Äù. Even worse, the awkward phrasing only serves to
    ensure certain constraints hold ---which are reified at the value level via
    the uninsightful ~refl~-exivity proof.
    #+begin_src agda  :tangle Context_examples.agda
pattern ‚ü®_,_‚ü© V E = (V , E , tt)

comap‚ÇÄ‚Ä≤ : ‚àÄ {A B : Set}
      ‚Üí (f : A ‚Üí B)
      ‚Üí Œ£ G ‚à∂ Graph :kind ‚Äµrecord ‚Ä¢ Field 0 G ‚â° B
      ‚Üí Œ£ G ‚à∂ Graph :kind ‚Äµrecord ‚Ä¢ Field 0 G ‚â° A
comap‚ÇÄ‚Ä≤ {A} {B} f (‚ü® .B , edgs ‚ü© , refl) = (A , (Œª a‚ÇÅ a‚ÇÇ ‚Üí edgs (f a‚ÇÅ) (f a‚ÇÇ)) , tt) , refl
        #+end_src
    /Without redefining graphs/, we can phrase the definition at the ‚Äòtypeclass‚Äô
    level ---i.e., records parameterised by the vertices. This form is not only
    clearer and easier to implement at the value-level, it also makes it clear
    that we are ‚Äúpulling back‚Äù the vertex type and so have also shown graphs are
    closed under reducts.
        #+begin_src agda   :tangle Context_examples.agda
pattern ‚ü®_‚ü©¬π E = (E , tt)

-- Way better and less awkward!
comap‚Ä≤ : ‚àÄ {A B : Set}
     ‚Üí (f : A ‚Üí B)
     ‚Üí (Graph :kind ‚Äµtypeclass) B
     ‚Üí (Graph :kind ‚Äµtypeclass) A
comap‚Ä≤ f ‚ü® edgs ‚ü©¬π = ‚ü® (Œª a‚ÇÅ a‚ÇÇ ‚Üí edgs (f a‚ÇÅ) (f a‚ÇÇ)) ‚ü©¬π
    #+end_src

    #+latex: \vspace{1em}\noindent
    Excellent, we can unbundle at will.

* COMMENT PROPOSAL ‚à∑ The Next 700 Module Systems
** Preamble & title page                                             :ignore:

 # Top level editorial comments.
 #+MACRO: remark  @@latex: \fbox{\textbf{Comment: $1 }}@@

*** Minted setup -- colouring code blocks                            :ignore:

 #+LATEX_HEADER: \usepackage[]{minted}
 #+LATEX_HEADER: \usepackage{tcolorbox}
 #+LATEX_HEADER: \usepackage{etoolbox}
 #+LATEX_HEADER: \def\mytitle{??? Program Code ???}
 #+LATEX_HEADER: \BeforeBeginEnvironment{minted}{\begin{tcolorbox}[title=\hfill \mytitle]}%
 #+LATEX_HEADER: \AfterEndEnvironment{minted}{\end{tcolorbox}}%

 # Before a code block, write {{{code(title-of-block)}}}
 #
 #+MACRO: code     #+LaTeX: \def\mytitle{$1}

 #+LaTeX: \setminted[haskell]{fontsize=\footnotesize}
 #+LaTeX: \setminted[agda]{fontsize=\footnotesize}

 # Removing the red box that appears in "minted" when using unicode.
 # Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
 #
 #+LATEX_HEADER: \makeatletter
 #+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
 #+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
 #+LATEX_HEADER: \makeatother
*** LaTeX setup                                                      :ignore:

 # Hijacking \date to add addtional text to the frontmatter of a ‚Äòreport‚Äô.
 #
 #
 # DATE: \today\vfill \centerline{---Supervisors---} {{{newline}}} [[mailto:carette@mcmaster.ca][Jacques Carette]] and [[mailto:kahl@cas.mcmaster.ca][Wolfram Kahl]]

 #+LATEX_HEADER: \usepackage[hmargin=25mm,vmargin=25mm]{geometry}
 #+LaTeX_HEADER: \setlength{\parskip}{1em}
 #+latex_class_options: [12pt]
 #+LATEX_CLASS: report-noparts
 # Defined below.
 #
 # Double spacing:
 # LaTeX: \setlength{\parskip}{3em}\renewcommand{\baselinestretch}{2.0}
 #
 #+LATEX_HEADER: \setlength{\parskip}{1em}

 #+LATEX_HEADER: \usepackage[backend=biber,style=alphabetic]{biblatex}
 # addbibresource{References.bib}

 #+LATEX_HEADER: \usepackage{UnicodeSymbols}

 #+LATEX_HEADER: \usepackage[dvipsnames]{xcolor} % named colours
 #+LATEX_HEADER: \usepackage{color}
 #+LATEX_HEADER: \definecolor{darkred}{rgb}{0.3, 0.0, 0.0}
 #+LATEX_HEADER: \definecolor{darkgreen}{rgb}{0.0, 0.3, 0.1}
 #+LATEX_HEADER: \definecolor{darkblue}{rgb}{0.0, 0.1, 0.3}
 #+LATEX_HEADER: \definecolor{darkorange}{rgb}{1.0, 0.55, 0.0}
 #+LATEX_HEADER: \definecolor{sienna}{rgb}{0.53, 0.18, 0.09}
 #+LATEX_HEADER: \hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkgreen}

 #+NAME: symbols for itemisation environment
 #+BEGIN_EXPORT latex
 \def\labelitemi{$\diamond$}
 \def\labelitemii{$\circ$}
 \def\labelitemiii{$\star$}

 % Level 0                 Level 0
 % + Level 1               ‚ãÑ Level 1
 %   - Level 2       --->      ‚àò Level 2
 %     * Level 3                   ‚ãÜ Level 3
 %
 #+END_EXPORT

 # Having small-font code blocks.
 # LATEX_HEADER: \RequirePackage{fancyvrb}
 # LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}

*** ~reports-noparts~ LaTeX Class                                  :noexport:

 A custom version of the reports class which makes the outermost headings
 chapters, rather than parts.
 #+NAME: make-reports-class
 #+BEGIN_SRC emacs-lisp :results none
(add-to-list
  'org-latex-classes
    '("report-noparts"
      "\\documentclass{report}"
      ("\\chapter{%s}" . "\\chapter*{%s}")
      ("\\section{%s}" . "\\section*{%s}")
      ("\\subsection{%s}" . "\\subsection*{%s}")
      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
      ("\\paragraph{%s}" . "\\paragraph*{%s}")
      ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
 #+END_SRC

*** Personal title page                                              :ignore:

 #+begin_center org

 #+begin_export latex
 \thispagestyle{empty}

 {\color{white}{.}}

 \vspace{5em}

 {\Huge The Next 700 Module Systems}

 \vspace{1em}

 {\Large Extending Dependently-Typed Languages to Implement
 \\ Module System Features In The Core Language}

 \vspace{2em}

 Department of Computing and Software

 McMaster University

 \vspace{2em}
 \href{mailto:alhassy@gmail.com}{Musa Al-hassy}

 \vspace{2em}
 \today
 #+end_export

 \vfill

 {{{code({\sc Thesis Proposal \hspace{12em} \color{grey}{.} })}}}
 #+begin_src haskell
-- Supervisors                                       -- Emails
Jacques Carette                                      carette@mcmaster.ca
Wolfram Kahl                                         kahl@cas.mcmaster.ca
 #+end_src
 #+end_center

 # LaTeX: \centerline{\sc Draft}

** Approach and Timeline
   :PROPERTIES:
   :CUSTOM_ID: approach_and_timeline
   :END:


 Packages, modules, classes, (dependent) records, (named) contexts, telescopes, theories, specifications
 ---whatever you wish to call them are essential structuring principles that
 enable modularity, encapsulation, inheritance, and reuse in formal libraries and programs.
 Moreover, as we have demonstrated, with the exception of use-cases,
 there are no significant differences between them in a dependently-typed setting, as cite:theories_as_types present a type theoretic calculus
 of a variant of record types that corresponds to theories.

*** Implementation Matter

 We will realise our proposal in an existing compiler
 and so working with it necessitates our implementations to be more than
 just ‚Äòresearch quality‚Äô but actually ready for a broad audience.

 Which compiler and for which language?

 Since our attention is focused on dependently typed languages within the
 realm of @@latex: Martin-L\"{o}f's@@ Type Theory
 cite:lof_constructive_math}, Agda \parencite{agda_web is a natural
 candidate.

 Agda is currently one of the most used tools for proof and program experimentation
 involving dependent types. With its support for mixfix Unicode lexemes, it has
 become a strong competitor to Coq cite:coq_website,coq_inductive_coc, coq_coc} for both proof construction \parencite{agda_fixpoints, agda_quantifier_elim, agda_nondeterministic, agda_mergesort, agda_type_Safety, agda_aop
 and general program construction cite:agda_web, agda_trains, agda_bitcoin, agda_hardware
 ---Agda's lack of /syntactic/ distinction between
 programs and propositions, along with its pattern matching utilities in-place of
 ‚Äòtactic sledgehammers‚Äô cite:tactics, it has also become an attractive
 language for introducing dependent types and functional programming
 cite:agda_iowa_book, agda_plf, agda_teaching. With its syntactic similarity to Haskell, many Agda users treat
 their Agda code as if it were lazy with the ~let~ and ~where~ clauses preserving sharing
 ---which is not the case, since such clauses rewrite to top-level functions
 cite:agda_docs.
 Instead, Agda's evaluation strategy is normal order: Function definitions
 are invoked before arguments are evaluated, but computations of arguments
 are /not/ shared. This is a prime location for efficiency issues since type-checking
 in a dependently typed language tends to involve evaluation of terms.
 Surprisingly this has not stopped users from producing large-scale software
 developments cite:RATH, agda_trains, agda_web.

 # for agda's evluation strategy, see also
 # https://stackoverflow.com/questions/21210569/is-the-evaluation-strategy-of-agda-specified-anywhere

 Needless to say,
 a poor choice of elaboration strategy can lead to a loss of sharing
 ---not that Agda has sharing to begin with---,
 contain too many undesirable side-effects, hinder efficiency, or forgo compile-time optimisations.
 For example,
 Agda, as currently implemented using the Glasgow Haskell Compiler (GHC), is a realisation
 of @@latex: Martin-L\"{o}f's@@ Type Theory (MLTT) that is heralded as
 both a programming language and proof assistant.
 Unfortunately MLTT, as many other dependent logics
 ---such as the Calculus of Constructions with inductive types, which underlies both
 the Coq and Lean proof assistants---
 does not account for modules, thereby leaving these as consistency-preserving hacks thrown onto the implementation.
 As mentioned earlier, Agda simply rewrites modules into top
 level functions with module parameters realised as parameters to the resulting functions.
 This is an implementation detail and has little impact on theory construction,
 however, code reuse becomes unreasonably slow
 due to the loss of sharing that happens when module arguments need to be
 re-normalised in each function-counterpart.
 Consequently, only a minor subset of the Agda community actually /executes/ their
 programs. The rest of the community is generally content with type checking only;
 which does not hinder the reliability of proof.

 It is important to note that we employ Agda only as a proof-of-concept for
 our proposed exploration of first-class structuring-mechanisms in dependently typed languages.
 Admittedly Agda's support for Unicode mixfix lexemes makes it a pleasure to work
 in, with mechanised proofs being little work more than their LaTeX renditions.

*** Next Steps

 The approach we intend to follow consists of the following steps.
 Notice that feedback loop of practice into theory.

 :Weakness:
 1. Really study the other mechanisms that already exist.

    *Exhibiting such a weakness may suggest insufficient preparatory work!*
    *Possibly resulting in a fail!*

    - Survey module systems in theory, in existing DTLs, *and* in non-DTLs.

    - As far as we can tell, besides the MTT cite{mmt_main_paper, mmt_api}
      group, no one else is working on actually implementing
      solutions to the flaws we have identified, such as combination over
      structures.

    - This is promising in terms of novelty, if anything.

    - Analyse why there are not multiple implementations of such seemingly
      immensely useful concepts.

 :End:

 1. Distill the /true/ requirements for a solution;
    ensure good /fit for purpose/ criteria exists.

    - Understand the requirements of `modularity mechanisms' for DTLs.
    - Narrow down a design by choosing a set of requirements.
    - Identify necessary, and practical, trade-offs.
      Conflicting feature sets? Usability?
    - Ideally we want our implementations to avoid too much overhead,
      such as creating an entire new language; this may necessitate the
      weakening of other functionality.

 2. Deepen understanding of the opportunities given by DTL.

    - Understand the relationships between
       modules, records, contexts, telescopes, and signatures.
      * Do they have differing `types'?
      * As types themselves, do they have differing `values'?
      * In the setting of DTLs, are they essentially isomorphic?
      * What are the intended uses? What intentions do particular choices communicate?
        - E.g., ‚Äú$x = y$‚Äù communicates an equality and nothing more, whereas
      ‚Äú$x\! \iff\! y$‚Äù communicates a Boolean equality: A redundant, particularised, equality
      symbol serves to succinctly and elegantly communicate more information.

 3. Formulate basic, draft, semantics for a small set of DTL module primitives.

    - What is the type of a package former?
    - How does it fit into Agda's existing type hierarchy?
    - What are the types of the primitives themselves?
      + We wish to avoid metaprogramming
        after all, and so wish to remain within the language rather than
        in a metalanguage.

 4. Prototype some mechanisms; a combination of old, adapted, and novel ones
    to demonstrate the power of the system.

    + Implement the structuring mechanism combinators discussed earlier
      ---such as combination over common-substructures.

      + Possibly begin with reifying first class grouping mechanisms by
        representing contexts ---i..e, sequences of declarations with optional definitions---
        as records in Agda with the undefined declarations being fields and the rest being
        derived or definitional.

 5. Evaluate the mechanisms ---using fit-for-criteria.

    + Since the realisation would be in Agda, we would keep in touch with the community
      to ensure that the additions contribute to program design.

    + Evaluate the strength of the resulting additions in terms
      of practical use for library designers as well as in terms of program speed.

 6. Make sure to have a denotational semantics for the mechanisms.

    + Ensure that the additions are minimal, orthogonal, and construct a sound
      type theory around them.

 7. Refine 2-6 until elegance, or deadline, is reached, whichever comes first.

 # More importantly, as our results will likely need to be re-proven for definitional adjustment,
 # we intend to /mechanise/ all of our proofs in Agda as well ---when possible.
 # Therefore, Agda plays multiple roles: A dependently-typed language to experiment
 # with, as well as a proof checker for our results.

 Our timeline will discuss how we will carry out this approach in multiple
 passes and will discuss the conditions of a successful pass.

*** Timeline

 We shall iterate through the `approach phase' three times,
 utilising a feedback loop of practice into theory.
 The phases are discussed below.

 As our results will likely need to be re-proven for definitional adjustment,
 we intend to /mechanise/ all of our proofs in Agda as well ---when possible.
 Therefore, Agda plays multiple roles: A dependently-typed language to experiment
 with, as well as a proof checker for our results.

**** The First Pass: May-October 2019
 This stage concludes successfully provided the following checkpoints are achieved.

 + A thorough understanding of what is being done by others, and how
   our approach differs, is obtained /and/ documented.

 + Understand the Agda compilation ecosystem, provide a report on how to make
   alterations to it, and actually implement at least one structuring mechanism
   and provide use cases as well as preliminary efficiency analysis.

 + A publication covering existing mechanisms, their features and flaws,
   and possibly an explanation of why there is theoretical work on these issues
   but little to no implementation on them
   ---with a focus on practical uses and possible hurdles to use.

   - A side-effect of this is to produce an evaluation strategy for the mechanisms.
   - Moreover, this necessitates looking into the associated semantics,
     evaluating them, and proposing semantics for the mechanism we have designed.

 + Thesis writing should have begun and nearing completion are sections
   on introduction and background.

**** The Middle Pass: November 2019 - February 2020
 This stage concluded successfully provided the following checkpoints are achieved.

 + The success of the previous stage ensures an understanding of the Agda compilation
   ecosystem, as such it should take less time to implement the more mechanisms,
   theory combinators. The goal is to have the remaining mechanisms implemented,
   with a focus on the combination-over-a-structure mechanism.

   - With each implementation, reach-out to the Agda community to solicit
     feedback regarding improvements and possible use cases.

 + Extending the semantics for the newly implemented mechanisms.

   - Evaluating which mechanisms are more primitive, which are derived, and
     which can be used to /allow users to make their own *using* the concrete language itself/!

 + A publication of case studies utilising these combinators, as well as
   a comparison of how these are an improvement over traditional methods.

   - Analysing the interactions between features; does the addition of one
     hinder another.

   - Empirical tests for efficiency and utility.

 + Thesis writing should have progressed with sections on
   use cases, semantics, and feature design,
   having substantial matter if not nearing completion.

**** The Final Pass: March - April 2020
 This stage concluded successfully provided the following checkpoints are achieved.

 + Ensure that our implementations are meeting our requirements for a solution.

 + Begin mechanisation of proofs authenticating that the denotational
   semantics has desired, expected, properties; such as soundness and safeness.

**** Concluding Phase
 Wrap up all proof matters and finish the thesis.

 Suffice to say life tends to be more hectic than a schedule may permit
 and as such some times may deviate from the above intentions.
 Regardless, the goal will be to complete the thesis within 2 years time;
 in particular before September 2020.
** COMMENT footer                                                    :ignore:

 eval (progn (org-babel-goto-named-src-block "make-reports-class") (org-babel-execute-src-block) (outline-hide-sublevels 1))
 compile-command (progn (org-babel-tangle) (org-latex-export-to-pdf) (async-shell-command "open thesis-proposal.pdf"))
* COMMENT Thesis Checklist
** What's a thesis? [0%]
   + [ ] The argument
     - What is it? Is it being argued clearly?
     - What's the plan?
   + [ ] An exposition of an orginal piece of research.
   + [ ] Distinctive contribution to the knowledge of the subject?
   + [ ] Evidence of orginality shown by the discovery of new facts?
   + [ ] How is the research best appreciated?
   + [ ] Ideas not mentioned in the thesis might as well not exist! Mention ideas.

** Planning an Argument [0%]
   One sentence for each:
   + [ ] Introduction to the area of study.
   + [ ] The problem being tackled.
   + [ ] What the literature says about the problem.
     - A review of previous work shows you know the subject.
     - Besides being descriptive, the review needs to be critical.
     - Summary of the essential features of other work as it relates to this study.
   + [ ] How /I/ tackle this problem.
     - What is the philosophy of approach?
     - How were you systematic?
     - How is this linked back to the literature review?
   + [ ] How /I/ implement my solution.
     - Provide details so that others can follow what was done.
     - Justify the approach taken.
     - Does the software appear to work satisfcatorily?
   + [ ] The result.
     - Application of the approach reduces thousands of lines of code to
       human-readable specfications with an extensible system?
     - *Link back to how the solutions obtained relate to the questions posed?*
     - Accurately identitfy & summarise patterns or trends in the results.
     - Provide a critical analysis to show you know its limitations.
     - ‚ÄòFuture Work‚Äô to show what's missing.
     - Beware of specfulations not grounded in the results.
   + [ ] Conclusion ---repetition of the intro, but with reference to the detail.

   An outline acts as a workplan for which the entire research process is an
   exercise addressing each item. Each item becomes at least one section in
   the writeup.

   + [ ] Set out clearly what each chapter should say.

** Say everything thrice [0%]

   It's not repetition, but linking and rationale.

   + [ ] In the thesis as a whole.
     - [ ] Introduction - What the thesis will say.
     - [ ] Body - Details of the work.
     - [ ] Conclusion - What the thesis said.

   + [ ] Within each chapter/section.
     - [ ] Signposting - What this section says.
     - [ ] Body - The details.
     - [ ] Summary - What this section has said.

   + [ ] Within each paragraph.
     - [ ] Each paragraph describes a single idea.
     - [ ] The first sentence introduces the idea ---linking it with the previous one.
     - [ ] The last sentence concludes the idea ---linking it with the next one.

   Signposts ensure it's clear what's being discussed and why
   ---from a writer's perspective, they help get the contents right.

** The Examiner's View

   They'll read it in meetings, trains, or planes.
   They're busy and an initial scan may be:

   1. abstract - what's it about?
   2. bibliography - Does it cite the right stuff? Has it been published already?
   3. conclusions - What was achieved? Do I believe it?
   4. contents listing - Is everything there? Is the argument clear?

   Weakeness in these locations might suggest large corrections.

   + [ ] Run spellchecking everywhere.
   + [ ] Run the grammar checker as well.

** What If I'm stuck?

   1. The task at hand may be too difficult.
   2. *Ask for help!*
   3. Change the plan.
   4. Cut away irrelevant bits.

** COMMENT Our Approach [0%]
  --Remaining Tasks--
  + [ ] Plan of Attack
  + [ ] Implementation Details
  + [ ] Discussion of Results
  + [ ] Future Work

* COMMENT Leftovers

** Let us conclude by attempting to justify the title of this thesis.

 Landin's /The Next 700 Programming Languages/ cite:seven_hundred_langs inspired a
 number of works, including
 cite:seven_hundred_tt_models,seven_hundred_provers,seven_hundred_hoas,seven_hundred_libraries,seven_hundred_data
 and more. The intended aim of the thesis is a requirements driven approach to
 coherent modularisation constructs in DTLs. In particular, we wish to extend
 Agda to be powerful enough to implement the module system features, in the core
 language, that people actually want and currently mimic by-hand or using
 third-party preprocessors. An eager fix would be to provide metaprogramming
 features, but unless one is altering the syntax or producing efficient code,
 this is glorified pre-processing ---it is a means to fake missing abstraction
 features. Moreover, metaprogramming would be a hammer too big for the nail we
 are interested in; so big that its introduction might ruin the soundness of the
 DTLs ---e.g., two terms may be ill-typed and ill-formed, such as ~x +~ and ~5 = 3~,
 but are meaningful when joined together, as in ~x + 5 = 3~. Our aim is to provide
 just the right level of abstraction so that, if anything, users can write a type
 of container or method upon it then derive ‚Äò700‚Äô simple alternate views of the
 same container and method.

 To be clear, consider a semi-ring ---or any simple record of 17 different kinds
 of data. A semi-ring consists of two monoids ---each consisting of a total of 7
 items of data and proof matter--- where one of them is commutative and there are
 two distributivity axioms. Hence, a semi-ring consists of 17 items. If we wanted
 to expose, say, 3 such items ---for example, the shared carrier and the
 identities of each monoid--- then there are a total of $\binom{17}{3} = 680$
 ways, and if we jump to 4 items we have $\binom{17}{4} = 2380$ possible forms.
 Of course these numbers are only upper bounds when record fields depend on
 earlier items. In section 3, we provide explicit examples of different
 structural presentations of packages.

 Usually, library designers provide one or two views, along with conversion functions,
 and commit to those; instead we want to liberate them to choose whatever presentation
 is convenient for the tasks at hand and to work comfortably with the guarantee that
 all the presentations are isomorphic. Humans should be left to tackle difficult and
 interesting problems; machines should derive the tedious and uninteresting
 ---even if it's simple, it saves time, is less error-prone, and clearly communicates
 the underlying principle.

 If anything, our aim is practical ---to save developers from ad hoc copy-paste
 preprocessing hacks.

** Introduction to diy modules

    A fundamental argument for the use of module systems in the design of large
  programs is that the structure of the program is partitioned into coherent
  semantical units that are furnished with an interface belying the complexity of
  their implementations. A well-established example is the use of the humble
  record to ‚Äòbundle‚Äô up the extensional properties of an object; here one works
  with objects as if they were atomic, rather than considering the
  collection of their identifying properties.  Users of dependently-typed
  languages like Agda and Coq will argue strongly that the effective use of
  module systems is extremely important for subsequent program development, and
  even users of dynamically typed languages like Javascript will admit that, for
  example, namespace violations are an area of concern.  A fundamental aspect of
  =PackageFormer= is that the relationship between a grouping mechanism and its
  constituent structuring sub-grouping mechanisms is made explicit: One extracts
  grouping mechanisms from declarations involving existing grouping mechanisms.
  In contrast to type theory wherein a type is specified by characterising how
  its elements may be formed, our approach allows both the building-up of
  grouping mechanisms from their parts and, also, the ‚Äòtearing down‚Äô of parts of
  existing grouping mechanisms ---as is the case of dropping a property from a
  record type to obtain another record type, or of transforming a record type
  into an algebraic data type.  Depending on their nature, grouping
  specifications may either allow the automatic derivation of ‚Äòintroduction
  rules‚Äô wherein the teared-down grouping is transformed into the new grouping,
  or allow ‚Äòelimination rules‚Äô wherein the individual groupings that built-up the
  new grouping can be identified.  The semantics of a grouping specification
  is essentially the ‚Äòflattening‚Äô of properties that extensionally constitute it.
  Our work describes the necessary primitives that allow grouping declarations.

  The intention is not to provide a fixed set of general-purpose grouping
  combinators that are sufficient to encompass all the future needs of all
  programmers but to provide a small kerneal of ‚Äòmeta-primitives‚Äô whereby
  programmers may invent their own grouping mechanisms peculiar to their own
  problem domain.

* Bib                                                                :ignore:
# addcontentsline{toc}{section}{References}
# bibliography{/Users/musa/thesis-proposal/papers/References.bib}
# +LaTeX: \addcontentsline{toc}{part}{References}
#+LaTeX: \printbibliography

  1. cite:haskell_modules_formally Diatchki, I. S., Jones, M. P., & Hallgren, T., A formal specification of the Haskell 98 module system , In ,  (pp. 17‚Äì28) (). : .

  2. cite:haskell_in_haskell Sheard, T., Harrison, W., & Hook, J., Modeling the fine control of demand in haskell. (2001). Unpublished manuscript.

  3. cite:classic_haskell_genericity Sheard, T., Generic unification via two-level types and parameterized modules, In , ICFP 2001 (pp. ) (). : acm press.

  4. cite:modular_modules Leroy, X., A modular module system, J. Funct. Program., 10(3), 269‚Äì303 (2000).  http://dx.doi.org/10.1017/S0956796800003683

  5. cite:acsl Brito, E., & Pinto, J. S., Program verification in SPARK and ACSL: A comparative case study, In , Reliable Software Technologiey - Ada-Europe 2010, 15th Ada-Europe International Conference on Reliable Software Technologies, Valencia, Spain, June 14-18, 2010. Proceedings (pp. 97‚Äì110) (2010). : .

  6. cite:programatica Hallgren, T., Hook, J., Jones, M. P., & Kieburtz, R. B., An overview of the programatica toolset, In , HCSS '04 (pp. ) (). : .

  7. cite:frama_c Volkov, G., Mandrykin, M. U., & Efremov, D., Lemma functions for frama-c: C programs as proofs, CoRR, abs/1811.05879(),  (2018).

  8. cite:knuth_lp Knuth, D. E., Literate Programming, Comput. J., 27(2), 97‚Äì111 (1984).  http://dx.doi.org/10.1093/comjnl/27.2.97

  9. cite:haskell_backpack Kilpatrick, S., Dreyer, D., Simon L. Peyton Jones, & Marlow, S., Backpack: retrofitting haskell with interfaces, In , The 41st Annual {ACM} {SIGPLAN-SIGACT} Symposium on Principles of Programming Languages, {POPL} '14, San Diego, CA, USA, January 20-21, 2014 (pp. 19‚Äì32) (2014). : .

 10. cite:lenses !!! No entry found !!!

 11. cite:coq_cat_experiences !!! No entry found !!!

 12. cite:perna Perna, N., (re-)creating sharing in agda's ghc backend (2017).

 13. cite:maude_module_algebra Francisco Dur\'an, & Jos\'e Meseguer, Maude's module algebra, Sci. Comput. Program., 66(2), 125‚Äì153 (2007).  http://dx.doi.org/10.1016/j.scico.2006.07.002

 14. cite:B_reuse Blazy, S., Fr\'ed\'eric Gervais, & R\'egine Laleau, Reuse of specification patterns with the B method, CoRR, abs/cs/0610097(),  (2006).

 15. cite:sec:three !!! No entry found !!!

 16. cite:sec:four !!! No entry found !!!

 17. cite:types_for_modules Dreyer, D., Crary, K., & Harper, R., A type system for higher-order modules, In , Conference Record of {POPL} 2003: The 30th {SIGPLAN-SIGACT} Symposium on Principles of Programming Languages, New Orleans, Louisisana, USA, January 15-17, 2003 (pp. 236‚Äì249) (2003). : .

 18. cite:dtls_give_modules MacQueen, D. B., Using dependent types to express modular structure, In , Conference Record of the Thirteenth Annual {ACM} Symposium on Principles of Programming Languages, St. Petersburg Beach, Florida, USA, January 1986 (pp. 277‚Äì286) (1986). : .

 19. cite:deriving_via Baldur Bl\"ondal, Andres L\"oh, & Scott, R., Deriving via: or, how to turn hand-written instances into an anti-pattern, In , Proceedings of the 11th {ACM} {SIGPLAN} International Symposium on Haskell, Haskell@ICFP 2018, St. Louis, MO, USA, September 27-17, 2018 (pp. 55‚Äì67) (2018). : .

 20. cite:hasochism Lindley, S., & McBride, C., Hasochism: the pleasure and pain of dependently typed haskell programming, In , Proceedings of the 2013 {ACM} {SIGPLAN} Symposium on Haskell, Boston, MA, USA, September 23-24, 2013 (pp. 81‚Äì92) (2013). : .

 21. cite:10.1145/1411204.1411213 Oury, N., & Swierstra, W., The power of pi, In , Proceedings of the 13th ACM SIGPLAN International Conference on Functional Programming (pp. 39‚Äì50) (2008). New York, NY, USA: Association for Computing Machinery.

 22. cite:DBLP:conf/gpce/Al-hassyCK19 Musa Al-hassy, Carette, J., & Kahl, W., A language feature to unbundle data at will (short paper), In I. Schaefer, C. Reichenbach, & T. v. d. Storm, Proceedings of the 18th {ACM} {SIGPLAN} International Conference on Generative Programming: Concepts and Experiences, {GPCE} 2019, Athens, Greece, October 21-22, 2019 (pp. 14‚Äì19) (2019). : ACM.

 23. cite:LF_practical_module_system Rabe, F., & Carsten Sch\"urmann, A practical module system for LF, In , Proceedings of the Fourth International Workshop on Logical Frameworks and Meta-Languages: Theory and Practice, {LFMTP} '09, McGill University, Montreal, Canada, August 2, 2009 (pp. 40‚Äì48) (2009). : .

 24. cite:named_instances Kahl, W., & Scheffczyk, J., Named instances for haskell type classes, In ,  (pp. ) (2001). : .

 25. cite:type_inference_in_math !!! No entry found !!!

 26. cite:understanding_typescript Bierman, G. M., Mart\'\in Abadi, & Torgersen, M., Understanding Typescript, In , ECOOP} 2014 - Object-Oriented Programming - 28th European Conference, Uppsala, Sweden, July 28 - August 1, 2014. Proceedings (pp. 257‚Äì281) (2014). : .

 27. cite:little_theories Farmer, W. M., Guttman, J. D., & Javier Thayer, F., Little theories, In D. Kapur, Automated Deduction---CADE-11 (pp. 567‚Äì581) (1992). Berlin, Heidelberg: Springer Berlin Heidelberg.

 28. cite:coq_canonical Gonthier, G., Ziliani, B., Nanevski, A., & Dreyer, D., How to make ad hoc proof automation less ad hoc, J. Funct. Program., 23(4), 357‚Äì401 (2013).  http://dx.doi.org/10.1017/S0956796813000051

 29. cite:coq_canonical_tutorial Mahboubi, A., & Tassi, E., Canonical structures for the working coq user, In S. Blazy, C. Paulin, & D. Pichardie, ITP 2013, 4th Conference on Interactive Theorem Proving (pp. 19‚Äì34) (2013). Rennes, France: Springer.

 30. cite:wiki_proof_assistants !!! No entry found !!!

 31. cite:agda_overview Bove, A., Dybjer, P., & Norell, U., A brief overview of Agda --- A functional language with dependent types, In , Theorem Proving in Higher Order Logics, 22nd International Conference, TPHOLs 2009, Munich, Germany, August 17--20, 2009. Proceedings (pp. 73‚Äì78) (2009). : .

 32. cite:agda_web Jeffrey, A., Dependently typed web client applications - FRP in agda in HTML5, In , Practical Aspects of Declarative Languages - 15th International Symposium, {PADL} 2013, Rome, Italy, January 21-22, 2013. Proceedings (pp. 228‚Äì243) (2013). : .

 33. cite:coq_implementation Paulin-Mohring, C., The calculus of inductive definitions and its implementation: the coq proof assistant, In ,  (pp. ) (). : .

 34. cite:coq_four_colour !!! No entry found !!!

 35. cite:coq_compcert !!! No entry found !!!

 36. cite:tacticstype !!! No entry found !!!

 37. cite:purposes_of_proof !!! No entry found !!!

 38. cite:coq_manual The Coq Development Team, The coq proof assistant, version 8.8.0 (2018).

 39. cite:maude , All about maude - A high-performance logical framework, how to specify, program and verify systems in rewriting logic (2007), : Springer.

 40. cite:casl_overview Astesiano, E., Bidoit, M., H\'el\`ene Kirchner, Bernd Krieg-Br\"uckner, Mosses, P. D., Sannella, D., & Tarlecki, A., CASL: the common algebraic specification language, Theor. Comput. Sci., 286(2), 153‚Äì196 (2002).  http://dx.doi.org/10.1016/S0304-3975(01)00368-1

 41. cite:idris_main Brady, E. C., IDRIS --- systems programming meets full dependent types, In , Proceedings of the 5th ACM workshop on Programming languages meets program verification (pp. 43‚Äì54) (2011). New York, NY, USA: ACM.

 42. cite:idris_website !!! No entry found !!!

 43. cite:idris_faq !!! No entry found !!!

 44. cite:lean_system_desc Leonardo Mendon\cca de Moura, Kong, S., Avigad, J., Doorn, F. v., & Raumer, J. v., The lean theorem prover (system description), In , Automated Deduction - {CADE-25} - 25th International Conference on Automated Deduction, Berlin, Germany, August 1-7, 2015, Proceedings (pp. 378‚Äì388) (2015). : .

 45. cite:ats_website !!! No entry found !!!

 46. cite:fstar_website !!! No entry found !!!

 47. cite:beluga Pientka, B., Beluga: programming with dependent types, contextual data, and contexts, In , Functional and Logic Programming, 10th International Symposium, {FLOPS} 2010, Sendai, Japan, April 19-21, 2010. Proceedings (pp. 1‚Äì12) (2010). : .

 48. cite:mizar_website !!! No entry found !!!

 49. cite:locales Ballarin, C., Locales and locale expressions in isabelle/isar, In , Types for Proofs and Programs, International Workshop, {TYPES} 2003, Torino, Italy, April 30 - May 4, 2003, Revised Selected Papers (pp. 34‚Äì50) (2003). : .

 50. cite:prl_site !!! No entry found !!!

 51. cite:girard_paradox Coquand, T., An analysis of girard's paradox, In , Proceedings of the Symposium on Logic in Computer Science {(LICS} '86), Cambridge, Massachusetts, USA, June 16-18, 1986 (pp. 227‚Äì236) (1986). : .

 52. cite:pvs_prover !!! No entry found !!!

 53. cite:twelf_site !!! No entry found !!!

 54. cite:lf_meta_mechanisation !!! No entry found !!!

 55. cite:lf_practical_modules Rabe, F., & Carsten Sch\"urmann, A practical module system for LF, In , Proceedings of the Fourth International Workshop on Logical Frameworks and Meta-Languages: Theory and Practice, {LFMTP} '09, McGill University, Montreal, Canada, August 2, 2009 (pp. 40‚Äì48) (2009). : .

 56. cite:matita_main Asperti, A., Coen, C. S., Tassi, E., & Zacchiroli, S., Crafting a proof assistant, In , Types for Proofs and Programs, International Workshop, {TYPES} 2006, Nottingham, UK, April 18-21, 2006, Revised Selected Papers (pp. 18‚Äì32) (2006). : .

 57. cite:dtl_imperative Nanevski, A., Morrisett, G., Shinnar, A., Govereau, P., & Birkedal, L., Ynot: dependent types for imperative programs, In , Proceeding of the 13th {ACM} {SIGPLAN} international conference on Functional programming, {ICFP} 2008, Victoria, BC, Canada, September 20-28, 2008 (pp. 229‚Äì240) (2008). : .

 58. cite:theories_as_types Dennis M\"uller, Rabe, F., & Kohlhase, M., Theories as types, In , Automated Reasoning - 9th International Joint Conference, {IJCAR} 2018, Held as Part of the Federated Logic Conference, FloC 2018, Oxford, UK, July 14-17, 2018, Proceedings (pp. 575‚Äì590) (2018). : .

 59. cite:tpc Carette, J., & O‚ÄôConnor, R., Theory Presentation Combinators, Intelligent Computer Mathematics, (), 202‚Äì215 (2012).  http://dx.doi.org/10.1007/978-3-642-31374-5_14

 60. cite:theory_interpretations_farmer  (Eds.),  (1993). : Springer-Verlag.

 61. cite:mlt_partial Palmgren, E., & Viggo Stoltenberg-Hansen, Domain interpretations of martin-l\"of's partial type theory, Ann. Pure Appl. Logic, 48(2), 135‚Äì196 (1990).  http://dx.doi.org/10.1016/0168-0072(90)90044-3

 62. cite:typeclasses_for_maths Spitters, B., & Weegen, E. v. d., Type classes for mathematics in type theory, Mathematical Structures in Computer Science, 21(4), 795‚Äì825 (2011).  http://dx.doi.org/10.1017/S0960129511000119

 63. cite:dtl_why !!! No entry found !!!

 64. cite:cats_logic_shulman !!! No entry found !!!

 65. cite:rig_computation !!! No entry found !!!

 66. cite:packaging_mathematical_structures Garillot, Fran\c cois, Gonthier, G., Mahboubi, A., & Rideau, L., Packaging Mathematical Structures, In T. Nipkow, & C. Urban, Theorem Proving in Higher Order Logics (pp. ) (2009). Munich, Germany: Springer.

 67. cite:realms !!! No entry found !!!

 68. cite:RATH !!! No entry found !!!

 69. cite:ambiguous_parsing Coen, C. S., & Zacchiroli, S., Efficient ambiguous parsing of mathematical formulae, Mathematical Knowledge Management, (), 347‚Äì362 (2004).  http://dx.doi.org/10.1007/978-3-540-27818-4_25

 70. cite:mathscheme !!! No entry found !!!

 71. cite:Norell-2007 Norell, U., Towards a practical programming language based on dependent type theory (Doctoral dissertation) (2007). Dept.\null{} Comp.\null{} Sci.\null{} and Eng., Chalmers Univ.\null{} of Technology, .

 72. cite:agda_std_lib !!! No entry found !!!

 73. cite:Hales-blog-post !!! No entry found !!!

 74. cite:Bird_2009 Bird, R., Thinking functionally with Haskell, , (),  (2009).  http://dx.doi.org/10.1017/cbo9781316092415

 75. cite:DBLP:conf/hopl/HudakHJW07 Hudak, P., Hughes, J., Simon L. Peyton Jones, & Wadler, P., A history of Haskell: being lazy with class, In B. G. Ryder, & B. Hailpern, Proceedings of the Third {ACM} {SIGPLAN} History of Programming Languages Conference (HOPL-III), San Diego, California, USA, 9-10 June 2007 (pp. 1‚Äì55) (2007). : ACM.

 76. cite:data_monoid !!! No entry found !!!

 77. cite:DBLP:journals/jfp/Swierstra08 Swierstra, W., Data types \`a la carte, J. Funct. Program., 18(4), 423‚Äì436 (2008).  http://dx.doi.org/10.1017/S0956796808006758

 78. cite:alhassy_thesis_proposal !!! No entry found !!!

 79. cite:10.5555/229872 Graham, P., Ansi Common Lisp (1995), USA: Prentice Hall Press.

 80. cite:DBLP:conf/europar/StanisicL14 Stanisic, L., & Legrand, A., Effective reproducible research with org-mode and git, In L. M. B. Lopes, J. Zilinskas, A. Costan, R. G. Cascella, G. Kecskemeti, E. Jeannot, M. Cannataro, L. Ricci, S. Benkner, S. Petit, V. Scarano, J. Gracia, S. Hunold, S. L. Scott, S. Lankes, C. Lengauer, J. Carretero, J. Breitbart, M. Alexander, .., Euro-Par 2014: Parallel Processing Workshops - Euro-Par 2014 International Workshops, Porto, Portugal, August 25-26, 2014, Revised Selected Papers, Part {I (pp. 475‚Äì486) (2014). : Springer.

 81. cite:10.5555/235337 Woodcock, J., & Davies, J., Using Z: specification, refinement, and proof (1996), USA: Prentice-Hall, Inc.

 82. cite:lof_constructive_math Martin-L\"of, P., Constructive mathematics and computer programming, In , Proc. Of a Discussion Meeting of the Royal Society of London on Mathematical Logic and Programming Languages (pp. 167‚Äì184) (1985). Upper Saddle River, NJ, USA: Prentice-Hall, Inc.

 83. cite:coq_website !!! No entry found !!!

 84. cite:coq_inductive_coc Pfenning, F., & Christine Paulin-Mohring, Inductively defined types in the calculus of constructions, In , Mathematical Foundations of Programming Semantics, 5th International Conference, Tulane University, New Orleans, Louisiana, USA, March 29 - April 1, 1989, Proceedings (pp. 209‚Äì228) (1989). : .

 85. cite:tactics Kamal Aboul-Hosn, A proof-theoretic approach to tactics, In , Mathematical Knowledge Management, 5th International Conference, {MKM} 2006, Wokingham, UK, August 11-12, 2006, Proceedings (pp. 54‚Äì66) (2006). : .

 86. cite:agda_iowa_book Stump, A., Verified functional programming in agda (2016), New York, NY, USA: Association for Computing Machinery and Morgan \&\#38; Claypool.

 87. cite:agda_docs !!! No entry found !!!

 88. cite:seven_hundred_langs Landin, P. J., The next 700 programming languages, Commun. {ACM, 9(3), 157‚Äì166 (1966).  http://dx.doi.org/10.1145/365230.365257

 89. cite:seven_hundred_tt_models Boulier, S., Pierre-Marie P\'edrot, & Tabareau, N., The next 700 syntactical models of type theory, In , Proceedings of the 6th {ACM} {SIGPLAN} Conference on Certified Programs and Proofs, {CPP} 2017, Paris, France, January 16-17, 2017 (pp. 182‚Äì194) (2017). : .

 90. cite:seven_hundred_provers Paulson, L. C., Isabelle: the next 700 theorem provers, CoRR, cs.LO/9301106(),  (1993).

 91. cite:seven_hundred_hoas Felty, A. P., Momigliano, A., & Pientka, B., The next 700 challenge problems for reasoning with higher-order abstract syntax representations - part 2 - A survey, J. Autom. Reasoning, 55(4), 307‚Äì372 (2015).  http://dx.doi.org/10.1007/s10817-015-9327-3

 92. cite:seven_hundred_libraries Ant\'onio Menezes Leit\~ao, The next 700 programming libraries, In , International Lisp Conference, {ILC} 2007, Cambridge, UK, April 1-4, 2007 (pp. 21) (2007). : .

 93. cite:seven_hundred_data Fisher, K., Mandelbaum, Y., & Walker, D., The next 700 data description languages, J. {ACM, 57(2), 10‚Äì1‚Äì10‚Äì51 (2010).  http://dx.doi.org/10.1145/1667053.1667059
