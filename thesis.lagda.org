#+title: Do-it-yourself Module Systems
# subtitle: We can change things later, but can't change it if there's nothing to change!

* COMMENT Story

1. There are a host of repeated module patterns since modules are not a first-class construct.
   - E.g., IsX and X in Agda's standard library.
   - E.g., Hom, and universal algebra constructs, /for/ a paraticular theory.     
   - E.g., common renaming patterns such as X_i or X' or etc for a theory X.
     - Cannot do this in Context due to Agda's limited support for fresh names.
     - Doable in PF.

2. To show that first-class modules are /reasonable/, we begin by providing
   PackageFormer: A specfication and manipulation language for modules.

   - Why Emacs Lisp? Super close to the Agda homebase.
   - Discuss how the issues in (1) are now doable.

3. The ideas learned from making the prototype lead us to form Context.
   - E.g., a termtype arises by keeping only the fields that target the elected ADT carrier.
   - Ideas of :waist!

4. Shallow comparision of PF and Context.

* COMMENT Outline

1. Motivating the problem
   - Where has this problem been encountered in the wild?
   - What benefits would there be to solving this problem?
   - Mention ~1 * x + 0 = x~ problem from the ICFP20 paper.  
     * Two monoidal units on the same carrier satisfy this law.

   Here is where the "STORY" is placed.

2. Background: What's necessary to solve this problem?
   - What is needed to just understand this problem?
   - Agda
   - System F
   - Monads
   - Metaprogramming

   Maybe tackle this "as needed", rather than upfront.  

3. PackageFormer
   - Why an editor extension? Why Lisp is reasonable?
   - Utility of a protottype?
   - Things learned from making a protottype?
     * Perhaps show the minimal code needed to get PF working; <= 300 lines?
     * Much more Lisp for implementing common grouping mechanisms; e.g., pushouts.
   - How usable is it?
   - What exotic notions of grouping mechanisms can be coded-up? Utilit!?
   - [Disadvantages of PackageFormer?
   - Comparision to other systems.

4. Contexts
   - Why PackageFormer is not enough.
   - Discuss Agda macros ---need to be self-contained.
   - Motivate the need for a practical syntax.
   - The reason it's a "do it yourself" system is that the semantics, >>=,
     can be tweaked easily for other forms of grouping besides Pi/Sigma ;-)
   - Current limitations; e.g., lack of termination/positivity of certain constructs;
     or how termtype generation requires the ADT carrier to be the first element
     of the sequence/context, whereas a DAG interpretation of Contexts would be better?
   - How does this compare with PF?
   - What are the benefits of Context?
   - Concrete problems its usage can solve.

5. Related works
   - Who has worked on this problem and where have they gotten?
   - What are their shortcomings and advantages wrt to our approach?
   - Shortcomings of our approach.
   - Missing features and next steps.

6. Conclusion
   - What we have done
   - How it is useful to others, now.

* Table of Contents                                    :Github:TOC_4:
- [[#examples-from-the-wild][Examples from the Wild]]
  - [[#renaming][Renaming]]
    - [[#renaming-problems-from-agdas-standard-library][Renaming Problems from Agda's Standard Library]]
    - [[#renaming-problems-from-the-rath-agda-library][Renaming Problems from the RATH-Agda Library]]
    - [[#renaming-problems-from-the-agda-categories-library][Renaming Problems from the Agda-categories Library]]

* Examples from the Wild

Tedium is for machines; interesting problems are for people.

In this section, we showcase a number of problems that occur in developing
libraries of code, with an eye to dependently-typed languages. We will refer
back to these real-world examples later on when developing our frameworks for
reducing their tedium and size.

** Renaming

The use of an idea is generally accompanied with particular notation that is
accepted by the community. Even though the choice of bound names it
theoretically irrelevant, certain communities would consider it unacceptable to
deviate from convention. Here are a few examples:

- ~x(f)~ :: Using ~x~ as a /function/ and ~f~ as an /argument/.; likewise $\frac{\partial x}{\partial f}$.

  With the exception of people familiar with the Yoneda Lemma, or continuations,
  such a notation is simply â€œwrongâ€!

- ~a Ã— a â‰ˆ a~ :: An idempotent operation denoted by multiplication; likewise for commutative operations.

  It is more common to use addition or join, ~âŠ”~.
    
- ~0 Ã— a â‰ˆ a~ :: The identity of â€œmultiplicative symbolsâ€ should never resemble
  â€œ0â€; instead it should resemble â€œ1â€ or, at least, ~â€œeâ€~ ---the standard
  abbreviation of the influential algebraic works of German authors who used
  â€œEinheitâ€ which means â€œidentityâ€.
  
- ~f + g~ :: Even if monoids are defined with the prototypical binary operation
  denoted â€œ+â€, it would be â€œwrongâ€ to continue using it to denote functional composition.
  One would need to introduce the new name â€œâˆ˜â€ or, at least, â€œÂ·â€.

From the few examples above, it is immediate that to even present a prototypical
notation for an idea, one immediately needs auxiliary notation when specialising
to a particular instance. For example, to use â€œadditive symbolsâ€ such as ~+, âŠ”,
âŠ•~ to denote an arbitrary binary operation leads to trouble in the function
composition instance above, whereas using â€œmultiplicative symbolsâ€ such as ~Ã—,
Â·, *~ leads to trouble in the idempotent case above. 

Regardless of prototypical choices, there will always be a need to rename.

Let's now turn to examples of renaming from three libraries:
1. Agda's standard library,
2. The RATH-Agda library, and
3. A recent categories library.

Each will provide a workaround to the problem of renaming. In particular, the
solutions are, respectively:

1. Rename as needed.
   - There is no systematic approach to account for the many common renamings.
   - Users are encouraged to do the same, since the standard library does it this way.
  
2. Pack-up the /common/ renamings as modules, and invoke them when needed.
   - Which renamings are provided is left at the discretion of the designer
     ---even â€œexpectedâ€ renamings may not be there since, say, there are too many
     choices or not enough man power to produce them.
   - The pattern to pack-up renamings leads nicely to consistent naming.

3. Names don't matter.
   - Users of the library need to be intimately connected with the definitions
     are domain to use the library.
   - Consequently, there are many inconsistencies in naming.     

*** Renaming Problems from Agda's Standard Library

[[http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Structures.html#2757][Here is an excerpt from Agda's standard library]], notice how the prototypical
notation for monoids is rename repeatedly /as needed/. Sometimes it is
relabelled with additive symbols, other times with multiplicative symbols.
#+BEGIN_SRC agda2
record IsNearSemiring {a â„“} {A : Set a} (â‰ˆ : Rel A â„“)
                      (+ * : Opâ‚‚ A) (0# : A) : Set (a âŠ” â„“) where
  open FunctionProperties â‰ˆ
  field
    +-isMonoid    : IsMonoid â‰ˆ + 0#
    *-isSemigroup : IsSemigroup â‰ˆ *
    distribÊ³      : * DistributesOverÊ³ +
    zeroË¡         : LeftZero 0# *

  open IsMonoid +-isMonoid public
         renaming ( assoc       to +-assoc
                  ; âˆ™-cong      to +-cong
                  ; isSemigroup to +-isSemigroup
                  ; identity    to +-identity
                  )

  open IsSemigroup *-isSemigroup public
         using ()
         renaming ( assoc    to *-assoc
                  ; âˆ™-cong   to *-cong
                  )

record IsSemiringWithoutOne {a â„“} {A : Set a} (â‰ˆ : Rel A â„“)
                            (+ * : Opâ‚‚ A) (0# : A) : Set (a âŠ” â„“) where
  open FunctionProperties â‰ˆ
  field
    +-isCommutativeMonoid : IsCommutativeMonoid â‰ˆ + 0#
    *-isSemigroup         : IsSemigroup â‰ˆ *
    distrib               : * DistributesOver +
    zero                  : Zero 0# *

  open IsCommutativeMonoid +-isCommutativeMonoid public
         hiding (identityË¡)
         renaming ( assoc       to +-assoc
                  ; âˆ™-cong      to +-cong
                  ; isSemigroup to +-isSemigroup
                  ; identity    to +-identity
                  ; isMonoid    to +-isMonoid
                  ; comm        to +-comm
                  )

  open IsSemigroup *-isSemigroup public
         using ()
         renaming ( assoc       to *-assoc
                  ; âˆ™-cong      to *-cong
                  )

record IsSemiringWithoutAnnihilatingZero
         {a â„“} {A : Set a} (â‰ˆ : Rel A â„“)
         (+ * : Opâ‚‚ A) (0# 1# : A) : Set (a âŠ” â„“) where
  open FunctionProperties â‰ˆ
  field
    +-isCommutativeMonoid : IsCommutativeMonoid â‰ˆ + 0#
    *-isMonoid            : IsMonoid â‰ˆ * 1#
    distrib               : * DistributesOver +

  open IsCommutativeMonoid +-isCommutativeMonoid public
         hiding (identityË¡)
         renaming ( assoc       to +-assoc
                  ; âˆ™-cong      to +-cong
                  ; isSemigroup to +-isSemigroup
                  ; identity    to +-identity
                  ; isMonoid    to +-isMonoid
                  ; comm        to +-comm
                  )

  open IsMonoid *-isMonoid public
         using ()
         renaming ( assoc       to *-assoc
                  ; âˆ™-cong      to *-cong
                  ; isSemigroup to *-isSemigroup
                  ; identity    to *-identity
                  )

record IsRing
         {a â„“} {A : Set a} (â‰ˆ : Rel A â„“)
         (_+_ _*_ : Opâ‚‚ A) (-_ : Opâ‚ A) (0# 1# : A) : Set (a âŠ” â„“) where
  open FunctionProperties â‰ˆ
  field
    +-isAbelianGroup : IsAbelianGroup â‰ˆ _+_ 0# -_
    *-isMonoid       : IsMonoid â‰ˆ _*_ 1#
    distrib          : _*_ DistributesOver _+_

  open IsAbelianGroup +-isAbelianGroup public
         renaming ( assoc               to +-assoc
                  ; âˆ™-cong              to +-cong
                  ; isSemigroup         to +-isSemigroup
                  ; identity            to +-identity
                  ; isMonoid            to +-isMonoid
                  ; inverse             to -â€¿inverse
                  ; â»Â¹-cong             to -â€¿cong
                  ; isGroup             to +-isGroup
                  ; comm                to +-comm
                  ; isCommutativeMonoid to +-isCommutativeMonoid
                  )

  open IsMonoid *-isMonoid public
         using ()
         renaming ( assoc       to *-assoc
                  ; âˆ™-cong      to *-cong
                  ; isSemigroup to *-isSemigroup
                  ; identity    to *-identity
                  )
#+END_SRC

At first glance, one solution would be to package up these renamings into helper modules:
#+BEGIN_SRC agda2
-- Orginal notations
--------------------------------------------------------------------------------
record IsMonoid {a â„“} {A : Set a} (â‰ˆ : Rel A â„“)
                (âˆ™ : Opâ‚‚ A) (Îµ : A) : Set (a âŠ” â„“) where
  open FunctionProperties â‰ˆ
  field
    isSemigroup : IsSemigroup â‰ˆ âˆ™
    identity    : Identity Îµ âˆ™

record IsCommutativeMonoid {a â„“} {A : Set a} (â‰ˆ : Rel A â„“)
                           (_âˆ™_ : Opâ‚‚ A) (Îµ : A) : Set (a âŠ” â„“) where
  open FunctionProperties â‰ˆ
  field
    isSemigroup : IsSemigroup â‰ˆ _âˆ™_
    identityË¡   : LeftIdentity Îµ _âˆ™_
    comm        : Commutative _âˆ™_

    â‹®
  isMonoid : IsMonoid â‰ˆ _âˆ™_ Îµ
  isMonoid = record { â‹¯ }

-- Renaming helpers
--------------------------------------------------------------------------------
module AdditiveIsMonoid {a â„“} {A : Set a} {â‰ˆ : Rel A â„“}
               {_âˆ™_ : Opâ‚‚ A} {Îµ : A} (+-isMonoid : IsMonoid â‰ˆ _âˆ™_ Îµ)  where

   open IsMonoid +-isMonoid public
         renaming ( assoc       to +-assoc
                  ; âˆ™-cong      to +-cong
                  ; isSemigroup to +-isSemigroup
                  ; identity    to +-identity
                  )              

module AdditiveIsCommutativeMonoid {a â„“} {A : Set a} {â‰ˆ : Rel A â„“}
               {_âˆ™_ : Opâ‚‚ A} {Îµ : A} (+-isCommutativeMonoid : IsMonoid â‰ˆ _âˆ™_ Îµ)  where

   open AdditiveIsMonoid (CommutativeMonoid.isMonoid +-isCommutativeMonoid) public
   open IsCommutativeMonoid +-isCommutativeMonoid public using () 
      renaming ( comm to +-comm
               ; isMonoid to +-isMonoid)
#+END_SRC
However, one then needs to make similar modules for /additive notation/ for
~IsAbelianGroup, IsRing, IsCommutativeRing, â€¦~. Moreover, this still invites
repetition: Additional notations, as used in ~IsSemiring~, would require
additional helper modules.
#+BEGIN_SRC agda2
module MultiplicativeIsMonoid {a â„“} {A : Set a} {â‰ˆ : Rel A â„“}
               {_âˆ™_ : Opâ‚‚ A} {Îµ : A} (*-isMonoid : IsMonoid â‰ˆ _âˆ™_ Îµ)  where

   open IsMonoid *-isMonoid public
         renaming ( assoc       to *-assoc
                  ; âˆ™-cong      to *-cong
                  ; isSemigroup to *-isSemigroup
                  ; identity    to *-identity
                  )              
#+END_SRC

Unless carefully organised, such notational modules would bloat the standard
library, resulting in difficulty when navigating the library. As it stands
however, the new algebraic structures appear large and complex due to the
â€œrenaming hellâ€ encountered to provide the expected conventional notation.

*** Renaming Problems from the RATH-Agda Library

The impressive [[http://relmics.mcmaster.ca/RATH-Agda/RATH-Agda-2.2.pdf][Relational Algebraic Theories in Agda]] library takes a disciplined
approach: Copy-paste notational modules, possibly using a find-replace mechanism
to vary the notation. The use of a find-replace mechanism leads to consistent naming
across different notations.

#+caption: Relation.Binary.Setoid.Utils
#+begin_quote
For contexts where calculation in different setoids is necessary, we provide
â€œdecoratedâ€ versions of the ~Setoidâ€²~ and ~SetoidCalc~ interfaces:
#+end_quote
#+BEGIN_SRC agda2
module SetoidA {i j : Level} (S : Setoid i j) = Setoidâ€² S renaming
    ( â„“ to â„“A ; Carrier to Aâ‚€ ; _â‰ˆ_ to _â‰ˆA_ ; â‰ˆ-isEquivalence to â‰ˆA-isEquivalence
    ; â‰ˆ-isPreorder to â‰ˆA-isPreorder ; â‰ˆ-preorder to â‰ˆA-preorder
    ; â‰ˆ-indexedSetoid to â‰ˆA-indexedSetoid
    ; â‰ˆ-refl to â‰ˆA-refl ; â‰ˆ-reflexive to â‰ˆA-reflexive ; â‰ˆ-sym to â‰ˆA-sym
    ; â‰ˆ-trans to â‰ˆA-trans ; â‰ˆ-transâ‚ to â‰ˆA-transâ‚ ; â‰ˆ-transâ‚‚ to â‰ˆA-transâ‚‚
    ; _âŸ¨â‰ˆâ‰ˆâŸ©_ to _âŸ¨â‰ˆAâ‰ˆâŸ©_ ; _âŸ¨â‰ˆâ‰ˆË˜âŸ©_ to _âŸ¨â‰ˆAâ‰ˆË˜âŸ©_ ; _âŸ¨â‰ˆË˜â‰ˆâŸ©_ to _âŸ¨â‰ˆAË˜â‰ˆâŸ©_ ; _âŸ¨â‰ˆË˜â‰ˆË˜âŸ©_ to _âŸ¨â‰ˆAË˜â‰ˆË˜âŸ©_
    ; _âŸ¨â‰¡â‰ˆâŸ©_ to _âŸ¨â‰¡â‰ˆAâŸ©_ ; _âŸ¨â‰¡â‰ˆË˜âŸ©_ to _âŸ¨â‰¡â‰ˆAË˜âŸ©_ ; _âŸ¨â‰¡Ë˜â‰ˆâŸ©_ to _âŸ¨â‰¡Ë˜â‰ˆAâŸ©_ ; _âŸ¨â‰¡Ë˜â‰ˆË˜âŸ©_ to _âŸ¨â‰¡Ë˜â‰ˆAË˜âŸ©_
    ; _âŸ¨â‰ˆâ‰¡âŸ©_ to _âŸ¨â‰ˆAâ‰¡âŸ©_ ; _âŸ¨â‰ˆâ‰¡Ë˜âŸ©_ to _âŸ¨â‰ˆAâ‰¡Ë˜âŸ©_ ; _âŸ¨â‰ˆË˜â‰¡âŸ©_ to _âŸ¨â‰ˆAË˜â‰¡âŸ©_ ; _âŸ¨â‰ˆË˜â‰¡Ë˜âŸ©_ to _âŸ¨â‰ˆAË˜â‰¡Ë˜âŸ©_
    )

module SetoidB {i j : Level} (S : Setoid i j) = Setoidâ€² S renaming
    ( â„“ to â„“B ; Carrier to Bâ‚€ ; _â‰ˆ_ to _â‰ˆB_ ; â‰ˆ-isEquivalence to â‰ˆB-isEquivalence
    ; â‰ˆ-isPreorder to â‰ˆB-isPreorder ; â‰ˆ-preorder to â‰ˆB-preorder
    ; â‰ˆ-indexedSetoid to â‰ˆB-indexedSetoid
    ; â‰ˆ-refl to â‰ˆB-refl ; â‰ˆ-reflexive to â‰ˆB-reflexive ; â‰ˆ-sym to â‰ˆB-sym
    ; â‰ˆ-trans to â‰ˆB-trans ; â‰ˆ-transâ‚ to â‰ˆB-transâ‚ ; â‰ˆ-transâ‚‚ to â‰ˆB-transâ‚‚
    ; _âŸ¨â‰ˆâ‰ˆâŸ©_ to _âŸ¨â‰ˆBâ‰ˆâŸ©_ ; _âŸ¨â‰ˆâ‰ˆË˜âŸ©_ to _âŸ¨â‰ˆBâ‰ˆË˜âŸ©_ ; _âŸ¨â‰ˆË˜â‰ˆâŸ©_ to _âŸ¨â‰ˆBË˜â‰ˆâŸ©_ ; _âŸ¨â‰ˆË˜â‰ˆË˜âŸ©_ to _âŸ¨â‰ˆBË˜â‰ˆË˜âŸ©_
    ; _âŸ¨â‰¡â‰ˆâŸ©_ to _âŸ¨â‰¡â‰ˆBâŸ©_ ; _âŸ¨â‰¡â‰ˆË˜âŸ©_ to _âŸ¨â‰¡â‰ˆBË˜âŸ©_ ; _âŸ¨â‰¡Ë˜â‰ˆâŸ©_ to _âŸ¨â‰¡Ë˜â‰ˆBâŸ©_ ; _âŸ¨â‰¡Ë˜â‰ˆË˜âŸ©_ to _âŸ¨â‰¡Ë˜â‰ˆBË˜âŸ©_
    ; _âŸ¨â‰ˆâ‰¡âŸ©_ to _âŸ¨â‰ˆBâ‰¡âŸ©_ ; _âŸ¨â‰ˆâ‰¡Ë˜âŸ©_ to _âŸ¨â‰ˆBâ‰¡Ë˜âŸ©_ ; _âŸ¨â‰ˆË˜â‰¡âŸ©_ to _âŸ¨â‰ˆBË˜â‰¡âŸ©_ ; _âŸ¨â‰ˆË˜â‰¡Ë˜âŸ©_ to _âŸ¨â‰ˆBË˜â‰¡Ë˜âŸ©_
    )

module SetoidC {i j : Level} (S : Setoid i j) = Setoidâ€² S renaming
    ( â„“ to â„“C ; Carrier to Câ‚€ ; _â‰ˆ_ to _â‰ˆC_ ; â‰ˆ-isEquivalence to â‰ˆC-isEquivalence
    ; â‰ˆ-isPreorder to â‰ˆC-isPreorder ; â‰ˆ-preorder to â‰ˆC-preorder
    ; â‰ˆ-indexedSetoid to â‰ˆC-indexedSetoid
    ; â‰ˆ-refl to â‰ˆC-refl ; â‰ˆ-reflexive to â‰ˆC-reflexive ; â‰ˆ-sym to â‰ˆC-sym
    ; â‰ˆ-trans to â‰ˆC-trans ; â‰ˆ-transâ‚ to â‰ˆC-transâ‚ ; â‰ˆ-transâ‚‚ to â‰ˆC-transâ‚‚
    ; _âŸ¨â‰ˆâ‰ˆâŸ©_ to _âŸ¨â‰ˆCâ‰ˆâŸ©_ ; _âŸ¨â‰ˆâ‰ˆË˜âŸ©_ to _âŸ¨â‰ˆCâ‰ˆË˜âŸ©_ ; _âŸ¨â‰ˆË˜â‰ˆâŸ©_ to _âŸ¨â‰ˆCË˜â‰ˆâŸ©_ ; _âŸ¨â‰ˆË˜â‰ˆË˜âŸ©_ to _âŸ¨â‰ˆCË˜â‰ˆË˜âŸ©_
    ; _âŸ¨â‰¡â‰ˆâŸ©_ to _âŸ¨â‰¡â‰ˆCâŸ©_ ; _âŸ¨â‰¡â‰ˆË˜âŸ©_ to _âŸ¨â‰¡â‰ˆCË˜âŸ©_ ; _âŸ¨â‰¡Ë˜â‰ˆâŸ©_ to _âŸ¨â‰¡Ë˜â‰ˆCâŸ©_ ; _âŸ¨â‰¡Ë˜â‰ˆË˜âŸ©_ to _âŸ¨â‰¡Ë˜â‰ˆCË˜âŸ©_
    ; _âŸ¨â‰ˆâ‰¡âŸ©_ to _âŸ¨â‰ˆCâ‰¡âŸ©_ ; _âŸ¨â‰ˆâ‰¡Ë˜âŸ©_ to _âŸ¨â‰ˆCâ‰¡Ë˜âŸ©_ ; _âŸ¨â‰ˆË˜â‰¡âŸ©_ to _âŸ¨â‰ˆCË˜â‰¡âŸ©_ ; _âŸ¨â‰ˆË˜â‰¡Ë˜âŸ©_ to _âŸ¨â‰ˆCË˜â‰¡Ë˜âŸ©_
    )
#+END_SRC

This keeps going to cover the alphabet ~SetoidD, SetoidE, SetoidF, â€¦, SetoidZ~
then we shift to subscripted versions ~Setoidâ‚€, Setoidâ‚, â€¦, Setoidâ‚„~. 

Next, RATH-Agda shifts to the need to calculate with setoids:
#+BEGIN_SRC agda2
module SetoidCalcA {i j : Level} (S : Setoid i j) where
  open SetoidA S public
  open SetoidCalc S public renaming
    ( _â–¡ to _â–¡A
    ; _â‰ˆâŸ¨_âŸ©_ to _â‰ˆAâŸ¨_âŸ©_
    ; _â‰ˆË˜âŸ¨_âŸ©_ to _â‰ˆAË˜âŸ¨_âŸ©_
    ; _â‰ˆâ‰¡âŸ¨_âŸ©_ to _â‰ˆAâ‰¡âŸ¨_âŸ©_
    ; _â‰ˆâŸ¨âŸ©_ to _â‰ˆAâŸ¨âŸ©_
    ; _â‰ˆâ‰¡Ë˜âŸ¨_âŸ©_ to _â‰ˆAâ‰¡Ë˜âŸ¨_âŸ©_
    ; â‰ˆ-begin_ to â‰ˆA-begin_
    )
module SetoidCalcB {i j : Level} (S : Setoid i j) where
  open SetoidB S public
  open SetoidCalc S public renaming
    ( _â–¡ to _â–¡B
    ; _â‰ˆâŸ¨_âŸ©_ to _â‰ˆBâŸ¨_âŸ©_
    ; _â‰ˆË˜âŸ¨_âŸ©_ to _â‰ˆBË˜âŸ¨_âŸ©_
    ; _â‰ˆâ‰¡âŸ¨_âŸ©_ to _â‰ˆBâ‰¡âŸ¨_âŸ©_
    ; _â‰ˆâŸ¨âŸ©_ to _â‰ˆBâŸ¨âŸ©_
    ; _â‰ˆâ‰¡Ë˜âŸ¨_âŸ©_ to _â‰ˆBâ‰¡Ë˜âŸ¨_âŸ©_
    ; â‰ˆ-begin_ to â‰ˆB-begin_
    )
module SetoidCalcC {i j : Level} (S : Setoid i j) where
  open SetoidC S public
  open SetoidCalc S public renaming
    ( _â–¡ to _â–¡C
    ; _â‰ˆâŸ¨_âŸ©_ to _â‰ˆCâŸ¨_âŸ©_
    ; _â‰ˆË˜âŸ¨_âŸ©_ to _â‰ˆCË˜âŸ¨_âŸ©_
    ; _â‰ˆâ‰¡âŸ¨_âŸ©_ to _â‰ˆCâ‰¡âŸ¨_âŸ©_
    ; _â‰ˆâŸ¨âŸ©_ to _â‰ˆCâŸ¨âŸ©_
    ; _â‰ˆâ‰¡Ë˜âŸ¨_âŸ©_ to _â‰ˆCâ‰¡Ë˜âŸ¨_âŸ©_
    ; â‰ˆ-begin_ to â‰ˆC-begin_
    )
#+END_SRC
This keeps going to cover the alphabet ~SetoidCalcD, SetoidCalcE, SetoidCalcF, â€¦, SetoidCalcZ~
then we shift to subscripted versions ~SetoidCalcâ‚€, SetoidCalcâ‚, â€¦, SetoidCalcâ‚„~.
If we ever have more than 4 setoids in hand, or prefer other decorations, then
we would need to produce similar helper modules.
| Each ~Setoidğ’³ğ’³ğ’³~ takes 10 lines, for a total of at-least 600 lines! |

Indeed, such renamings bloat the library, but, unlike the Standard Library, they
allow new records to be declared easily ---â€œrenaming hellâ€ has been deferred
from the user to the library designer. However, later on, in ~Categoric.CompOp~,
we see the variations ~LocalEdgeSetoidğ’Ÿ~ and ~LocalSetoidCalcğ’Ÿ~ where decoration
~ğ’Ÿ~ ranges over ~â‚€, â‚, â‚‚, â‚ƒ, â‚„, R~. The inconsistency in not providing the other
decorations used for ~Setoidğ““~ earlier is understandable: These take time to
write and maintain.

Various similar decorations can be found in RATH, such as for ~Semigroupoidğ’Ÿ~ in
~Categoric.Semigroupoid~.

*** Renaming Problems from the Agda-categories Library

With RATH-Agda's focus on notational modules at one end of the spectrum, and the
Standard Library's casual do-as-needed in the middle, it is inevitable that
there are other equally popular libraries but at the other end of the spectrum.
The [[https://github.com/agda/agda-categories][Agda-categories]] library seemingly ignored the need for meaningful names
altogether! Below are a few notable instances.

+ Functors have fields named ~Fâ‚€, Fâ‚, F-resp-â‰ˆ, â€¦~.
  - This could be considered reasonable even if one has a functor named ~G~.
  - This [[https://github.com/agda/agda-categories/blob/master/src/Categories/Category/Product.agda][leads to expressions]] such as ~< F.Fâ‚€ , G.Fâ‚€ >~.
  - Incidentally, and somewhat inconsistently, a ~Pseudofunctor~ has fields ~Pâ‚€,
    Pâ‚, P-homomophism~ ---where the latter is documented /P preserves â‰ƒ/.

  On the opposite extreme, RATH-Agda's importance on naming has it functor record
  having fields named ~obj, mor, mor-cong~ instead of ~Fâ‚€, Fâ‚, F-resp-â‰ˆ~
  ---which refer to a functor's â€œobjâ€ect map, â€œmorâ€phism map, and the fact that the
  â€œmorâ€phism map is a â€œcongâ€ruence.

+ Such lack of concern for naming might be acceptable for well-known concepts
  such as functors, where some communities use ~Fáµ¢~ to denote the object/0 or
  morphism/1 operations. However, considering [[https://github.com/agda/agda-categories/blob/master/src/Categories/Category/SubCategory.agda][subcategories]] one is sees field
  names ~U, R, Rid, _âˆ˜R_~ which are wholly unhelpful. Instead, more meaningful
  names such as ~embed, keep, id-kept, keep-resp-âˆ˜~ could have been used.

+ The ~Iso, Inverse,~ and ~NaturalIsomorphism~ records have fields ~to / from, f
  / fâ»Â¹,~ and ~~Fâ‡’G / Fâ‡G~, respectively.

  #  ( ~Categories.Category~ )

  Even though some of these build on one another, with Agda's namespacing
  features, all â€œforwardâ€ and â€œbackwardâ€ morphism fields could have been named,
  say, ~to~ and ~from~. The naming may not have propagated from ~Iso~ to other
  records possibly due to the low priority for names.

  From a usability perspective, projections like ~f~ are reminiscent of the OCaml
  community and may be more acceptable there. Since Agda is more likely to attract
  Haskell programmers than OCaml ones, such a particular projection seems completely
  our of place. Likewise, the field name ~Fâ‡’G~ seems only appropriate if the
  functors involved happen to be named ~F~ and ~G~.

  These unexpected deviations are not too surprising since the Agda-categories
  library seems to give names no priority at all. Field projections are treated
  little more than classic array indexing with numbers.


By largely avoiding renaming, Agda-categories has no â€œrenaming hellâ€ anywhere at
the heavy price of being difficult to read: Any attempt to read code requires
one to â€œsquint awayâ€ the numerous projections to â€œseeâ€ the concepts of
relevance. Consider the [[https://github.com/agda/agda-categories/blob/master/src/Categories/Yoneda.agda][following excerpt]].
#+BEGIN_SRC agda
helper : âˆ€ {F : Functor (Category.op C) (Setoids â„“ e)}
                     {A B : Obj} (f : B â‡’ A)
                     (Î² Î³ : NaturalTransformation Hom[ C ][-, A ] F) â†’
                   Setoid._â‰ˆ_ (Fâ‚€ Nat[Hom[C][-,c],F] (F , A)) Î² Î³ â†’
                   Setoid._â‰ˆ_ (Fâ‚€ F B) (Î· Î² B âŸ¨$âŸ© f âˆ˜ id) (Fâ‚ F f âŸ¨$âŸ© (Î· Î³ A âŸ¨$âŸ© id))
          helper {F} {A} {B} f Î² Î³ Î²â‰ˆÎ³ = S.begin
            Î· Î² B âŸ¨$âŸ© f âˆ˜ id          S.â‰ˆâŸ¨ cong (Î· Î² B) (id-comm â—‹ (âŸº identityË¡)) âŸ©
            Î· Î² B âŸ¨$âŸ© id âˆ˜ id âˆ˜ f     S.â‰ˆâŸ¨ commute Î² f CE.refl âŸ©
            Fâ‚ F f âŸ¨$âŸ© (Î· Î² A âŸ¨$âŸ© id) S.â‰ˆâŸ¨ cong (Fâ‚ F f) (Î²â‰ˆÎ³ CE.refl) âŸ©
            Fâ‚ F f âŸ¨$âŸ© (Î· Î³ A âŸ¨$âŸ© id) S.âˆ
            where module S where
                    open Setoid (Fâ‚€ F B) public
                    open SetoidR (Fâ‚€ F B) public
#+END_SRC

Here are a few downsides of not renaming:

1. The type of the function is difficult to comprehend; though it need not be.
   - Take ~_â‰ˆâ‚€_ = Setoid._â‰ˆ_ (Fâ‚€ Nat[Hom[C][-,c],F] (F , A))~, and
   - Take ~_â‰ˆâ‚_ = Setoid._â‰ˆ_ (Fâ‚€ F B)~,
   - Then the type says: If ~Î² â‰ˆâ‚€ Î³~ then 
     ~Î· Î² B âŸ¨$âŸ© f âˆ˜ id â‰ˆâ‚ Fâ‚ F f âŸ¨$âŸ© (Î· Î³ A âŸ¨$âŸ© id)~
     ---a naturality condition!

2. The short proof is difficult to read!
   - The repeated terms such as ~Î· Î² B~ and ~Î· Î² A~ could have been renamed with
     mnemoic-names such as ~Î·â‚, Î·â‚‚~ or ~Î·â‚›, Î·â‚œ~ for â€˜sâ€™ource/1 and â€˜tâ€™arget/2.

Recall that functors ~F~ have projections ~Fáµ¢~, so the â€œmorâ€phism map on a given
morphism ~f~ becomes ~Fâ‚ F f~, as in the excerpt above; however, using
RATH-Agda's naming it would have been ~mor F f~.

Since names are given a lower priority, one no longer needs to perform renaming.
Instead, one is content with projections. The downside is now there are too many
projections, leaving code difficult to comprehend. Moreover, this leads to
inconsistent renaming.

* COMMENT More pointers
*** TODO From IsX to X ---Packing away components

Agda's standard library explicitly documents two forms to common structures:
1. /Some algebraic structures (not packed up with sets, operations, etc./
   - http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Structures.html#1
2. /Definitions of algebraic structures like monoids and rings (packed in
   records together with sets, operations, etc.)/
   - http://www.cse.chalmers.se/~nad/listings/lib/Algebra.html#1

#+BEGIN_SRC agda2
record IsSemigroup {a â„“} {A : Set a} (â‰ˆ : Rel A â„“)
                   (âˆ™ : Opâ‚‚ A) : Set (a âŠ” â„“) where
  open FunctionProperties â‰ˆ
  field
    isEquivalence : IsEquivalence â‰ˆ
    assoc         : Associative âˆ™
    âˆ™-cong        : âˆ™ Preservesâ‚‚ â‰ˆ âŸ¶ â‰ˆ âŸ¶ â‰ˆ

record Semigroup c â„“ : Set (suc (c âŠ” â„“)) where
  infixl 7 _âˆ™_
  infix  4 _â‰ˆ_
  field
    Carrier     : Set c
    _â‰ˆ_         : Rel Carrier â„“
    _âˆ™_         : Opâ‚‚ Carrier
    isSemigroup : IsSemigroup _â‰ˆ_ _âˆ™_
#+END_SRC

Similarly for ~X~ being: ~Monoid, Group, AbelianGroup, CommutativeMonoid,~
~SemigroupWithoutOne, NearSemiring, Semiring, CommutativeSemiringWithoutOne,
CommutativeSemiring, CommutativeRing~.

It thus seems that to present an idea ~X~, we require the same amount of space
to present it unpacked or packed, and so doing both duplicates the process
and only hints at the underlying principle: From ~IsX~ we pack away the carriers
and function symbols to ~X~.

These examples are from the standard library: http://www.cse.chalmers.se/~nad/listings/lib/Algebra.html#601

*** TODO Design Patterns as Library Methods

The homomorphism construction
-- See http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Morphism.html#1
which only presents ~An example showing how a morphism type can be defined~!
+ Why?
+ The procedure is essentially the same for other algebraic structures.
+ It takes time to do form these explicitly, even for the common structures.
+ An example, rather than a library method, is rather unreasonable.

This is Agda's ~Algebra.Morphism~ â€œlibraryâ€!
** TODO One

Think of a language that does not support currying and you need to have a
function of 10 arguments that needs to support accepting any number of arguments
less than 10, say for partial application. In such languages, one must utilise
the builder design pattern, or quickly copy-paste the function 10 times,
altering it slightly each time. In general, if such a function definition
requires N lines and M forms of the function are needed, then nearly N Ã— M lines
of code are written manually.

** TODO Two
Design patterns for theories become library methods! An interesting side-effect
of having meta-primitives for packages is that traditional patterns for theories
â€”e.g., homomorphisms, syntax, interpretation functionsâ€” can now be codified as
general re-usable methods.

** TODO Four

What is the definition of a monoid? ---See GPCE19 paper

** TODO Five :PF:

The extension problem: Monoid to CommutativeMonoid

- Even JavaScript provides { ...obj, newkey: value } to extend items
- Or inheritance in Python
- or subclassing in Haskell

** TODO Six  :PF:

- Unions
- Duality
- Extracting Little Theories
- See Â§3.10

** TODO Seven

The exclusion problem: Dropping fields from too rich/experssive settings
---interface segresgation principle. The former may make certain things easier, but
one could have a more minimal form being the latter.

E.g., In Agda's standard categories library one can find ~ğ’³Helper~, for some notions
~ğ’³~, which provides a minimised version since ~ğ’³~ has derivable fields.
- E.g., category comes this way
  - https://github.com/agda/agda-categories/blob/master/src/Categories/Category/Core.agda
  #+begin_quote
  Since we add extra proofs in the definition of `Category` (i.e. `sym-assoc` and
  `identityÂ²`), we might still want to construct a `Category` in its originally
  easier manner. Thus, this redundant definition is here to ease the construction.
  #+end_quote
- E.g., natural isomorphism comes this way
  - https://github.com/agda/agda-categories/blob/master/src/Categories/NaturalTransformation/NaturalIsomorphism.agda
  #+begin_quote
  This helper definition lets us specify only one of the commuting
  squares and have the other one derived.
  #+end_quote

  Incidentally, since this is not a library method, inconsitencies are bound to arise.

  The orginal is named ~NaturalIsomorphism~ and we would expect to see
  ~NaturalIsomorphismHelper~, but instead it is ~NIHelper~.

  Such issues could be reduced, if not avoided, if we used library methods.

- E.g., symmetric monoidal categories ---with inconsistent naming
  ~Symmetricâ€²~ for the larger and ~Symmetric~ for the helper!
  #+begin_quote
  it requires again a redundant hexagon proof which allows achieves definitional
equality of the opposite.
  #+end_quote

  ( Since names are given a low priority, the brading operation is simply called
  ~B~! A symbol closer to the standard model, inverses ~_â»Â¹~, such as ~_Ë˜~ may
  have been more suggestive. )

  - https://github.com/agda/agda-categories/blob/master/src/Categories/Category/Monoidal/Symmetric.agda

** COMMENT Misc

The user manual, among other things, shows how we can avoid the open â‹¯ public â‹¯
renaming â‹¯ pattern which plagues Agda's standard library â€”and is much more
pronounced in the RATH-Agda, which devotes p27-39 for simple setoid renaming and
does much more elsewhereâ€”, as well as showing how to avoid laborious, yet
tedious, definitions of homomorphisms in Agda's library. Moreover, the
motivating factor of this work is to avoid the pattern of defining a predicate
IsX câ‚€ â‹¯ câ‚™ on constituents cáµ¢ then packaging the constituents along with a
proof of this predicate as a record X.

* TODO COMMENT Abstract [100%]

* COMMENT Introduction

   A fundamental argument for the use of module systems in the design of large
 programs is that the structure of the program is partitioned into coherent
 semantical units that are furnished with an interface belying the complexity of
 their implementations. A well-established example is the use of the humble
 record to â€˜bundleâ€™ up the extensional properties of an object; here one works
 with objects as if they were atomic, rather than considering the
 collection of their identifying properties.  Users of dependently-typed
 languages like Agda and Coq will argue strongly that the effective use of
 module systems is extremely important for subsequent program development, and
 even users of dynamically typed languages like Javascript will admit that, for
 example, namespace violations are an area of concern.  A fundamental aspect of
 =PackageFormer= is that the relationship between a grouping mechanism and its
 constituent structuring sub-grouping mechanisms is made explicit: One extracts
 grouping mechanisms from declarations involving existing grouping mechanisms.
 In contrast to type theory wherein a type is specified by characterising how
 its elements may be formed, our approach allows both the building-up of
 grouping mechanisms from their parts and, also, the â€˜tearing downâ€™ of parts of
 existing grouping mechanisms ---as is the case of dropping a property from a
 record type to obtain another record type, or of transforming a record type
 into an algebraic data type.  Depending on their nature, grouping
 specifications may either allow the automatic derivation of â€˜introduction
 rulesâ€™ wherein the teared-down grouping is transformed into the new grouping,
 or allow â€˜elimination rulesâ€™ wherein the individual groupings that built-up the
 new grouping can be identified.  The semantics of a grouping specification
 is essentially the â€˜flatteningâ€™ of properties that extensionally constitute it.
 Our work describes the necessary primitives that allow grouping declarations.

 The intention is not to provide a fixed set of general-purpose grouping
 combinators that are sufficient to encompass all the future needs of all
 programmers but to provide a small kerneal of â€˜meta-primitivesâ€™ whereby
 programmers may invent their own grouping mechanisms peculiar to their own
 problem domain.

* TODO COMMENT Review of Related Work [0%]
   --Remaining Tasks--
 + [ ] â€¦
 + [ ] â€¦
 + [ ] â€¦
 + [ ] â€¦
* TODO COMMENT Our Approach [0%]
 --Remaining Tasks--
 + [ ] Plan of Attack
 + [ ] Implementation Details
 + [ ] Discussion of Results
 + [ ] Future Work

* TODO COMMENT Conclusions [0%]
   --Remaining Tasks--
 + [ ] â€¦
 + [ ] â€¦
 + [ ] â€¦
 + [ ] â€¦

* COMMENT What's a thesis? [0%]
  + [ ] The argument
    - What is it? Is it being argued clearly?
    - What's the plan?
  + [ ] An exposition of an orginal piece of research.
  + [ ] Distinctive contribution to the knowledge of the subject?
  + [ ] Evidence of orginality shown by the discovery of new facts?
  + [ ] How is the research best appreciated?
  + [ ] Ideas not mentioned in the thesis might as well not exist! Mention ideas.

* COMMENT Planning an Argument [0%]
  One sentence for each:
  + [ ] Introduction to the area of study.
  + [ ] The problem being tackled.
  + [ ] What the literature says about the problem.
    - A review of previous work shows you know the subject.
    - Besides being descriptive, the review needs to be critical.
    - Summary of the essential features of other work as it relates to this study.
  + [ ] How /I/ tackle this problem.
    - What is the philosophy of approach?
    - How were you systematic?
    - How is this linked back to the literature review?
  + [ ] How /I/ implement my solution.
    - Provide details so that others can follow what was done.
    - Justify the approach taken.
    - Does the software appear to work satisfcatorily?
  + [ ] The result.
    - Application of the approach reduces thousands of lines of code to
      human-readable specfications with an extensible system?
    - *Link back to how the solutions obtained relate to the questions posed?*
    - Accurately identitfy & summarise patterns or trends in the results.
    - Provide a critical analysis to show you know its limitations.
    - â€˜Future Workâ€™ to show what's missing.
    - Beware of specfulations not grounded in the results.
  + [ ] Conclusion ---repetition of the intro, but with reference to the detail.

  An outline acts as a workplan for which the entire research process is an
  exercise addressing each item. Each item becomes at least one section in
  the writeup.

  + [ ] Set out clearly what each chapter should say.

* COMMENT Say everything thrice [0%]

  It's not repetition, but linking and rationale.

  + [ ] In the thesis as a whole.
    - [ ] Introduction - What the thesis will say.
    - [ ] Body - Details of the work.
    - [ ] Conclusion - What the thesis said.

  + [ ] Within each chapter/section.
    - [ ] Signposting - What this section says.
    - [ ] Body - The details.
    - [ ] Summary - What this section has said.

  + [ ] Within each paragraph.
    - [ ] Each paragraph describes a single idea.
    - [ ] The first sentence introduces the idea ---linking it with the previous one.
    - [ ] The last sentence concludes the idea ---linking it with the next one.

  Signposts ensure it's clear what's being discussed and why
  ---from a writer's perspective, they help get the contents right.

* COMMENT The Examiner's View

  They'll read it in meetings, trains, or planes.
  They're busy and an initial scan may be:

  1. abstract - what's it about?
  2. bibliography - Does it cite the right stuff? Has it been published already?
  3. conclusions - What was achieved? Do I believe it?
  4. contents listing - Is everything there? Is the argument clear?

  Weakeness in these locations might suggest large corrections.

  + [ ] Run spellchecking everywhere.
  + [ ] Run the grammar checker as well.

* COMMENT What If I'm stuck?

  1. The task at hand may be too difficult.
  2. *Ask for help!*
  3. Change the plan.
  4. Cut away irrelevant bits.
