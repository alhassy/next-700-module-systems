#+title: Do-it-yourself Module Systems
# subtitle: We can change things later, but can't change it if there's nothing to change!

* Story

1. There are a host of repeated module patterns since modules are not a first-class construct.
   - E.g., IsX and X in Agda's standard library.
   - E.g., Hom, and universal algebra constructs, /for/ a paraticular theory.     
   - E.g., common renaming patterns such as X_i or X' or etc for a theory X.
     - Cannot do this in Context due to Agda's limited support for fresh names.
     - Doable in PF.

2. To show that first-class modules are /reasonable/, we begin by providing
   PackageFormer: A specfication and manipulation language for modules.

   - Why Emacs Lisp? Super close to the Agda homebase.
   - Discuss how the issues in (1) are now doable.

3. The ideas learned from making the prototype lead us to form Context.
   - E.g., a termtype arises by keeping only the fields that target the elected ADT carrier.
   - Ideas of :waist!

4. Shallow comparision of PF and Context.

* Outline

1. Motivating the problem
   - Where has this problem been encountered in the wild?
   - What benefits would there be to solving this problem?
   - Mention ~1 * x + 0 = x~ problem from the ICFP20 paper.  
     * Two monoidal units on the same carrier satisfy this law.

   Here is where the "STORY" is placed.

2. Background: What's necessary to solve this problem?
   - What is needed to just understand this problem?
   - Agda
   - System F
   - Monads
   - Metaprogramming

   Maybe tackle this "as needed", rather than upfront.  

3. PackageFormer
   - Why an editor extension? Why Lisp is reasonable?
   - Utility of a protottype?
   - Things learned from making a protottype?
     * Perhaps show the minimal code needed to get PF working; <= 300 lines?
     * Much more Lisp for implementing common grouping mechanisms; e.g., pushouts.
   - How usable is it?
   - What exotic notions of grouping mechanisms can be coded-up? Utilit!?
   - [Disadvantages of PackageFormer?
   - Comparision to other systems.

4. Contexts
   - Why PackageFormer is not enough.
   - Discuss Agda macros ---need to be self-contained.
   - Motivate the need for a practical syntax.
   - The reason it's a "do it yourself" system is that the semantics, >>=,
     can be tweaked easily for other forms of grouping besides Pi/Sigma ;-)
   - Current limitations; e.g., lack of termination/positivity of certain constructs;
     or how termtype generation requires the ADT carrier to be the first element
     of the sequence/context, whereas a DAG interpretation of Contexts would be better?
   - How does this compare with PF?
   - What are the benefits of Context?
   - Concrete problems its usage can solve.

5. Related works
   - Who has worked on this problem and where have they gotten?
   - What are their shortcomings and advantages wrt to our approach?
   - Shortcomings of our approach.
   - Missing features and next steps.

6. Conclusion
   - What we have done
   - How it is useful to others, now.

* TODO COMMENT Abstract [100%]

* COMMENT Table of Contents                                    :Github:TOC_4:
- [[#introduction][Introduction]]

* COMMENT Introduction

   A fundamental argument for the use of module systems in the design of large
 programs is that the structure of the program is partitioned into coherent
 semantical units that are furnished with an interface belying the complexity of
 their implementations. A well-established example is the use of the humble
 record to ‘bundle’ up the extensional properties of an object; here one works
 with objects as if they were atomic, rather than considering the
 collection of their identifying properties.  Users of dependently-typed
 languages like Agda and Coq will argue strongly that the effective use of
 module systems is extremely important for subsequent program development, and
 even users of dynamically typed languages like Javascript will admit that, for
 example, namespace violations are an area of concern.  A fundamental aspect of
 =PackageFormer= is that the relationship between a grouping mechanism and its
 constituent structuring sub-grouping mechanisms is made explicit: One extracts
 grouping mechanisms from declarations involving existing grouping mechanisms.
 In contrast to type theory wherein a type is specified by characterising how
 its elements may be formed, our approach allows both the building-up of
 grouping mechanisms from their parts and, also, the ‘tearing down’ of parts of
 existing grouping mechanisms ---as is the case of dropping a property from a
 record type to obtain another record type, or of transforming a record type
 into an algebraic data type.  Depending on their nature, grouping
 specifications may either allow the automatic derivation of ‘introduction
 rules’ wherein the teared-down grouping is transformed into the new grouping,
 or allow ‘elimination rules’ wherein the individual groupings that built-up the
 new grouping can be identified.  The semantics of a grouping specification
 is essentially the ‘flattening’ of properties that extensionally constitute it.
 Our work describes the necessary primitives that allow grouping declarations.

 The intention is not to provide a fixed set of general-purpose grouping
 combinators that are sufficient to encompass all the future needs of all
 programmers but to provide a small kerneal of ‘meta-primitives’ whereby
 programmers may invent their own grouping mechanisms peculiar to their own
 problem domain.

* TODO COMMENT Review of Related Work [0%]
   --Remaining Tasks--
 + [ ] …
 + [ ] …
 + [ ] …
 + [ ] …
* TODO COMMENT Our Approach [0%]
 --Remaining Tasks--
 + [ ] Plan of Attack
 + [ ] Implementation Details
 + [ ] Discussion of Results
 + [ ] Future Work

* TODO COMMENT Conclusions [0%]
   --Remaining Tasks--
 + [ ] …
 + [ ] …
 + [ ] …
 + [ ] …

* COMMENT What's a thesis? [0%]
  + [ ] The argument
    - What is it? Is it being argued clearly?
    - What's the plan?
  + [ ] An exposition of an orginal piece of research.
  + [ ] Distinctive contribution to the knowledge of the subject?
  + [ ] Evidence of orginality shown by the discovery of new facts?
  + [ ] How is the research best appreciated?
  + [ ] Ideas not mentioned in the thesis might as well not exist! Mention ideas.

* COMMENT Planning an Argument [0%]
  One sentence for each:
  + [ ] Introduction to the area of study.
  + [ ] The problem being tackled.
  + [ ] What the literature says about the problem.
    - A review of previous work shows you know the subject.
    - Besides being descriptive, the review needs to be critical.
    - Summary of the essential features of other work as it relates to this study.
  + [ ] How /I/ tackle this problem.
    - What is the philosophy of approach?
    - How were you systematic?
    - How is this linked back to the literature review?
  + [ ] How /I/ implement my solution.
    - Provide details so that others can follow what was done.
    - Justify the approach taken.
    - Does the software appear to work satisfcatorily?
  + [ ] The result.
    - Application of the approach reduces thousands of lines of code to
      human-readable specfications with an extensible system?
    - *Link back to how the solutions obtained relate to the questions posed?*
    - Accurately identitfy & summarise patterns or trends in the results.
    - Provide a critical analysis to show you know its limitations.
    - ‘Future Work’ to show what's missing.
    - Beware of specfulations not grounded in the results.
  + [ ] Conclusion ---repetition of the intro, but with reference to the detail.

  An outline acts as a workplan for which the entire research process is an
  exercise addressing each item. Each item becomes at least one section in
  the writeup.

  + [ ] Set out clearly what each chapter should say.

* COMMENT Say everything thrice [0%]

  It's not repetition, but linking and rationale.

  + [ ] In the thesis as a whole.
    - [ ] Introduction - What the thesis will say.
    - [ ] Body - Details of the work.
    - [ ] Conclusion - What the thesis said.

  + [ ] Within each chapter/section.
    - [ ] Signposting - What this section says.
    - [ ] Body - The details.
    - [ ] Summary - What this section has said.

  + [ ] Within each paragraph.
    - [ ] Each paragraph describes a single idea.
    - [ ] The first sentence introduces the idea ---linking it with the previous one.
    - [ ] The last sentence concludes the idea ---linking it with the next one.

  Signposts ensure it's clear what's being discussed and why
  ---from a writer's perspective, they help get the contents right.

* COMMENT The Examiner's View

  They'll read it in meetings, trains, or planes.
  They're busy and an initial scan may be:

  1. abstract - what's it about?
  2. bibliography - Does it cite the right stuff? Has it been published already?
  3. conclusions - What was achieved? Do I believe it?
  4. contents listing - Is everything there? Is the argument clear?

  Weakeness in these locations might suggest large corrections.

  + [ ] Run spellchecking everywhere.
  + [ ] Run the grammar checker as well.

* COMMENT What If I'm stuck?

  1. The task at hand may be too difficult.
  2. *Ask for help!*
  3. Change the plan.
  4. Cut away irrelevant bits.
