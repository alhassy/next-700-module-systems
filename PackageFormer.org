# C-c C-v C-b to execute all code blocks in buffer.

#+TITLE: Package Formers
#+DESCRIPTION: Generalising ADTS, records, typeclasses to â€œpackage formersâ€.
#+AUTHOR: Musa Al-hassy
#+EMAIL: alhassy@gmail.com
#+STARTUP: indent
# PROPERTY: header-args :tangle tangled.agda :comments link

#+CATEGORIES: Agda MetaProgramming Lisp
#+OPTIONS: html-postamble:nil toc:nil d:nil tag:nil
# IMAGE: ../assets/img/org_logo.png
# SOURCE: https://raw.githubusercontent.com/alhassy/org-agda-mode/master/literate.lagda

# INCLUDE: ~/Dropbox/MyUnicodeSymbols.org

* Abstract       :ignore:
#+BEGIN_CENTER org
*Abstract*
#+END_CENTER

Editor extension for supporting â€œthe next 700 module systemsâ€.

Everything here works with Agda version 2.6.0.

#+TOC: headlines 2

* Getting Started

We're going to write a compiler in Lisp that is going to compile
fictitious Agda code ---henceforth referred to as â€œ700 codeâ€---
into currently legitimate Agda code.

For example, something like the following, henceforth referred to as ~test~:
#+NAME:test
#+BEGIN_Example org-agda
PackageFormer Semigroup (v : Variation) : Set where
  field
    _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v
    Id  : Semigroup v
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

SemigroupR = Semigroup record
SemigroupD = Semigroup data
SemigroupT = Semigroup typeclass
#+END_Example
Will behave as if:
#+BEGIN_Example org-agda
record SemigroupR  : Set where
  field
    Carrier : Set
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

data SemigroupD : Set where
    _â¨¾_ : SemigroupD â†’ SemigroupD â†’ SemigroupD
    Id  : SemigroupD

record SemigroupT (Carrier : Set) : Set where
  field
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
#+END_Example
This is a nearly 200% increase in size; that is, our fictitious code will
save us a lot of repetition.

* Global preconditions
1. All package formers have exactly one explicit ~Variation~ parameter.
2. The ~where~ keyword appears on the same line as the ~PackageFormer~ key-phrase.
3. The name of the PackageFormer should not contain ~PackageFormer~ as a sub-identifier.
4. The first child of the package former is the ~field~ declaration, on its own line.
* Getting indented children

Consider the following todo list,
#+NAME: children-example
#+BEGIN_SRC org
+ item 1
  - subitem 1.1
    ,* subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 1.2
+ item 3
#+END_SRC

:Example:
#+BEGIN_SRC emacs-lisp :var it = children-example
(message it)
#+END_SRC

#+RESULTS:
: + item 1
:   - subitem 1.1
:     * subsubitem 1.1.1
:   - subitem 1.2
: + item 2
:   - subitem 1.2
: + item 3
:End:

We would think that ~item 1~ has two â€˜childrenâ€™, and, moreover, one grand-child.
Whereas ~item 2~ has a single child and ~item 3~ is barren.

#+BEGIN_SRC emacs-lisp
(defun get-indentation (string)
  "How many spaces are there at the front of â€˜stringâ€™?

  Property: The resulting number is â€˜â‰¤ length stringâ€™.
  "
  (if string (length (s-shared-start string (s-repeat (length string) " "))) 0)
)

(stringp "nice")
(stringp '(nice))

(listp "nice")
(listp '(nice))

(cl-defun get-children (parent the-wild &key (then #'identity))
  "Go into â€˜the-wildâ€™ seeking out the first occurence of â€˜parentâ€™,
   who once found, ought to have a minimal indentation for its children.

   â€œMinimalâ€ in that if there are items with a greater indentation,
    then they are children of children and should be kept.

   The first input argument is of type â€˜stringâ€™,
   the second argument may be of type â€˜stringâ€™ or â€˜listâ€™ of strings
   ---if it's a string, we split along new lines---,
   the optional â€˜thenâ€™ is a function acting on children strings.

   Result is the parent followed by its children, as a list of lines,
   where each child has been altered using the optional â€˜thenâ€™ function.
   Moreover, we also return the rest of the unconsidered portion of â€˜the-wildâ€™:
   Result: ( (cons parent-line children-lines) . unconsidered-remaining-lines )

   Warning: We do /not/ return the unconsidered prefix of â€˜the-wildâ€™; i.e,
   the porition that does not contain an occurence of â€˜parentâ€™.
   Why? I currently have no need for it, so I throw it away.

   Implementation: Look at the indentation of the
   first child, then use that as a lower bound to find the indentation
   of the remaining children.
  "

  (let ( (lines (if (stringp the-wild) (s-lines the-wild) the-wild))
         (indentation -1)
         (parent-line nil) )
    ;; Ensure: lines â‰ˆ (parent-here . more-lines)
    (while (and (car lines) (not (s-contains? parent (car lines))))
      ;; â€˜andâ€™ in-case parent is not even in the list, and so we reach nil.
      (setq lines (cdr lines))
      )

    ;; Throw away parent, but keep its contextual line.
    (setq parent-line (car lines))
    (setq lines (cdr lines))

    ;; How far is the first child indented?
    (setq indentation (get-indentation (car lines)))

    ;; Keep only the children that have at least this level of indentation.
    (setq lines&more (--split-with (<= indentation (get-indentation it)) lines))
    (setq lines (car lines&more))
    (setq unconsidered (cadr lines&more))

    ;; Alter the children according to the given function.
    (setq lines (mapcar then lines))

    ;; Yield the parent line along with the children lines.
    `( ,(cons parent-line lines) . ,unconsidered )
  )
)
#+END_SRC

#+RESULTS:
: get-children

Let's try this out on our example hierarchy, ~eh~, from earlier.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both
(car (get-children "+ item 1" eh))
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 |

Excellent! Let's looks at the other parents.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both
(get-children "+ item 2" eh)
#+END_SRC

#+RESULTS:
| (+ item 2   - subitem 1.2) | + item 3 |

Notice that we found the parent ~+ item 2~ and its only child ~- subitem 1.2~, and
we dropped the prefix of ~eh~ that did not contain the parent but have kept
the remaining unconsidered portion of ~eh~.

Finally, the barren parent.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both
(get-children "+ item 3" eh)
#+END_SRC

#+RESULTS:
| + item 3 |

Yay :smile:

Before we move on, let's try altering a child clause; e.g., I'd like
~* subitem 1.1.1~ to be renamed to ~* subitem that is super deep~.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both
(car (get-children "+ item 1" eh
 :then (lambda (x) (s-replace "1.1.1" "that is super deep" x))))
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem that is super deep | - subitem 1.2 |

Nice :grin:

Now the moment of truth, let's try this out on our example.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(car (get-children "PackageFormer" test))
#+END_SRC

#+RESULTS:
| PackageFormer Semigroup (v : Variation) : Set where | field | _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v | Id  : Semigroup v | assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z) |

Also, does the list variant work:
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(car (get-children "PackageFormer" (s-lines test)))
#+END_SRC

#+RESULTS:
| PackageFormer Semigroup (v : Variation) : Set where | field | _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v | Id  : Semigroup v | assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z) |

Test-driven development doesn't seem bad ğŸ˜²

* PackageFormer Name and Variation Symbol

A PackageFormer is generally declared as
#+BEGIN_SRC haskell :tangle no
PackageFormer Semigroup (v : Variation) : Set where â€¦
#+END_SRC

#+RESULTS:
: Prelude>
: <interactive>:2:47-51: error: parse error on input â€˜whereâ€™

The body of such a declaration mentions ~Semigroup v~, which we would like to rewrite
with other names when the package is instantiated. As such, we form a method for
obtaining the name, the variation symbol, and a method to rewrite substrings of the
children ---wait, we already have the last one: ~get-children~ with optional ~:then~
keyword.

#+BEGIN_SRC emacs-lisp
;; The following two only work on headers of PackageFormer declarations.

(defun package-former-name (declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (v : Variation) : Set whereâ€
   return the name â€œSemigroupâ€.
  "
  (s-chop-prefix "PackageFormer "
    (s-chop-suffix " ("
      (car (s-match "PackageFormer .* (" declaration))))
)


(defun variation-symbol (declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (v : Variation) : Set whereâ€
   return the name â€œvâ€.
  "
  (s-chop-prefix "("
    (s-chop-suffix " : Variation)"
      (car (s-match "(.*)" declaration))))
)
#+END_SRC

#+RESULTS:
: variation-symbol

Let's test these two out.
#+BEGIN_SRC emacs-lisp
(package-former-name "PackageFormer Semigroup (v : Variation) : Set where")
;; â‡’ "Semigroup"

(variation-symbol "PackageFormer Semigroup (v : Variation) : Set where")
;; â‡’ "v"
#+END_SRC

#+RESULTS:
: v

* Parameter Erasure & Insertion

When a PackageFormer such as the following is instantiated, say, to a typeclass
variation, we must erase the variation parameter and insert a new type parameter.
#+BEGIN_SRC haskell :tangle no
   PackageFormer Semigroup (v : Variation) : Set where â€¦
â†¦  record Semigroup (Carrier : Set) : Set  where â‹¯
#+END_SRC

#+RESULTS:
: <interactive>:5:1: error: parse error on input â€˜â†¦â€™

#+BEGIN_SRC emacs-lisp
;; The following only work on headers of PackageFormer declarations.

(defun erase-parameters (declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (existing-params) : Set â„“ whereâ€
   return
   â€œPackageFormer Semigroup : Set â„“ whereâ€
  "
  (s-collapse-whitespace ;; Convert all adjacent whitespace chars to a single space.
   (s-replace
      (car (s-match "(.*) : Set" declaration))
      ": Set"
      declaration))
)

(defun insert-parameter (param declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (existing-params) : Set â„“ whereâ€
   return
   â€œPackageFormer Semigroup (existing-params) â€˜paramâ€™ : Set â„“ whereâ€

   Precondition: â€˜paramâ€™ is a string.
  "
  (let ((rest-of-line (car (s-match ": Set.*" declaration))))
  (s-replace
      rest-of-line
      (concat param " " rest-of-line)
      declaration)
  )
)
#+END_SRC

#+RESULTS:
: insert-parameter

Let's test these out:
#+BEGIN_SRC emacs-lisp :exports both
(erase-parameters "PackageFormer Semigroup (v : Variation) (C : Set) : Set where")
#+END_SRC

#+RESULTS:
: PackageFormer Semigroup : Set where

# Notice the superfluous whitespace is /not/ collapsed for parameter insertion.
#+BEGIN_SRC emacs-lisp :exports both
(insert-parameter "(Carrier : Set)"
  (erase-parameters "PackageFormer Semigroup (v : Variation) : Set where"))
#+END_SRC

#+RESULTS:
: PackageFormer Semigroup (Carrier : Set) : Set where

A naturally expected property is if we obtain the variation symbol of a package former,
erase said parameter, then insert it; then we have essentially done nothing.
#+BEGIN_SRC emacs-lisp :exports both
(let* ((ex "PackageFormer Semigroup (ww : Variation) : Set where")
       (vs (variation-symbol ex))
       (vd (format "(%s : Variation)" vs)))

  (and (equal "PackageFormer Semigroup : Set where" (erase-parameters ex))
       (equal ex (insert-parameter vd (erase-parameters ex))))
)
#+END_SRC

#+RESULTS:
: t

Excellent ğŸ˜

* package-formers list
#+BEGIN_SRC emacs-lisp
;; TODO: The global variables package-formers & instance-declaration should be /buffer/ specfic.

(defvar package-formers nil
  "The list of PackageFormer's declarations in the current Agda buffer.")

(defstruct package-former-declaration
  "Record of componenets that form a PackageFormer."
  name variation-symbol level fields
  )
;; TODO: For now, PackageFormer's have no other parameters besides the variation symbol.

(cl-defmethod show ((p package-former-declaration))
  "Pretty print a package-former-declaration record value"

  (concat
    (format "PackageFormer %s (%s : Variation) : Set %s where \n"
            (package-former-declaration-name p)
              (package-former-declaration-variation-symbol p)
              (package-former-declaration-level p))
    (s-join "\n" (package-former-declaration-fields p))
  )
)

;; nice
;; (show (car package-formers))

(defun load-package-former-declaration (lines)
  "The input â€˜linesâ€™ mut be a list of lines forming a full PackageFormer declaration;
   e.g., obtained by calling â€˜get-childrenâ€™.

   It is parsed and added to the list of â€˜package-formersâ€™.
  "

  ;; Precondition Example, with intentionally strange whitespacing:
  ;; header â‰ˆ â€œPackageFormer Semigroup   (v : Variation) : Set  ( â„“expr)   whereâ€

  (-let [header (car lines)]
    (add-to-list 'package-formers
               (make-package-former-declaration
                   :name             (substring-delimited-$ "PackageFormer $here (" header)
                   :variation-symbol (substring-delimited-$ "($here : Variation"    header)
                     ;; â€˜levelâ€™ may be â€œâ€, that's okay.
                   :level            (substring-delimited-$ "Set $here where"       header)
                   :fields           (cdr lines))) ;; maybe skip line with â€œfieldsâ€ header?
  )
)
#+END_SRC

#+RESULTS:
: load-package-former-declaration

testing
#+BEGIN_SRC emacs-lisp :var test = test
(setq package-formers nil)

(load-package-former-declaration
 (car (get-children "PackageFormer" test)))

; test
(substring-delimited-$ "Set $here where" (caar (get-children "PackageFormer" test)))
#+END_SRC

#+RESULTS:

* ~instantiate~ ---the /backend/ core utility
Let's put the pieces together.
#+BEGIN_SRC emacs-lisp
(cl-defun instantiate (decls &key
  new-name (type "record") carrier
  name-suffix
  (variation-replacement "")
  (prefix-fields "") (suffix-fields "") omit-field-header
  (keep-fields (lambda (x) t))
  (alter-raw-fields #'identity)
  (alter-fields #'identity)
  )

  "Given a PackageFormer declaration, instantiate it into a concrete Agda type.

   Remarks or example values:

   - â€˜declsâ€™ is immediately provided to â€˜get-childrenâ€™, so it may be a string
      or a list.

   - â€˜typeâ€™: The replacement for â€œPackageFormerâ€; default is â€œrecordâ€.

   - â€˜carrierâ€™: What is the carrier of this new instance? E.g., â€œCarrierâ€.
      By default it's the â€˜new-nameâ€™; but this is unresonable when, say, a typeclass
      variation is requested.

   - â€˜name-suffixâ€™: When no â€˜new-nameâ€™ is provided, the default is
      â€œâŸªPackageFormer'sNameâŸ«-âŸªvariationâŸ«-g*â€, where â€˜*â€™ is an arbitrarily generated number.

     This may be useful for rapid development when one does not want to provide
     a name to an instance, but simply wants the instance to exist.

   - â€˜variation-replacementâ€™: â€œ(Carrier : Set)â€; empty string by default.

   - â€˜prefix-fieldsâ€™: List of fields, â€œname : typeâ€, to be added at the beginning
      of the field declaration. Default is empty string.

   - â€˜suffix-fieldsâ€™: List of fields, â€œname : typeâ€, to be added at the beginning
      of the field declaration. Default is empty string.

   - â€˜omit-field-headerâ€™: Should the â€œfieldâ€ word be removed? No by default.

   - â€˜keep-fieldsâ€™: Predicate that determines which fields should be kept.
      By default, no fields are dropped.

   - â€˜alter-raw-fieldsâ€™: A function that alters the list of fields of a PackageFormer *before*
     any processing has transpiried. This is the identity function by default.

   - â€˜alter-fieldsâ€™: A function to alter existing fields *after* processing;
     it does not alter inserted fields via â€˜prefix-fieldsâ€™ nor â€˜suffix-fieldsâ€™.
     This is the identity function by default.
  "

  (let* ((pf (car (get-children "PackageFormer" decls)))
         (header     (car pf))
         (pf-name (package-former-name header))
         (pf-variation (variation-symbol header))
         (field-decl (cadr pf)) ;; In order to maintain user-provided indentation.
         (fields     (funcall alter-raw-fields (cddr pf)))
         (indentation (s-repeat (if fields (get-indentation (car fields)) 0) " "))
           (preFields   (--map (concat indentation it) prefix-fields))
           (postFields  (--map (concat indentation it) suffix-fields))
         (tc nil)
         )

  ;; Default value of â€˜new-nameâ€™ & â€˜carrierâ€™ are âŸªPackageFormer'sNameâŸ«-âŸªname-suffixâŸ«.
  (unless new-name (setq new-name (format "%s-%s-%s" pf-name name-suffix (gensym))))
  (unless carrier  (setq carrier new-name))

  ;; Replace "(? : Variation)" with the provided â€˜variation-replacementâ€™
  (setq header (insert-parameter variation-replacement (erase-parameters header)))

  ;; Replace "PackageFormer" with â€˜typeâ€™.
  (setq header (s-replace "PackageFormer" type header))

  ;; Replace PackageFormer's name with provided instantiation name.
  (setq header (s-replace pf-name new-name header))

  ;; Replace all occurences of â€œpackage-former-name followed by variationâ€
  ;; with â€˜carrierâ€™.
  (setq fields (--map (s-replace (concat pf-name " " pf-variation) carrier it) fields))

  ;; Perform any processing on the fields.
  (setq fields (funcall alter-fields (-filter keep-fields fields)))

  ;; Stick all the pieces together, along with the new fields.
  (setq tc (s-join "\n"
        (-cons* header
        (-concat
           (if omit-field-header () (list field-decl))
           preFields fields  postFields))))

  ;; Declare generation source matter.
  (concat
   "\n{- This was generated from the PackageFormer " pf-name " -}\n"
    tc)
 )
)
#+END_SRC

#+RESULTS:
: instantiate

Let's instantiate our test example from earlier to produce a typeclass.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(instantiate test   ;; :new-name "SemigroupT"
                    :name-suffix "typeclass"
                    :type "record"
                    :variation-replacement "(Carrier : Set)"
                    :carrier "Carrier"
                    )
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-typeclass-g105 (Carrier : Set) : Set where
:   field
:     _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
:     Id  : Carrier
:     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

#+BEGIN_SRC emacs-lisp :var test = test :exports both
;; (instantiate test)

(setq _test (show (car package-formers)))

(instantiate _test :variation-replacement "noice")

;; (erase-parameters _test)
; (insert-parameter "(nn : ?)" (erase-parameters _test)))

;; (instantiate-as-typeclass (show (car package-formers)))
;; (instantiate (show (car package-formers)))
;; -as-typeclass (show (car package-formers)))
;; (stringp (show (car package-formers)))
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-nil-g106 noice : Set where
:   field
:     _â¨¾_ : Semigroup-nil-g106 â†’ Semigroup-nil-g106 â†’ Semigroup-nil-g106
:     Id  : Semigroup-nil-g106
:     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

What about a bundled up record declaration?
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(instantiate test   ;; :new-name "SemigroupT"
                    :name-suffix "semantics"
                    :type "record"
                    :carrier "Carrier"
                    :prefix-fields '("Carrier : Set")
                    )
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-semantics-g107  : Set where
:   field
:     Carrier : Set
:     _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
:     Id  : Carrier
:     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

Records provide a semantics, what if we want the syntax?
Since ~data~ declarations consist of constructors, whose target type necessarily
begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.

First, a helper function.
#+BEGIN_SRC emacs-lisp
(defun field-target (field)
  " Given a declaration â€œname : type0 â†’ â‹¯ â†’ typeNâ€, yield â€œtypeNâ€. "
  (car (-take-last 1 (s-split "â†’" field)))
)
#+END_SRC

#+RESULTS:
: field-target

Let's test it out:
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(-let [package-former-name "Semigroup-syntax"]

  (list (s-contains? package-former-name (field-target "     Id  : Semigroup-syntax"))
        (s-contains? package-former-name (field-target "_â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax"))
        (s-contains? package-former-name (field-target "     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)")))
)
#+END_SRC

#+RESULTS:
| t | t | nil |

The results are as expected, so let's move to the real use case.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(-let [package-former-name "Semigroup-syntax"]

  (instantiate test  :name-suffix "syntax"
                     :type "data"
                     :omit-field-header t
                       :new-name package-former-name
                       ;; :carrier package-former-name
                     :keep-fields (lambda (f) (s-contains? package-former-name (field-target f)))
                    )
)
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: data Semigroup-syntax  : Set where
:     _â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax
:     Id  : Semigroup-syntax

Yeehaw! We've got three variations and possibly much more from a single fancy well-toggled
function ğŸ¤  We can emulate generative modules this way too! ğŸ˜»

Let's package these particular toggle configurations into their own functions.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-typeclass (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda â€œtypeclassâ€.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (instantiate decls :new-name new-name
                     :name-suffix "typeclass"
                     :type "record"
                     :variation-replacement (format "(%s : Set)" carrier)
                     :carrier carrier
                    )
)
#+END_SRC

#+RESULTS:
: instantiate-as-typeclass

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-record (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (instantiate test :new-name new-name
                    :name-suffix "record"
                    :type "record"
                    :carrier carrier
                    :prefix-fields `(,(format "%s : Set" carrier))
                    )
)

#+END_SRC

#+RESULTS:
: instantiate-as-record

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-data (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (let* ((pf (car (get-children "PackageFormer" decls)))
         (header     (car pf))
         (pf-name (package-former-name header)))

    (instantiate test  :new-name new-name
                       :name-suffix "syntax"
                       :type "data"
                       :omit-field-header t
                       :keep-fields (lambda (f) (s-contains? pf-name (field-target f)))
                      )
  )
)
#+END_SRC

#+RESULTS:
: instantiate-as-data

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(s-join "\n" `(
,(instantiate-as-typeclass test)
,(instantiate-as-record test)
,(instantiate-as-data test)
))
#+END_SRC

#+RESULTS:
#+begin_example

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-typeclass-g108 (Carrier : Set) : Set where
  field
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-record-g109  : Set where
  field
    Carrier : Set
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup -}
data Semigroup-syntax-g110  : Set where
    _â¨¾_ : Semigroup-syntax-g110 â†’ Semigroup-syntax-g110 â†’ Semigroup-syntax-g110
    Id  : Semigroup-syntax-g110
#+end_example

Notice that the results contained generated names since no names were provided.

* Acting on Agda Buffer

The aim is to process test enclosed in ~{-700 â‹¯ -}~ comments,
produce legitimate Agda from that, and ensure the generated Agda is accessible to the
current buffer automatically.

** TODO substring-delimited and friends
First, the function to get everything in these special â€œ700-commentsâ€.
#+BEGIN_SRC emacs-lisp
(cl-defun buffer-substring-delimited (start end &optional (highlight nil))
  "
  Get the current buffer's /next/ available substring that is delimited
  between the regexp tokens â€˜startâ€™ up to â€˜endâ€™, exclusively.

  If no tokens are found, an error is thrown.

  The â€˜highlightâ€™ option simply highlights the selected region ---visual feedback
  for the user.
  "
  (let (p1 p2)
    (re-search-forward start)
    (setq p1 (point))

    (re-search-forward end)
    (backward-word)
    (setq p2 (point))

    (when highlight ;; do we want to highlight the region?
      (goto-char p1)
      (push-mark p2)
      (setq mark-active t)
    )

    ;; (copy-region-as-kill p1 p2)
    (buffer-substring-no-properties p1 p2)
))
#+END_SRC

#+RESULTS:
: buffer-substring-delimited

Let's obtain the contents of /all/ 700-comments.
#+BEGIN_SRC emacs-lisp
(cl-defun buffer-substring-delimited-whole-buffer (start end)
  "Return a list of all substrings in the current buffer that
   are delimited by regexp tokens â€˜startâ€™ and â€˜endâ€™, exclusively.
  "
  (save-excursion
    (let ((l nil) (continue t))
     (beginning-of-buffer)

     (while continue
       (condition-case nil
         ;; attemptClause
         (setq l (cons (buffer-substring-delimited start end) l))
         ;; recoveryBody
         (error (setq continue nil))))

     ;; We've collected items as we saw them, so â€˜lâ€™ is in reverse.
    (reverse l)
    )
  )
)
#+END_SRC

#+RESULTS:
: buffer-substring-delimited-whole-buffer

#+BEGIN_SRC emacs-lisp
(cl-defun substring-delimited
    (prefix suffix string &key preserve-spaces longest-substring)
  "Assuming â€˜stringâ€™ â‰ˆ â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯, return the /first/ such needle
   by default, unless â€˜longest-substringâ€™ is true, in which case yield /longest/
   such needle.

  Unless â€˜preserve-spacesâ€™ is true, we convert all adjacent whitespace
  characters to a single space in the input â€˜stringâ€™ and trim any surrounding
  whitespace from the resulting output needle string.
  "

  (let (longest-needle context first-ending result)

    (unless preserve-spaces (setq string (s-collapse-whitespace string)))
    (setq context (concat prefix ".*" suffix))
    (setq longest-needle (s-chop-prefix prefix
                           (s-chop-suffix suffix
                             (car (s-match context string)))))

    (setq first-ending (s-index-of suffix longest-needle))
    (setq result (if (and (not longest-substring) first-ending)
                       (substring longest-needle 0 (1- first-ending))
                       longest-needle))
    (if preserve-spaces result (s-trim result))
  )
)

(cl-defun substring-delimited-$
    (context string &key preserve-spaces longest-substring)
  "Assuming â€˜contextâ€™ = â€œâŸªprefixâŸ« $here âŸªsuffixâŸ«â€
   and â€˜stringâ€™ â‰ˆ â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯, return the /first/ such needle
   by default, unless â€˜longest-substringâ€™ is true, in which case yield /longest/
   such needle.

  Unless â€˜preserve-spacesâ€™ is true, we convert all adjacent whitespace
  characters to a single space in the input â€˜stringâ€™ and trim any surrounding
  whitespace from the resulting output needle string.
  "

  (-let [pre-post (s-split "$here" context)]
    (substring-delimited (car pre-post) (s-trim (cadr pre-post)) string
     :preserve-spaces preserve-spaces :longest-substring longest-substring)
  )
)

;; testing
(setq _header "PackageFormer  Semigroup   (  v : Variation) : Set (  â„“expr)   where")
(substring-delimited "PackageFormer " "(" _header :preserve-spaces t :longest-substring t)
(substring-delimited "PackageFormer " "(" _header :preserve-spaces t)
(substring-delimited "PackageFormer " "(" _header)
(substring-delimited-$ "PackageFormer $here (" _header) ;; nice!
#+END_SRC

#+RESULTS:
: Semigroup

:RndmTests:
#+BEGIN_SRC emacs-lisp :tangle no
;; Get text delimited by quotes
;; (buffer-substring-delimited "^\"" "^\"")

;; Get text delimited by quotes
;; (buffer-substring-delimited "^\{-" "^-\}")

;; (setq it (buffer-substring-delimited-whole-buffer "^\{-700" "^-\}"))
#+END_SRC

#+RESULTS:

:End:
** insert-generated-import
Let's give the current buffer access to the location of the generated file.
#+BEGIN_SRC emacs-lisp
(defun insert-generated-import (name-of-generated-file)
  "In the current file, find the top-most module declaration
   then insert an import of the generated file.
  "
  (interactive)

  (save-excursion
    (beginning-of-buffer)
    (condition-case the-err
      ;; attemptClause
      (re-search-forward (concat "open import " name-of-generated-file))
       ;; recoveryBody
      (error
       ;; (message-box (format "%s" the-err))
         (re-search-forward "\\(module.*\\)")
         (replace-match (concat "\\1\nopen import " name-of-generated-file))
        )
    )
  )
)
#+END_SRC

#+RESULTS:
: insert-generated-import

** instantiations-remaining list
#+BEGIN_SRC emacs-lisp
(defvar instantiations-remaining nil
  "The PackageFormer instantiations that need to be performed.")

(defstruct instance-declaration
  "Record of componenets for an PackageFormer instance declaration:
   âŸªnameâŸ« = âŸªpackage-formerâŸ« âŸªvariationâŸ«.
  "
  name package-former variation
) ;; TODO: Add consideration for â€˜renamingâ€™ clauses!
  ;; Need to alter load-instance-declaration and maybe no other methods.

(defun load-instance-declaration (line)
  "If the current â€˜lineâ€™ string is an instance declaration,
   then parse and add it to the list of â€˜instantiations-remainingâ€™;
   else do nothing.

   Returns t if an instance-declaration was loaded, otherwise nil.
  "

  ;; Example instance declaration: â€œMagmaR = Magma recordâ€
  ;; â‡’ 4 pieces, sepearted by spaces, where second item must be an equality.

  (let ( (pieces (s-split " " line)) )
   (when (and (<= 4 (length pieces)) (equal (nth 1 pieces) "="))
     (add-to-list 'instantiations-remaining
                  (make-instance-declaration :name           (nth 0 pieces)
                                             :package-former (nth 2 pieces)
                                             :variation      (nth 3 pieces)
                                             ))
     t ;; Indicate that an instance was loaded.
   )
  )
)
#+END_SRC

#+RESULTS:
: load-instance-declaration

** parse-700-comments
#+BEGIN_SRC emacs-lisp
(defvar 700-comments nil
  "The contents of the 700-comments.

   If this variable does not change, we short-circut all processing.
  ") ;; TODO

(cl-defun parse-700-comments ()
  "
   Parse comments of the form â€œ{-700 â‹¯ -}â€ and add all PackageFormer declarations
   to the â€˜package-formersâ€™ list and all instantations to the â€˜instantiations-remainingâ€™ list.
  "
  (interactive)

  (let (item lines) ;; â€˜itemâ€™ is either a PackageFormer or instantiation declaration.

  ;; Step 0: Catenate all 700-comments into a single string.
  (setq 700-comments (s-join "\n" (buffer-substring-delimited-whole-buffer "^\{-700" "^-\}")))
  ;; TODO: Assign to a local var, check equality against global 700-comments,
  ;; if identical, no more processing since everything already generated.

  ;; View comments as a sequence of lines, ignore empty lines ---which are not in our grammar.
  (setq lines (--remove (s-blank? (s-collapse-whitespace it)) (s-lines 700-comments)))

  ;; Traverse the 700-comments:
  ;; If we view a â€œlhs = rhsâ€ equation, add to global â€˜instantiations-remainingâ€™ list.
  ;; If we view a PackageFormer declaration, add to global â€˜package-formersâ€™ list.
  (while lines
   (setq item (car lines))
   (if (load-instance-declaration item) (setq lines (cdr lines))
     ;; Else we have a PackageFormer declaration:
     ;; Get it along with the remaining 700-comments.
     (setq item (get-children "PackageFormer" lines))
     (load-package-former-declaration (car item))
     (setq lines (cdr item))))

  (message "Finished parsing 700-comments.")
  )
)
#+END_SRC

#+RESULTS:
: parse-700-comments

* Now for the /frontend/ core utility

#+BEGIN_SRC emacs-lisp
(cl-defun reify-instances ()
 " Instantiate all items in â€˜instantiations-remainingâ€™.
 "
 (interactive)
 (let* (result name pf-type pf variation reify)

   (dolist (inst instantiations-remaining)
        (setq name (instance-declaration-name inst))
          (setq variation (instance-declaration-variation inst))
        (setq pf-type (instance-declaration-package-former inst))
        (setq pf (car (--filter (equal pf-type (package-former-declaration-name it)) package-formers)))
        (setq reify (pcase (instance-declaration-variation inst)
                      ("typeclass" (instantiate-as-typeclass (show pf) :new-name name))
                      ("record" (instantiate-as-record (show pf) :new-name name))
                      ("data" (instantiate-as-data (show pf) :new-name name))
                    (otherwise  (message-box "Error: Variation %s not supported yet." variation))
              ))
        (setq result (-cons* reify result)))

   (s-join "\n" result)
))

(global-set-key (kbd "<f7>") 'reify-instances)
#+END_SRC

#+RESULTS:
: reify-instances

#+BEGIN_SRC emacs-lisp
(defun reify-package-formers (orig-fun &rest args)
  (interactive)

  ;; Sometimes we may want the full name due to files being in a nested
  ;; directory hierarchy:
  ;; (file-name-sans-extension buffer-file-name)
  (setq generated-file-name (concat(file-name-sans-extension (buffer-name))
                  "_Generated"))

  ;; Thisâ€™ inefficent.
  (setq package-formers nil)
  (setq instantiations-remaining nil)
  (parse-700-comments)

  (with-temp-buffer
    (beginning-of-buffer)

    (insert (s-join "\n" `(
             "{- This file is generated ;; do not alter. -}"
             "open import Relation.Binary.PropositionalEquality using (_â‰¡_)"
               "open import Level as â„“"
             ,(format "module %s where " generated-file-name)
             ,(reify-instances))))

    ;; (mark-whole-buffer)
    (write-region (beginning-of-buffer) (end-of-buffer)
                  (concat generated-file-name ".agda"))
    )
    ;; MA: Using â€˜(write-file "Generated.agda")â€™ means we make a file
    ;; then the temporary buffer /vistis/ the agda file, which loads the
    ;; agda process therein, which is undesirable since it could leave
    ;; agda working on the buffer even after it has been killed!
    ;; This would necessiate calling (agda2-restart) afterwards.
    ;;
    ;; Instead we write the whole region, without visiting the resuting file.

  (insert-generated-import generated-file-name)
  ;; call agda2-load
  (apply orig-fun args)
  (message "700 âˆ· All the best coding! (â€¢Ì€á´—â€¢Ì)Ùˆ")
)

(advice-add 'agda2-load :around #'reify-package-formers)
#+END_SRC

#+RESULTS:

* TODO Minor mode ---Menu matter
#+BEGIN_SRC emacs-lisp

(defvar 700-menu-bar-menu (make-sparse-keymap "700 PackageFormers"))
(define-key global-map [menu-bar my-menu] (cons "700PackageFormers" 700-menu-bar-menu))

(defun enable-package-formers ()
 (interactive)
 (advice-add 'agda2-load :around #'reify-package-formers)
 ;; place notification in modeline
 (setq global-mode-string
      (cond ((consp global-mode-string)
             (add-to-list 'global-mode-string "700 (â€¢Ì€á´—â€¢Ì)Ùˆ"))
            ((not global-mode-string)
             (list "700 (â€¢Ì€á´—â€¢Ì)Ùˆ"))
            ((stringp global-mode-string)
             (list "700 (â€¢Ì€á´—â€¢Ì)Ùˆ" global-mode-string))))
)

(defun disable-package-formers ()
 (interactive)
 (advice-remove 'agda2-load #'reify-package-formers)
 (setq global-mode-string (remove "700 (â€¢Ì€á´—â€¢Ì)Ùˆ" global-mode-string))
)

(define-key 700-menu-bar-menu [enable-package-formers]
  '(menu-item "Enable PackageFormer Generation" enable-package-formers))

(define-key 700-menu-bar-menu [disable-package-formers]
  '(menu-item "Disable PackageFormer Generation" disable-package-formers))
#+END_SRC

#+RESULTS:
| menu-item | Disable PackageFormer Generation | disable-package-formers |

* TODO missing features
+ [A] Generated.agda needs to inherit all open/import declarations from parent.
+ [A] Lifting a field to the parameter level.
  - [A] â€œpf typeclass lifting Nâ€ lifts the first N fields to the parameter level.
+ [A] Explain how generative modules can be emulated.
+ [B] Renaming?

  #+BEGIN_SRC emacs-lisp
(defun generate-all-instances () ;; TODO
  "For each PackageFormer â€˜pfâ€™, produce the default instances:
   â€˜pf-recordâ€™, â€˜pf-typeclassâ€™, â€˜pf-dataâ€™.

   Use: You want a particular instance in rapid developement and don't want
   to be bothered to give it a name. Or experimenting and unsure which instance
   is most desirable, so have access to all of them.

   Possible extensions:
   0. Introduce concrete syntax â€œGenerateDefaultInstances pfâ€ to invoke this command.
   1. Have a global list of default instances.
  "

  (interactive)

    ;; Keep this around since we may want to produce variations wholesale with
  ;; names: packageformer-variation; e.g., Magma-typeclass.
  ;;
  ;;
  ;; the variations
;;  (setq the-vars-shush (--map (car it) (--map (-take-last 1 it) (--map (s-split " " it) decls-vars-shush))))
  ;;
  ;; (dolist (variation the-vars-shush ll)
  ;;  (setq ll (cons (make-typeclass decls (concat pf-name "-" variation)) ll)))

  )
#+END_SRC

#+RESULTS:
: generate-all-instances


* COMMENT footer

# Local Variables:
# eval: (load-file "~/org-agda-mode/org-agda-mode.el")
# eval: (visual-line-mode t)
# compile-command: (progn (org-babel-tangle) (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# End:
