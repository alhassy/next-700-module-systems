# (org-babel-load-file "PackageFormer.org")
;; â‡’ (defalias (quote ap-it) (cons (quote macro) (function (lambda (itbody more) (list (quote ap) (list (quote lambda) (quote (it)) itbody) more)))))
# Export all Lisp blocks into a file then load it.
#
# (setq test outsidetest)

#+TITLE: Prototyping PackageFormers with Elisp
#+DESCRIPTION: Generalising ADTS, records, typeclasses to â€œpackage formersâ€.
#+AUTHOR: Musa Al-hassy
#+EMAIL: alhassy@gmail.com
#+STARTUP: indent
#+PROPERTY: header-args :results none :tangle no :comments link

#+CATEGORIES: Agda MetaProgramming Lisp
#+OPTIONS: html-postamble:nil toc:nil d:nil tag:nil

# IMAGE: ../assets/img/org_logo.png
# SOURCE: https://raw.githubusercontent.com/alhassy/org-agda-mode/master/literate.lagda

# (defun org-outline-overlay-data (x) )

#+TODO: TODO | Future

:Threading_Remarks:

;; The â€œthread-first x formsâ€ syntax feeds initial value â€˜xâ€™ as the first argument into the
;; next form, which in-turn is then fed as the first argument to the form following it, and so on.
;; It provides a nice way to avoid lots of parenthesising on a particular argument; thereby being clearer.
;;
;; (insert (format "\nâ‡’ %s" (macroexpand '(thread-first xâ‚€ (fâ‚ xâ‚Â¹ â€¦ xÂ¹â‚˜) â‹¯ (fâ‚™ xâ‚™Â¹ â€¦ xâ¿â‚–)))))
;; â‡’ (fâ‚™ (â‹¯ (fâ‚ xâ‚€ xâ‚Â¹ â€¦ xÂ¹â‚˜)) xâ‚™Â¹ â€¦ xâ¿â‚–)
;;
;; A simple implementation can be found [[https://www.emacswiki.org/emacs/ThreadMacroFromClojure][here]].
;;
;; Dually, thread-last behaves the same but being at the final-most
;; form position;
;; that is, it is essentially â€œforwards function applicationâ€.
;; More generally, the dash library provides â€˜-as->â€™ which allows us to bind a name
;; such as â€˜resâ€™, which is then an alias for all intermediate results.
;;
;; (insert (format "\nâ‡’ %s" (macroexpand '(-as-> xâ‚€ res (fâ‚ xâ‚Â¹ â€¦ res â‹¯ xÂ¹â‚˜) â‹¯resâ‹¯))))
;; â‡’ (let ((res xâ‚€)) (-as-> (fâ‚ xâ‚Â¹ â€¦ res â‹¯ xÂ¹â‚˜) res â‹¯resâ‹¯))
;;
;; It is defined recursively to make use of the same name.
;;
;; The operator â€˜-->â€™ uses the name â€˜itâ€™ by default.
:End:

:Testing_Remarks:
#+BEGIN_SRC emacs-lisp
 ;; â‡’ crashes since equality is nil.
 ; (assert (= (+ 1 2) 4))

;; M-x ert RET t â‡’ crashes explaining that (3 = 4) â‰¡ nil; much better!
;; â€˜shouldâ€™ shows intermediate values.
(ert-deftest addition-test ()
  ;; â€œI know it fails, tell me but don't provide report.â€
  ;; :expected-result :failed
    (should (equal (+ 2 2) 4)))

;; There are also â€˜should-notâ€™ and â€˜should-errorâ€™.

;; â€˜Mockingâ€™: We can elimitate side-effects from functions we wish to test by using Lisp's dynamic
;; binding to locally redefine the side-effects to, say, do nothing and yield true.
(defun go () (if (file-exists-p "nice.txt") 'yay 'boom))
(ert-deftest eg-mock ()
  (flet ((file-exists-p (file) t))
    (should (equal (go) 'yay))))

;; Run all tests; run tests táµ¢ with: (ert (or 't0 ... 'tN))
;; (ert t)

;; Execute all blocks, then run all tests.
;; (progn (org-babel-execute-buffer) (ert t))

;; Shortcut
(local-set-key (kbd "C-x e")
  (lambda () (interactive) (ert t)))
#+END_SRC

In the ~*ert*~ buffer, press ~r~ on a test to re-run it.
+ Re-run failed tests to ensure that they are deterministic before trying to find
  the cause for the failure.
  - ~m~ to see the messages that the test may have emitted, and ~b~ to see the backtrace.
+ The logical error may be in the test, rather than the code.
+ See [[https://www.gnu.org/software/emacs/manual/html_node/ert/Interactive-Debugging.html#Interactive-Debugging][here]] for more tips.
  + [ ] See [[http://www.gigamonkeys.com/book/][Practical Common Lisp]]'s Chapter 9 on [[http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html][Practical: Building a Unit Test Framework]].
:End:

* COMMENT org/ob-agda setup :load_me:

Just C-c C-c this block (â€¢Ì€á´—â€¢Ì)Ùˆ
#+begin_src emacs-lisp
(add-to-list 'org-src-lang-modes '("results-agda" . org-agda))

;; No code execution on export
;; âŸª For a particular block, we use â€œ:eval never-exportâ€ âŸ«
;;
(setq org-export-use-babel nil)

(progn "Set up some colours *before* loading org-agda-mode"

  (setq org-agda-extra-word-colours nil)
(add-to-list 'org-agda-extra-word-colours '("typeclass" 0 'agda2-highlight-keyword-face))
(add-to-list 'org-agda-extra-word-colours '("PackageFormer" 0 'font-lock-type-face))
(add-to-list 'org-agda-extra-word-colours '("_â¨¾_" 0 'font-lock-type-face))
(add-to-list 'org-agda-extra-word-colours '("assoc" 0 'font-lock-type-face))

;; Treat the following words as if they were â€˜typesâ€™; i.e., bold red.
(dolist (word (s-split " " "PackageFormer _â¨¾_ assoc rightId leftId Semigroup-semantics Semigroup-syntax SemigroupOn M.*") org-agda-extra-word-colours)
  (add-to-list 'org-agda-extra-word-colours `(,word 0 'font-lock-type-face))
  )

  ; (load-file "~/org-agda-mode/org-agda-mode.el")
  (load-file "~/org-agda-mode/literate.el")
)

;; org-agda-mode.el has now deviated as follows:
;;
; (defvar org-agda-extra-word-colours nil "other words that user of org-mode wants coloured, along with their specified font-lock-type-face")
;
; (define-generic-mode
;     'org-agda-mode                      ;; name of the mode
;     (list '("{-" . "-}"))               ;; comments delimiter
;     org-agda-keywords
;     ;; font lock list: Order of colouring matters;
;     ;; the numbers refer to the subpart, or the whole(0), that should be coloured.
;     (-concat  ;; â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜… org-agda-extra-word-colours is a free variable, user should define it /before/ loading org-agda-mode â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
               (if (boundp (quote org-agda-extra-word-colours)) org-agda-extra-word-colours nil)
;     (list â‹¯) â‹¯))

;; Also this so people use â€œagdaâ€ instead of being forced to use â€œorg-agdaâ€
;;
;;  If an Emacs major-mode named <lang>-mode exists, where <lang> is the language identifier from code blockâ€™s header line, then the edit buffer uses that major-mode. Use this variable to arbitrarily map language identifiers to major modes.
;;
(add-to-list 'org-src-lang-modes '("agda" . ob-agda))

;; The following allows me to do â€œC-c C-câ€ on agda org-src blocks.
;; The result is just the src body parroted to us, no â€œevaluationâ€ performed.
;;
;;
;; (async-shell-command "cp  ~/.emacs.d/elpa/org-9.2.3/ob-C.el ~/org-agda-mode/ob-agda.el")

; (async-shell-command "ln -s ~/org-agda-mode/ob-agda.el ~/.emacs.d/elpa/org-plus-contrib-20190408/ob-agda.el")
(load-file "~/org-agda-mode/ob-agda.el")

;; Execute this for alias:
(add-to-list 'org-src-lang-modes '("results-agda" . ob-agda))
;; (defalias 'results-agda 'org-agda)

;;
(org-babel-do-load-languages
 'org-babel-load-languages
 '((agda . t)))
#+end_src

#+RESULTS:

* HTML Stuffs :ignore:
# super brief intro to tables: https://www.w3schools.com/html/html_tables.asp
# See here for a nice intro to tables: https://www.w3.org/TR/CSS2/tables.html
# Here for borders: https://www.w3schools.com/css/css_border.asp
#
#
#+begin_export html
<style>

/* wrap lengthy lines for code blocks */
pre{white-space:pre-wrap}

/* inline code; see here for other colours: https://www.w3schools.com/colors/colors_names.asp */
code { background: LightGray;
       border-radius: 5px; /* How curvy the borders should be. */
}

table {
    background: pink;
    border-radius: 10px; /* How curvy the borders should be. */
    /* width:90% */

    border-bottom: hidden;
    border-top: hidden;

    /* Put table in the center of the page, horizontally. */
    margin-left:auto;margin-right:auto;

    font-family:"Courier New";
    font-size:90%;
}

/* table â€˜dâ€™ata elements */
td {
    border: 1px solid red; padding: 1em;
    /* border: none;
    border-left: 1px solid transparent;
    border-right: 1px solid transparent; */


}


/* Alter visible labels of source blocks */
pre.src-agda:before { content: 'Agda'; }
pre.src-haskell:before { content: 'Agda'; }
pre.src-org:before { content: 'Text'; }

/* Using source blocks â€œagda-resultsâ€ as pink-background coloured blocks in HTML. */
/* pre.src-results-agda:before { content: 'Results: Agda'; } */
pre.src-results-agda { background: pink;}
/* Execute this for alias: (add-to-list 'org-src-lang-modes '("results-agda" . org-agda)) */

</style>
#+end_export

** Macro: fold                                                      :ignore:
# Folding up some code blocks in the resulting html.
#
# Usage: {{{fold(title here)}}} contents {{{end-fold}}}
#
#+MACRO: end-fold  #+HTML: </details>
#+MACRO: fold      #+HTML: <details class="code-details"> <summary> <strong> <font face="Courier" size="3" color="green"> $1 </font> </strong> </summary>

* Abstract       :ignore:
#+BEGIN_CENTER org
*Abstract*
#+END_CENTER

This article is about implementing a prototype supporting [[https://alhassy.github.io/next-700-module-systems-proposal/][â€œthe next 700 module systemsâ€ proposal]]
as an editor extension. In particular, we show how intimately related presentations of a type
can be /derived automatically/ from a single generic declaration which we call a ~PackageFormer~.

Think of a language that does not support currying and you need to have a function of
10 arguments that needs to support accepting any number of arguments less than 10, say
for partial application. In such languages, one must utilise the builder design pattern,
or quickly copy-paste the function 10 times, altering it slightly each time.
In general, if such a function definition requires /N/ lines and /M/ forms of the function
are needed, then nearly /N Ã— M/ lines of code are written manually.

Our prototype deals with this problem, among others, for functions on /types/
---i.e., type constructors--- and reduces this quadractic count to a linear
count /N + M/: One declaration of /N/ lines, then /M/ lines, each being an instantiation
of the desired form. These ideas are discussed in the pre-print
[[https://github.com/alhassy/next-700-module-systems-proposal/blob/master/Paper0.pdf][A Language Feature to Unbundle Data at Will]].

The [[Aim: /Scrap the Repetition/][first section]] below quickly elaborates on our goal,
after that is a â€˜[[User Manual][user manual]]â€™, then the remainder of
the article serves as literate documentation of the prototype;
as well as an opportunity for me to explore emojis.
To follow along, it may be useful to look at an [[https://alhassy.github.io/ElispCheatSheet/][Elisp Cheat Sheet]].

# In some sense, we are â€œcontinuingâ€ the story of Z's schemas.

#+BEGIN_CENTER org
/Everything here works with Agda version 2.6.0./
#+END_CENTER

| Results of tests will be in pink, like this. |

#+TOC: headlines 2

* Aim: /Scrap the Repetition/

We're going to write a code generator in Lisp that is going to interpret
fictitious Agda code ---henceforth referred to as â€œ700 codeâ€---
into currently legitimate Agda code.

For example, something like the following, henceforth referred to as ~test~:
#+NAME: test
#+BEGIN_Src agda :results replace :exports code
PackageFormer Semigroup (v : Variation) : Set where
    _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v
    Id  : Semigroup v
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

Semigroup-semantics  =  Semigroup record
Semigroup-syntax     =  Semigroup data
SemigroupOn          =  Semigroup typeclass
#+END_Src

:Hide:
#+RESULTS: test
: PackageFormer Semigroup (v : Variation) : Set where
:     _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v
:     Id  : Semigroup v
:     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
:
: Semigroup-semantics  =  Semigroup record
: Semigroup-syntax     =  Semigroup data
: SemigroupOn          =  Semigroup typeclass

#
# The â€œ:results replaceâ€ is since we actually want the results of this
# block later on when using â€œtestâ€ as a org-provided variable to org-src blocks.
:End:

:Hide_Needs_CcCvCb:
# Someplaces I want to use â€˜testâ€™ without having it in the header, whence:
#+BEGIN_SRC emacs-lisp :var outsidetest = test :exports both :results none
(setq test outsidetest)
#+END_SRC
:End:

Will behave as if it were written:
#+BEGIN_Src agda
record Semigroup-semantics  : Set where
  field
    Carrier : Set
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

data Semigroup-syntax : Set where
    _â¨¾_ : SemigroupD â†’ SemigroupD â†’ SemigroupD
    Id  : SemigroupD

record SemigroupOn (Carrier : Set) : Set where
  field
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
#+END_Src
This is a nearly <<<200% increase>>> in size; that is, our fictitious code will
save us a lot of repetition.

Below is a sample source file which contains special comments that are picked up
by the prototype which then copy-paste-cuts to produce a generated file.

{{{fold(Testing.agda)}}}
#+INCLUDE: "Testing.agda" src agda
{{{end-fold}}}

{{{fold(Testing_Generated.agda)}}}
#+INCLUDE: "Testing_Generated.agda" src agda
{{{end-fold}}}

 For this prototype, we have the following <<<constraints>>>:

1. The type of a PackageFormer is ~Set â„“~ where ~â„“~ is the empty string
   or a parenthesised expression of type ~Level~.
   - In-particular, subscript types are not yet supported.

2. The ~where~ keyword appears on the same line as the ~PackageFormer~ key-phrase.

3. The name of the PackageFormer should not contain ~PackageFormer~ as a sub-identifier.
   - Likewise, no element should be named ~to~.

4. We are only considering single-sorted structures, for now.

   The research [[https://alhassy.github.io/next-700-module-systems-proposal/][proposal]] addresses how to move beyond this issue.

There are many useful features outlined in the proposal, such as default implementations, that we
hope to include in the future. For now, we just want something that works, is decently documented, and
can be useful.

* User Manual
:PROPERTIES:
:CUSTOM_ID: user-manual
:END:

If the previous section is unclear regarding the aims and uses of this prototype,
please consult the pre-print [[https://github.com/alhassy/next-700-module-systems-proposal/blob/master/Paper0.pdf][A Language Feature to Unbundle Data at Will]]
or [[https://alhassy.github.io/next-700-module-systems-proposal/][the next 700 module systems proposal]].

** Installation

Click here to obtain [[https://raw.githubusercontent.com/alhassy/next-700-module-systems-proposal/master/PackageFormer.el][PackageFormer.el]], place it somewhere, open an Agda file, execute
~M-x your/locatio/PackageFormer.el~, then enable the mode by executing ~M-x 700-mode~.

*Alternatively*, add the following to your Emacs configuration file:
#+BEGIN_EXAMPLE emacs-lisp :tangle no
;; Ensure you have the pre-requsite libraries ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; String and list manipulation libraries
;; https://github.com/magnars/dash.el
;; https://github.com/magnars/s.el
(package-install 's)                ;; â€œThe long lost Emacs string manipulation libraryâ€
(package-install 'dash)             ;; â€œA modern list library for Emacsâ€
(package-install 'dash-functional)  ;; â€œFunction combinatorsâ€
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Obtain the Elisp file, load it, and attach it to Agda.

(shell-command (concat "curl "
  "https://raw.githubusercontent.com/alhassy/next-700-module-systems-proposal/master/PackageFormer.el "
  ">> ~/.emacs.d/PackageFormer.el"))

(load-file "~/.emacs.d/PackageFormer.el")

(add-hook 'agda2-mode-hook #'700-mode)
#+END_EXAMPLE

When you enable ~700-mode~:

0. A menu-bar ~700PackageFormers~ will be added.

1. It will allow you to temporarily disable and enable this new feature,
   as well as providing a help menu. Invoke ~M-x 700-mode~ to toggle turning off this feature
   completely.

2. The string icon ~700 (â€¢Ì€á´—â€¢Ì)Ùˆ~ is displayed in the mode line ---near the bottom of Emacs.

3. You may use ~C-c c-l~ as usual, but it will now recognise 700-comments and generate
   legitimate Agda code from them ---more on this later.

   - PackageFormer syntactical items are coloured green, PackageFormer names are
     coloured yellow, and their instantations are simply bolded. To update a coloured
     item, simply save then revert-buffer (F5), then reload with C-c C-l.

If you need any assistance, please contact me!

** Syntax

The prototype works by translating fictitious 700-syntax into legitimate Agda;
as follows:
#+BEGIN_SRC agda
...agda code here...
{-700
       ...700-syntactical items here
-}
...more agda code...
#+END_SRC
Since the first section provides an example source fragment with both 700-comments as well
as instantiations, we shall only enclose 700-syntax in 700-comments when it is surrounded
by other Agda code, and otherwise leave it free standing.

/We will provide full source listings at the end of discussions that only display fragments!/

 <<<700-syntax>>> is defined informally as follows:
#+BEGIN_EXAMPLE text
âŸª700-syntaxâŸ«    ::=  âŸªPackageFormerâŸ« | âŸªInstantiationâŸ« | âŸªAgdaâŸ«

âŸªPackageFormerâŸ« ::= PackageFormer âŸªIdentifierâŸ« (v : Variation) : Set (âŸªlevelâŸ«) where
                       âŸªnewline-with-indentationâŸ« âŸªElementâŸ«*

âŸªElementâŸ«       ::=  âŸªIdentifierâŸ« : âŸªAny-Agda-TypeâŸ«

âŸªinstantiationâŸ« ::= âŸªIdentifierâŸ« = âŸªIdentifierâŸ« âŸªVariationâŸ« [âŸªVOpâŸ«]

{- Only listing the currently implemented -}
âŸªVariationâŸ«     ::= typeclass | data | record
âŸªVOpâŸ«           ::=   renaming âŸªToListâŸ«
                    | unbundling âŸªâ„•âŸ«
                    | exposing (âŸªSemicolon-seperated-list-of-IdentifiersâŸ«)
                    | with     âŸªToListâŸ«

âŸªToListâŸ« ::= (âŸªIdentifierâ‚€âŸ« to âŸªIdentifierâ‚€âŸ«; â‹¯; âŸªIdentifierâ‚™âŸ« to âŸªIdentifierâ‚™âŸ«) {- for any n : â„• -}
#+END_EXAMPLE

One derives many presentations of a grouping mechanism by what we call â€˜variational clausesâ€™,
for which there is currently only simple support ---namely, they cannot be combined in intricate ways.

+ Example uses of the variational clauses could be seen in the ~Testing.agda~ listing in the first section above.

** Summary of Variational Clauses

Let ~PF~ denote the name of a PackageFormer, then
~PFâ€² = PF Clause~ behaves as follows:
| _Clause_                 | _Behaviour_                                         |
| ~data~                   | A data, ADT, is declared                          |
| ~record~                 | A record having a new field â€˜Carrierâ€™             |
| ~typeclass~              | A record with one parameter â€˜Carrierâ€™             |
| ~v unbundling N~         | Instantiation  ~v~ with first ~N~ items as parameters |
| ~v exposing (eâ‚€;â€¦;eâ‚™)~   | Instantiation ~v~ with parameters ~eáµ¢~                |
| ~v hiding (eâ‚€;â€¦;eâ‚™)~     | Instantiation ~v~ discarding ~eáµ¢~                     |
| ~v renaming (eáµ¢ to eáµ¢â€²)~ | Instantiation ~v~ with specified renames            |
| ~v with (eáµ¢ to eáµ¢â€²)~     | Instantiation ~v~ with specified rewrites           |

** Currying for Datatypes

Suppose you're a Haskell programmer and want to have multiple monoid instances for the Booleans.
You may make isomorphic copies of the Booleans, say ~And~ and ~Any~, and implement the desired instance
for each. What about if you want a Monoid instance but insist only that the unit be ~false~, what do you do then?

With this prototype, you expose the carrier and the operation in the first case, and expose the identity in the second case.
Moreover, you only write the definition of monoid once, leading to our motto:
#+BEGIN_CENTER
/Write once, derive many!/
#+END_CENTER

Here's our formalisation of monoids:
#+BEGIN_SRC agda
PackageFormer Monoid (v : Variation) : Set where
    _â¨¾_     : Monoid v â†’ Monoid v â†’ Monoid v
    Id      : Monoid v
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Monoid v} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Monoid v} â†’ x â¨¾ Id â‰¡ x
#+END_SRC

We regain the Haskell-style typeclass definition with the following declaration:
#+BEGIN_SRC agda
 Classical = Monoid typeclass
#+END_SRC
Loading the script, with ~C-c C-l~ as usual, produces a generated file that elaborate this definition as follows:
#+BEGIN_SRC agda
record Classical (Carrier : Set) : Set where
  field
    _â¨¾_     : Carrier â†’ Carrier â†’ Carrier
    Id      : Carrier
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x
#+END_SRC
Notice that a name ~Carrier~ has been introduced and it has replaced all syntactic occurences of ~Monoid v~.

We could use the letter ~m~ in-place of ~Carrier~, as is done in Haskell, as follows.
#+BEGIN_SRC agda
 Monoid-m = Monoid typeclass renaming (Carrier to m)
#+END_SRC
Which propagates ~Carrier = m~ into the fields. The propagation is necessary
if we were, for example, to rename ~_â¨¾_ to _âŠ•_~ ---otherwise we would need to parse
mixfix applications of this operator, as in ~assoc~!
#+BEGIN_SRC agda
record Monoid-m (m : Set) : Set where
  field
    _â¨¾_     : let Carrier = m in m â†’ m â†’ m
    Id      : let Carrier = m in m
    assoc   : let Carrier = m in âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : let Carrier = m in âˆ€ {x : let Carrier = m in m} â†’ Id â¨¾ x â‰¡ x
    rightId : let Carrier = m in âˆ€ {x : let Carrier = m in m} â†’ x â¨¾ Id â‰¡ x
#+END_SRC

Since Agda supports â€˜named instancesâ€™, the Haskeller's first problem is solved. However, we demonstrate
an alternative solution that will allow us to solve the second problem in a fashion that current Agda
can only awkwardly approximate.

For example, with the current setup, we may go about requesting multiple monoid instances for the Booleans:
#+BEGIN_SRC agda
open Classical using () renaming (_â¨¾_ to Op)

yuck-one :  (X Y : Classical ğ”¹)
         â†’  Op X  â‰¡ _âˆ§_  â†’  Op Y  â‰¡ _âˆ¨_
         â†’  Set
yuck-one = ???
#+END_SRC

The following declaration lets us â€˜uncurryâ€™ the first ~N = 2~ elements
from the field-position to the parameter-position; namely the
monoidal operation, ~_â¨¾_~ since the first element is always ~Carrier~.
In fact, ~typeclass~ is sugar that behaves as if it were ~record unbundled 1~.
#+BEGIN_SRC agda
 MonoidOp = Monoid record unbundling 2
#+END_SRC

This then yields:
#+BEGIN_SRC agda
record MonoidOp (Carrier : Set) (_â¨¾_ : Carrier â†’ Carrier â†’ Carrier) : Set where
  field
    Id      : Carrier
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x
#+END_SRC

Which let's us solve the first problem elegantly as so:
#+BEGIN_SRC agda
first-problem : MonoidOp ğ”¹ _âˆ§_  â†’  MonoidOp ğ”¹ _âˆ¨_  â†’ Set
first-problem = ???
#+END_SRC

Neato ^_^ Short and sweet.

Now for the second problem. Rather than forming a new data-type,
we hoist up the ~Id~-entity field as a parameter.
#+BEGIN_SRC agda
 MonoidId = Monoid record exposing (Carrier; Id)
#+END_SRC
Which results in:
#+BEGIN_SRC agda
record MonoidId (Carrier : Set) (Id : Carrier) : Set where
  field
    _â¨¾_     : Carrier â†’ Carrier â†’ Carrier
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x
#+END_SRC

Resulting in the solution type:
#+BEGIN_SRC agda
second-problem-okay : (X Y : MonoidId ğ”¹ false) â†’ Set
second-problem-okay = ???
#+END_SRC
However, this too can get tedious if we wish to only consider monoids
with unit ~false~. In that case, we /treat/ the fields as if they where
manifest fields and instantiate them to form a new type.
#+BEGIN_SRC agda
{-700 Monoid-false = Monoid record with (Carrier to ğ”¹; Id to false) -}

record Monoid-false : Set where
  field
    _â¨¾_     : ğ”¹ â†’ ğ”¹ â†’ ğ”¹
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftfalse  : âˆ€ {x : ğ”¹} â†’ false â¨¾ x â‰¡ x
    rightfalse : âˆ€ {x : ğ”¹} â†’ x â¨¾ false â‰¡ x

second-problem-better : (X Y : Monoid-false) â†’ Set
second-problem-better = ???
#+END_SRC

The full source of this discussion is as follows.
{{{fold(CaseStudy.agda)}}}
#+INCLUDE: "CaseStudy.agda" src agda
{{{end-fold}}}

* Strings and Things

Since our prototype is intended to be as minimally obtrusive as possible, we will
need to extract our special 700-syntactical items between delimited tokens
and process them.

The following subsections introduce:
+ ~get-children~ :: Obtaining intended items from a hierarchical listing.
+ ~sub-string-delimited-$~ :: Finding the shortest substring between a prefix
      ~ğ‘³~ and a postfix ~ğ‘¹~ by using the â€˜metavariableâ€™ ~$here~; e.g., ~â€œğ‘³ $here ğ‘¹â€.~
+ ~buffer-substring-delimited-whole-buffer~ :: Yield all portions of the
     buffer enclosed in the given delimiters, as a list of strings.
+ ~extract-imports~ :: Obtain all â€˜importâ€™ clauses so that they can be
     ported over to the generated file.

First some useful libraries:
#+BEGIN_SRC emacs-lisp :tangle no
;; String and list manipulation libraries
;; https://github.com/magnars/dash.el
;; https://github.com/magnars/s.el
(require 's)               ;; â€œThe long lost Emacs string manipulation libraryâ€
(require 'dash)            ;; â€œA modern list library for Emacsâ€
(require 'dash-functional) ;; â€œFunction combinatorsâ€
#+END_SRC

** Finding Children in the Wild

Being a prototype, we are talking a mostly string-based approach to working
with hierarchical phrases.
For example, consider the following todo list,
#+NAME: children-example
#+BEGIN_SRC org :results replace
+ item 1
  - subitem 1.1
    ,* subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 2.2
+ item 3
#+END_SRC

#+RESULTS: children-example
+ item 1
  - subitem 1.1
    * subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 2.2
+ item 3

:Example:
#+BEGIN_SRC emacs-lisp :var it = children-example
(message it)
#+END_SRC

#+RESULTS:
: + item 1
:   - subitem 1.1
:     * subsubitem 1.1.1
:   - subitem 1.2
: + item 2
:   - subitem 1.2
: + item 3
:End:

We would think that ~item 1~ has two â€˜childrenâ€™, and, moreover, one grand-child.
Whereas ~item 2~ has a single child and ~item 3~ is barren.

Here's my intuitive algorithm: We obtain the indentation of the first child,
then all subsequent lines with at least that much indentation have the same ancestor.

{{{fold(get-indentation Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(defun get-indentation (string)
  "How many spaces are there at the front of â€˜stringâ€™?

  Property: The resulting number is â€˜â‰¤ length stringâ€™.
  "
  (if string (length (s-shared-start string (s-repeat (length string) " "))) 0)
)
#+END_SRC
{{{end-fold}}}

{{{fold(get-children Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun get-children (parent the-wild &key (then #'identity))
  "Go into â€˜the-wildâ€™ seeking out the first occurence of â€˜parentâ€™,
   who once found, ought to have a minimal indentation for its children.

   â€œMinimalâ€ in that if there are items with a greater indentation,
    then they are children of children and should be kept.

   The first input argument is of type â€˜stringâ€™,
   the second argument may be of type â€˜stringâ€™ or â€˜listâ€™ of strings
   ---if it's a string, we split along new lines---,
   the optional â€˜thenâ€™ is a function acting on children strings.

   Result is the parent followed by its children, as a list of lines,
   where each child has been altered using the optional â€˜thenâ€™ function.
   Moreover, we also return the rest of the unconsidered portion of â€˜the-wildâ€™:

   Result list: (  unconsidered-prefix-of-the-wild
                   (cons parent-line children-lines)
                   unconsidered-remaining-lines )

   The first element is the porition that does not contain an occurence
   of â€˜parentâ€™. The second is the parent and its children, if possible.
   The third is the remainder of the wild.

   Implementation: Look at the indentation of the
   first child, then use that as a lower bound to find the indentation
   of the remaining children.
  "

  (let ((lines (if (stringp the-wild) (s-lines the-wild) the-wild))
        (indentation -1)
        prefix
        parent-line)

    ;; Ensure: lines â‰ˆ (cons (not-here-prefix) (cons parent-here more-lines) )
    (setq lines (--split-with (not (s-contains? parent it)) lines))

    ;; Discard prefix, for now.
    (setq prefix (car lines))
    (setq lines (cadr lines))

    ;; Discard parent, but remember its contextual line.
    (setq parent-line (car lines))
    (setq lines (cdr lines))

    ;; How far is the first child indented?
    (setq indentation (get-indentation (car lines)))

    ;; Keep only the children that have at least this level of indentation.
    (setq lines&more (--split-with (<= indentation (get-indentation it)) lines))
    (setq lines (car lines&more))
    (setq unconsidered (cadr lines&more))

    ;; Alter the children according to the given function.
    (setq lines (mapcar then lines))

    ;; Yield the parent line along with the children lines; and the unconsumed wild's prefix and suffix.
    `(,prefix ,(cons parent-line lines) ,unconsidered)
  )
)
#+END_SRC
{{{end-fold}}}

Let's try this out on our example hierarchy, ~eh~, from earlier.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(cadr (get-children "+ item 1" eh))
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 |

Excellent! Let's looks at the other parents.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(get-children "+ item 2" eh)
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 |
| + item 2 | - subitem 2.2 |                    |               |
| + item 3 |               |                    |               |

Notice that we found the parent ~+ item 2~ and its only child ~- subitem 1.2~, and
we kept the prefix of ~eh~ that did not contain the parent as well as
the remaining unconsidered portion of ~eh~. ---Moreover, it looks like we obtained
the transpose of the example hierarchy ğŸ˜›

Finally, the barren parent.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(get-children "+ item 3" eh)
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem 1.1.1 | - subitem 1.2 | + item 2 | - subitem 2.2 |
| + item 3 |               |                    |               |          |               |

Everything before it is considered the prefix. Yay :smile:

Before we move on, let's try altering a child clause; e.g., I'd like
~* subitem 1.1.1~ to be renamed to ~* subitem that is super deep~.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(cadr (get-children "+ item 1" eh
 :then (lambda (x) (s-replace "1.1.1" "that is super deep" x))))
#+END_SRC

#+RESULTS:
| + item 1 | - subitem 1.1 | * subsubitem that is super deep | - subitem 1.2 |

Nice :grin:

Now the moment of truth, let's try this out on our example.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results table replace :wrap "src results-agda"
(cadr (get-children "PackageFormer" test))
#+END_SRC

#+RESULTS:
#+begin_src results-agda
| PackageFormer Semigroup (v : Variation) : Set where | _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v | Id  : Semigroup v | assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z) |
#+end_src

Also, does the list variant work:
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace  :wrap "src results-agda"
(cadr (get-children "PackageFormer" (s-lines test)))
#+END_SRC

#+RESULTS:
#+begin_src results-agda
| PackageFormer Semigroup (v : Variation) : Set where | _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v | Id  : Semigroup v | assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z) |
#+end_src

Test-driven development doesn't seem bad ğŸ˜²

These pretty-coloured tests and results may be nice for exposition,
however for maintenance it is ideal to include unit tests that can
be checked without human intervention. ~M-x ert <RET> t <RET>~, after
executing the following block, will report which tests pass and tries to explain
why tests fail.

{{{fold(Tests)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest get-ind ()
  (loop for s in '(nil "" "x" "  x" "  x ")
    do (should (<= (get-indentation s) (length s))))
  )

(ert-deftest get-child ()
  (-let [eh
"+ item 1
  - subitem 1.1
    ,* subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 2.2
+ item 3"]

    ;; Consider each line above as a parent, with â€˜ehâ€™ as the wild.
    (loop for parent in (s-split "\n" eh) do
      (let* ((cs (get-children parent eh))
             (children (cdadr cs)))

      ;; Result is a list of lists: Each is either nil or a cons.
      (loop for r in cs do (should (listp r)))

      ;; The parent line contains the parent.
      (should (equal parent (caadr cs)))

      ;; The children all have the same indentation.
      (loop for c in children for d in children do (should (equal (get-indentation c) (get-indentation d))))

      ;; Extensionality: Orginal input can be regained from resulting parts.
      (should (equal eh (s-trim (s-join "\n" (--map (s-join "\n" it) cs)))))
    )
  )
))
#+END_SRC
{{{end-fold}}}

** Substrings Delimited by Tokens

#+begin_center
/How do we find a string delimited by two tokens?/
#+end_center

Before we can get to the real stuff, we need to produce a few low-level ---string manipulation---
utilities, so that we can work with higher-level abstract datatypes.

+ ~substring-delimited~: Given ~prefix~ and ~suffix~,
  this operation takes a string of the form  ~â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯~ and yields ~needle~.
+ ~substring-delimited-$~: Given ~"âŸªprefixâŸ« $here âŸªsuffixâŸ«"~
  this operation takes a string of the form  ~â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯~ and yields ~needle~.

{{{fold(substring-delimited Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun substring-delimited
    (prefix suffix string &key preserve-spaces longest-substring)
  "Assuming â€˜stringâ€™ â‰ˆ â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯, return the /first/ such needle
   by default, unless â€˜longest-substringâ€™ is true, in which case yield /longest/
   such needle.

  NOTE: Delimiters â€˜prefixâ€™ and â€˜suffixâ€™ may be empty.

  Unless â€˜preserve-spacesâ€™ is true, we convert all adjacent whitespace
  characters to a single space in the input â€˜stringâ€™ and trim any surrounding
  whitespace from the resulting output needle string.
  "

  (if (not (and (s-contains? prefix string) (s-contains? suffix string))) string
  (--> string
   (if preserve-spaces it (s-collapse-whitespace (or it "")))
   (if (s-blank? prefix) it (s-join prefix (cdr (s-split prefix it)))) ;; Discard stuff before hand, join remaining possibly multiple parts seperated by prefix.
   (if (s-blank? suffix) (list it 'empty) (s-split suffix it))
   (if (< 1 (length it)) (-drop-last 1 it) it) ;; Discard stuff after the final occurence of â€˜suffixâ€™, if any. Indeed when suffix â‰ˆ prefix, there wont be any.
   (if longest-substring (s-join suffix it) (car it))
   (if preserve-spaces it (s-trim it))
  ))
)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(ert-deftest subst-delimit ()
  (-let [str "ğŸ˜ ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ ğŸ"] ;; Intentionally repeated â€˜ğŸœâ€™.
    ;; Pattern for loop: (prefix postfix expected-needle :comment))
    (loop for it in `( ( "" "" ,str            :Identity)
                       ( "ğŸ˜" "ğŸ" "ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ"  :Boundaries)
                       ( "" "ğŸ" "ğŸ˜ ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ" :NoLeft)
                       ( "ğŸ˜" "" "ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ ğŸ" :NoRight)
                       ( "ğŸ " ""  ,str          :BogusL)
                       ( "" "âˆ"  ,str          :BogusR)
                       ( "ğŸ " "âˆ" ,str          :BogusLR)
                     )
      do (should (equal (third it) (substring-delimited (first it) (second it) str))))

    ;; Longest substring
    (should (equal "ğŸ›" (substring-delimited "ğŸš" "ğŸœ" str)))
    (should (equal "ğŸ› ğŸœ ğŸ" (substring-delimited "ğŸš" "ğŸœ" str :longest-substring t)))
    ;; We expect to see from ğŸš to the very final occurance of a ğŸœ.

    ;; Identical boundaries.
    (should (equal "ğŸ™" (substring-delimited "ğŸ˜" "ğŸ˜" "ğŸ˜ ğŸ™ ğŸ˜")))
    (should (equal ""  (substring-delimited "ğŸ˜" "ğŸ˜" "ğŸ˜ ğŸ˜")))
    (should (equal ""  (substring-delimited "ğŸ˜" "ğŸ˜" "ğŸ˜ğŸ˜")))

    ;; Multiple occurances of prefix or postfix
    (should (equal "x ğ‘³ y"  (substring-delimited "ğ‘³" "ğ‘¹" "ğ‘³ x ğ‘³ y ğ‘¹")))
    (should (equal "x"  (substring-delimited "ğ‘³" "ğ‘¹" "ğ‘³ x ğ‘¹ y ğ‘¹")))
    (should (equal "x ğ‘¹ y"  (substring-delimited "ğ‘³" "ğ‘¹" "ğ‘³ x ğ‘¹ y ğ‘¹" :longest-substring t)))

    ))
#+END_SRC
{{{end-fold}}}

{{{fold(substring-delimited-$ Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun substring-delimited-$
    (context string &key preserve-spaces longest-substring)
  "Assuming â€˜contextâ€™ = â€œâŸªprefixâŸ« $here âŸªsuffixâŸ«â€
   and â€˜stringâ€™ â‰ˆ â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯, return the /first/ such needle
   by default, unless â€˜longest-substringâ€™ is true, in which case yield /longest/
   such needle.

  NOTE: âŸªprefixâŸ« and âŸªsuffixâŸ« cannot be emptry strings!

  Unless â€˜preserve-spacesâ€™ is true, we convert all adjacent whitespace
  characters to a single space in the input â€˜stringâ€™ and trim any surrounding
  whitespace from the resulting output needle string.
  "

  (-let [pre-post (s-split "$here" context)]
    (substring-delimited (s-trim (car pre-post)) (s-trim (cadr pre-post)) string
     :preserve-spaces preserve-spaces :longest-substring longest-substring)
  )
)

(ert-deftest subst-delimit-$ ()
  (-let [str "ğŸ˜ ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ ğŸ"] ;; Intentionally repeated â€˜ğŸœâ€™.
    ;; Pattern for loop: (prefix postfix expected-needle :comment)
    (loop for it in `( ( "$here" ,str              :Identity)
                       ( "ğŸ˜ $here ğŸ" "ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ"  :Boundaries)
                       ( "$here ğŸ" "ğŸ˜ ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ"  :NoLeft)
                       ( "ğŸ˜ $here"  "ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸœ ğŸ" :NoRight)
                       ( "ğŸ  $here"   ,str          :BogusL)
                       ( "$here âˆ"   ,str          :BogusR)
                       ( "ğŸ  $here âˆ" ,str          :BogusLR)
                     )
      do (should (equal (second it) (substring-delimited-$ (first it) str))))

    ;; Longest substring
    (should (equal "ğŸ›" (substring-delimited-$ "ğŸš $here ğŸœ" str)))
    (should (equal "ğŸ› ğŸœ ğŸ" (substring-delimited-$ "ğŸš $here ğŸœ" str :longest-substring t)))
    ;; We expect to see from ğŸš to the very final occurance of a ğŸœ.

    ;; Identical boundaries.
    (should (equal "ğŸ™" (substring-delimited-$ "ğŸ˜ $here ğŸ˜" "ğŸ˜ ğŸ™ ğŸ˜")))
    (should (equal ""  (substring-delimited-$ "ğŸ˜ $here ğŸ˜" "ğŸ˜ ğŸ˜")))
    (should (equal ""  (substring-delimited-$ "ğŸ˜ $here ğŸ˜" "ğŸ˜ğŸ˜")))

    ;; Multiple occurances of prefix or postfix
    (should (equal "x ğ‘³ y"  (substring-delimited-$ "ğ‘³ $here ğ‘¹" "ğ‘³ x ğ‘³ y ğ‘¹")))
    (should (equal "x"  (substring-delimited-$ "ğ‘³ $here ğ‘¹" "ğ‘³ x ğ‘¹ y ğ‘¹")))
    (should (equal "x ğ‘¹ y"  (substring-delimited-$ "ğ‘³ $here ğ‘¹" "ğ‘³ x ğ‘¹ y ğ‘¹" :longest-substring t)))

    ;; Space irrelevance for keyword â€˜$hereâ€™:
    (should (equal "ğŸ™" (substring-delimited-$ "ğ‘³ $here ğ‘¹" "ğ‘³ ğŸ™ ğ‘¹")))
    (should (equal "ğŸ™" (substring-delimited-$ "ğ‘³ $hereğ‘¹" "ğ‘³ ğŸ™ ğ‘¹")))
    (should (equal "ğŸ™" (substring-delimited-$ "ğ‘³$here ğ‘¹" "ğ‘³ ğŸ™ ğ‘¹")))
    (should (equal "ğŸ™" (substring-delimited-$ "ğ‘³$hereğ‘¹" "ğ‘³ ğŸ™ ğ‘¹")))
    (should (equal "ğŸ™" (substring-delimited-$ "ğ‘³      $here  ğ‘¹" "ğ‘³ ğŸ™ ğ‘¹")))
    ))
#+END_SRC
{{{end-fold}}}

Suppose a user provides us with an awkwardly spaced PackageFormer header,
our string manipulation setup is robust enough to get at the constituents:
#+BEGIN_SRC emacs-lisp :results replace :exports both
(-let [header "PackageFormer  Semigroup   (  v : Variation) : Set (  â„“expr)   where"]
  ;; Three kinds of invocations; the last is my preferred choice â™¥â€¿â™¥
  `( ,(substring-delimited "PackageFormer " "(" header :preserve-spaces t :longest-substring t)
     ,(substring-delimited "PackageFormer " "(" header)
     ,(substring-delimited-$ "PackageFormer $here (" header)
   )
)
#+END_SRC

#+RESULTS:
| Semigroup   (  v : Variation) : Set | Semigroup | Semigroup |

The aim is to eventually have an interface that interacts with an buffer containing Agda code.
To that end, we propose that our fictitious syntax be directly embedded via special comments,
~{-700 â‹¯ -}~, henceforth referred to as â€œ<<<700-comments>>>â€.

+ ~(buffer-substring-delimited starting-regexp ending-regexp)~ yields the /next/ portion of the buffer
  as a string, relative to the current position of the cursor, that is contained in the â€˜parenthesisâ€™
  ~starting-regexp~ and ~ending-regexp~.

+ ~(buffer-substring-delimited-whole-buffer starting-regexp ending-regexp)~ yields /all/ portions of the buffer,
  contained in the â€˜parenthesisâ€™ ~starting-regexp~ and ~ending-regexp~, as a list of strings.

  - Cursor position is saved.
  - This function let's us obtain the contents of /all/ 700-comments.

{{{fold(buffer-substring-delimited Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun buffer-substring-delimited (start end &optional (highlight nil))
  "
  Get the current buffer's /next/ available substring that is delimited
  between the regexp tokens â€˜startâ€™ up to â€˜endâ€™, exclusively.

  If no tokens are found, an error is thrown.

  The â€˜highlightâ€™ option simply highlights the selected region ---visual feedback
  for the user.
  "
  (let (p1 p2)
    (re-search-forward start)
    (setq p1 (point))

    (re-search-forward end)
    (backward-word)
    (setq p2 (point))

    (when highlight ;; do we want to highlight the region?
      (goto-char p1)
      (push-mark p2)
      (setq mark-active t)
    )

    ;; (copy-region-as-kill p1 p2)
    (buffer-substring-no-properties p1 p2)
))
#+END_SRC
{{{end-fold}}}

{{{fold(buffer-substring-delimited-whole-buffer Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun buffer-substring-delimited-whole-buffer (start end)
  "Return a list of all substrings in the current buffer that
   are delimited by regexp tokens â€˜startâ€™ and â€˜endâ€™, exclusively.
  "
  (save-excursion
    (let ((l nil) (continue t))
     (beginning-of-buffer)

     (while continue
       (condition-case nil
         ;; attemptClause
         (setq l (cons (buffer-substring-delimited start end) l))
         ;; recoveryBody
         (error (setq continue nil))))

     ;; We've collected items as we saw them, so â€˜lâ€™ is in reverse.
    (reverse l)
    )
  )
)
#+END_SRC
{{{end-fold}}}

Here are some possible invocations, the last one being our use case.
#+BEGIN_SRC emacs-lisp
;; Get text delimited by quotes
(buffer-substring-delimited "^\"" "^\"")

;; Get text delimited by usual Agda comments
(buffer-substring-delimited "^\{-" "^-\}")

;; Execute the following in an Agda buffer to see this function in action.
(setq it (buffer-substring-delimited-whole-buffer "^\{-700" "^-\}"))
#+END_SRC

We also want to prefix the generated file with the imports of the current file.
{{{fold(extract-imports Implementation)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun extract-imports ()
  "Return substring of buffer whose lines mention â€œimportâ€.
   Throw away any that mention the substring â€œâŸªFileNameâŸ«_Generatedâ€.
  "
  (thread-last (buffer-substring-no-properties (point-min) (point-max))
    (s-split "\n")
    (--filter (s-contains? "import" it))
    (--remove (s-contains?
               (format  "%s_Generated" (file-name-sans-extension (buffer-name))) it))
    (s-join "\n")
  )
)
#+END_SRC
{{{end-fold}}}

So much string meddling, hopefully no more ğŸ™ˆ :hear_no_evil: :speak_no_evil:

* The ~package-former~ Datatype

For this prototype's constraints, a PackageFormer will generally declared as
#+BEGIN_SRC agda :tangle no
PackageFormer Semigroup (v : Variation) : Set â„“ where
     â‹®
#+END_SRC

The body, ~â‹®~, of such a declaration mentions ~Semigroup v~, which we would like to rewrite
with other names when the package is instantiated. Likewise, we also want to erase or rewrite
the sole parameter, and possibly increment the level. Let's form a type to work with these components
rather than meddle with strings all the time.

#+BEGIN_SRC emacs-lisp  :tangle yes
(defvar package-formers nil
  "The list of PackageFormer schema declarations in the current Agda buffer.")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(defstruct package-former
  "Record of components that form a PackageFormer.

   - â€˜docstringâ€™: Relevant documentation about this structure; e.g.,
      what is the instance declaration that generated this type, if any.

   - â€˜typeâ€™: PackageFormer, record, data, module, etc.

   - â€˜nameâ€™: The name of the grouping mechanism schema.

   - â€˜levelâ€™: The universe level that the instantiations will inhabit.
              The universe level of the PackageFormer.

   - Finally, the children fields are the typed-names that constitute the body of the
     grouping mechanism. As long as consistent indentation is selected, it does not matter how much.
     As such, we keep track of these indentation numerics ourselves in case we need to tweak them.

   - Internally, the zeroth element always refers to the variation symbol whereas the first element
     refers to the â€˜universe of discourse ğ’°â€™, if any is explicitly provided, and the next â€˜waistâ€™-many
     elements are considered parameters. Note that for an ADT, ğ’° is the ADT name, the ğ’° of a record
     is the record name, but for a typeclass ğ’° is generally specfiied as a set, say â€œCarrier : Set â„“â€.
  "
  docstring
  type
  name
  level

  waist ;; Delimits elements into parameters and fields.

  ;; children
  indentation ;; useful for when new elements are added.
  elements
)
#+END_SRC

It will get rather redundant to write ~(package-former-X p)~ to project the constituents of a PackageFormer ~p~. As such, let's introduce
a useful macro to â€œopen pâ€ locally.
#+BEGIN_SRC emacs-lisp :tangle yes
;; An anaphoric macro ^_^
(defmacro open-pf (p &rest body)
  `(let*
    ((docstring             (package-former-docstring ,p))
     (type                  (package-former-type ,p))
     (name                  (package-former-name ,p))
     (level                 (package-former-level ,p))
     (waist                 (package-former-waist ,p))
     (indentation           (package-former-indentation ,p))
     (elements              (package-former-elements ,p))

    ;; It is the user's repsonsibility to pop-off the variation,
    ;; if it is undesirable.

    (carrier               (nth 1 elements))
    (parameters            (-take waist elements))
    (fields                (-drop waist elements)))
    ,@body
  )
)
#+END_SRC

( Lisp convention would advise this function to be named ~with-pf~, but I'm using the prefix ~open~,
as it is closer to the object language, Agda. )

Finally, it seems we need support for typed names ---pairs ~â€œname : typeâ€~.
We could use ~car~ and ~cdr~ on pairs, but let's use named projections instead
so we don't have this extra mental strain and implicit type-checking to ensure.
{{{fold(Working with â€œname : typeâ€ Pairs)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(defun make-tn (name type)
  "Produce a typed-name pair."
  (concat (s-trim name) " : " (s-trim type)))

(defun get-name (tn)
  "Given a string â€œname : typeâ€, return the â€˜nameâ€™;
   which will not have any colons in it.
   Whitespace at the edges is trimmed away.
  "
  (s-trim (car (s-split " : " tn))))

(defun get-type (tn)
  "Given a string â€œname : typeâ€, return the longest possible â€˜typeâ€™ substring.
  Whitespace at the edges is trimmed away."
  (s-trim (s-join " : " (cdr (s-split " : " tn)))))

;;

(defmacro map-name (fbody tn)
  "Apply string expression â€˜fbodyâ€™ to the â€˜nameâ€™ position of a typed-named structure.
   â€˜fbodyâ€™ may mention â€˜nameâ€™.
  "
  `(let ((name (get-name ,tn)))
       (make-tn ,fbody (get-type ,tn)))
)

(defmacro map-type (fbody tn)
  "Apply string expression â€˜fbodyâ€™ to the â€˜typeâ€™ position of a typed-named structure.
   â€˜fbodyâ€™ may mention â€˜typeâ€™.
  "
  `(let ((type (get-type ,tn)))
       (make-tn (get-name ,tn) ,fbody))
)

(ert-deftest tn ()
  ;; Superflous space
  (should (equal "name" (get-name "name   : type")))
  ;; Multiple â€œ:â€.
  (should (equal "âˆ€ {X : Obj ğ’} â†’ (X âŸ¶ X)"
                 (get-type"Id : âˆ€ {X : Obj ğ’} â†’ (X âŸ¶ X)") ))
  )

#+END_SRC
{{{end-fold}}}

** Package Former Parsing and Pretty Printing

With this in hand, let's produce a robust parser.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun parse-package-former (lines)
  "The input â€˜linesâ€™ must be a list of lines forming a full PackageFormer declaration;
   e.g., obtained by calling â€˜get-childrenâ€™.

   It is parsed and a â€˜package-formerâ€™ value is returned.

   - Whitespace is stripped off of items.
   - Docstrings are ignored.
  "

  ;; Precondition example, with intentionally strange whitespacing:
  ;; header â‰ˆ â€œPackageFormer Semigroup   (v : Variation) : Set  ( â„“expr)   whereâ€

  (if (not lines)
      (error "parse-package-former: Error: Input must be non-empty list.")

  (let* ((header (car lines))
         (vs (substring-delimited-$ "($here : Variation" header))
         (name (substring-delimited-$ "PackageFormer $here (" header))
         (level (substring-delimited-$ "Set$here where" header))
         (carrier (concat name " " vs " : Set" level)))

    (--map (highlight-phrase (s-trim it) 'hi-yellow) (cdr lines))

    (make-package-former
     :type                     "PackageFormer"
     :name                     name
     ;; â€˜levelâ€™ may be â€œâ€, that's okay. It may be a subscript & so no space after â€˜Setâ€™.
     :level                    level
     :waist                    1 ;; The variation symbol is a parameter
     :indentation              (get-indentation (cadr lines))
     :elements                 (-cons* (concat vs " : Variation") carrier (--map (s-trim it) (cdr lines))))
  )
))

(ert-deftest pf-parse ()

  ;; Error on empty list of lines.
   (should-error (parse-package-former nil))

   ;; No crash on empty line.
   (should (parse-package-former (list "")))

   ;; No crash on PackageFormer with no elements.
   (should (parse-package-former (list "PackageFormer PF (w : Variation) : Set â„“ where")))

   ;; Full parsing.
   (-let [pf (parse-package-former (cadr (get-children "PackageFormer" test)))]
     (should (equal pf
                    #s(package-former nil "PackageFormer" "Semigroup" "" 1 4
                        ("v : Variation" "Semigroup v : Set"
                         "_â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v"
                         "Id  : Semigroup v"
                         "assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)"))))
  ))
#+END_SRC

Let's try this out.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results table replace
(parse-package-former (cadr (get-children "PackageFormer" test)))
#+END_SRC

#+RESULTS:
| #s(package-former nil PackageFormer Semigroup  1 4 (v : Variation Semigroup v : Set _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v Id  : Semigroup v assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z))) |

Conversely, let's have a pretty printer.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun special (f)
  "Special elements, for whatever reason are exceptional, and so
   are maked as singleton lists and their indentation is lessened.
   That is, these denote sibling fields rather than more children.

   Special elements include: field, private.

   See â€˜show-package-formerâ€™ for their use and how their printed.
  "
  (--any? (s-contains? it f) '("field" "private")))

(cl-defun show-package-former (p &key waist-strings
                                 (omit-level nil) omit-docstring omit-car-element)
  "Pretty print a package-former record value.

   -â€˜waist-stringsâ€™: Arbitrary new elements that are input at the location of the
     PackageFormer's waist. E.g., the following results in a new local alias â€˜nâ€™
     before the remaining constitutents are printed under a â€œfieldâ€ clause.

         :waist-strings (list â€œprivateâ€ â€œn : â„•â€ â€œn = 3â€ â€œfieldâ€)
  "

  (open-pf p (s-join "\n" (-cons*

     ;; 0. The documentation string
     (and (not omit-docstring) docstring (format "{- %s -}" docstring))

     ;; 1. The schema declaration
     (s-collapse-whitespace (s-join " "
        (list type name (s-join " " (--map (concat "(" it ")") parameters))
              (unless omit-level (concat ": Set" level))
              "where")))

     ;; The elements of a PackageFormer
       (thread-last fields

        ;; Print the waist strings; not efficient, but thisâ€™ a prototype.
        (-split-at waist)
        (funcall (lambda (it) (-concat (car it) waist-strings (cadr it))))

        ;; Indent all elements, less indentation for the specials.
        (--map (concat (s-repeat (- indentation (if (special it) 2 0)) " ") it))
        (funcall (if omit-car-element #'cdr #'identity))
        )
    )
  )
))
#+END_SRC

Let's test it out by /including/ a whole new local variable and trying
to include the ~field~ Agda keyword.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(-let [pf (cadr (get-children "PackageFormer" test))]
   (show-package-former (parse-package-former pf)
    :omit-car-element t
    :waist-strings (list "private" "n : â„•" "n = 3" "field {- elements -} "))
   ))
#+END_SRC

#+RESULTS:
#+begin_src results-agda

PackageFormer Semigroup (v : Variation) : Set where
  private
    n : â„•
    n = 3
  field {- elements -}
    _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v
    Id  : Semigroup v
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
#+end_src

The call to ~s-collapse-whitespace~ permits us to phrase an approximation of the opinion
that parsing and showing should be inverses.

#+BEGIN_SRC emacs-lisp :var test = test :exports both :results table replace
(-let [pf (cadr (get-children "PackageFormer" test))]
  (equal (s-concat "\n" (s-join "\n" pf))
         (show-package-former (parse-package-former pf) :omit-car-element t)))
#+END_SRC

#+RESULTS:
| t |

#+begin_center
( /In Lisp, ~t~ denotes â€œtrueâ€!/ )
#+end_center

:Assert_based_test:
Since this test makes use of a â€˜testâ€™ output variable, we cannot
encode it using ert; instead we use a raw assert.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace
  (-let [pf (cadr (get-children "PackageFormer" test))]
  (assert (equal (s-concat "\n" (s-join "\n3" pf))
                 (show-package-former (parse-package-former pf)
                         :omit-car-element t)))
  )
#+END_SRC

#+RESULTS:

:End:

* Parsing an Agda Buffer

Before we can parse an Agda buffer, we need to be able to parse an instantiation declaration;
for which we would later generate code.

** ~instantiations-remaining~ list
Here in we define the datatype of ~instance-declaration~, describe how
to parse such entities, and monitor them within list.
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar instantiations-remaining nil
  "The PackageFormer instantiations that need to be performed.")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(defstruct instance-declaration
  "Record of componenets for an PackageFormer instance declaration:
   âŸªnameâŸ« = âŸªpackage-formerâŸ« âŸªvariationâŸ« (âŸªrenamesâŸ« | âŸªhidingsâŸ« | âŸªmanifestâŸ« | âŸªexposesâŸ« | âŸªdecorationsâŸ«)
   âŸªrenamesâŸ«     = Îµ | renaming (Î± to Î±â€² ; â€¦ ; Ï‰ to Ï‰â€²)
   âŸªopeningâŸ«     = Îµ | opening (âŸªrecord-nameâŸ«; Î± to Î±â€² ; â€¦ ; Ï‰ to Ï‰â€²)
   âŸªhidingsâŸ«     = Îµ | hiding (Î±; â€¦; Ï‰)
   âŸªmanifestâŸ«    = Îµ | with (Î± to Î±â€² ; â€¦ ; Ï‰ to Ï‰â€²)
   âŸªexposesâŸ«     = Îµ | exposes (Î±; â€¦; Ï‰)
   âŸªdecorationâŸ«  = decorated (it-exprssion)  ;; TODO: Form generalised renaming; use a Î»: Agda users aren't acustomed to anaphoric macros.
  "
  docstring ;; What the declaration looks like, useful for reference.
  name package-former variation
  (waist 0)
  renames  ;; an association list, trimmed whitespace
  hidings  ;; list, trimmed whitespace
  manifest ;; an association list, trimmed whitespace
  exposes  ;; list, trimmed whitespace
  decorations ;; function to be applied to name and element-names of a PackageFormer.
  opening ;; FIXME: Not ideal; merge with renaming?
  extra-params
)
#+END_SRC

TODO: Above, instead of ~renames~ have a field, say, ~alteration~ which is intended
to be a functional reification of a Variation expression; e.g., the renaming ops are within ~alteration~.
Before moving to this generality, ensure ~renames~ works then generalise.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun load-instance-declaration (line)
  "If the current â€˜lineâ€™ string is an instance declaration,
   then parse and add it to the list of â€˜instantiations-remainingâ€™;
   else do nothing.

   Returns the instance-declaration that was loaded, otherwise nil.

   Whitespace is automatically collopased from â€˜lineâ€™.
  "

  ;; Example instance declaration:
  ;; â€œMagmaR = Magma record renaming (Carrier to C; _â¨¾_ to _âˆ˜_)â€
  ;; â‡’ â‰¥4 pieces, separated by spaces, where second item must be an equality.
  ;; Note: (cddddr nil) â‰ˆ nil

  (let* (inst (pieces (s-split " " (s-collapse-whitespace line))) (more (cddddr pieces)) renames hidings exposes manifest (unbundling 0) decorations openings openings-param)
   (when (and (<= 4 (length pieces)) (equal (nth 1 pieces) "="))

     (when (equal (car more) "unbundling")

       ;; Discard identifying tokens
       (setq unbundling (string-to-number (cadr more))))


     (when (equal (car more) "hiding")

       ;; Stick them back together
       (setq hidings (s-join " " more))

       ;; Discard identifying tokens
       (setq hidings (substring-delimited-$ "hiding ($here)" hidings))

       ;; Split along semicolons to obtain a list.
       (setq hidings (--map (s-trim it) (s-split ";" hidings))))


     (when (equal (car more) "exposing")

       ;; Stick them back together
       (setq exposes (s-join " " more))

       ;; Discard identifying tokens
       (setq exposes (substring-delimited-$ "exposing ($here)" exposes))

       ;; Split along semicolons to obtain a list.
       (setq exposes (--map (s-trim it) (s-split ";" exposes)))

       ;; The exposed items should be hoisted upwards in the elements listing.
       ;;
       ;; Then the waist is also hoisted.
       (setq unbundling (length exposes))
       )

     (when (equal (car more) "with")

       ;; Stick them back together
       (setq manifest (s-join " " more))

       ;; Discard identifying tokens
       (setq manifest (substring-delimited-$ "with ($here)" manifest))

       ;; Split along semicolons, then turn into dotted pairs.
       (setq manifest (--map (cons (s-trim (first it)) (s-trim (second it))) (--map (s-split "to" it) (s-split ";" manifest))))

       ;; If â€˜Carrierâ€™ is one of the items, then reduce the waist line;
       ;; otherwise the next item is hoisted upwards.
       (when (--any? (equal it "Carrier") (-map #'car manifest))
           (decf unbundling)
       ))

     ;; LHS = PF opening (âŸªrecord-nameâŸ«; Î± to Î±â€² ; â€¦ ; Ï‰ to Ï‰â€²)
     ;;
     ;; NOTE: This clause differs from the rest: No variation tag â€˜record, data, typeclassâ€™.
     ;; Since a âŸªrecord-nameâŸ« is requested, even the PF is irrelevant.
     (when (equal (nth 3 pieces) "opening")
      (setq openings
       (thread-last
         ;; Stick them back together
         (s-join " " more)

         ;; Discard identifying tokens
         (substring-delimited-$ "opening ( $here )")

         ;; Split along semicolons
         (s-split ";")

         ;; Save the name of the record being opened
         (funcall (lambda (it) (setq openings-param (s-chop-prefix "(" (car it))) (cdr it)))

         ;; MA: TODO: Turn the rest into dotted pairs.
         ;; (--map (s-split "to" it))
         ;; (--map (cons (s-trim (first it)) (s-trim (second it))))

         ;; Transform it into a Lisp expression
         (-take-last 1)
         car
         (s-replace "++" " ")
         (format "(concat %s)")
       )))


     (when (equal (car more) "renaming")

       ;; Stick them back together
       (setq renames (s-join " " more))

       ;; Discard identifying tokens
       (setq renames (substring-delimited-$ "renaming ($here)" renames))

       ;; Split along semicolons, then turn into dotted pairs.
       (setq renames (--map (cons (s-trim (first it)) (s-trim (second it))) (--map (s-split "to" it) (s-split ";" renames)))))


     ;; E.g., PFâ€² = PF v decorated (â‹¯itâ‹¯ ++ "â€²")
     (when (equal (car more) "decorated")

       ;; Stick them back together
       (setq decorations (s-join " " more))

       ;; Discard identifying tokens
       (setq decorations (substring-delimited-$ "decorated ($here)" decorations))

       ;; Transform it into a Lisp expression.
       (setq decorations (s-replace "++" " " decorations))
       (setq decorations (format "(concat %s)" decorations)))

     (setq inst (make-instance-declaration
                 :docstring      line
                 :name           (nth 0 pieces)
                 :package-former (nth 2 pieces)
                 :variation      (nth 3 pieces)
                 :waist          unbundling
                 :hidings        hidings
                 :exposes        exposes
                 :manifest       manifest
                 :opening        openings
                 :extra-params   openings-param
                 :decorations    decorations
                 :renames        renames))

     (add-to-list 'instantiations-remaining inst)

     ;; PackageFormer names are in yellow; instances are are bolded.
     (highlight-phrase (format "%s " (nth 2 pieces)) 'hi-yellow)
     (highlight-phrase (nth 0 pieces) 'bold) ;; 'warning) ;; i.e., orange

   )
   ;; Return value.
   inst
  )
)

(ert-deftest load-inst () "" t)
(when nil
  :expected-result :failed
  (should (equal (load-instance-declaration "MagmaR = Magma record renaming (Carrier to C; _â¨¾_ to _âˆ˜_)")
                 #s(instance-declaration "MagmaR = Magma record renaming (Carrier to C; _â¨¾_ to _âˆ˜_)" "MagmaR" "Magma" "record" 0
                 (("Carrier" . "C") ("_â¨¾_" . "_âˆ˜_")) nil nil nil nil nil)))

  ;; Extra whitespace
  (should (equal (load-instance-declaration "MagmaR    = Magma record renaming (Carrier to C; _â¨¾_ to _âˆ˜_)")
                 #s(instance-declaration "MagmaR    = Magma record renaming (Carrier to C; _â¨¾_ to _âˆ˜_)" "MagmaR" "Magma" "record" 0
                 (("Carrier" . "C") ("_â¨¾_" . "_âˆ˜_")) nil nil nil nil nil)))


  ;; TODO: Test where we forgot to provide a name on the LHS, fix code to yield an error message-box.
  ;; More tests needed.
  (should (equal 'more-tests-for-loaded-instance 'needed))

)

#+END_SRC

{{{fold(Tests)}}}

#+BEGIN_SRC emacs-lisp :results replace
(load-instance-declaration
  "LHS = Magma opening (MagmaR; Carrier to C; _â¨¾_ to _âˆ˜_; it ++ \"â€²\"") ;; MA: TODO: Acknowledge init-tail of to-list.
#+END_SRC

#+RESULTS:
: #s(instance-declaration "LHS = Magma opening (MagmaR; Carrier to C; _â¨¾_ to _âˆ˜_; it ++ \"â€²\"" "LHS" "Magma" "opening" 0 nil nil nil nil nil "(concat  it   \"â€²\")" "MagmaR")

Testing renames:
#+BEGIN_SRC emacs-lisp :results replace
(pp (load-instance-declaration
  " = Magma record renaming (Carrier to C; _â¨¾_ to _âˆ˜_)"))
#+END_SRC

#+RESULTS:
: #s(instance-declaration " = Magma record renaming (Carrier to C; _â¨¾_ to _âˆ˜_)" "" "Magma" "record" 0
: (("Carrier" . "C")
: ("_â¨¾_" . "_âˆ˜_"))
: nil nil nil nil nil nil)

Testing unbundling:
#+BEGIN_SRC emacs-lisp :results replace
(pp (load-instance-declaration
  "MagmaR = Magma record unbundling 3"))
#+END_SRC

#+RESULTS:
: #s(instance-declaration "MagmaR = Magma record unbundling 3" "MagmaR" "Magma" "record" 3 nil nil nil nil it)

Testing hiding:
#+BEGIN_SRC emacs-lisp :results replace
(pp (load-instance-declaration
  "MagmaR = Magma record hiding (Id)"))
#+END_SRC

#+RESULTS:
: #s(instance-declaration "MagmaR = Magma record hiding (Id)" "MagmaR" "Magma" "record" 0 nil
: ("Id")
: nil nil nil)

Testing manifest clause:
#+BEGIN_SRC emacs-lisp :results replace
(pp (load-instance-declaration
  "MonoidB = Monoid record with (Carrier to ğ”¹; Id to false)"))
#+END_SRC

#+RESULTS:
: #s(instance-declaration "MonoidB = Monoid record with (Carrier to ğ”¹; Id to false)" "MonoidB" "Monoid" "record" -1 nil nil
: (("Carrier" . "ğ”¹")
: ("Id" . "false"))
: nil)

This limits us to have monoidal operations âˆ¨ or â‰¢, for example, but forbids âˆ§ and â‰¡.

Testing exposes clause:
#+BEGIN_SRC emacs-lisp :results replace
(pp (load-instance-declaration
  "MonoidB = Monoid record exposing (Carrier; Id)"))
#+END_SRC

#+RESULTS:
: #s(instance-declaration "MonoidB = Monoid record exposing (Carrier; Id)" "MonoidB" "Monoid" "record" 2 nil nil nil
: ("Carrier" "Id"))

This is a counterpart to Agda's ~using~ keyword, we are only showing items as parameters and the rest are â€˜hiddenâ€™ as components.

Testing decoration clause:
#+BEGIN_SRC emacs-lisp :results replace
(pp (load-instance-declaration
  "MonoidB = Monoid record decorated (it ++ \"â€²\")"))
#+END_SRC

#+RESULTS:
: #s(instance-declaration "MonoidB = Monoid record decorated (it ++ \"â€²\")" "MonoidB" "Monoid" "record" 0 nil nil nil nil "(concat it   \"â€²\")")



{{{end-fold}}}

** ~parse-700-comments~
#+BEGIN_SRC emacs-lisp  :tangle yes
(defvar 700-comments nil
  "The contents of the 700-comments.

   If this variable does not change, we short-circut all processing.
   See step â€˜Â½â€™ below.
  ")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(defvar porting-list nil
  "List of items in 700-comments that are neither PackageFormer declarations
   nor instantations, and so are ported to the generated file.")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun parse-700-comments ()
  "
   Parse comments of the form â€œ{-700 â‹¯ -}â€ and add all PackageFormer declarations
   to the â€˜package-formersâ€™ list and all instantations to the â€˜instantiations-remainingâ€™ list.
  "
  (interactive)

  ;; For now, â€˜itemâ€™ is either a PackageFormer or instantiation declaration.
  (let (item lines 700-cmnts)

  ;; 0. Catenate all 700-comments into a single string.
  (setq 700-cmnts (s-join "\n" (buffer-substring-delimited-whole-buffer "^\{-700" "^-\}")))

  (if (equal 700-comments 700-cmnts) (message "700-comments Unchanged.")

    ;; Â½. Update global.
    (setq 700-comments 700-cmnts)

    ;; 1. View comments as a sequence of lines, ignore empty lines ---which are not in our grammar.
    (setq lines (--remove (s-blank? (s-collapse-whitespace it)) (s-lines 700-comments)))

    ;; 2. Traverse the 700-comments:
    ;; If we view a â€œlhs = rhsâ€ equation, add to global â€˜instantiations-remainingâ€™ list.
    ;; If we view a PackageFormer declaration, add to global â€˜package-formersâ€™ list.
    (while lines
     (setq item (car lines))
     (if (load-instance-declaration item) (setq lines (cdr lines))
       ;; Else we have a PackageFormer declaration and other possiblly-non-700 items.
       (setq item (get-children "PackageFormer" lines))
       (push (s-join "\n" (car item)) porting-list) ;; port non-700 items to generated file
       (when (cadr item) (add-to-list 'package-formers (parse-package-former (cadr item)))) ;; acknowledge PackageFormer declaration, if any
       (setq lines (caddr item))))                                        ;; Update lines to be the unconsidered porition of the wild comments.

  (message "Finished parsing 700-comments.")
  )
))
#+END_SRC

Let's test this out on our sample input file, ~Testing.agda~.
#+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
(progn
  (find-file "Testing.agda")

  (setq package-formers nil) (setq 700-comments nil)
  (setq instantiations-remaining nil)
  (parse-700-comments)

  (switch-to-buffer "PackageFormer.org")

  (s-join "\n\n"
          (list (s-trim 700-comments)
                (pp package-formers) (pp instantiations-remaining)))
)
#+END_SRC

#+RESULTS:
#+begin_src results-agda
variable
   â„“ : Level

PackageFormer Monoid (v : Variation) : Set where
    _â¨¾_     : Monoid v â†’ Monoid v â†’ Monoid v
    Id      : Monoid v
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Monoid v} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Monoid v} â†’ x â¨¾ Id â‰¡ x

MonoidTypeclass = Monoid typeclass hiding (_â¨¾_)
MonoidT = Monoid typeclass renaming (Carrier to C; _â¨¾_ to _âŠ•_)
MonoidR = Monoid record unbundling 2

(#s(package-former nil "PackageFormer" "Monoid" "" 1 4
                   ("v : Variation" "Monoid v : Set" "_â¨¾_     : Monoid v â†’ Monoid v â†’ Monoid v" "Id      : Monoid v" "assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)" "leftId  : âˆ€ {x : Monoid v} â†’ Id â¨¾ x â‰¡ x" "rightId : âˆ€ {x : Monoid v} â†’ x â¨¾ Id â‰¡ x")))


(#s(instance-declaration "MonoidR = Monoid record unbundling 2" "MonoidR" "Monoid" "record" 2 nil nil nil nil nil)
   #s(instance-declaration "MonoidT = Monoid typeclass renaming (Carrier to C; _â¨¾_ to _âŠ•_)" "MonoidT" "Monoid" "typeclass" 0
                           (("Carrier" . "C")
                            ("_â¨¾_" . "_âŠ•_"))
                           nil nil nil nil)
   #s(instance-declaration "MonoidTypeclass = Monoid typeclass hiding (_â¨¾_)" "MonoidTypeclass" "Monoid" "typeclass" 0 nil
                           ("_â¨¾_")
                           nil nil nil))
#+end_src

* TODO ~instantiate~ ---the core utility :BROKEN:
** Top matter :ignore:
Let's put the pieces together.
#+BEGIN_SRC emacs-lisp  :tangle yes
(cl-defun instantiate (decls &key

  new-name (type "record") carrier
  name-suffix
  universe-of-discourse

  omit-level-decl
  (waist 0)
  waist-strings
  prefix-fields
  suffix-fields
  (keep-fields (lambda (x) t))
  (alter-raw-fields #'identity)
  (alter-fields #'identity)
  docstring
  (inc-level t)
  )

  "Given a PackageFormer declaration, instantiate it into a concrete Agda type.

   Remarks or example values:

   - â€˜declsâ€™ is immediately provided to â€˜get-childrenâ€™, so it may be a string,
      a list, or a value of type â€˜package-formerâ€™.
      NOTE: If you do pass in a â€˜package-formerâ€™, we will not alter yours;
      we will copy it and work with the local copy.

   - â€˜typeâ€™: The replacement for â€œPackageFormerâ€; default is â€œrecordâ€.

   - â€˜carrierâ€™: What is the carrier of this new instance? E.g., â€œCarrierâ€.
      By default it's the â€˜new-nameâ€™; but this is unresonable when, say, a typeclass
      variation is requested.

   - â€˜name-suffixâ€™: When no â€˜new-nameâ€™ is provided, the default is
      â€œâŸªPackageFormer'sNameâŸ«-âŸªvariationâŸ«-g*â€, where â€˜*â€™ is an arbitrarily generated number.

     This may be useful for rapid development when one does not want to provide
     a name to an instance, but simply wants the instance to exist.

   - â€˜waistâ€™: Agda grouping mechanisms ---e.g., record, data, module, function---
      essentially take a list of parameters. The nebulous consitutents of a PackageFormer
      are partitioned into two groups: The first â€˜waistâ€™-many elements are the parameters,
      and the remaining are the fields/constructor/constituent componenets.
      The anaology is that the parameters are like the top-porition of a person,
      the part you notice immediately, delimited by the waist.

   - â€˜universe-of-discourseâ€™: '(â€œCarrierâ€ . â€œSetâ€); empty string by default.

   - â€˜waist-stringsâ€™: List of additional strings to insert at the waist position.

   - â€˜has-level-declâ€™: Is the top-most level to appear?

   - â€˜prefix-fieldsâ€™: List of fields, â€œname : typeâ€, to be added at the beginning
      of the field declaration. Default is empty string.

   - â€˜suffix-fieldsâ€™: List of fields, â€œname : typeâ€, to be added at the beginning
      of the field declaration. Default is empty string.

   - â€˜keep-fieldsâ€™: Predicate that determines which fields should be kept.
      By default, no fields are dropped.

   - â€˜alter-raw-fieldsâ€™: A function that alters the list of fields of a PackageFormer *before*
     any processing has transpiried. This is the identity function by default.

   - â€˜alter-fieldsâ€™: A function to alter existing fields *after* processing;
     it does not alter inserted fields via â€˜prefix-fieldsâ€™ nor â€˜suffix-fieldsâ€™.
     This is the identity function by default.

   - â€˜docstringâ€™: What is the parent PackageFormer, or instance declaration, of
     the currently intantiated data-type.

   - â€˜inc-levelâ€™: Should the level be incremented? Yes, by default.
  "

  (let* ((pf (if (package-former-p decls) (copy-package-former decls) (parse-package-former (cadr (get-children "PackageFormer" decls)))))
         (pf-name (package-former-name pf))
         (variation (car (s-split " : " (car (package-former-elements pf)))))
         (pfv (concat pf-name " " variation))
         (fields     (funcall alter-raw-fields (package-former-elements pf)))
         )

  ;; -1. Source generation declaration.
  (setf (package-former-docstring pf)
    (or docstring (format "This was generated from the PackageFormer %s ." pf-name)))

  ;; 0. Replace "PackageFormer" string with provided â€˜typeâ€™ qualifier.
  (setf (package-former-type pf) type)

  ;; 1. First element is always the variation; let's drop it.
  ;; Instantiations should not have an abstract varation component.
  (setf (package-former-elements pf) (cdr (package-former-elements pf)))

  ;; Â½. TODO: When we move to multi-sorted, as in Graphs, this issue will need to be revisited.
  ;; If the carrier is not exposed, then we need to increase the level.
  (when (and (equal waist 0) inc-level)
    (setf (package-former-level pf) (format " (Level.suc %s)"
           (if (s-blank? (package-former-level pf))
               "Level.zero" (package-former-level pf)))))

  ;; 2. Replace all occurences of â€œpackage-former-name followed by variationâ€
  ;; with â€˜carrierâ€™, if any.
  ;; Default value of â€˜new-nameâ€™ & â€˜carrierâ€™ are âŸªPackageFormer'sNameâŸ«-âŸªname-suffixâŸ«.
  (unless new-name
    (setq new-name (concat (package-former-name pf) "-" name-suffix)))

  (unless carrier  (setq carrier new-name))

 ;; (error (format "âŸ¨%sâŸ©" carrier)  )

  (setf (package-former-elements pf)
          (--map (s-replace pfv carrier it) (package-former-elements pf)))

  ;; 3. Replace PackageFormer's name with provided instantiation name.
  (setf (package-former-name pf) new-name)

  ;; 4. Insert new fields and process the altered existing fields.
  (setf (package-former-elements pf)
        (-concat
             prefix-fields
               ;; Perform any processing on the fields.
               (funcall alter-fields (-filter keep-fields fields))
             suffix-fields
           ))

  ;; 5. Set the new waist
  (setf (package-former-waist pf) waist)

  ;; 6. Stringify!
  (show-package-former pf :waist-strings waist-strings
                          :omit-level    omit-level-decl
                       )

 )
)
#+END_SRC

Let's instantiate our test example from earlier to produce a two-argument typeclass:
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(instantiate test   ; :new-name "SemigroupT"
                    :name-suffix "On"
                    ; :type "record"
                    :carrier "Carrier"
                    :docstring "" ; "Look ma: The Carrier and the op are exposed!"
                    ; :waist-strings (list "field")
                    ; :waist 2
                    )
#+END_SRC

#+RESULTS:
#+begin_src results-agda
{-  -}
record Semigroup-On : Set (Level.suc Level.zero) where
    v : Variation
    Semigroup v : Set
    _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v
    Id  : Semigroup v
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
#+end_src



#RESULTS:
#+begin_src results-agda

{- Look ma: The Carrier and the op are exposed! -}
record Semigroup-On (Carrier : Set) (_â¨¾_ : Carrier â†’ Carrier â†’ Carrier) : Set where
  field
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
#+end_src

What about a bundled up record declaration? Simple, we leave the waist with default value zero.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(instantiate test   :name-suffix "semantics"
                    :type "record"
                    :carrier "Carrier"
                    :has-field-decl t
                    )
#+END_SRC

#+RESULTS:
#+begin_src results-agda

{- This was generated from the PackageFormer Semigroup. -}
record Semigroup-semantics : Set(Level.suc Level.zero) where
  field
    Carrier : Set
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
#+end_src

Records provide a semantics, what if we want the syntax?
Since ~data~ declarations consist of constructors, whose target type necessarily
begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.

First, a helper function.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun field-target (field)
  "Given a declaration â€œname : type0 â†’ â‹¯ â†’ typeNâ€, yield â€œtypeNâ€. "
  (ignore-errors (car (-take-last 1 (s-split "â†’" field))))
  ;; Ignore errors since field may be nil.
)
#+END_SRC

Let's test it out:
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace
(-let [pf-name "Semigroup-syntax"]

  (list (s-contains? pf-name (field-target "Id    :  Semigroup-syntax"))
        (s-contains? pf-name (field-target "_â¨¾_   :  Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax"))
        (s-contains? pf-name (field-target "assoc :  âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)"))
        (s-contains? pf-name (field-target "Semigroup-syntax : Set")))
)
#+END_SRC

#+RESULTS:
| t | t | nil | t |

As the last test case shows, the name position of a declaration could have
a data-type name --which is not allowed in Agda since constructors share the
same namespace as types, yet this property is not ensured in our generation;
so let's sanitise for it.

Now a real use case.
#+BEGIN_SRC emacs-lisp :var test = test :exports both  :results replace :wrap "src results-agda"
(-let [pf-name "Semigroup-syntax"]

  (instantiate test  :name-suffix "syntax"
                     :type "data"
                     :new-name pf-name
                     :inc-level nil
                     :keep-fields (lambda (f) (s-contains? pf-name (field-target (cadr (s-split ":" f)))))
                     ;; :alter-fields (lambda (fs) (--map (format "Nice-%s" it) fs))
                    )
)
#+END_SRC

#+RESULTS:
#+begin_src results-agda

{- This was generated from the PackageFormer Semigroup. -}
data Semigroup-syntax : Set where
    _â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax
    Id  : Semigroup-syntax
#+end_src

Yeehaw! We've got three variations and possibly much more from a single fancy well-toggled
function ğŸ¤  We can emulate generative modules this way too! ğŸ˜»

Let's package these particular toggle configurations into their own functions.

The instantations are straight-forward:
#+BEGIN_SRC emacs-lisp  :tangle yes
(cl-defun instantiate-as-data (decls &key new-name (carrier "Carrier") docstring (alter-fields #'identity) (waist 0))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - â€˜declsâ€™ is immediately provided to â€˜get-childrenâ€™, so it may be a string,
      a list, or a value of type â€˜package-formerâ€™.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

   - TODO: Document remaining arguments.
  "
  (let* ((pf (if (package-former-p decls) (copy-package-former decls) (parse-package-former (cadr (get-children "PackageFormer" decls)))))
         (pf-name (package-former-name pf)))

    ;; TODO: MA: Should this be â€˜declsâ€™ or â€˜pfâ€™? Write some tests.
    (instantiate decls  :new-name new-name
                       :name-suffix "syntax"
                       :type "data"
                       :inc-level nil
                       :keep-fields (lambda (f) (s-contains? pf-name (field-target (cadr (s-split ":" f)))))
                       :docstring docstring
                       :alter-fields alter-fields
                       :waist waist
                      )
  )
)
#+END_SRC

#+BEGIN_SRC emacs-lisp  :tangle yes
(cl-defun instantiate-as-unbundled (depth decls &key new-name name-suffix (carrier "Carrier") docstring (alter-fields #'identity) (waist 0))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda â€œrecordâ€
  where the first â€˜depthâ€™ constituents of the PackageFormer are now parameters.

  In the case â€˜depthâ€™ is 1 we obtain the â€˜typeclassâ€™ persepctive and the case
  it is 0, we obtain a fully bundled perspective.

  The extra â€˜wasitâ€™ is for the â€˜unbundledâ€™ variational clause.

   - â€˜declsâ€™ is immediately provided to â€˜get-childrenâ€™, so it may be a string,
      a list, or a value of type â€˜package-formerâ€™.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (instantiate decls :new-name new-name
                    :name-suffix name-suffix
                    :type "record"
                    :carrier carrier
                    :docstring docstring
                    :has-field-decl t
                    :waist (+ depth waist)
                    :alter-fields alter-fields
                    )
)
#+END_SRC


That's a lot of mumbo jumbo, let's have a sanity check.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(s-join "\n" (list
 (instantiate-as-unbundled 1 test :name-suffix "On") ;; typeclass
 (instantiate-as-unbundled 0 test :name-suffix "semantics") ;; record
 (instantiate-as-data test)
))
#+END_SRC

#+RESULTS:
#+begin_src results-agda

{- This was generated from the PackageFormer Semigroup. -}
record Semigroup-On (Carrier : Set) : Set where
  field
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup. -}
record Semigroup-semantics : Set (Level.suc Level.zero) where
  field
    Carrier : Set
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup. -}
data Semigroup-syntax : Set where
    _â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax
    Id  : Semigroup-syntax
#+end_src

Notice that the results contained generated names since no names were provided.

Woah, look at that: This' reminiscent of that 200% increase from earlier ;-)
*Moreover*, with ~unbundled~ we may expose any or all constituents of a package
at will.

*** Module instantions

We can emit module declarations as follows; which may be useful for ADT instantions
of PackageFormers that contain derived operations.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(instantiate test   :new-name "Semanticsâ‚"
                    :type "module"
                    :carrier "Carrier"
                    :has-field-decl nil
                    :omit-level-decl t
                    :waist 4
                    )
#+END_SRC

#+RESULTS:
#+begin_src results-agda

{- This was generated from the PackageFormer Semigroup. -}
module Semanticsâ‚ (Carrier : Set) (_â¨¾_ : Carrier â†’ Carrier â†’ Carrier) (Id : Carrier) (assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)) where
#+end_src

For now, a common scenario is forming modules that re-export a type under a new superficial disguise;
e.g., in the setting where we want to have multiple references to a structure, as in when defining homomorphisms.
#  :tangle yes
#+BEGIN_SRC emacs-lisp exports both :results replace :wrap "src results-agda"
(cl-defun instantiate-as-opening (decls &key new-name kind docstring (alter-fields #'identity) (renames-itexpr "it"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - â€˜declsâ€™ is immediately provided to â€˜get-childrenâ€™, so it may be a string,
      a list, or a value of type â€˜package-formerâ€™.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   TODO: Document remaining args.
  "

    (instantiate (car package-formers)
      ;; :new-name new-name
      ;; :type "module"
      ;; :has-field-decl nil
      ;; :omit-level-decl t
      ;; :docstring docstring
      ;; :waist 1
      ;; :alter-fields (lambda (fs) fs)
      )

    )

                 (when nil :new-name new-name


                    ;;
                    ;; opening formation
                    (let (fsnew)
                    ; (loop for f in (funcall alter-fields (cdr fs)) ;; omit â€˜carrierâ€™
                       ; do (push (format "%s to %s" (get-name f) (rename-mixfix-it (car (read-from-string "it")) (get-name f))) fsnew))

                    (thread-last
                        ;; Resulting elements must be a list, so we make a singleton list.
                        (format "\t\t( %s\n\t\t\t)" (s-join "\n\t\t\t; " fsnew))
                        list

                        ;; Stick on the renaming, which in turn requires an opening clause;
                        ;; which in turn requires a module parameter.
                        ; (cons "\t renaming")
                        ; (cons (format "open %s â„› public" kind))
                        ; (cons (format "â„› : %s" kind))
                    )) fs ))

;;  "Monoidâ€²  = Monoid opening (MonoidRDT; it ++ \"â€²\")"

(instantiate-as-opening (car package-formers) :new-name "Decoratedâ‚")
#+END_SRC

#+RESULTS:
#+begin_src results-agda
#+end_src


  (let* () ; (pf (if (package-former-p decls) (copy-package-former decls) (parse-package-former (cadr (get-children "PackageFormer" decls)))))
         ; (pf-name (package-former-name pf)))

    (instantiate decls    :new-name "Semanticsâ‚!!!"
                    :type "module"
                    ; :docstring "???"
                    :has-field-decl nil
                    :omit-level-decl t
                    :waist 1 :alter-fields (lambda (fs)
                    ;;
                    ;; opening formation
                    (let (fsnew (kind "(instance-declaration-extra-params inst)"))
                    (loop for f in (cdr fs) ;; omit â€˜carrierâ€™
                       do (push (format "%s to %s" 1 2)))
                                        ; (get-name f) (rename-mixfix-it (eval (car (read-from-string (instance-declaration-opening inst)))) (get-name f)) fs

                    (thread-last
                        ;; Resulting elements must be a list, so we make a singleton list.
                        (format "\t\t( %s\n\t\t\t)" (s-join "\n\t\t\t; " fsnew))
                        list

                        ;; Stick on the renaming, which in turn requires an opening clause;
                        ;; which in turn requires a module parameter.
                        ; (cons "\t renaming")
                        ; (cons (format "open %s â„› public" kind))
                        ; (cons (format "â„› : %s" kind))
                    ))))))


Let's test it out.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(instantiate-as-opening "Monoidâ€²  = Monoid opening (MonoidRDT; it ++ \"â€²\")")
#+END_SRC

** Instantiate all items in ~instantiations-remaining~

#+BEGIN_SRC emacs-lisp :tangle yes
;; Function combinators; e.g., -partial/-cut, -const, -compose, -orfn & -andfn for generalised âˆƒ/âˆ€.
(use-package dash-functional) ;; https://github.com/magnars/dash.el
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defun reify-instances ()
 "Instantiate all items in â€˜instantiations-remainingâ€™."

 (interactive)

 (let* (result name pf-type pf pfs variation reify perform coherent-cutting)

   (dolist (inst instantiations-remaining)

     ;; Get pieces of the instance declaration.
     (setq name (instance-declaration-name inst))
     (setq variation (instance-declaration-variation inst))
     (setq pf-type (instance-declaration-package-former inst))

     ;; Get the package-former that is being instantiated.
     (setq pfs (car (--filter (equal pf-type (package-former-name it)) package-formers)))

     ;; Perform the instantiation.

     (setq perform ;; Recall that :x is sugar for 'x, which is then just an argument.
           (cond ((not pfs) (-const (format "\n%s = {! No PackageFormer â€˜%sâ€™ declared. !}" name pf-type)))
                 (t (pcase (instance-declaration-variation inst)
                      ("typeclass" (-partial 'instantiate-as-unbundled 1))
                      ("record"    (-partial 'instantiate-as-unbundled 0))
                      ("data"      'instantiate-as-data)
                      (v  (-const (format "\n%s = {! Variation â€˜%sâ€™ not yet supported !}" name v)))))))

     ;; Exposes clause should not be used with typeclass since it is a special case of record.
     (setq exposes-hoisting (lambda (fs)
                         (let* ((fsnew fs) (es (instance-declaration-exposes inst)) (l (length es)))
                           (loop for e in (reverse es)
                              do (push (car (--filter (equal e (get-name it)) fsnew)) fsnew)
                           )
                         (setf (nthcdr l fsnew) (--remove (-contains? es (get-name it)) (nthcdr l fsnew)))
                         fsnew
                         )))

     ;; Mainfest is like renaming but stronger, the fields are actually dropped.
     ;; One may think â€œmanifest = dropped âˆ˜ renamingâ€, but our drop feature is too strong
     ;; since it tries to drop all fields that mention a dropped item as well.
     ;;
     ;;
     (setq manifest-rewriting (lambda (fs)
                                (-let [fsnew (--remove (-contains? (-map #'car (instance-declaration-manifest inst)) (get-name it)) fs)]
                                  (loop for old-new in (instance-declaration-manifest inst)
                                    do (setq fsnew (--map (s-replace (car old-new) (cdr old-new) it) fsnew)))
                                  fsnew)))

     ;; Remove the dropped fields and (almost) anything that mentions them; not a high priority.
     (setq coherent-cutting (lambda (fs) (--remove (or (-contains? (instance-declaration-hidings inst) (get-name it))
                                                  (-any? (lambda (h) (s-contains? (s-replace "_" "" h) it)) (instance-declaration-hidings inst)))
                                              fs)))

     ;; (funcall `(lambda (it) ,(car (read-from-string "(concat \"a\" it)"))) "2e")
     ;;
     (setq decorated-rewriting (lambda (fs) (if (instance-declaration-decorations inst)
                                  (-let ((fsnew nil) old new (letin nil))
                                      (loop for f in (reverse fs)
                                            do (setq old (get-name f))
                                               (push (map-name (setq new (rename-mixfix-it (eval (car (read-from-string (instance-declaration-decorations inst)))) name)) f) fsnew)
                                               (setq letin (cons (format "let %s = %s in " old new) letin))
                                            )
                                      ;; Could ty this into renaming, but avoiding such entaglement for now.
                                      ;; Stick all renames â€œso farâ€ in front of each declaration.
                                      (loop for f in fsnew for i from 0 do (setf (nth i fsnew) (map-type (concat (s-join "" (-take i letin)) type) f)))
                                      fsnew
                                    )
                                  fs
                                  )))

     ;; Possibly better than the find-replace approach below.
     (setq reify (funcall perform pfs :new-name name :docstring (instance-declaration-docstring inst)
                          :waist (instance-declaration-waist inst)
                          :alter-fields (lambda (fs)
                                                         (funcall decorated-rewriting

                                                         (funcall exposes-hoisting ;; for exposes variational clause

                                                         (funcall manifest-rewriting ;; for manifest variational clause

                                                         (funcall coherent-cutting ;; for dropping variational clause

                                                         ;; renaming
                                                         (if-let ((rns (instance-declaration-renames inst)) (fsnew fs) (changes 0) )
                                                          ;; For each â€œold to newâ€, replace â€˜oldâ€™ in every /subsequent/ field with â€˜newâ€™ via a let-clause.
                                                          (progn (loop for f in fs for i from 0
                                                                       do (when-let* ((old (get-name f)) (new (cdr (assoc old rns))))
                                                                            (setq fsnew (--map (s-replace old new it) fsnew))
                                                                            ; (push (format "private %s = %s" old new) (cdr (nthcdr (+ i changes) fsnew)))
                                                                            ; (push "field" (cdr (nthcdr (+ i changes 1) fsnew)))
                                                                            (setf (nthcdr (+ i 1 changes) fsnew)
                                                                                  (--map (s-replace ": " (format ": let %s = %s in " old new) it) (nthcdr (+ i 1 changes) fsnew)))
                                                                            (incf changes)))
                                                                 fsnew)
                                                         fs)))))))) ;; otherwise leave fields alone.

     ;; Naive Perform renames.
     ;; (--map (setq reify (s-replace (car it) (cdr it) reify))
     ;; (instance-declaration-renames inst))

     ;; Add to list of results.
     (setq result (-cons* reify result))
)
   ;; Output results as a string.
     (s-join "\n" result)
))
#+END_SRC

â†’ Naive replacement does not work since Agda supports mixfix identifers; e.g.,
  If we rename ~_â¨¾_ to _âŠ•_~ then it is not as easy to propogate this renaming into,
  say, ~assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)~. However, we cannot ask the
  user to rename ~â¨¾~ since it is a different identifer than ~_â¨¾_~.

â†’ I also tried adding new local aliases, as in ~private _â¨¾_ = _âŠ•_~, however this does not
propogate well to ADT declarations.

â†’ The solution was to bind the renames even more locally via let-in clauses.

As always, let's ensure this works as intended.
#+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
(progn
  (find-file "Testing.agda")

  (setq package-formers nil) (setq instantiations-remaining nil) (setq 700-comments nil)
  (setq porting-list nil)

  (parse-700-comments)

  (switch-to-buffer "PackageFormer.org")

  (reify-instances)
)

#+END_SRC

#+RESULTS:
#+begin_src results-agda

Monoidâ€² = {! Variation â€˜openingâ€™ not yet supported !}
#+end_src

#RESULTS:
#+begin_src results-agda

{- MonoidTypeclass = Monoid typeclass hiding (_â¨¾_) -}
record MonoidTypeclass (Carrier : Set(â„“â‚€)) : Set (â„“â‚€) where
  field
    Id      : Carrier

{- MonoidT = Monoid typeclass renaming (Carrier to C; _â¨¾_ to _âŠ•_) -}
record MonoidT (C : Set(â„“â‚€)) : Set (â„“â‚€) where
  field
    _âŠ•_     : let Carrier = C in C â†’ C â†’ C
    Id      : let Carrier = C in C
    assoc   : let _â¨¾_ = _âŠ•_ in let Carrier = C in âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : let _â¨¾_ = _âŠ•_ in let Carrier = C in âˆ€ {x : let _â¨¾_ = _âŠ•_ in let Carrier = C in C} â†’ Id â¨¾ x â‰¡ x
    rightId : let _â¨¾_ = _âŠ•_ in let Carrier = C in âˆ€ {x : let _â¨¾_ = _âŠ•_ in let Carrier = C in C} â†’ x â¨¾ Id â‰¡ x

{- MonoidR = Monoid record unbundling 2 -}
record MonoidR (Carrier : Set(â„“â‚€)) (_â¨¾_ : Carrier â†’ Carrier â†’ Carrier) : Set (â„“â‚€) where
  field
    Id      : Carrier
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x

{- MonoidE = Monoid record exposing (Carrier; Id) -}
record MonoidE (Carrier : Set(â„“â‚€)) (Id : Carrier) : Set (â„“â‚€) where
  field
    _â¨¾_     : Carrier â†’ Carrier â†’ Carrier
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x

{- MonoidB = Monoid record with (Carrier to Bool; Id to false) -}
record MonoidB : Set (â„“â‚€) where
  field
    _â¨¾_     : Bool â†’ Bool â†’ Bool
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftfalse  : âˆ€ {x : Bool} â†’ false â¨¾ x â‰¡ x
    rightfalse : âˆ€ {x : Bool} â†’ x â¨¾ false â‰¡ x
#+end_src

Super cool stuff ~(à¸‡à² _à² )à¸‡~

Note that the renaming clause must have its old forms appear in the same order that they appear in the original declaration.
This could be avoided by obtaining the names of the continents, then intersecting that with the renames list, along the first component.

NOTE: Level polymorphism with generalised variables does not work for data declaration.

** TODO: Location?

Macros with ~it~ as the name of functional parts.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun ap (f x) "bye" (funcall f x))

(defmacro ap-it (itbody more)
  ;; `(ap (lambda (it) ,itbody) ,more)
  (list 'ap (list 'lambda '(it) itbody) more)
  )

;; 0. too clunky
(ap (lambda (it) (+ 2 it)) 3) ;; â‡’ 5
;; 1. Desired
(itify ap)
(ap-it (+ 2 it) 3) ;; nice.
;; 2. Works with lambdas?
((lambda (e) (ap-it (+ 2 it) e)) 2)
;; 3. Scoping is fine?
;; Outermost â€˜itâ€™ belongs to --map; inner-most â€˜itâ€™ belongs to ap-it. (â”€â€¿â€¿â”€)
(--map (ap-it (+ 2 it) it) '(1 2 3)) ;; â‡’ (3 4 5)
;; 4. Works well with read/eval?
(ap-it (eval (car (read-from-string "(+ 2 it)"))) 3) ;; â‡’ 5

;; itify
(defmacro itify (fname)
  "
   From a function (h f x), obtain a macro (h-it (â‹¯itâ‹¯) x) that rewrites into
   the orginal such that the first (functional) argument  may now be an expression
   with free variable â€˜itâ€™.

   NOTE: Since functions are of the form (cons 'macro-or-fun (function (lambda args body)))
   we can obtain the number of args by getting â€˜argsâ€™ and taking its length.
   Then we can change any of its indices to take an expression rather than a function.
  "

;; â‡’ (defalias (quote ap-it) (cons (quote macro) (function (lambda (itbody more) (list (quote ap) (list (quote lambda) (quote (it)) itbody) more)))))
  `(defmacro ,(intern (format "%s-it" (symbol-name fname))) (itbody more)
       (list (quote ,fname) (list 'lambda '(it) itbody) more))
;; â‡’ (defalias (quote ap-it) (cons (quote macro) (function (lambda (itbody more) (list (quote ap) (list (quote lambda) (quote (it)) itbody) more)))))
)
;; â‡’ (defalias (quote ap-it) (cons (quote macro) (function (lambda (itbody more) (list (quote ap) (list (quote lambda) (quote (it)) itbody) more)))))

(insert (format "\n;; â‡’ %s" (macroexpand ' (itify ap) )))
;; â‡’ (defalias (quote ap-it) (cons (quote macro) (function (lambda (itbody more) (list (quote ap) (list (quote lambda) (quote (it)) itbody) more)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(defun rename-mixfix (f op)
  "Given an Agda mixfix operator, apply a function on strings â€˜fâ€™ on
   the inner-most delimiting tokens of the operator, in-particular ignoring
   outer argument markers â€˜_â€™.

   For example, if you wish to decorate an operator with a prime or a subscript,
   we cannot simply catenate else we obtain â€œ_âŠ•_â‚â€ rather than â€œ_âŠ•â‚_â€.

   Here are some sample results, assuming â€œf â‰ˆ (Î» (it) (format â€œâ‚€%sÂ¹â€ it))â€:
   _âŠ•_     â†¦  _â‚€âŠ•Â¹_
   _[_âŠ—_]  â†¦  _â‚€[_âŠ—_]Â¹
   he_lo   â†¦  â‚€he_loÂ¹
   he-lo   â†¦  â‚€he-loÂ¹
  "

  (let* ((parts (s-split "_" op)) (front (s-blank? (first parts))) (rear (s-blank? (car (last parts)))))

  (--> (concat (when front "_") "$here" (when rear "_"))
       (substring-delimited-$ it op :longest-substring t)
       (funcall f it)
       (concat (when front "_") it (when rear "_"))
   )))

  ;; TODO: MA: Discard old code

;; â‡’ (defalias (quote ap-it) (cons (quote macro) (function (lambda (itbody more) (list (quote ap) (list (quote lambda) (quote (it)) itbody) more)))))

 ;; (cond
  ;;      ( (and front rear) (format "_%s_" (funcall f (substring-delimited-$ "_$here_" op))))
  ;;      (front (format "_%s" (funcall f (s-chop-prefix "_" op))))
  ;;      (rear  (format "%s_" (funcall f (s-chop-suffix "_" op))))
  ;;      (t (funcall f op))
  ;;    )
  ;;   )
  ;; )

;; Need this for â€˜reify-instancesâ€™.
(itify rename-mixfix)

;; â‡’ (defalias (quote ap-it) (cons (quote macro) (function (lambda (itbody more) (list (quote ap) (list (quote lambda) (quote (it)) itbody) more)))))

;; Test: Crash if error; else remain silent.
;;
(assert (equal (--map (rename-mixfix-it (format "â‚€%sÂ¹" it) it) '("_âŠ•_" "_[_âŠ—_]" "he_lo" "he-lo"))
       ;; Outermost â€˜itâ€™ belongs to --map; inner-most â€˜itâ€™ belongs to rename-mixfix-it.
  '("_â‚€âŠ•Â¹_" "_â‚€[_âŠ—_]Â¹" "â‚€he_loÂ¹" "â‚€he-loÂ¹")))

(rename-mixfix #'identity "_âŠ•_")

(rename-mixfix-it (eval (car (read-from-string "(concat it \"â€²\")"))) "_âŠ•_") ;; â‡’ _âŠ•â€²_
#+END_SRC

** COMMENT Construction Site :TestingGround:

 ;; zip elements with their index.
 ;; (loop for e in '(a b c) for i from 0 collect (cons e i))

#+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
(defun as-Agda-let (xys)
  "Given a dotted pair, form an Agda let-in clause."

  (concat "let "
          (s-join "; " (--map (format "%s = %s" (car it) (cdr it)) xys))
          " in "
  ))

;; (as-Agda-let '( (x . y) (a . b)))

#+END_SRC

#+BEGIN_SRC emacs-lisp :results replace :wrap "src results-agda"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; TODO: :new-name with -as-data does not work ???
(-let [inst (car instantiations-remaining)]
(-let [pfs (car package-formers)]

(setq opening-formation (lambda (fs) (list "opening MonoidR : ğ’©yet")))

(setq rename-rewriting (lambda (fs) (if-let ((rns (instance-declaration-renames inst)) (fsnew fs) (changes 0) )
                                                          ;; For each â€œold to newâ€, replace â€˜oldâ€™ in every /subsequent/ field with â€˜newâ€™ via a let-clause.
                                                          (progn (loop for f in fs for i from 0
                                                                       do (when-let* ((old (get-name f)) (new (cdr (assoc old rns))))
                                                                            (setq fsnew (--map (s-replace old new it) fsnew))
                                                                            ; (push (format "private %s = %s" old new) (cdr (nthcdr (+ i changes) fsnew)))
                                                                            ; (push "field" (cdr (nthcdr (+ i changes 1) fsnew)))
                                                                            (setf (nthcdr (+ i 1 changes) fsnew)
                                                                                  (--map (s-replace ": " (format ": let %s = %s in " old new) it) (nthcdr (+ i 1 changes) fsnew)))
                                                                            (incf changes)))
                                                                 fsnew)
                                                         fs) )) ;; otherwise leave fields alone.


;; instantiate-as-unbundled 0 pfs  :waist (instance-declaration-waist inst) :alter-fields â€¦

     (setq decorated-rewriting (lambda (fs) (if (instance-declaration-decorations inst)
                                  (-let ((fsnew nil) old new (letin nil))
                                      (loop for f in (reverse fs)
                                            do (setq old (get-name f))
                                               (push (map-name (setq new (rename-mixfix-it (eval (car (read-from-string (instance-declaration-decorations inst)))) name)) f) fsnew)
                                               (setq letin (cons (format "let %s = %s in " old new) letin))
                                            )
                                      ;; Could ty this into renaming, but avoiding such entaglement for now.
                                      ;; Stick all renames â€œso farâ€ in front of each declaration.
                                      (loop for f in fsnew for i from 0 do (setf (nth i fsnew) (map-type (concat (s-join "" (-take i letin)) type) f)))
                                      fsnew
                                    )
                                  fs
                                  )))

(instantiate pfs    :new-name "Semanticsâ‚!!!"
                    :type "module"
                    ; :docstring "???"
                    :has-field-decl nil
                    :omit-level-decl t
                    :waist 1 :alter-fields (lambda (fs)
                    ;;
                    ;; opening formation
                    (let (fsnew (kind (instance-declaration-extra-params inst)))
                    (loop for f in (cdr fs) ;; omit â€˜carrierâ€™
                       do (push (format "%s to %s" (get-name f) (rename-mixfix-it (eval (car (read-from-string (instance-declaration-opening inst)))) (get-name f))) fsnew))

                    (thread-last
                        ;; Resulting elements must be a list, so we make a singleton list.
                        (format "\t\t( %s\n\t\t\t)" (s-join "\n\t\t\t; " fsnew))
                        list

                        ;; Stick on the renaming, which in turn requires an opening clause;
                        ;; which in turn requires a module parameter.
                        (cons "\t renaming")
                        (cons (format "open %s â„› public" kind))
                        (cons (format "â„› : %s" kind))
                    ))))
))
#+END_SRC

#+RESULTS:
#+begin_src results-agda

{- This was generated from the PackageFormer Monoid. -}
module Semanticsâ‚!!! (â„› : MonoidRDT) where
    open MonoidRDT â„› public
         renaming
            ( rightId to rightIdâ€²
            ; leftId to leftIdâ€²
            ; assoc to assocâ€²
            ; Id to Idâ€²
            ; _â¨¾_ to _â¨¾â€²_
            )
#+end_src







# RESULTS:
#+begin_src results-agda

{- This was generated from the PackageFormer Monoid. -}
record Monoid- (Carrier : Set) : Set where
  field
    _â¨¾_     : Carrier â†’ Carrier â†’ Carrier
    Id      : Carrier
    assoc   : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId  : âˆ€ {x : Carrier} â†’ Id â¨¾ x â‰¡ x
    rightId : âˆ€ {x : Carrier} â†’ x â¨¾ Id â‰¡ x
#+end_src

(setq fsnew (-map (lambda (f) (setq new (map-name (concat name "-nice") f)) (push (cons (get-name f) (concat (get-name f) "-nice")) (instance-declaration-renames inst)) new) fsnew))

#+RESULTS:
#+begin_src results-agda

{- This was generated from the PackageFormer Monoid. -}
record Monoid- (Carrier-nice : Set) : Set where
  field
    _â¨¾_-nice : Carrier â†’ Carrier â†’ Carrier
    Id-nice : Carrier
    assoc-nice : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
    leftId-nice : âˆ€ {x
    rightId-nice : âˆ€ {x
#+end_src

* Advising our Beloved ~C-c C-l~

Let's give the current buffer access to the location of the generated file.
#+BEGIN_SRC emacs-lisp  :tangle yes
(defun insert-generated-import (name-of-generated-file)
  "In the current file, find the top-most module declaration
   then insert an import of the generated file.
  "
  (interactive)

  (save-excursion
    (beginning-of-buffer)
    (condition-case the-err
      ;; attemptClause:
      (re-search-forward (concat "open import " name-of-generated-file))
       ;; recoveryBody:
      (error ;; (message-box (format "%s" the-err))
         (re-search-forward "\\(module.*\\)")
         (replace-match (concat "\\1\nopen import " name-of-generated-file))
        )
    )
  )
)
#+END_SRC

The aim is to process test enclosed in ~{-700 â‹¯ -}~ comments,
produce legitimate Agda from that, and ensure the generated Agda is accessible to the
current buffer automatically.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun reify-package-formers (orig-fun &rest args)
  (interactive)

  (let (generated-file-name
        (parent-imports (extract-imports))
       )

  ;; Sometimes we may want the full name due to files being in a nested
  ;; directory hierarchy: (file-name-sans-extension buffer-file-name)
  (setq generated-file-name (concat(file-name-sans-extension (buffer-name))
                  "_Generated"))

  ;; Thisâ€™ inefficent.
  (setq package-formers nil)
  (setq instantiations-remaining nil)
  (setq 700-comments nil)
  (setq porting-list nil)
  (parse-700-comments)

  (with-temp-buffer
    (beginning-of-buffer)

    ;; Copy/paste imports from parent file.
    (insert (s-join "\n" `(
             "{- This file is generated ;; do not alter. -}\n"
             ,parent-imports
             "open import Level as Level"
             ,(format "module %s where " generated-file-name)
             , (s-join "\n" porting-list)
             ,(reify-instances))))

    (write-region (beginning-of-buffer) (end-of-buffer)
                  (concat generated-file-name ".agda"))
    )

  (insert-generated-import generated-file-name)
  )

  ;; Need to revert buffer to discard old colours.
  ;; (save-buffer) (revert-buffer t t t)

  ;; call agda2-load
  (apply orig-fun args)

   ;; Colour 700 keywords
  (loop for kw in '("PackageFormer" "Variation" "hiding" "renaming" "unbundling" "exposing" "renaming" "with")
    do (highlight-phrase kw 'hi-green))
  (highlight-phrase "700" 'error)

  (message "700 âˆ· All the best coding! (â€¢Ì€á´—â€¢Ì)Ùˆ")
)

(advice-add 'agda2-load :around #'reify-package-formers)
#+END_SRC

Personal note:
Using ~(write-file "Generated.agda")~ means we make a file
then the temporary buffer /visits/ the Agda file, which loads the
Agda process therein, which is undesirable since it could leave
Agda working on the buffer even after it has been killed!
+ This would necessiate calling ~(agda2-restart)~ afterwards.
+ Instead we write the whole region, without visiting the resuting file.

* Menu matter
Let's quickly add a menu bar that allows users to enable or disable using PackageFormer's;
along with a brief help menu.

{{{fold(The global map)}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar 700-menu-bar (make-sparse-keymap "700 PackageFormers"))

(define-key global-map [menu-bar 700menu] (cons "700PackageFormers" 700-menu-bar))
#+END_SRC
{{{end-fold}}}

{{{fold( Enabling the feature )}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(define-key 700-menu-bar [enable-package-formers]
  '(menu-item "Enable PackageFormer Generation" enable-package-formers))

(defun enable-package-formers ()
 (interactive)
 (advice-add 'agda2-load :around #'reify-package-formers)
 (message-box "C-c C-l now reifies â€œ700-commentsâ€ into legitimate Agda.")
)
#+END_SRC
{{{end-fold}}}

{{{fold( Disabling the feature )}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(define-key 700-menu-bar [disable-package-formers]
  '(menu-item "Disable PackageFormer Generation" disable-package-formers))

(defun disable-package-formers ()
 (interactive)
 (advice-remove 'agda2-load #'reify-package-formers)
 (setq global-mode-string (remove "700 (â€¢Ì€á´—â€¢Ì)Ùˆ " global-mode-string))
  (message-box "C-c C-l now behaves as it always has.")
)
#+END_SRC
{{{end-fold}}}

{{{fold( About menu )}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(define-key 700-menu-bar [package-formers-about]
  '(menu-item "About PackageFormers" package-formers-about))

(defun package-formers-about ()
 (interactive)
 (switch-to-buffer "*PackageFormer-About*") (insert
  " This is an editor extension prototyping â€œthe next 700 module systemsâ€ proposed research.

    An informal documentation, with examples, page can be found at
    https://alhassy.github.io/next-700-module-systems-proposal/PackageFormer.html

    The technical matter can be found at https://alhassy.github.io/next-700-module-systems-proposal/

    If you experience anything â€œgoing wrongâ€ or have any ideas for improvement,
    please contact Musa Al-hassy at alhassy@gmail.com; thank-you â™¥â€¿â™¥
  "
 )
)

#+END_SRC
{{{end-fold}}}

Let's pack these together into a minor mode.
{{{fold( Minor mode )}}}
#+BEGIN_SRC emacs-lisp :tangle yes
(define-minor-mode 700-mode
    "This is an editor extension prototyping â€œthe next 700 module systemsâ€ proposed research.

    An informal documentation, with examples, page can be found at
    https://alhassy.github.io/next-700-module-systems-proposal/PackageFormer.html

    The technical matter can be found at https://alhassy.github.io/next-700-module-systems-proposal/

    If you experience anything â€œgoing wrongâ€ or have any ideas for improvement,
    please contact Musa Al-hassy at alhassy@gmail.com; thank-you â™¥â€¿â™¥
  "
  :lighter " 700 (â€¢Ì€á´—â€¢Ì)Ùˆ)" ;; Icon to display indicating the mode is enabled.
  :require 'foo

  ;; Toggle the menu bar
  ;; (define-key global-map [menu-bar 700menu] t)(not 700-mode))
  (define-key global-map [menu-bar 700menu] (and 700-mode (cons "700PackageFormers" 700-menu-bar)))

  (letf (( (symbol-function 'message-box) #'message))
  (if 700-mode
      ;; Initilisation
      (enable-package-formers)

      ;; Closing
      (disable-package-formers)
  ))

)
#+END_SRC
{{{end-fold}}}

* TODO tooltips

https://stackoverflow.com/questions/293853/defining-new-tooltips-in-emacs

http://kitchingroup.cheme.cmu.edu/blog/2016/03/16/Getting-graphical-feedback-as-tooltips-in-Emacs/

;; List of pairs of strings that denote words and their associated tool tips.
;; May move to a hash.
(setq 700-words nil)

(push '("GNUU" . "Editor MACroS") 700-words)

(loop for (key . value) in 700-words
      do (font-lock-add-keywords nil
          `(( ,key
             0
             '(face font-lock-keyword-face help-echo
                    (lambda (window object position) "t" ,value))))))
* Future Work

Well, that was a lot of Lisp I had to learn ~(à¸‡à² _à² )à¸‡~

Hopefully the resulting prototype will be useful to others;
drop me a line if you're interested in this effort or have
any feedback or pointers!

#+begin_center org
â˜… â˜… â˜…
#+end_center

Below are some desirable features to work on.

+ [ ] MA: WK: hiding â†¦ dropping

+ [ ] Use buffer-substring-delimited-whole-buffer to parse /multiple/
      700-comments!

+ [ ] Add a level component to an instance structure; reduce it if Carrier is a parameter and otherwise leave it alone.
      Instead, let the level of a PackageFormer denote the level of the typeclass instantiation, then with this in mind
      we increase the level component of an instance structure only for those variations that keep the carrier as a field.
      When we move to multi-sorted, as in Graphs, this issue will need to be revisited.

+ [ ] Currently can only perform simple variational clauses; need to support complex clauses.

+ [ ] Currently variational clauses apply as follows ~PF v clause~, it would be useful to have them also apply
  as ~I clause~ where ~I = PF v~ has already been declared. This would requuire we keep a list of instances and their parent PF;
  our current list is consumed and thrown away.

   # TODO: Give an example making use of suffix-fields to â€˜extendâ€™ a packageformer with new fields. E.g., PackageFormer B = A extended-by cs ought to be valid but so should I = A vs extended-by cs which is amicable syntax for the instantation (A extended-by cs) vs. Should this automatically yield forgetful coercisions â€œIâ‡’Aâ€? For now, maybe yes by default and no if we use, say, fields instead of extended-by. There will be issues of coherency when we add items.

+ [ ] Need to implement a *front-end* system to extend variational clauses.

+ [ ] The ~elements~ of a PackageFormer should be  an alist, ~'(name . type)~.

+ [ ] Refactor load-instantions function to make use of an ~alter~ field rather than overloading alter-fields in reify-instances.

+ [ ] Refactor ~instantiate~ to make use of an ~instance~ structure, rather than 13 arguments.

+ [ ] Why does â€˜buffer-substring-delimited-whole-bufferâ€™ return a list of strings? Why not join its result to simply return a list?

+ [ ] Generated.agda needs to inherit all open/import declarations from parent.

+ [ ] Give an example PackageFormer with some definitions or derived constructs, then hoist-up your waist so that the non-defined items are ~module~ parameters.

+ [ ] ~B = cs âŸ¨+ A âŸ¨+ csâ€²~ where each cs is a single name-type declaration and the operation is left-associative, and A is an existing packageformer. This gives us a nice way to build a hierarchy. Note that since only A has a name, we may form a forgetful coercion Bâ‡’A automatically.
  E.g., ~Monoid = Type âŸ¨+ Pointed âŸ¨+ (Magma renaming (_âŠ•_ to _â¨¾_)) âŸ¨+ LeftUnital âŸ¨+ RightUnital âŸ¨+ assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)~ gives, automatically, ~Monoidâ‡’Type, Monoidâ‡’Pointed, Monoidâ‡’Magma, Monoidâ‡’LeftUnital, Magmaâ‡’RightUnital~ (â€¢Ì€á´—â€¢Ì)Ùˆ MA: To begin with, ignore the rename and work up the sequence one âŸ¨+ at a time.

+ [ ] PF's should account for equations. For simplicity they become components of a record & module, but derived operations on datatypes.

+ [ ] Demonstrate how generative modules can be emulated.

+ [ ] For now, PackageFormer's have no other parameters besides the variation symbol.

+ [ ] The global variables package-formers & instance-declaration should be /buffer/ specific?

+ [ ] Assign to a local var, check equality against global 700-comments,
      if identical, no more processing since everything already generated.

+ [ ] Make use of docstring so that when a user enters a key sequence or selects from a menu, we can show them a listing of all â€˜majorâ€™ components of a program: An org-mode file is displayed with an enumeration of the items, each being a link to the source, and only their docstring is shown. This is a nice â€˜overviewâ€™ of the program source.

+ [ ] Currently it looks like we are a minor mode, but this is not true. We only have a menu and the icon (â€¢Ì€á´—â€¢Ì)Ùˆ is displayed when our feature is supported.

+ [ ] Generate all instances of a PackageFormer schema.

+ [ ] Allow package formers to have explicit ~Variation~ parameters; but
      how do we then deal with nested invocations? What are the uses of
      having differing invocations?

      For example,
      #+BEGIN_SRC agda
PackageFormer LawfullyPointed (v : Variation) : Set where
   point : LawfullyPointed v
   law   : LawfullyPointed FOL {- Concrete variation -}

                                             #+END_SRC
      Would elaborate to something like:
      #+BEGIN_SRC agda
       data LP-Term (Vars : Set) : Set where
            {- Abstract fields from constituents of packageformer -}
            Point    : LP-Term
            {- Fragment of first order logic term formation -}
            _â€²       : Vars â†’ LP-Term {- Injection of vars as terms -}
            _â‰ˆ_      : LP-Term â†’ LP-Term â†’ LP-Term
            âˆ€â€² âˆƒâ€²    : (Vars â†’ LP-Term) â†’ LP-Term

       record LP : Setâ‚ where
         constructor _,_,_
         field
            Carrier : Set
            point   : Carrier
            law     : LP-Term Carrier
#+END_SRC

      With the following example uses.
      #+BEGIN_SRC agda
      Contractable : (A : Set) (a : A) â†’ LP
      Contractable A a =  A , a , âˆ€â€² (Î» x â†’ x â‰ˆ a â€²)

      Indistinguishable : (A : Set)  â†’  LP hiding point
      Indistinguishable A a =  A , âˆ€â€² (Î» x â†’ âˆ€â€² (Î» y â†’ x â‰ˆ y))
      #+END_SRC
      Where ~PF hiding c~ is the largest sub-PackageFormer of ~PF~ with constituent ~c~
      removed ---in particular, constituents that depend on ~c~ would also be dropped.

      :Hide:
        #+BEGIN_SRC emacs-lisp
(defun generate-all-instances () ;; TODO
  "For each PackageFormer â€˜pfâ€™, produce the default instances:
   â€˜pf-recordâ€™, â€˜pf-typeclassâ€™, â€˜pf-dataâ€™.

   Use: You want a particular instance in rapid developement and don't want
   to be bothered to give it a name. Or experimenting and unsure which instance
   is most desirable, so have access to all of them.

   Possible extensions:
   0. Introduce concrete syntax â€œGenerateDefaultInstances pfâ€ to invoke this command.
   1. Have a global list of default instances.
  "

  (interactive)

    ;; Keep this around since we may want to produce variations wholesale with
  ;; names: packageformer-variation; e.g., Magma-typeclass.
  ;;
  ;;
  ;; the variations
;;  (setq the-vars-shush (--map (car it) (--map (-take-last 1 it) (--map (s-split " " it) decls-vars-shush))))
  ;;
  ;; (dolist (variation the-vars-shush ll)
  ;;  (setq ll (cons (make-typeclass decls (concat pf-name "-" variation)) ll)))

  )
#+END_SRC
      :End:

* COMMENT ~instantiate~ ---the /backend/ core utility                         :posterity:
Let's put the pieces together.
#+BEGIN_SRC emacs-lisp
(cl-defun instantiate (decls &key
  new-name (type "record") carrier
  name-suffix
  (variation-replacement "")
  (prefix-fields "") (suffix-fields "") omit-field-header
  (keep-fields (lambda (x) t))
  (alter-raw-fields #'identity)
  (alter-fields #'identity)
  )

  "Given a PackageFormer declaration, instantiate it into a concrete Agda type.

   Remarks or example values:

   - â€˜declsâ€™ is immediately provided to â€˜get-childrenâ€™, so it may be a string
      or a list.

   - â€˜typeâ€™: The replacement for â€œPackageFormerâ€; default is â€œrecordâ€.

   - â€˜carrierâ€™: What is the carrier of this new instance? E.g., â€œCarrierâ€.
      By default it's the â€˜new-nameâ€™; but this is unresonable when, say, a typeclass
      variation is requested.

   - â€˜name-suffixâ€™: When no â€˜new-nameâ€™ is provided, the default is
      â€œâŸªPackageFormer'sNameâŸ«-âŸªvariationâŸ«-g*â€, where â€˜*â€™ is an arbitrarily generated number.

     This may be useful for rapid development when one does not want to provide
     a name to an instance, but simply wants the instance to exist.

   - â€˜variation-replacementâ€™: â€œ(Carrier : Set)â€; empty string by default.

   - â€˜prefix-fieldsâ€™: List of fields, â€œname : typeâ€, to be added at the beginning
      of the field declaration. Default is empty string.

   - â€˜suffix-fieldsâ€™: List of fields, â€œname : typeâ€, to be added at the beginning
      of the field declaration. Default is empty string.

   - â€˜omit-field-headerâ€™: Should the â€œfieldâ€ word be removed? No by default.

   - â€˜keep-fieldsâ€™: Predicate that determines which fields should be kept.
      By default, no fields are dropped.

   - â€˜alter-raw-fieldsâ€™: A function that alters the list of fields of a PackageFormer *before*
     any processing has transpiried. This is the identity function by default.

   - â€˜alter-fieldsâ€™: A function to alter existing fields *after* processing;
     it does not alter inserted fields via â€˜prefix-fieldsâ€™ nor â€˜suffix-fieldsâ€™.
     This is the identity function by default.
  "

  (let* ((pf (cadr (get-children "PackageFormer" decls)))
         (header     (car pf))
         (pf-name (package-former-name header))
         (pf-variation (variation-symbol header))
         (field-decl (cadr pf)) ;; In order to maintain user-provided indentation.
         (fields     (funcall alter-raw-fields (cddr pf)))
         (indentation (s-repeat (if fields (get-indentation (car fields)) 0) " "))
           (preFields   (--map (concat indentation it) prefix-fields))
           (postFields  (--map (concat indentation it) suffix-fields))
         (tc nil)
         )

  ;; Default value of â€˜new-nameâ€™ & â€˜carrierâ€™ are âŸªPackageFormer'sNameâŸ«-âŸªname-suffixâŸ«.
  (unless new-name (setq new-name (format "%s-%s-%s" pf-name name-suffix (gensym))))
  (unless carrier  (setq carrier new-name))

  ;; Replace "(? : Variation)" with the provided â€˜variation-replacementâ€™
  (setq header (insert-parameter variation-replacement (erase-parameters header)))

  ;; Replace "PackageFormer" with â€˜typeâ€™.
  (setq header (s-replace "PackageFormer" type header))

  ;; Replace PackageFormer's name with provided instantiation name.
  (setq header (s-replace pf-name new-name header))

  ;; Replace all occurences of â€œpackage-former-name followed by variationâ€
  ;; with â€˜carrierâ€™.
  (setq fields (--map (s-replace (concat pf-name " " pf-variation) carrier it) fields))

  ;; Perform any processing on the fields.
  (setq fields (funcall alter-fields (-filter keep-fields fields)))

  ;; Stick all the pieces together, along with the new fields.
  (setq tc (s-join "\n"
        (-cons* header
        (-concat
           (if omit-field-header () (list field-decl))
           preFields fields  postFields))))

  ;; Declare generation source matter.
  (concat
   "\n{- This was generated from the PackageFormer " pf-name " -}\n"
    tc)
 )
)
#+END_SRC

#+RESULTS:
: instantiate

Let's instantiate our test example from earlier to produce a typeclass.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(instantiate test   ;; :new-name "SemigroupT"
                    :name-suffix "typeclass"
                    :type "record"
                    :variation-replacement "(Carrier : Set)"
                    :carrier "Carrier"
                    )
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-typeclass-g105 (Carrier : Set) : Set where
:   field
:     _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
:     Id  : Carrier
:     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

#+BEGIN_SRC emacs-lisp :var test = test :exports both
;; (instantiate test)

(setq _test (show (car package-formers)))

(instantiate _test :variation-replacement "noice")

;; (erase-parameters _test)
; (insert-parameter "(nn : ?)" (erase-parameters _test)))

;; (instantiate-as-typeclass (show (car package-formers)))
;; (instantiate (show (car package-formers)))
;; -as-typeclass (show (car package-formers)))
;; (stringp (show (car package-formers)))
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-nil-g106 noice : Set where
:   field
:     _â¨¾_ : Semigroup-nil-g106 â†’ Semigroup-nil-g106 â†’ Semigroup-nil-g106
:     Id  : Semigroup-nil-g106
:     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

What about a bundled up record declaration?
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(instantiate test   ;; :new-name "SemigroupT"
                    :name-suffix "semantics"
                    :type "record"
                    :carrier "Carrier"
                    :prefix-fields '("Carrier : Set")
                    )
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-semantics-g107  : Set where
:   field
:     Carrier : Set
:     _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
:     Id  : Carrier
:     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

Records provide a semantics, what if we want the syntax?
Since ~data~ declarations consist of constructors, whose target type necessarily
begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.

First, a helper function.
#+BEGIN_SRC emacs-lisp
(defun field-target (field)
  " Given a declaration â€œname : type0 â†’ â‹¯ â†’ typeNâ€, yield â€œtypeNâ€. "
  (car (-take-last 1 (s-split "â†’" field)))
)
#+END_SRC

#+RESULTS:
: field-target

Let's test it out:
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(-let [package-former-name "Semigroup-syntax"]

  (list (s-contains? package-former-name (field-target "     Id  : Semigroup-syntax"))
        (s-contains? package-former-name (field-target "_â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax"))
        (s-contains? package-former-name (field-target "     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)")))
)
#+END_SRC

#+RESULTS:
| t | t | nil |

The results are as expected, so let's move to the real use case.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(-let [package-former-name "Semigroup-syntax"]

  (instantiate test  :name-suffix "syntax"
                     :type "data"
                     :omit-field-header t
                       :new-name package-former-name
                       ;; :carrier package-former-name
                     :keep-fields (lambda (f) (s-contains? package-former-name (field-target f)))
                    )
)
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: data Semigroup-syntax  : Set where
:     _â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax
:     Id  : Semigroup-syntax

Yeehaw! We've got three variations and possibly much more from a single fancy well-toggled
function ğŸ¤  We can emulate generative modules this way too! ğŸ˜»

Let's package these particular toggle configurations into their own functions.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-typeclass (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda â€œtypeclassâ€.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (instantiate decls :new-name new-name
                     :name-suffix "typeclass"
                     :type "record"
                     :variation-replacement (format "(%s : Set)" carrier)
                     :carrier carrier
                    )
)
#+END_SRC

#+RESULTS:
: instantiate-as-typeclass

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-record (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (instantiate test :new-name new-name
                    :name-suffix "record"
                    :type "record"
                    :carrier carrier
                    :prefix-fields `(,(format "%s : Set" carrier))
                    )
)

#+END_SRC

#+RESULTS:
: instantiate-as-record

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-data (decls &key new-name (carrier "Carrier") (alter-fields #'identity))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (let* ((pf (cadr (get-children "PackageFormer" decls)))
         (header     (car pf))
         (pf-name (package-former-name header)))

    (instantiate test  :new-name new-name
                       :name-suffix "syntax"
                       :type "data"
                       :omit-field-header t
                       :keep-fields (lambda (f) (s-contains? pf-name (field-target f)))
                       :alter-fields alter-fields
                      )
  )
)
#+END_SRC

#+RESULTS:
: instantiate-as-data

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(s-join "\n" `(
,(instantiate-as-typeclass test)
,(instantiate-as-record test)
,(instantiate-as-data test)
))
#+END_SRC

#+RESULTS:
#+begin_example

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-typeclass-g108 (Carrier : Set) : Set where
  field
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-record-g109  : Set where
  field
    Carrier : Set
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup -}
data Semigroup-syntax-g110  : Set where
    _â¨¾_ : Semigroup-syntax-g110 â†’ Semigroup-syntax-g110 â†’ Semigroup-syntax-g110
    Id  : Semigroup-syntax-g110
#+end_example

Notice that the results contained generated names since no names were provided.
* COMMENT PackageFormer Name and Variation Symbol          :possibly_not_needed:

As such, we form a method for
obtaining the name, the variation symbol, and a method to rewrite substrings of the
children ---wait, we already have the last one: ~get-children~ with optional ~:then~
keyword.

#+BEGIN_SRC emacs-lisp
;; The following two only work on headers of PackageFormer declarations.

(defun package-former-name (declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (v : Variation) : Set whereâ€
   return the name â€œSemigroupâ€.
  "
  (s-chop-prefix "PackageFormer "
    (s-chop-suffix " ("
      (car (s-match "PackageFormer .* (" declaration))))
)


(defun variation-symbol (declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (v : Variation) : Set whereâ€
   return the name â€œvâ€.
  "
  (s-chop-prefix "("
    (s-chop-suffix " : Variation)"
      (car (s-match "(.*)" declaration))))
)
#+END_SRC

#+RESULTS:
: variation-symbol

Let's test these two out.
#+BEGIN_SRC emacs-lisp
(package-former-name "PackageFormer Semigroup (v : Variation) : Set where")
;; â‡’ "Semigroup"

(variation-symbol "PackageFormer Semigroup (v : Variation) : Set where")
;; â‡’ "v"
#+END_SRC

#+RESULTS:
: v

* COMMENT Parameter Erasure & Insertion           :possibly_not_needed:
MA: Just change the package-former-variation to package-former-parameter ---which is a pair, â€œname : typeâ€.
This may make it easier later to transition to having multiple parameters.

When a PackageFormer such as the following is instantiated, say, to a typeclass
variation, we must erase the variation parameter and insert a new type parameter.
#+BEGIN_SRC agda
   PackageFormer Semigroup (v : Variation) : Set where â€¦
â†¦  record Semigroup (Carrier : Set) : Set  where â‹¯
#+END_SRC

#+RESULTS:
: <interactive>:5:1: error: parse error on input â€˜â†¦â€™

#+BEGIN_SRC emacs-lisp
;; The following only work on headers of PackageFormer declarations.

(defun erase-parameters (declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (existing-params) : Set â„“ whereâ€
   return
   â€œPackageFormer Semigroup : Set â„“ whereâ€
  "
  (s-collapse-whitespace ;; Convert all adjacent whitespace chars to a single space.
   (s-replace
      (car (s-match "(.*) : Set" declaration))
      ": Set"
      declaration))
)

(defun insert-parameter (param declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (existing-params) : Set â„“ whereâ€
   return
   â€œPackageFormer Semigroup (existing-params) â€˜paramâ€™ : Set â„“ whereâ€

   Precondition: â€˜paramâ€™ is a string.
  "
  (let ((rest-of-line (car (s-match ": Set.*" declaration))))
  (s-replace
      rest-of-line
      (concat param " " rest-of-line)
      declaration)
  )
)
#+END_SRC

#+RESULTS:
: insert-parameter

Let's test these out:
#+BEGIN_SRC emacs-lisp :exports both
(erase-parameters "PackageFormer Semigroup (v : Variation) (C : Set) : Set where")
#+END_SRC

#+RESULTS:
: PackageFormer Semigroup : Set where

# Notice the superfluous whitespace is /not/ collapsed for parameter insertion.
#+BEGIN_SRC emacs-lisp :exports both
(insert-parameter "(Carrier : Set)"
  (erase-parameters "PackageFormer Semigroup (v : Variation) : Set where"))
#+END_SRC

#+RESULTS:
: PackageFormer Semigroup (Carrier : Set) : Set where

A naturally expected property is if we obtain the variation symbol of a package former,
erase said parameter, then insert it; then we have essentially done nothing.
#+BEGIN_SRC emacs-lisp :exports both :results replace
(let* ((ex "PackageFormer Semigroup (ww : Variation) : Set where")
       (vd "(%ww : Variation)"))

  (and (equal "PackageFormer Semigroup : Set where" (erase-parameters ex))
       (equal ex (insert-parameter vd (erase-parameters ex))))
)
#+END_SRC

#+RESULTS:
  | nil |

Excellent ğŸ˜

* COMMENT footer

# Local Variables:
# eval: (visual-line-mode t)
# compile-command: (progn (org-babel-tangle) (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# End:
