# C-c C-v C-b to execute all code blocks in buffer.

#+TITLE: Package Formers
#+DESCRIPTION: Generalising ADTS, records, typeclasses to â€œpackage formersâ€.
#+AUTHOR: Musa Al-hassy
#+EMAIL: alhassy@gmail.com
#+STARTUP: indent
# PROPERTY: header-args :tangle tangled.agda :comments link
#+PROPERTY: header-args :results none :tangle no

#+CATEGORIES: Agda MetaProgramming Lisp
#+OPTIONS: html-postamble:nil toc:nil d:nil tag:nil
# IMAGE: ../assets/img/org_logo.png
# SOURCE: https://raw.githubusercontent.com/alhassy/org-agda-mode/master/literate.lagda

# INCLUDE: ~/Dropbox/MyUnicodeSymbols.org

* COMMENT org/ob-agda setup :load_me:

Just C-c C-c this block (â€¢Ì€á´—â€¢Ì)Ùˆ
#+begin_src emacs-lisp
(add-to-list 'org-src-lang-modes '("results-agda" . org-agda))

;; No code execution on export
;; âŸª For a particular block, we use â€œ:eval never-exportâ€ âŸ«
;;
(setq org-export-use-babel nil)

(progn "Set up some colours *before* loading org-agda-mode"

  (setq org-agda-extra-word-colours nil)
(add-to-list 'org-agda-extra-word-colours '("typeclass" 0 'agda2-highlight-keyword-face))
(add-to-list 'org-agda-extra-word-colours '("PackageFormer" 0 'font-lock-type-face))
(add-to-list 'org-agda-extra-word-colours '("_â¨¾_" 0 'font-lock-type-face))
(add-to-list 'org-agda-extra-word-colours '("assoc" 0 'font-lock-type-face))

;; Treat the following words as if they were â€˜typesâ€™; i.e., bold red.
(dolist (word (s-split " " "PackageFormer _â¨¾_ assoc Semigroup-semantics Semigroup-syntax SemigroupOn") org-agda-extra-word-colours)
  (add-to-list 'org-agda-extra-word-colours `(,word 0 'font-lock-type-face))
  )

  (load-file "~/org-agda-mode/org-agda-mode.el")
)

;; org-agda-mode.el has now deviated as follows:
;;
; (defvar org-agda-extra-word-colours nil "other words that user of org-mode wants coloured, along with their specified font-lock-type-face")
;
; (define-generic-mode
;     'org-agda-mode                      ;; name of the mode
;     (list '("{-" . "-}"))               ;; comments delimiter
;     org-agda-keywords
;     ;; font lock list: Order of colouring matters;
;     ;; the numbers refer to the subpart, or the whole(0), that should be coloured.
;     (-concat  ;; â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜… org-agda-extra-word-colours is a free variable, user should define it /before/ loading org-agda-mode â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
               (if (boundp (quote org-agda-extra-word-colours)) org-agda-extra-word-colours nil)
;     (list â‹¯) â‹¯))

;; Also this so people use â€œagdaâ€ instead of being forced to use â€œorg-agdaâ€
;;
;;  If an Emacs major-mode named <lang>-mode exists, where <lang> is the language identifier from code blockâ€™s header line, then the edit buffer uses that major-mode. Use this variable to arbitrarily map language identifiers to major modes.
;;
(add-to-list 'org-src-lang-modes '("agda" . org-agda))

;; The following allows me to do â€œC-c C-câ€ on agda org-src blocks.
;; The result is just the src body parroted to us, no â€œevaluationâ€ performed.
;;
;;
;; (async-shell-command "cp  ~/.emacs.d/elpa/org-9.2.3/ob-C.el ~/org-agda-mode/ob-agda.el")
(async-shell-command "ln -s ~/org-agda-mode/ob-agda.el ~/.emacs.d/elpa/org-plus-contrib-20190408/ob-agda.el")
; (load-file "~/org-agda-mode/ob-agda.el")
;;
(org-babel-do-load-languages
 'org-babel-load-languages
 '((agda . t)))
#+end_src

#+RESULTS:

* HTML Stuffs :ignore:
# super brief intro to tables: https://www.w3schools.com/html/html_tables.asp
# See here for a nice intro to tables: https://www.w3.org/TR/CSS2/tables.html
# Here for borders: https://www.w3schools.com/css/css_border.asp
#
#
#+begin_export html
<style>

/* inline code; see here for other colours: https://www.w3schools.com/colors/colors_names.asp */
code { background: LightGray;
       border-radius: 5px; /* How curvy the borders should be. */
}

table {
    background: pink;
    border-radius: 10px; /* How curvy the borders should be. */
    /* width:90% */

    border-bottom: hidden;
    border-top: hidden;

    /* Put table in the center of the page, horizontally. */
    margin-left:auto;margin-right:auto;
}

/* table â€˜dâ€™ata elements */
td {
    border: 1px solid red; padding: 1em;
    /* border: none;
    border-left: 1px solid transparent;
    border-right: 1px solid transparent; */


}


/* Alter visible labels of source blocks */
pre.src-agda:before { content: 'Agda'; }
pre.src-haskell:before { content: 'Agda'; }
pre.src-org:before { content: 'Text'; }

/* Using source blocks â€œagda-resultsâ€ as pink-background coloured blocks in HTML. */
pre.src-results-agda:before { content: 'Results: Agda'; }
pre.src-results-agda { background: pink;}
/* Execute this for alias: (add-to-list 'org-src-lang-modes '("results-agda" . org-agda)) */

</style>
#+end_export
# Org-mode Templates --A reason I â€œgenerateâ€ templates ;):1 ends here

# [[file:~/.emacs.d/init.org::*Org-mode%20Templates%20--A%20reason%20I%20%E2%80%9Cgenerate%E2%80%9D%20templates%20;)][Org-mode Templates --A reason I â€œgenerateâ€ templates ;):6]]

* Macro: fold                                                        :ignore:
# Folding up some code blocks in the resulting html.
#
# Usage: {{{fold(title here)}}} contents {{{end-fold}}}
#
#+MACRO: end-fold  #+HTML: </details>
#+MACRO: fold      #+HTML: <details class="code-details"> <summary> <strong> <font face="Courier" size="3" color="green"> $1 </font> </strong> </summary>

* Abstract       :ignore:
#+BEGIN_CENTER org
*Abstract*
#+END_CENTER

Editor extension for supporting [[https://alhassy.github.io/next-700-module-systems-proposal/][â€œthe next 700 module systemsâ€ proposal]].

#+BEGIN_CENTER org
/Everything here works with Agda version 2.6.0./
#+END_CENTER

#+TOC: headlines 2

* Aim: /Scrap the Repetition/

We're going to write a code generator in Lisp that is going to interpret
fictitious Agda code ---henceforth referred to as â€œ700 codeâ€---
into currently legitimate Agda code.

For example, something like the following, henceforth referred to as ~test~:
#+NAME: test
#+BEGIN_Src agda :results replace
PackageFormer Semigroup (v : Variation) : Set where
  field
    _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v
    Id  : Semigroup v
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

Semigroup-semantics  =  Semigroup record
Semigroup-syntax     =  Semigroup data
SemigroupOn          =  Semigroup typeclass
#+END_Src

#+RESULTS: test
: PackageFormer Semigroup (v : Variation) : Set where
:   field
:     _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v
:     Id  : Semigroup v
:     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
:
: Semigroup-semantics  =  Semigroup record
: Semigroup-syntax     =  Semigroup data
: SemigroupOn          =  Semigroup typeclass

#
# The â€œ:results replaceâ€ is since we actually want the results of this
# block later on when using â€œtestâ€ as a org-provided variable to org-src blocks.

Will behave as if it were written:
#+BEGIN_Src agda
record Semigroup-semantics  : Set where
  field
    Carrier : Set
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

data Semigroup-syntax : Set where
    _â¨¾_ : SemigroupD â†’ SemigroupD â†’ SemigroupD
    Id  : SemigroupD

record SemigroupOn (Carrier : Set) : Set where
  field
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
#+END_Src
This is a nearly 200% increase in size; that is, our fictitious code will
save us a lot of repetition.

* Global Preconditions
For this prototype, we have the following <<<constraints>>>:

1. All package formers have exactly one explicit ~Variation~ parameter.
   - They have no other parameters.

2. The type of a PackageFormer is ~Set â„“~ where ~â„“~ is the empty string
   or an expression of type ~Level~.
   - In-particular, subscript types are not yet supported.

3. The ~where~ keyword appears on the same line as the ~PackageFormer~ key-phrase.

4. The name of the PackageFormer should not contain ~PackageFormer~ as a sub-identifier.

5. The first child of the package former is the ~field~ declaration, on its own line.
* Finding Children in the Wild

Consider the following todo list,
#+NAME: children-example
#+BEGIN_SRC org
+ item 1
  - subitem 1.1
    ,* subsubitem 1.1.1
  - subitem 1.2
+ item 2
  - subitem 1.2
+ item 3
#+END_SRC

:Example:
#+BEGIN_SRC emacs-lisp :var it = children-example
(message it)
#+END_SRC

#+RESULTS:
: + item 1
:   - subitem 1.1
:     * subsubitem 1.1.1
:   - subitem 1.2
: + item 2
:   - subitem 1.2
: + item 3
:End:

We would think that ~item 1~ has two â€˜childrenâ€™, and, moreover, one grand-child.
Whereas ~item 2~ has a single child and ~item 3~ is barren.

Here's my intuitive algorithm: We obtain the indentation of the first child,
then all subsequent lines with at least that much indentation have the same ancestor.

{{{fold( get-indentation Implementation)}}}
#+BEGIN_SRC emacs-lisp
(defun get-indentation (string)
  "How many spaces are there at the front of â€˜stringâ€™?

  Property: The resulting number is â€˜â‰¤ length stringâ€™.
  "
  (if string (length (s-shared-start string (s-repeat (length string) " "))) 0)
)
#+END_SRC

#+RESULTS:
: get-indentation

{{{end-fold}}}
{{{fold( get-children Implementation)}}}
#+BEGIN_SRC emacs-lisp
(cl-defun get-children (parent the-wild &key (then #'identity))
  "Go into â€˜the-wildâ€™ seeking out the first occurence of â€˜parentâ€™,
   who once found, ought to have a minimal indentation for its children.

   â€œMinimalâ€ in that if there are items with a greater indentation,
    then they are children of children and should be kept.

   The first input argument is of type â€˜stringâ€™,
   the second argument may be of type â€˜stringâ€™ or â€˜listâ€™ of strings
   ---if it's a string, we split along new lines---,
   the optional â€˜thenâ€™ is a function acting on children strings.

   Result is the parent followed by its children, as a list of lines,
   where each child has been altered using the optional â€˜thenâ€™ function.
   Moreover, we also return the rest of the unconsidered portion of â€˜the-wildâ€™:
   Result: ( (cons parent-line children-lines) . unconsidered-remaining-lines )

   Warning: We do /not/ return the unconsidered prefix of â€˜the-wildâ€™; i.e,
   the porition that does not contain an occurence of â€˜parentâ€™.
   Why? I currently have no need for it, so I throw it away.

   Implementation: Look at the indentation of the
   first child, then use that as a lower bound to find the indentation
   of the remaining children.
  "

  (let ( (lines (if (stringp the-wild) (s-lines the-wild) the-wild))
         (indentation -1)
         (parent-line nil) )
    ;; Ensure: lines â‰ˆ (parent-here . more-lines)
    (while (and (car lines) (not (s-contains? parent (car lines))))
      ;; â€˜andâ€™ in-case parent is not even in the list, and so we reach nil.
      (setq lines (cdr lines))
      )

    ;; Throw away parent, but keep its contextual line.
    (setq parent-line (car lines))
    (setq lines (cdr lines))

    ;; How far is the first child indented?
    (setq indentation (get-indentation (car lines)))

    ;; Keep only the children that have at least this level of indentation.
    (setq lines&more (--split-with (<= indentation (get-indentation it)) lines))
    (setq lines (car lines&more))
    (setq unconsidered (cadr lines&more))

    ;; Alter the children according to the given function.
    (setq lines (mapcar then lines))

    ;; Yield the parent line along with the children lines.
    `( ,(cons parent-line lines) . ,unconsidered )
  )
)
#+END_SRC

#+RESULTS:
: get-children

{{{end-fold}}}

Let's try this out on our example hierarchy, ~eh~, from earlier.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(car (get-children "+ item 1" eh))
#+END_SRC

#+RESULTS:


Excellent! Let's looks at the other parents.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(get-children "+ item 2" eh)
#+END_SRC

#+RESULTS:
| nil |

Notice that we found the parent ~+ item 2~ and its only child ~- subitem 1.2~, and
we dropped the prefix of ~eh~ that did not contain the parent but have kept
the remaining unconsidered portion of ~eh~.

Finally, the barren parent.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(get-children "+ item 3" eh)
#+END_SRC

#+RESULTS:
| nil |

Yay :smile:

Before we move on, let's try altering a child clause; e.g., I'd like
~* subitem 1.1.1~ to be renamed to ~* subitem that is super deep~.
#+BEGIN_SRC emacs-lisp :var eh = children-example :exports both :results table replace
(car (get-children "+ item 1" eh
 :then (lambda (x) (s-replace "1.1.1" "that is super deep" x))))
#+END_SRC

#+RESULTS:


Nice :grin:


Now the moment of truth, let's try this out on our example.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results table replace
(car (get-children "PackageFormer" test))
#+END_SRC

#+RESULTS:
| PackageFormer Semigroup (v : Variation) : Set where | field | _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v | Id  : Semigroup v | assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z) |

Also, does the list variant work:
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results table replace
(car (get-children "PackageFormer" (s-lines test)))
#+END_SRC

#+RESULTS:
| PackageFormer Semigroup (v : Variation) : Set where | field | _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v | Id  : Semigroup v | assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z) |

Test-driven development doesn't seem bad ğŸ˜²

* Substrings Delimited by Tokens

#+begin_center
/How do we find a string delimited by two tokens?/
#+end_center

Before we can get to the real stuff, we need to produce a few low-level ---string manipulation---
utilities, so that we can work with higher-level abstract datatypes.

+ ~substring-delimited~: Given ~prefix~ and ~suffix~,
  this operation takes a string of the form  ~â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯~ and yields ~needle~.
+ ~substring-delimited-$~: Given ~"âŸªprefixâŸ« $here âŸªsuffixâŸ«"~
  this operation takes a string of the form  ~â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯~ and yields ~needle~.

{{{fold(substring-delimited Implementation)}}}
#+BEGIN_SRC emacs-lisp :results none
(cl-defun substring-delimited
    (prefix suffix string &key preserve-spaces longest-substring)
  "Assuming â€˜stringâ€™ â‰ˆ â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯, return the /first/ such needle
   by default, unless â€˜longest-substringâ€™ is true, in which case yield /longest/
   such needle.

  Unless â€˜preserve-spacesâ€™ is true, we convert all adjacent whitespace
  characters to a single space in the input â€˜stringâ€™ and trim any surrounding
  whitespace from the resulting output needle string.
  "

  (let (longest-needle context first-ending result)

    (unless preserve-spaces (setq string (s-collapse-whitespace string)))
    (setq context (concat prefix ".*" suffix))
    (setq longest-needle (s-chop-prefix prefix
                           (s-chop-suffix suffix
                             (car (s-match context string)))))

    (setq first-ending (s-index-of suffix longest-needle))
    (setq result (if (and (not longest-substring) first-ending)
                       (substring longest-needle 0 (1- first-ending))
                       longest-needle))
    (if preserve-spaces result (s-trim result))
  )
)
#+END_SRC
{{{end-fold}}}
{{{fold(substring-delimited-$ Implementation)}}}
#+BEGIN_SRC emacs-lisp
(cl-defun substring-delimited-$
    (context string &key preserve-spaces longest-substring)
  "Assuming â€˜contextâ€™ = â€œâŸªprefixâŸ« $here âŸªsuffixâŸ«â€
   and â€˜stringâ€™ â‰ˆ â‹¯â€˜prefixâ€™âŸªneedleâŸ«â€˜suffixâ€™â‹¯, return the /first/ such needle
   by default, unless â€˜longest-substringâ€™ is true, in which case yield /longest/
   such needle.

  Unless â€˜preserve-spacesâ€™ is true, we convert all adjacent whitespace
  characters to a single space in the input â€˜stringâ€™ and trim any surrounding
  whitespace from the resulting output needle string.
  "

  (-let [pre-post (s-split "$here" context)]
    (substring-delimited (car pre-post) (s-trim (cadr pre-post)) string
     :preserve-spaces preserve-spaces :longest-substring longest-substring)
  )
)
#+END_SRC
{{{end-fold}}}

Suppose a user provides us with an awkwardly spaced PackageFormer header,
our string manipulation setup is robust enough to get at the constituents:
#+BEGIN_SRC emacs-lisp :results replace :exports both
(-let [header "PackageFormer  Semigroup   (  v : Variation) : Set (  â„“expr)   where"]
  ;; Three kinds of invocations; the last is my preferred choice â™¥â€¿â™¥
  `( ,(substring-delimited "PackageFormer " "(" header :preserve-spaces t :longest-substring t)
     ,(substring-delimited "PackageFormer " "(" header)
     ,(substring-delimited-$ "PackageFormer $here (" header)
   )
)
#+END_SRC

#+RESULTS:
| Semigroup   (  v : Variation) : Set | Semigroup | Semigroup |

The aim is to eventually have an interface that interacts with an buffer containing Agda code.
To that end, we propose that our fictitious syntax be directly embedded into via special comments,
~{-700 â‹¯ -}~, henceforth referred to as â€œ<<<700-comments>>>â€.

+ ~(buffer-substring-delimited starting-regexp ending-regexp)~ yields the /next/ portion of the buffer
  as a string, relative to the current position of the cursor, that is contained in the â€˜parenthesisâ€™
  ~starting-regexp~ and ~ending-regexp~.

+ ~(buffer-substring-delimited-whole-buffer starting-regexp ending-regexp)~ yields /all/ portions of the buffer,
  contained in the â€˜parenthesisâ€™ ~starting-regexp~ and ~ending-regexp~, as a list of strings.

  - Cursor position is saved.
  - This function let's us obtain the contents of /all/ 700-comments.

{{{fold(buffer-substring-delimited Implementation)}}}
#+BEGIN_SRC emacs-lisp
(cl-defun buffer-substring-delimited (start end &optional (highlight nil))
  "
  Get the current buffer's /next/ available substring that is delimited
  between the regexp tokens â€˜startâ€™ up to â€˜endâ€™, exclusively.

  If no tokens are found, an error is thrown.

  The â€˜highlightâ€™ option simply highlights the selected region ---visual feedback
  for the user.
  "
  (let (p1 p2)
    (re-search-forward start)
    (setq p1 (point))

    (re-search-forward end)
    (backward-word)
    (setq p2 (point))

    (when highlight ;; do we want to highlight the region?
      (goto-char p1)
      (push-mark p2)
      (setq mark-active t)
    )

    ;; (copy-region-as-kill p1 p2)
    (buffer-substring-no-properties p1 p2)
))
#+END_SRC
{{{end-fold}}}

{{{fold(buffer-substring-delimited-whole-buffer Implementation)}}}
#+BEGIN_SRC emacs-lisp
(cl-defun buffer-substring-delimited-whole-buffer (start end)
  "Return a list of all substrings in the current buffer that
   are delimited by regexp tokens â€˜startâ€™ and â€˜endâ€™, exclusively.
  "
  (save-excursion
    (let ((l nil) (continue t))
     (beginning-of-buffer)

     (while continue
       (condition-case nil
         ;; attemptClause
         (setq l (cons (buffer-substring-delimited start end) l))
         ;; recoveryBody
         (error (setq continue nil))))

     ;; We've collected items as we saw them, so â€˜lâ€™ is in reverse.
    (reverse l)
    )
  )
)
#+END_SRC
{{{end-fold}}}

Here are some possible invocations, the last one being our use case.
#+BEGIN_SRC emacs-lisp :tangle no
;; Get text delimited by quotes
(buffer-substring-delimited "^\"" "^\"")

;; Get text delimited by quotes
(buffer-substring-delimited "^\{-" "^-\}")

;; Execute the following in an Agda buffer to see this function in action.
(setq it (buffer-substring-delimited-whole-buffer "^\{-700" "^-\}"))
#+END_SRC

So much string meddling, hopefully no more ğŸ™ˆ :hear_no_evil: :speak_no_evil:

* The ~package-former~ Datatype

For this prototype's constraints, a PackageFormer will generally declared as
#+BEGIN_SRC agda :tangle no
PackageFormer Semigroup (v : Variation) : Set â„“ where
   field
     â‹®
#+END_SRC

The body, ~â‹®~, of such a declaration mentions ~Semigroup v~, which we would like to rewrite
with other names when the package is instantiated. Likewise, we also want to erase or rewrite
the sole parameter, and possibly increment the level. Let's form a type to work with these components
rather than meddle with strings all the time.

#+BEGIN_SRC emacs-lisp
(defstruct package-former
  "Record of components that form a PackageFormer."
  docstring
  (type "PackageFormer")
  name
  (param (make-typedname :name "v" :type "Variation"))
  level
  (carrier "PackageFormer v")
  ;; children
  ;;
  ;; As long as consistent indentation is selected, it does not matter how much.
  field-header-indentation
  fields-indentation
  fields

)
;;   - â€˜docstringâ€™: What is the parent PackageFormer, or instance declaration, of
;;     the currently intantiated data-type.
;;
;;    - â€˜typeâ€™: PackageFormer, record, data, module, etc.
;;   when construed as a function type, the â€˜typeâ€™ value is rendered ""?
;;
;;    - â€˜carrierâ€™: What is the carrier of this new instance? E.g., â€œCarrierâ€.
;;      By default it's the â€˜new-nameâ€™; but this is unresonable when, say, a typeclass
;;      variation is requested.
#+END_SRC

Whops, we need support for typed names ---pairs ~â€œname : typeâ€~.
We could use ~car~ and ~cdr~ on pairs, but let's use named projections instead
so we don't have this extra mental strain and implicit type-checking to ensure.

** Typed Names

#+BEGIN_SRC emacs-lisp
(defstruct typedname
  "Representation of pairs â€œname : typeâ€,
   for use in a context as in a parameter list
   or in a list of fields of a record-like type."
  name
  type
  )

(cl-defun show-tn (tn)
  "Pretty print a typed-name record value"
  (if tn (format "(%s : %s)" (typedname-name tn) (typedname-type tn)) "")
)
#+END_SRC

(cl-defmethod show ((x t))
  "Catch-all show method"
  (message (format "Default show invoked for object: %s" x))
  t
)


** Package Former Parsing and Pretty Printing

With this in hand, let's produce a robust parser.
#+BEGIN_SRC emacs-lisp
(defun parse-package-former (lines)
  "The input â€˜linesâ€™ must be a list of lines forming a full PackageFormer declaration;
   e.g., obtained by calling â€˜get-childrenâ€™.

   It is parsed and a â€˜package-formerâ€™ value is returned.

   Docstrings are ignored.
  "

  ;; Precondition Example, with intentionally strange whitespacing:
  ;; header â‰ˆ â€œPackageFormer Semigroup   (v : Variation) : Set  ( â„“expr)   whereâ€

  (let* ((header (car lines))
         (vs (substring-delimited-$ "($here : Variation"    header)))
               (make-package-former
                :type "PackageFormer"
                :carrier (concat "PackageFormer " vs)
                :name             (substring-delimited-$ "PackageFormer $here (" header)
                :param (make-typedname :name vs :type "Variation")
                     ;; â€˜levelâ€™ may be â€œâ€, that's okay.
                :level            (substring-delimited-$ "Set $here where"       header)
                  :field-header-indentation (get-indentation (cadr lines))
                  :fields-indentation (get-indentation (caddr lines))
                  :fields (--map (s-trim it) (cddr lines)))
  )
)
#+END_SRC

Let's try this out.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results table replace
(parse-package-former (car (get-children "PackageFormer" test)))
#+END_SRC

#+RESULTS:
| #s(package-former PackageFormer Semigroup #s(typedname v Variation)  PackageFormer v 2 4 (_â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v Id  : Semigroup v assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z))) |

Conversely, let's have a pretty printer ---for testing purposes, if anything.
#+BEGIN_SRC emacs-lisp
;;
;;   - â€˜carrierâ€™: What is the carrier of this new instance? E.g., â€œCarrierâ€.
;;      By default it's the â€˜new-nameâ€™; but this is unresonable when, say, a typeclass
;;      variation is requested.
;;
(cl-defun show-pf (p &key carrier omit-field-decl omit-docstring)
  "Pretty print a package-former record value"

  (let ((flds (s-join "\n"
                      (funcall (if omit-field-decl #'cdr #'identity) (package-former-fields p)))))
        ; (pf-name (concat (package-former-name p) " " (typedname-name (package-former-param p)))))
        ;; E.g., â€œSemigroup vâ€

    ; (unless carrier (setq carrier pf-name))
    ; (setq flds (s-replace pf-name carrier flds))

    (concat
     (unless omit-docstring (format "\n{- %s -}\n" (package-former-docstring p)))
     (s-join " "
      `( ,(package-former-type p)
         ,(package-former-name p)
         ,(show-tn (package-former-param p))
         ": Set"
         ,(format "%swhere\n" (package-former-level p))))

        (unless omit-field-decl
          (concat (s-repeat (package-former-field-header-indentation p) " ") "field\n"))

      (s-join       "\n"
       (--map (concat (s-repeat (package-former-fields-indentation p) " ") it)
                (package-former-fields p)))
      )
   )
)
#+END_SRC

#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace
 (-let [pf (car (get-children "PackageFormer" test))]
   (show (parse-package-former pf) :omit-docstring t))
#+END_SRC

#+RESULTS:
: PackageFormer Semigroup (v : Variation) : Set where
:   field
:     _â¨¾_ : Semigroup v â†’ Semigroup v â†’ Semigroup v
:     Id  : Semigroup v
:     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

At a first glance, ~%swhere\n"~ is in desperate need of some spacing, however
this space miserliness permits us to phrase an approximation of the opinion
that parsing and showing should be inverses.

#+BEGIN_SRC emacs-lisp :var test = test :exports both :results table replace
(-let [pf (car (get-children "PackageFormer" _test))]
  (equal (s-join "\n" pf) (show (parse-package-former pf) :omit-docstring t))
  )
#+END_SRC

#+RESULTS:
| t |

#+begin_center
( /In Lisp, ~t~ denotes â€œtrueâ€!/ )
#+end_center

** ~package-formers~ List
#+BEGIN_SRC emacs-lisp
(defvar package-formers nil
  "The list of PackageFormer's declarations in the current Agda buffer.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun load-package-former (lines)
  "The input â€˜linesâ€™ mut be a list of lines forming a full PackageFormer declaration;
   e.g., obtained by calling â€˜get-childrenâ€™.

   It is parsed and added to the list of â€˜package-formersâ€™.
  "

    (add-to-list 'package-formers (parse-package-former lines))
)
#+END_SRC

* Testing :neato:

#+BEGIN_SRC emacs-lisp :results replace :wrap "example"
(progn
  (switch-to-buffer "Testing.agda")
  (setq _res "hi")
  (setq package-formers nil) (parse-700-comments)
  (switch-to-buffer "PackageFormer.org")

  ; _res
  ; 700-comments
  ; instantiations-remaining

   package-formers
   ; (reify-instances)
   ; (instantiate-as-data (car package-formers))

(-let [pf-name "M-syntax"]

  (instantiate (cadr package-formers)  :name-suffix "syntax"
                     :type "data"
                     :omit-field-header t
                     :new-name pf-name

                     ; :keep-fields (lambda (f) (s-contains? "Vertex" (field-target f)))
                    )


)

  (instantiate-as-data (cadr package-formers))
)
#+END_SRC

#+RESULTS:
#+begin_example

{- This was generated from the PackageFormer Magma -}
data Magma-syntax  : Set (â„“.suc â„“.zero)where
    _â¨¾_ : Magma-syntax â†’ Magma-syntax â†’ Magma-syntax
    -- Id  : Magma-syntax
#+end_example




    (instantiate decls  :new-name new-name
                       :name-suffix "syntax"
                       :type "data"
                       :omit-field-header t
                       :keep-fields (lambda (f) (s-contains? pf-name (field-target f)))
                      ))

#+RESULTS:
#+begin_example

{- This was generated from the PackageFormer Graph -}
record Graph-typeclass (Carrier : Set) : Set (â„“.suc â„“.zero)where
  field
    Vertex : Set
    _âŸ¶_ : Vertex â†’ Vertex â†’ Set
#+end_example

* Parsing an Agda Buffer
** instantiations-remaining list
#+BEGIN_SRC emacs-lisp
(defvar instantiations-remaining nil
  "The PackageFormer instantiations that need to be performed.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defstruct instance-declaration
  "Record of componenets for an PackageFormer instance declaration:
   âŸªnameâŸ« = âŸªpackage-formerâŸ« âŸªvariationâŸ« âŸªrenamesâŸ«,
   âŸªrenamesâŸ« = Îµ | renaming (Î± to Î±â€² ; â€¦ ; Ï‰ to Ï‰â€²).
  "
  name package-former variation renames
)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun load-instance-declaration (line)
  "If the current â€˜lineâ€™ string is an instance declaration,
   then parse and add it to the list of â€˜instantiations-remainingâ€™;
   else do nothing.

   Returns the instance-declaration that was loaded, otherwise nil.
  "

  ;; Example instance declaration:
  ;; â€œMagmaR = Magma record renaming (Carrier to C; _â¨¾_ to _âˆ˜_)â€
  ;; â‡’ â‰¥4 pieces, sepearted by spaces, where second item must be an equality.
  ;; Note: (cddddr nil) â‰ˆ nil

  (let* (inst (pieces (s-split " " line)) (renames (cddddr pieces)))
   (when (and (<= 4 (length pieces)) (equal (nth 1 pieces) "="))

     (when renames

       ;; Stick them back together
       (setq renames (s-join " " renames))

       ;; Discard identifying tokens
       (setq renames (substring-delimited-$ "renaming ($here)" renames))

       ;; Split along semicolons, then turn into pairs.
       (setq renames (--map (s-split "to" it) (s-split ";" renames))))

     (setq inst (make-instance-declaration
                 :name           (nth 0 pieces)
                 :package-former (nth 2 pieces)
                 :variation      (nth 3 pieces)
                 :renames        renames))

     (add-to-list 'instantiations-remaining inst)
   )
   ;; Return value.
   inst
  )
)
#+END_SRC

Test:
#+BEGIN_SRC emacs-lisp :results replace
(load-instance-declaration
  "MagmaR = Magma record renaming (Carrier to C; _â¨¾_ to _âˆ˜_)")
#+END_SRC

#+RESULTS:
: #s(instance-declaration "MagmaR" "Magma" "record" (("Carrier " " C") (" _â¨¾_ " " _âˆ˜_")))

** parse-700-comments
#+BEGIN_SRC emacs-lisp
(defvar 700-comments nil
  "The contents of the 700-comments.

   If this variable does not change, we short-circut all processing.
  ")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(cl-defun parse-700-comments ()
  "
   Parse comments of the form â€œ{-700 â‹¯ -}â€ and add all PackageFormer declarations
   to the â€˜package-formersâ€™ list and all instantations to the â€˜instantiations-remainingâ€™ list.
  "
  (interactive)

   ;; for testing
   ;; (setq instantiations-remaining nil)
   ;; (setq package-formers nil)

  ;; For now, â€˜itemâ€™ is either a PackageFormer or instantiation declaration.
  (let (item lines)

  ;; Step 0: Catenate all 700-comments into a single string.
  (setq 700-comments (s-join "\n" (buffer-substring-delimited-whole-buffer "^\{-700" "^-\}")))

  ;; View comments as a sequence of lines, ignore empty lines ---which are not in our grammar.
  (setq lines (--remove (s-blank? (s-collapse-whitespace it)) (s-lines 700-comments)))

  ;; Traverse the 700-comments:
  ;; If we view a â€œlhs = rhsâ€ equation, add to global â€˜instantiations-remainingâ€™ list.
  ;; If we view a PackageFormer declaration, add to global â€˜package-formersâ€™ list.
  (while lines
   (setq item (car lines))
   (if (load-instance-declaration item) (setq lines (cdr lines))
     ;; Else we have a PackageFormer declaration:
     ;; Get it along with the remaining 700-comments.
     (setq item (get-children "PackageFormer" lines))
     (load-package-former (car item))
     (setq lines (cdr item))))

  (message "Finished parsing 700-comments.")
  )
)

;; (global-set-key (kbd "<f7>") 'parse-700-comments)
#+END_SRC

* ~instantiate~ ---the core utility
Let's put the pieces together.
#+BEGIN_SRC emacs-lisp
(cl-defun instantiate (decls &key
  new-name (type "record") carrier
  name-suffix
  param-replacement
  prefix-fields suffix-fields omit-field-header
  (keep-fields (lambda (x) t))
  (alter-raw-fields #'identity)
  (alter-fields #'identity)
  docstring
  )

  "Given a PackageFormer declaration, instantiate it into a concrete Agda type.

   Remarks or example values:

   - â€˜declsâ€™ is immediately provided to â€˜get-childrenâ€™, so it may be a string,
      a list, or a value of type â€˜package-formerâ€™.
      NOTE: If you do pass in a â€˜package-formerâ€™, we will not alter yours;
      we will copy it and work with the local copy.

   - â€˜typeâ€™: The replacement for â€œPackageFormerâ€; default is â€œrecordâ€.

   - â€˜carrierâ€™: What is the carrier of this new instance? E.g., â€œCarrierâ€.
      By default it's the â€˜new-nameâ€™; but this is unresonable when, say, a typeclass
      variation is requested.

   - â€˜name-suffixâ€™: When no â€˜new-nameâ€™ is provided, the default is
      â€œâŸªPackageFormer'sNameâŸ«-âŸªvariationâŸ«-g*â€, where â€˜*â€™ is an arbitrarily generated number.

     This may be useful for rapid development when one does not want to provide
     a name to an instance, but simply wants the instance to exist.

   - â€˜param-replacementâ€™: '(â€œCarrierâ€ . â€œSetâ€); empty string by default.

   - â€˜prefix-fieldsâ€™: List of fields, â€œname : typeâ€, to be added at the beginning
      of the field declaration. Default is empty string.

   - â€˜suffix-fieldsâ€™: List of fields, â€œname : typeâ€, to be added at the beginning
      of the field declaration. Default is empty string.

   - â€˜omit-field-headerâ€™: Should the â€œfieldâ€ word be removed? No by default.

   - â€˜keep-fieldsâ€™: Predicate that determines which fields should be kept.
      By default, no fields are dropped.

   - â€˜alter-raw-fieldsâ€™: A function that alters the list of fields of a PackageFormer *before*
     any processing has transpiried. This is the identity function by default.

   - â€˜alter-fieldsâ€™: A function to alter existing fields *after* processing;
     it does not alter inserted fields via â€˜prefix-fieldsâ€™ nor â€˜suffix-fieldsâ€™.
     This is the identity function by default.

   - â€˜docstringâ€™: What is the parent PackageFormer, or instance declaration, of
     the currently intantiated data-type.
  "

  (let* ((pf (if (package-former-p decls) (copy-package-former decls) (parse-package-former (car (get-children "PackageFormer" decls)))))
         (pf-name (package-former-name pf))
         (pfv (concat pf-name " " (typedname-name (package-former-param pf))))
         (fields     (funcall alter-raw-fields (package-former-fields pf)))
         )

  ;; -1. Source generation declaration.
  (setf (package-former-docstring pf)
    (or docstring
        (concat "This was generated from the PackageFormer " pf-name)))

  ;; 0. Replace "PackageFormer" with â€˜typeâ€™.
  (setf (package-former-type pf) type)

  ;; 1. Replace "(? : Variation)" with the provided â€˜variation-replacementâ€™.
  (setf (package-former-param pf) param-replacement)

  ;; 2. Replace all occurences of â€œpackage-former-name followed by variationâ€
  ;; with â€˜carrierâ€™, if any.
  ;; Default value of â€˜new-nameâ€™ & â€˜carrierâ€™ are âŸªPackageFormer'sNameâŸ«-âŸªname-suffixâŸ«.
  (unless new-name (setq new-name (concat (package-former-name pf) "-" name-suffix)))
  (unless carrier  (setq carrier new-name))
  (setf (package-former-fields pf)
          (--map (s-replace pfv carrier it) (package-former-fields pf)))

  ;; 3. Replace PackageFormer's name with provided instantiation name.
  (setf (package-former-name pf) new-name)

  ;; 4. Insert new fields and process the altered existing fields.
  (setf (package-former-fields pf)
        (-concat
             prefix-fields
               ;; Perform any processing on the fields.
               (funcall alter-fields (-filter keep-fields (package-former-fields pf)))
             suffix-fields
           ))

  ;; 5. Stringify!
  (show-pf pf :omit-field-decl omit-field-header)

 )
)

(cl-defun specialise (instance)
 "Input is an instantiation declaration, output is a pacakge former value."

 (make-package-former)

)
#+END_SRC

#+BEGIN_SRC emacs-lisp :results replace
(load-instance-declaration
  "MagmaR = Magma record renaming (Carrier to C; _â¨¾_ to _âˆ˜_)")
#+END_SRC


Let's instantiate our test example from earlier to produce a typeclass.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(instantiate _test   ;; :new-name "SemigroupT"
                    :name-suffix "typeclass"
                    :type "record"
                    :param-replacement (make-typedname :name "Carrier" :type "Set")
                    :carrier "Carrier"
                      :docstring "This is a test"
                    )
#+END_SRC

#+RESULTS:
#+begin_src results-agda

{- This is a test -}
record Semigroup-typeclass (Carrier : Set) : Set where
  field
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
#+end_src



What about a bundled up record declaration?
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(instantiate test   ;; :new-name "SemigroupT"
                    :name-suffix "semantics"
                    :type "record"
                    :carrier "Carrier"
                    :prefix-fields '("Carrier : Set")
                    )
#+END_SRC

#+RESULTS:
#+begin_src results-agda

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-semantics  : Set where
  field
    Carrier : Set
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)
#+end_src

Records provide a semantics, what if we want the syntax?
Since ~data~ declarations consist of constructors, whose target type necessarily
begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.

First, a helper function.
#+BEGIN_SRC emacs-lisp
(defun field-target (field)
  " Given a declaration â€œname : type0 â†’ â‹¯ â†’ typeNâ€, yield â€œtypeNâ€. "
  (car (-take-last 1 (s-split "â†’" field)))
)
#+END_SRC

Let's test it out:
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace
(-let [pf-name "Semigroup-syntax"]

  (list (s-contains? pf-name (field-target "Id    :  Semigroup-syntax"))
        (s-contains? pf-name (field-target "_â¨¾_   :  Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax"))
        (s-contains? pf-name (field-target "assoc :  âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)")))
)
#+END_SRC

#+RESULTS:
| t | t | nil |

The results are as expected, so let's move to the real use case.
#+BEGIN_SRC emacs-lisp :var test = test :exports both  :results replace :wrap "src results-agda"
(-let [pf-name "Semigroup-syntax"]

  (instantiate test  :name-suffix "syntax"
                     :type "data"
                     :omit-field-header t
                     :new-name pf-name
                     ;; :carrier pf-name
                     :keep-fields (lambda (f) (s-contains? pf-name (field-target f)))
                    )
)
#+END_SRC

#+RESULTS:
#+begin_src results-agda

{- This was generated from the PackageFormer Semigroup -}
data Semigroup-syntax  : Set where
    _â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax
    Id  : Semigroup-syntax
#+end_src

Yeehaw! We've got three variations and possibly much more from a single fancy well-toggled
function ğŸ¤  We can emulate generative modules this way too! ğŸ˜»

Let's package these particular toggle configurations into their own functions.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-typeclass (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda â€œtypeclassâ€.

   - â€˜declsâ€™ is immediately provided to â€˜get-childrenâ€™, so it may be a string,
      a list, or a value of type â€˜package-formerâ€™.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (instantiate decls :new-name new-name
                     :name-suffix "typeclass"
                     :type "record"
                       :param-replacement (make-typedname :name carrier :type "Set")
                     :carrier carrier
                    )
)
#+END_SRC

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-record (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - â€˜declsâ€™ is immediately provided to â€˜get-childrenâ€™, so it may be a string,
      a list, or a value of type â€˜package-formerâ€™.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (instantiate decls :new-name new-name
                    :name-suffix "semantics"
                    :type "record"
                    :carrier carrier
                    :prefix-fields `(,(format "%s : Set" carrier))
                    )
)
#+END_SRC

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-data (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - â€˜declsâ€™ is immediately provided to â€˜get-childrenâ€™, so it may be a string,
      a list, or a value of type â€˜package-formerâ€™.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (let* ((pf (if (package-former-p decls) (copy-package-former decls) (parse-package-former (car (get-children "PackageFormer" decls)))))
         (pf-name (package-former-name pf)))

    (instantiate decls  :new-name new-name
                       :name-suffix "syntax"
                       :type "data"
                       :omit-field-header t
                       :keep-fields (lambda (f) (s-contains? pf-name (field-target f)))
                      )
  )
)
#+END_SRC

That's a lot of mumbo jumbo, let's have a sanity check.
#+BEGIN_SRC emacs-lisp :var test = test :exports both :results replace :wrap "src results-agda"
(s-join "\n" `(
,(instantiate-as-typeclass test)
,(instantiate-as-record test)
,(instantiate-as-data test)
))

;; (instantiate-as-typeclass (cadr package-formers) :new-name "hello")
#+END_SRC

#+RESULTS:
#+begin_src results-agda

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-typeclass (Carrier : Set) : Set where
  field
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-semantics  : Set where
  field
    Carrier : Set
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup -}
data Semigroup-syntax  : Set where
    _â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax
    Id  : Semigroup-syntax
#+end_src



Notice that the results contained generated names since no names were provided.

* Instantiate all items in â€˜instantiations-remainingâ€™

# (funcall (read "(insert 1)") 3 3)
# (funcall (read "equal") 3 3)

#+BEGIN_SRC emacs-lisp
(cl-defun reify-instances ()
 "Instantiate all items in â€˜instantiations-remainingâ€™."

 (interactive)

 (let* (result name pf-type pf pfs variation reify)

   (dolist (inst instantiations-remaining)

     ;; Get pieces of the instance declaration.
     (setq name (instance-declaration-name inst))
     (setq variation (instance-declaration-variation inst))
     (setq pf-type (instance-declaration-package-former inst))

     ;; Get the package-former that is being instantiated.
     (setq pfs (--filter (equal pf-type (package-former-name it)) package-formers))

     ;; Perform the instantiation.
     (setq reify
           (cond ((not pfs) (format "%s = {! No PackageFormer â€˜%sâ€™ declared. !}" name pf-type))
                 (t (pcase (instance-declaration-variation inst)
                      ("typeclass" (instantiate-as-typeclass (car pfs) :new-name name))
                      ("record"    (instantiate-as-record (car pfs) :new-name name))
                      ("data"      (instantiate-as-data (car pfs) :new-name name))
                      (v  (format "%s = {! Variation %s not yet supported!}" name v))))))

     ;; Add to list of results.
     (setq result (-cons* reify result))
)
   ;; Output results as a string.
   (s-join "\n" result)
))

(global-set-key (kbd "<f7>") 'reify-instances)

        ;; Perform the instantiation.
        ; (setq reify (pcase (instance-declaration-variation inst)


                      ;("record" (instantiate-as-record (show pf) :new-name name))
                      ;("data" (instantiate-as-data (show pf) :new-name name))
          ;            (otherwise  "neat")))) ;;(message-box "Error: Variation %s not supported yet." variation))
        )



#+END_SRC

# ;-)
# (funcall (read (concat "instantiate-as-")) (show pf) :new-name name)

#+BEGIN_SRC emacs-lisp
(defun reify-package-formers (orig-fun &rest args)
  (interactive)

  ;; Sometimes we may want the full name due to files being in a nested
  ;; directory hierarchy:
  ;; (file-name-sans-extension buffer-file-name)
  (setq generated-file-name (concat(file-name-sans-extension (buffer-name))
                  "_Generated"))

  ;; Thisâ€™ inefficent.
  (setq package-formers nil)
  (setq instantiations-remaining nil)
  (parse-700-comments)

  (with-temp-buffer
    (beginning-of-buffer)

    (insert (s-join "\n" `(
             "{- This file is generated ;; do not alter. -}"
               "{-# OPTIONS --allow-unsolved-metas #-}"
             "open import Relation.Binary.PropositionalEquality using (_â‰¡_)"
               "open import Level as â„“"
             ,(format "module %s where " generated-file-name)
             ,(reify-instances))))

    ;; (mark-whole-buffer)
    (write-region (beginning-of-buffer) (end-of-buffer)
                  (concat generated-file-name ".agda"))
    )
    ;; MA: Using â€˜(write-file "Generated.agda")â€™ means we make a file
    ;; then the temporary buffer /vistis/ the agda file, which loads the
    ;; agda process therein, which is undesirable since it could leave
    ;; agda working on the buffer even after it has been killed!
    ;; This would necessiate calling (agda2-restart) afterwards.
    ;;
    ;; Instead we write the whole region, without visiting the resuting file.

  (insert-generated-import generated-file-name)
  ;; call agda2-load
  (apply orig-fun args)
  (message "700 âˆ· All the best coding! (â€¢Ì€á´—â€¢Ì)Ùˆ")
)

(advice-add 'agda2-load :around #'reify-package-formers)
#+END_SRC

* TODO COMMENT Acting on Agda Buffer

The aim is to process test enclosed in ~{-700 â‹¯ -}~ comments,
produce legitimate Agda from that, and ensure the generated Agda is accessible to the
current buffer automatically.

** insert-generated-import
Let's give the current buffer access to the location of the generated file.
#+BEGIN_SRC emacs-lisp
(defun insert-generated-import (name-of-generated-file)
  "In the current file, find the top-most module declaration
   then insert an import of the generated file.
  "
  (interactive)

  (save-excursion
    (beginning-of-buffer)
    (condition-case the-err
      ;; attemptClause
      (re-search-forward (concat "open import " name-of-generated-file))
       ;; recoveryBody
      (error
       ;; (message-box (format "%s" the-err))
         (re-search-forward "\\(module.*\\)")
         (replace-match (concat "\\1\nopen import " name-of-generated-file))
        )
    )
  )
)
#+END_SRC

* TODO COMMENT Minor mode ---Menu matter
#+BEGIN_SRC emacs-lisp

(defvar 700-menu-bar-menu (make-sparse-keymap "700 PackageFormers"))
(define-key global-map [menu-bar my-menu] (cons "700PackageFormers" 700-menu-bar-menu))

(defun enable-package-formers ()
 (interactive)
 (advice-add 'agda2-load :around #'reify-package-formers)
 ;; place notification in modeline
 (setq global-mode-string
      (cond ((consp global-mode-string)
             (add-to-list 'global-mode-string "700 (â€¢Ì€á´—â€¢Ì)Ùˆ"))
            ((not global-mode-string)
             (list "700 (â€¢Ì€á´—â€¢Ì)Ùˆ"))
            ((stringp global-mode-string)
             (list "700 (â€¢Ì€á´—â€¢Ì)Ùˆ" global-mode-string))))
)

(defun disable-package-formers ()
 (interactive)
 (advice-remove 'agda2-load #'reify-package-formers)
 (setq global-mode-string (remove "700 (â€¢Ì€á´—â€¢Ì)Ùˆ" global-mode-string))
)

(define-key 700-menu-bar-menu [enable-package-formers]
  '(menu-item "Enable PackageFormer Generation" enable-package-formers))

(define-key 700-menu-bar-menu [disable-package-formers]
  '(menu-item "Disable PackageFormer Generation" disable-package-formers))
#+END_SRC

#+RESULTS:
| menu-item | Disable PackageFormer Generation | disable-package-formers |

* TODO COMMENT missing features

+ MA: Just change the package-former-variation to package-former-parameter ---which is a pair, â€œname : typeâ€.
  This may make it easier later to transition to having multiple parameters.

+ !? why does â€˜buffer-substring-delimited-whole-bufferâ€™ return a list of strings? Why not join its result to simply return a list?

+ [A] Generated.agda needs to inherit all open/import declarations from parent.
+ [A] Lifting a field to the parameter level.
  - [A] â€œpf typeclass lifting Nâ€ lifts the first N fields to the parameter level.
+ [A] Explain how generative modules can be emulated.
+ [B] Renaming?
+ ;; TODO: For now, PackageFormer's have no other parameters besides the variation symbol.
+ ;; TODO: The global variables package-formers & instance-declaration should be /buffer/ specific?
+   ;; TODO: Assign to a local var, check equality against global 700-comments,
  ;; if identical, no more processing since everything already generated.


  #+BEGIN_SRC emacs-lisp
(defun generate-all-instances () ;; TODO
  "For each PackageFormer â€˜pfâ€™, produce the default instances:
   â€˜pf-recordâ€™, â€˜pf-typeclassâ€™, â€˜pf-dataâ€™.

   Use: You want a particular instance in rapid developement and don't want
   to be bothered to give it a name. Or experimenting and unsure which instance
   is most desirable, so have access to all of them.

   Possible extensions:
   0. Introduce concrete syntax â€œGenerateDefaultInstances pfâ€ to invoke this command.
   1. Have a global list of default instances.
  "

  (interactive)

    ;; Keep this around since we may want to produce variations wholesale with
  ;; names: packageformer-variation; e.g., Magma-typeclass.
  ;;
  ;;
  ;; the variations
;;  (setq the-vars-shush (--map (car it) (--map (-take-last 1 it) (--map (s-split " " it) decls-vars-shush))))
  ;;
  ;; (dolist (variation the-vars-shush ll)
  ;;  (setq ll (cons (make-typeclass decls (concat pf-name "-" variation)) ll)))

  )
#+END_SRC

#+RESULTS:
: generate-all-instances


* COMMENT ~instantiate~ ---the /backend/ core utility                         :posterity:
Let's put the pieces together.
#+BEGIN_SRC emacs-lisp
(cl-defun instantiate (decls &key
  new-name (type "record") carrier
  name-suffix
  (variation-replacement "")
  (prefix-fields "") (suffix-fields "") omit-field-header
  (keep-fields (lambda (x) t))
  (alter-raw-fields #'identity)
  (alter-fields #'identity)
  )

  "Given a PackageFormer declaration, instantiate it into a concrete Agda type.

   Remarks or example values:

   - â€˜declsâ€™ is immediately provided to â€˜get-childrenâ€™, so it may be a string
      or a list.

   - â€˜typeâ€™: The replacement for â€œPackageFormerâ€; default is â€œrecordâ€.

   - â€˜carrierâ€™: What is the carrier of this new instance? E.g., â€œCarrierâ€.
      By default it's the â€˜new-nameâ€™; but this is unresonable when, say, a typeclass
      variation is requested.

   - â€˜name-suffixâ€™: When no â€˜new-nameâ€™ is provided, the default is
      â€œâŸªPackageFormer'sNameâŸ«-âŸªvariationâŸ«-g*â€, where â€˜*â€™ is an arbitrarily generated number.

     This may be useful for rapid development when one does not want to provide
     a name to an instance, but simply wants the instance to exist.

   - â€˜variation-replacementâ€™: â€œ(Carrier : Set)â€; empty string by default.

   - â€˜prefix-fieldsâ€™: List of fields, â€œname : typeâ€, to be added at the beginning
      of the field declaration. Default is empty string.

   - â€˜suffix-fieldsâ€™: List of fields, â€œname : typeâ€, to be added at the beginning
      of the field declaration. Default is empty string.

   - â€˜omit-field-headerâ€™: Should the â€œfieldâ€ word be removed? No by default.

   - â€˜keep-fieldsâ€™: Predicate that determines which fields should be kept.
      By default, no fields are dropped.

   - â€˜alter-raw-fieldsâ€™: A function that alters the list of fields of a PackageFormer *before*
     any processing has transpiried. This is the identity function by default.

   - â€˜alter-fieldsâ€™: A function to alter existing fields *after* processing;
     it does not alter inserted fields via â€˜prefix-fieldsâ€™ nor â€˜suffix-fieldsâ€™.
     This is the identity function by default.
  "

  (let* ((pf (car (get-children "PackageFormer" decls)))
         (header     (car pf))
         (pf-name (package-former-name header))
         (pf-variation (variation-symbol header))
         (field-decl (cadr pf)) ;; In order to maintain user-provided indentation.
         (fields     (funcall alter-raw-fields (cddr pf)))
         (indentation (s-repeat (if fields (get-indentation (car fields)) 0) " "))
           (preFields   (--map (concat indentation it) prefix-fields))
           (postFields  (--map (concat indentation it) suffix-fields))
         (tc nil)
         )

  ;; Default value of â€˜new-nameâ€™ & â€˜carrierâ€™ are âŸªPackageFormer'sNameâŸ«-âŸªname-suffixâŸ«.
  (unless new-name (setq new-name (format "%s-%s-%s" pf-name name-suffix (gensym))))
  (unless carrier  (setq carrier new-name))

  ;; Replace "(? : Variation)" with the provided â€˜variation-replacementâ€™
  (setq header (insert-parameter variation-replacement (erase-parameters header)))

  ;; Replace "PackageFormer" with â€˜typeâ€™.
  (setq header (s-replace "PackageFormer" type header))

  ;; Replace PackageFormer's name with provided instantiation name.
  (setq header (s-replace pf-name new-name header))

  ;; Replace all occurences of â€œpackage-former-name followed by variationâ€
  ;; with â€˜carrierâ€™.
  (setq fields (--map (s-replace (concat pf-name " " pf-variation) carrier it) fields))

  ;; Perform any processing on the fields.
  (setq fields (funcall alter-fields (-filter keep-fields fields)))

  ;; Stick all the pieces together, along with the new fields.
  (setq tc (s-join "\n"
        (-cons* header
        (-concat
           (if omit-field-header () (list field-decl))
           preFields fields  postFields))))

  ;; Declare generation source matter.
  (concat
   "\n{- This was generated from the PackageFormer " pf-name " -}\n"
    tc)
 )
)
#+END_SRC

#+RESULTS:
: instantiate

Let's instantiate our test example from earlier to produce a typeclass.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(instantiate test   ;; :new-name "SemigroupT"
                    :name-suffix "typeclass"
                    :type "record"
                    :variation-replacement "(Carrier : Set)"
                    :carrier "Carrier"
                    )
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-typeclass-g105 (Carrier : Set) : Set where
:   field
:     _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
:     Id  : Carrier
:     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

#+BEGIN_SRC emacs-lisp :var test = test :exports both
;; (instantiate test)

(setq _test (show (car package-formers)))

(instantiate _test :variation-replacement "noice")

;; (erase-parameters _test)
; (insert-parameter "(nn : ?)" (erase-parameters _test)))

;; (instantiate-as-typeclass (show (car package-formers)))
;; (instantiate (show (car package-formers)))
;; -as-typeclass (show (car package-formers)))
;; (stringp (show (car package-formers)))
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-nil-g106 noice : Set where
:   field
:     _â¨¾_ : Semigroup-nil-g106 â†’ Semigroup-nil-g106 â†’ Semigroup-nil-g106
:     Id  : Semigroup-nil-g106
:     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

What about a bundled up record declaration?
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(instantiate test   ;; :new-name "SemigroupT"
                    :name-suffix "semantics"
                    :type "record"
                    :carrier "Carrier"
                    :prefix-fields '("Carrier : Set")
                    )
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: record Semigroup-semantics-g107  : Set where
:   field
:     Carrier : Set
:     _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
:     Id  : Carrier
:     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

Records provide a semantics, what if we want the syntax?
Since ~data~ declarations consist of constructors, whose target type necessarily
begins with the name of the ~data~-type being defined, let's only keep those fields and drop the rest.

First, a helper function.
#+BEGIN_SRC emacs-lisp
(defun field-target (field)
  " Given a declaration â€œname : type0 â†’ â‹¯ â†’ typeNâ€, yield â€œtypeNâ€. "
  (car (-take-last 1 (s-split "â†’" field)))
)
#+END_SRC

#+RESULTS:
: field-target

Let's test it out:
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(-let [package-former-name "Semigroup-syntax"]

  (list (s-contains? package-former-name (field-target "     Id  : Semigroup-syntax"))
        (s-contains? package-former-name (field-target "_â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax"))
        (s-contains? package-former-name (field-target "     assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)")))
)
#+END_SRC

#+RESULTS:
| t | t | nil |

The results are as expected, so let's move to the real use case.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(-let [package-former-name "Semigroup-syntax"]

  (instantiate test  :name-suffix "syntax"
                     :type "data"
                     :omit-field-header t
                       :new-name package-former-name
                       ;; :carrier package-former-name
                     :keep-fields (lambda (f) (s-contains? package-former-name (field-target f)))
                    )
)
#+END_SRC

#+RESULTS:
:
: {- This was generated from the PackageFormer Semigroup -}
: data Semigroup-syntax  : Set where
:     _â¨¾_ : Semigroup-syntax â†’ Semigroup-syntax â†’ Semigroup-syntax
:     Id  : Semigroup-syntax

Yeehaw! We've got three variations and possibly much more from a single fancy well-toggled
function ğŸ¤  We can emulate generative modules this way too! ğŸ˜»

Let's package these particular toggle configurations into their own functions.
#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-typeclass (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda â€œtypeclassâ€.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (instantiate decls :new-name new-name
                     :name-suffix "typeclass"
                     :type "record"
                     :variation-replacement (format "(%s : Set)" carrier)
                     :carrier carrier
                    )
)
#+END_SRC

#+RESULTS:
: instantiate-as-typeclass

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-record (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (instantiate test :new-name new-name
                    :name-suffix "record"
                    :type "record"
                    :carrier carrier
                    :prefix-fields `(,(format "%s : Set" carrier))
                    )
)

#+END_SRC

#+RESULTS:
: instantiate-as-record

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(cl-defun instantiate-as-data (decls &key new-name (carrier "Carrier"))

  "Given a PackageFormer declaration, instantiate it into a concrete Agda record.

   - â€˜new-nameâ€™ is the name of the resulting instance.
     Default is â€œâŸªPackageFormer'sNameâŸ«-record-g*â€ for a random sequence of digits â€˜*â€™.

   - â€˜carrierâ€™: What is the carrier of this new instance? Default is â€œCarrierâ€.

  "
  (let* ((pf (car (get-children "PackageFormer" decls)))
         (header     (car pf))
         (pf-name (package-former-name header)))

    (instantiate test  :new-name new-name
                       :name-suffix "syntax"
                       :type "data"
                       :omit-field-header t
                       :keep-fields (lambda (f) (s-contains? pf-name (field-target f)))
                      )
  )
)
#+END_SRC

#+RESULTS:
: instantiate-as-data

#+BEGIN_SRC emacs-lisp :var test = test :exports both
(s-join "\n" `(
,(instantiate-as-typeclass test)
,(instantiate-as-record test)
,(instantiate-as-data test)
))
#+END_SRC

#+RESULTS:
#+begin_example

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-typeclass-g108 (Carrier : Set) : Set where
  field
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup -}
record Semigroup-record-g109  : Set where
  field
    Carrier : Set
    _â¨¾_ : Carrier â†’ Carrier â†’ Carrier
    Id  : Carrier
    assoc : âˆ€ {x y z} â†’ (x â¨¾ y) â¨¾ z â‰¡ x â¨¾ (y â¨¾ z)

{- This was generated from the PackageFormer Semigroup -}
data Semigroup-syntax-g110  : Set where
    _â¨¾_ : Semigroup-syntax-g110 â†’ Semigroup-syntax-g110 â†’ Semigroup-syntax-g110
    Id  : Semigroup-syntax-g110
#+end_example

Notice that the results contained generated names since no names were provided.
* COMMENT PackageFormer Name and Variation Symbol          :possibly_not_needed:

As such, we form a method for
obtaining the name, the variation symbol, and a method to rewrite substrings of the
children ---wait, we already have the last one: ~get-children~ with optional ~:then~
keyword.

#+BEGIN_SRC emacs-lisp
;; The following two only work on headers of PackageFormer declarations.

(defun package-former-name (declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (v : Variation) : Set whereâ€
   return the name â€œSemigroupâ€.
  "
  (s-chop-prefix "PackageFormer "
    (s-chop-suffix " ("
      (car (s-match "PackageFormer .* (" declaration))))
)


(defun variation-symbol (declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (v : Variation) : Set whereâ€
   return the name â€œvâ€.
  "
  (s-chop-prefix "("
    (s-chop-suffix " : Variation)"
      (car (s-match "(.*)" declaration))))
)
#+END_SRC

#+RESULTS:
: variation-symbol

Let's test these two out.
#+BEGIN_SRC emacs-lisp
(package-former-name "PackageFormer Semigroup (v : Variation) : Set where")
;; â‡’ "Semigroup"

(variation-symbol "PackageFormer Semigroup (v : Variation) : Set where")
;; â‡’ "v"
#+END_SRC

#+RESULTS:
: v

* COMMENT Parameter Erasure & Insertion           :possibly_not_needed:
MA: Just change the package-former-variation to package-former-parameter ---which is a pair, â€œname : typeâ€.
This may make it easier later to transition to having multiple parameters.

When a PackageFormer such as the following is instantiated, say, to a typeclass
variation, we must erase the variation parameter and insert a new type parameter.
#+BEGIN_SRC agda
   PackageFormer Semigroup (v : Variation) : Set where â€¦
â†¦  record Semigroup (Carrier : Set) : Set  where â‹¯
#+END_SRC

#+RESULTS:
: <interactive>:5:1: error: parse error on input â€˜â†¦â€™

#+BEGIN_SRC emacs-lisp
;; The following only work on headers of PackageFormer declarations.

(defun erase-parameters (declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (existing-params) : Set â„“ whereâ€
   return
   â€œPackageFormer Semigroup : Set â„“ whereâ€
  "
  (s-collapse-whitespace ;; Convert all adjacent whitespace chars to a single space.
   (s-replace
      (car (s-match "(.*) : Set" declaration))
      ": Set"
      declaration))
)

(defun insert-parameter (param declaration)
  "Given a declaration of the form
   â€œPackageFormer Semigroup (existing-params) : Set â„“ whereâ€
   return
   â€œPackageFormer Semigroup (existing-params) â€˜paramâ€™ : Set â„“ whereâ€

   Precondition: â€˜paramâ€™ is a string.
  "
  (let ((rest-of-line (car (s-match ": Set.*" declaration))))
  (s-replace
      rest-of-line
      (concat param " " rest-of-line)
      declaration)
  )
)
#+END_SRC

#+RESULTS:
: insert-parameter

Let's test these out:
#+BEGIN_SRC emacs-lisp :exports both
(erase-parameters "PackageFormer Semigroup (v : Variation) (C : Set) : Set where")
#+END_SRC

#+RESULTS:
: PackageFormer Semigroup : Set where

# Notice the superfluous whitespace is /not/ collapsed for parameter insertion.
#+BEGIN_SRC emacs-lisp :exports both
(insert-parameter "(Carrier : Set)"
  (erase-parameters "PackageFormer Semigroup (v : Variation) : Set where"))
#+END_SRC

#+RESULTS:
: PackageFormer Semigroup (Carrier : Set) : Set where

A naturally expected property is if we obtain the variation symbol of a package former,
erase said parameter, then insert it; then we have essentially done nothing.
#+BEGIN_SRC emacs-lisp :exports both :results replace
(let* ((ex "PackageFormer Semigroup (ww : Variation) : Set where")
       (vd "(%ww : Variation)"))

  (and (equal "PackageFormer Semigroup : Set where" (erase-parameters ex))
       (equal ex (insert-parameter vd (erase-parameters ex))))
)
#+END_SRC

#+RESULTS:
  | nil |

Excellent ğŸ˜

* COMMENT footer

# Local Variables:
# eval: (visual-line-mode t)
# compile-command: (progn (org-babel-tangle) (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# End:
