:High_Priority:
+ Rename this paper to: gpce19_a_language_feature_to_unbundle_data_at_will.org
+ Move it into a papers/ directory.
+ Also make a proposal/ directory and move stuff there.
+ Ensure the same colouring for all variationals, else possibly confusion for
  readers!
+ [ ] Page 3, References: URLs and ISSNs are superfluous when a DOI is provided.
   [Ler00], [Nor07]: add DOIs if available (then remove the URLs).

    Please remove sentences/words that don't add new information:
   - The URLs in the bibliography.

+ The proposed idea is better motivated if the paper provides an example that library users come across in practice.
  Different variants of working with a vertex set in graph applications is a good example.
:End:

#+TITLE: A Language Feature to Unbundle Data at Will (Short Paper)
#+DESCRIPTION: Thesis proposal for Musa Al-hassy; McMaster University 2019.
#+AUTHOR: Musa Al-hassy, Jacques Carette, Wolfram Kahl
#+EMAIL: alhassy@gmail.com
#+OPTIONS: toc:nil d:nil title:t
#+PROPERTY: header-args :tangle no :comments link
#+TODO: TODO | OLD LaTeX README Remarks space

:summary:
In a language with dependent types, the same notion may be formalised several different ways. For instance, a monoid could be:

(1) a record with as fields (i) its carrier, (ii) a binary operation on the carrier, (iii) an identity element of the carrier, and (iv) associative, (v) left, and (vi) right identity laws;

(2) a record indexed on a carrier, with (ii)-(vi) as fields;

(3) a record indexed on a carrier, binary operation, and identity, with (iv)-(vi) as fields;

(4) a datatype of free monoids, with a binary operation and identity as constructors;

(5) a datatype of free monoids indexed on a type of variables, with an injection from the variables as an additional constructor.

In general, a record with N fields might have M interesting variations, requiring order of N*M lines of code. The paper presents a technique (implemented as Emacs macros) where one can write N+M lines, from which the N*M lines are generated.
:End:

* Remarks COMMENT on writing
# At the end of a section, explain why the section is there,
# and what the reader should take away from it.

# MA: LaTeX pads colons, :, with spacing.
# For inline typing annotations, use ghost colon ‚Äú\:‚Äù to avoid this issue.

# Drop the 'proposed'. Use positive, active language like

# YS.
# Maybe start with asking what is the message you want to deliver in this paper? What kind of
# bundling is bad and why is it so?

# (add-to-list 'org-latex-text-markup-alist '(code . verb))
# (add-to-list 'org-latex-text-markup-alist '(verbatim . verb))

:WK_Tips:

‚óà Re: abstract:
Paragraph 1: Background and identified problem
Paragraph 2: Contribution

‚óà After code blocks, and especially before one-line paragraphs between
code blocks, always put \noindent unless there is a strong reason not to.
Also consider doubling the code block indentation.

‚óà  PacakageFormer --> \textsf{\upshape PackageFormer}
    [Code is ALWAYS typeset as code,
     just like math is always typeset as math.]

:End:
:JC_Remarks:
‚óÜ Consider Finite State Machines, rather than graphs, so as to have a multi-sorted
  structure where the sorts do not ‚Äòdepend‚Äô on each other.

- The introduction needs to cover the *problem* that is being solved - and not the solution; that is not 100% clear below
- You need to save space for related work (can be a short paragraph, but without it, it'll get rejected)
- Where are the citations? There should be citations throughout!
:End:

* README COMMENT Dependencies of this org file

In the source blocks below, go into each one and press C-c C-c
to have it executed. Some ‚Äòresults‚Äô will be echoed into the buffer
if everything went well.

Rather than executing the following blocks each time you edit this file,
consider adding them to your Emacs [[https://alhassy.github.io/init/][configuration file]].

 + org-mode :: This particular markup is called org-mode.

     Let's obtain Org-mode along with the extras that allow us to ignore
     heading names, but still utilise their contents --e.g., such as a heading
     named ‚Äòpreamble‚Äô that contains org-mode setup for a file.
     #+begin_src emacs-lisp
;; first we get a handy-dandy package manager

(require 'package)
(setq package-archives '(("org"       . "https://orgmode.org/elpa/")
                         ("gnu"       . "https://elpa.gnu.org/packages/")
                         ("melpa"     . "https://melpa.org/packages/")
                         ("melpa-stable" . "https://stable.melpa.org/packages/")
                         ))
(package-initialize)

(package-refresh-contents)

(package-install 'use-package)
(require 'use-package)
(setq use-package-always-ensure t)

;; then we get the org-mode goodness

(use-package org
  :ensure org-plus-contrib
  :config
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines)))
#+end_src

     This lets us use the ~:ignore:~ tag on headlines you'd like to have ignored,
     while not ignoring their content --see [[https://emacs.stackexchange.com/a/17677/10352][here]].

     - Use the ~:noexport:~ tag to omit a headline /and/ its contents.

 + minted & bib :: Source blocks obtain colour.

     Execute the following for bib ref as well as minted
     Org-mode uses the Minted package for source code highlighting in PDF/LaTeX
     --which in turn requires the pygmentize system tool.
     #+BEGIN_SRC emacs-lisp
     (setq org-latex-listings 'minted
           org-latex-packages-alist '(("" "minted"))
           org-latex-pdf-process
           '("pdflatex -shell-escape -output-directory %o %f"
             ;; "biber %b"
             "bibtex %b"
             "pdflatex -shell-escape -output-directory %o %f"
             "pdflatex -shell-escape -output-directory %o %f")
     )
     #+END_SRC

     #+RESULTS:
     | pdflatex -shell-escape -output-directory %o %f | bibtex %b | pdflatex -shell-escape -output-directory %o %f | pdflatex -shell-escape -output-directory %o %f |

  # Enable the following to have small-font code blocks.
  # LATEX_HEADER: \RequirePackage{fancyvrb}
  # LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}

 + amart :: Enable acmart latex class.

   #+NAME: make-acmart-class
   #+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("acmart" "\\documentclass{acmart}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

 (message "acmart has been loaded")
 #+END_SRC

 #+RESULTS: make-acmart-class
 : acmart has been loaded

   The ‚Äòfooter‚Äô at the end of this file currently executes only this code block for you
   ---if you enable the local vars. You can easily tweak it to execute the other blocks,
   if you like.

 + org-ref :: [[https://github.com/jkitchin/org-ref][An exquisite system]] for handling references.

    If everything works, the following entity will display useful data
    when the mouse hovers over it (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà If you click on it, then you're
    in for a lot of super neat stuff, such as searching for the pdf online!

    cite:agda_overview

    #+BEGIN_SRC emacs-lisp
(use-package org-ref :demand t)

;; Files to look at when no ‚Äú‚ï≤bibliography{‚ãØ}‚Äù is not present in a file.
;; Most useful for non-LaTeX files.
(setq reftex-default-bibliography '("References.bib"))

(use-package helm-bibtex :demand t)
;; If you use helm-bibtex as the citation key completion method you should set these variables too.

(setq bibtex-completion-bibliography "References.bib")
#+END_SRC

#+RESULTS:
: References.bib

#+RESULTS:
: References.bib

  Execute ~M-x helm-bibtex~ and, say, enter ~agda~ and you will be presented with
  all the entries in the bib database that mention ‚Äòagda‚Äô. Super cool stuff.

* LaTeX setup                                                        :ignore:

  #+LATEX_CLASS: acmart
  #+latex_class_options: [sigplan,review]
  # latex_class_options: [sigplan,review,anonymous]
  # latex_class_options: [acmsmall,review,anonymous]

  # ACM uses the natbib package
  #
  # LATEX_HEADER: \settopmatter{printfolios=true,printccs=false,printacmref=false}

  # Visible editorial comments.
  #+LATEX_HEADER: \usepackage{edcomms}
  #+LATEX_HEADER: \edcommsfalse

  #+LATEX_HEADER: \acmYear{2019}
  #+LATEX_HEADER: \setcopyright{none}
  # LATEX_HEADER: \acmJournal{GPCE}
  # LATEX_HEADER: \acmVolume{1}
  # LATEX_HEADER: \acmNumber{GPCE}
  # LATEX_HEADER: \acmArticle{1}
  # LATEX_HEADER: \acmMonth{1}
  # LATEX_HEADER: \acmDOI{}

  # Dark green colour for links.
  #+LATEX_HEADER: \usepackage{color}
  #+LATEX_HEADER: \definecolor{darkgreen}{rgb}{0.0, 0.3, 0.1}
  #+LATEX_HEADER: \hypersetup{colorlinks,linkcolor=darkgreen,citecolor=darkgreen,urlcolor=darkgreen}

  #+LATEX_HEADER: \usepackage{CheatSheet/UnicodeSymbols}

  #+LATEX_HEADER: \DeclareMathOperator{\VCCompose}{\longrightarrow\hspace{-3ex}\oplus\;}
  #+LATEX_HEADER: \newunicodechar{‚ü¥}{\ensuremath{\VCCompose}}
  #+LATEX_HEADER: \newunicodechar{ùìã}{\ensuremath{v}}
  #+LATEX_HEADER: \newunicodechar{ùí±}{\ensuremath{\mathcal{V}}}
  #+LATEX_HEADER: \newunicodechar{Œ±}{\ensuremath{\alpha}}

  # ùëõùëéùëöùëí
  #+LATEX_HEADER: \newunicodechar{ùëõ}{\ensuremath{n}}
  #+LATEX_HEADER: \newunicodechar{ùëé}{\ensuremath{a}}
  #+LATEX_HEADER: \newunicodechar{ùëö}{\ensuremath{m}}
  #+LATEX_HEADER: \newunicodechar{ùëí}{\ensuremath{e}}

  #+LATEX_HEADER: \newunicodechar{‚Å∞}{\ensuremath{^0}}
  #+LATEX_HEADER: \newunicodechar{¬≥}{\ensuremath{^3}}

* Abstract :ignore:
#+begin_center
*Abstract*
#+end_center
#+begin_small

  # The eager commit to what data should be a type parameter or a record component
  # is a premature design decision. We demonstrate a language feature that circumvents
  # such over-specification.
  #
  # WK:  That's quite a mouthful and hard to parse. Perhaps establish some context first?

  # This is analogous to
  # which information is exposed dynamically at runtime and which is known statically,
  # respectively.

  Programming languages with sufficiently expressive type theories provide users with
  different means of data ‚Äòbundling‚Äô. Specifically one can choose to encode information
  in a record either as a parameter or a field, in dependently-typed languages such as
  Agda, Coq, Lean and Idris.
  For example, we can speak of graphs /over/ a particular vertex set, or speak
  of arbitrary graphs where the vertex set is a component.
  These create isomorphic types, but differ with respect to intended use.
  Traditionally, a library designer would make this choice (between parameters and fields);
  if a user wants a different variant, they are forced to build conversion utilities as well as
  duplicate functionality. For a graph data type,
  if a library only provides a Haskell-like typeclass view of graphs /over/ a vertex set,
  yet a user wishes to work with the category of graphs, they must now package a vertex
  set as a component in a record along with a graph over that set.

  We design and implement a language feature that allows both the library designer and
  the user to make the choice of information exposure only when necessary, and otherwise leave
  the distinguishing line between parameters and fields unspecified.
  Our language feature is currently implemented as a prototype meta-program
  incorporated into Agda's Emacs ecosystem, in a way that is unobtrusive to Agda users.
#+end_small

* Introduction --- Selecting the ‚Äòright‚Äô perspective

  :Ideas:
  Which perspective of semigroups does one select? Semigroupùíæ from the thesis proposal;
     the perspective considered should have legitimate uses rather than artificial ones.
     How do we write, e.g., ‚Äòconcat‚Äô in the various forms. What is the minimal reduplication required using
     existing techniques.
   :End:

  Library designers want to produce software components that are useful for
  the perceived needs of a variety of users and usage scenarios.  It is therefore
  natural for designers to aim for a high-level of generality, in the hopes of increased
  reusability. One such particular ``choice'' will occupy us here: When creating a
  record to bundle up certain information that ‚Äúnaturally‚Äù belongs together, what
  parts of that record should be /parameters/ and what parts should be
  /fields/? This is analogous to whether functions are curried and so arguments
  may be provided partially, or otherwise must be provided all-together in one tuple.

  The subtlety of what is a ‚Äòparameter‚Äô --- exposed at the type level --- and what is a
  ‚Äòfield‚Äô --- a component value --- has led to awkward formulations and
  the duplication of existing types for the sole purpose of different uses.

  :JC:
  \edcomm{JC}{Incorporate a little bit of the text of Tom Hales' critique of
  Lean, verbation and cite, here}

  MA: If you mean [[https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/][this review]], then you likely mean item 4 regarding the issues
  of Lean being its own metalanguage. However, this appears to be problematic
  due to limited man-power working on Lean: ‚Äúthe tools simply are not available‚Äù.
  Item 7 regarding ugly projection chains has already been addressed below, briefly,
  when mentioning flattening. Re item 9, Agda allows [simulated] diamonds.
  Re item 10, that's what's being addressed in this work.
  :End:

  # For example, the ubiquitous monoid, used to model compositionality,
  # in Haskell, is only allowed one instance per datatype. However, the Booleans,
  # for example, support multiple monoid instances such as sequential and parallel monoids
  # ---the former being conjunction with
  # identity /true/ and the latter being disjunction with identity /false/.
  For example, each Haskell typeclass can have only one instance per datatype;
  since there are several monoids with the datatype ~Bool~ as carrier,
  in particular those induced by conjunction and disjunction,
  the de-facto-standard libraries for Haskell
  define two isomorphic copies ~All~ and ~Any~ of ~Bool~,
  only for the purpose of being able to attach the respective monoid instances to them.

  But perhaps Haskell's type system does not give the programmer sufficient
  tools to adequately express such ideas. As such, for the rest of this paper
  we will illustrate our ideas in Agda cite:Norell-2007,agda_overview.
  For the monoid example,
  it seems that there are three contenders for the monoid interface:

  \newpage
  #+begin_src agda
  record Monoid‚ÇÄ : Set‚ÇÅ where
    field
      Carrier : Set
      _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
      Id      : Carrier
      assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
      leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
      rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x

  record Monoid‚ÇÅ (Carrier : Set) : Set where
    field
      _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
      Id      : Carrier
      assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
      leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
      rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x

  record Monoid‚ÇÇ
           (Carrier : Set)
           (_‚®æ_ : Carrier ‚Üí Carrier ‚Üí Carrier)
         : Set  where
    field
      Id      : Carrier
      assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
      leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
      rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x
  #+end_src

  \vspace{0.3em}\noindent
  In ~Monoid‚ÇÄ~, we will call ~Carrier~ ‚Äúbundled up‚Äù,
  while we call it ‚Äúexposed‚Äù in ~Monoid‚ÇÅ~ and ~Monoid‚ÇÇ~.
  The bundled-up version allows us to speak of /a/
  monoid, rather than /a monoid on a given type/ which is captured by ~Monoid‚ÇÅ~.
  While ~Monoid‚ÇÇ~ exposes both the carrier and the composition operation,
  we might in some situation be interested
  in exposing the identity element instead
  --- e.g., the discrepancy ‚Äò‚â¢‚Äô and indistinguishability ‚Äò‚â°‚Äô operations
  on the Booleans
  have the same identities as conjunction and disjunction, respectively.
  Moreover, there are other combinations of what is to be exposed and hidden,
  for applications that we might never think of.

  Rather than code with /interface formulations we think people will likely use/, it is far
  more general to /commit to no particular formulation/ and allow the user to select
  the form most convenient for their use-cases. This desire for reusability motivates
  a new language feature: The \textsf{\upshape PackageFormer}.

  Moreover, it is often the case that one begins working with a record of useful
  semantic data, but then, say, for proof automation, may want to use the associated
  datatype for syntax. For example, the syntax of closed monoid terms is formalised, using
  trees, as follows.
  #+begin_src agda
    data Monoid‚ÇÉ : Set where
      _‚®æ_ : Monoid‚ÇÉ ‚Üí Monoid‚ÇÉ ‚Üí Monoid‚ÇÉ
      Id  : Monoid‚ÇÉ
  #+end_src
  \noindent
  We can see that this version can also be
  mechanically obtained from ~Monoid‚ÇÄ~ by discarding ‚Äònon-simple‚Äô
  fields then turning the remaining fields into constructors.
  # That would necessitate yet another nearly identical data-structure
  # --- having constructors rather than field projections.

  We show how all these different
  presentations can be derived from a /single/
  \textsf{\upshape PackageFormer} declaration
  via a generative meta-program integrated into the
  most widely used Agda ``IDE'', the Emacs mode for Agda.
  In particular, a package of $N$ constituents with $M$
  presentations of bundling results in nearly $N √ó M$ lines of code,
  yet this quadratic count becomes linear $N + M$ by having a single
  package declaration of $N$ constituents with $M$ subsequent instantiations.
  It is this massive reduction in duplicated efforts and maintenance that we view
  as the main contribution of our work.

  :Remarks:
  To demonstrate the generality of the notion of package formers we shall demonstrate how other common forms could be ‚Äòderived‚Äô from the single declaration above. It is to be noted that for such a small example, such derived code may be taken for granted, however for much larger theories ‚Äîfor example, a ‚Äúfield‚Äù comes with more than 20 fields‚Äî the ability to derive different perspectives in a consistent fashion is indispens- able; especially when the package is refactored. More realistically, a symmetric rig groupoid uses about 212 coherence laws [rig_computation], for which case-splitting, to perform proofs, yields over 200 goals thereby making metaprogramming a tempting approach.
  :End:

* \textsf{\upshape PackageFormer}s --- Being non-committal as much as possible
  :Remarks:
  Unifying the different perspectives under the same banner. We speak in terms of elaborations,
     but may propose elementary typing rules or semantics. Discuss \textsf{\upshape PackageFormer} polymorphism, from ¬ß4 of thesis proposal.
     :End:

    # It is notoriously difficult to reconstruct the possible inputs to a function
    # that yielded a certain output.
    # That is, unless you are using Prolog of-course,
    # where the distinctions between input and output are an illusion
    # that is otherwise
    # made real only by how Prolog users treat arguments to a relation.
    # Dependently-typed programming at its core is the adamant hygienic blurring of
    # concepts
    # --- namely, types are terms \cite{types_overview} ---
    # and so the previous presentations of monoids are unified in the following
    # single declaration which does not distinguish between parameters and fields.
    #
    We claim that the previous monoid-related pieces of Agda code
    can all be unified as a single declaration
    which does not distinguish between parameters and fields,
    where ~PackageFormer~ is a keyword with similar syntax as ~record~:

      #+begin_src agda
  PackageFormer MonoidP : Set‚ÇÅ where
    Carrier : Set
     _‚®æ_    : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x} ‚Üí x ‚®æ Id ‚â° x
  #+end_src

  \noindent

  # #+BEGIN_EXPORT latex
  # \emph{One uses a \textsf{\upshape PackageFormer} by instantiating the particular presentation that is desired.}
  # #+END_EXPORT

    # Superficially, the parameters and fields have been flattened into a single location
  Coupled with various directives that let one declare
  what should be parameters and what should be fields,
  we can reproduce the above presentations.
  A package former is used via /instantiations/, written as low-precedence
 juxtapositions of a package former name and expression of type
 ~Variational~.
 The latter can be built in particular via the following:
    #+begin_src agda
id          :  Variational
record      :  Variational
typeclass   :  Variational
termtype    :  Variational
unbundled   :  ‚Ñï ‚Üí Variational
exposing    :  List Name ‚Üí Variational
_‚ü¥_        :  Variational ‚Üí Variational ‚Üí Variational
#+end_src
#                           -- Syntax as for using
# # JC proposes ~termlanguage~ for ~termtype~
\noindent
 The variationals ~unbundled~ and ~exposing~ have arguments.
 While\linebreak ~exposing~ explicitly lists the names that should be turned
 into parameters, in that sequence, ‚Äú ~unbundled~ $n$'' exposes the
 first $n$ names declared in the package former.

 An instantiation juxtaposition is written ~PF ùìã~ to indicate that the PackageFormer
 named ~PF~ is to be restructred according to scheme ~ùìã~. A /composition/ of variationals
 is denoted using the symbol ‚Äò‚ü¥‚Äô; for example,
 ~PF ùìã‚ÇÅ ‚ü¥ ùìã‚ÇÇ ‚ü¥ ‚ãØ ‚ü¥ ùìã‚Çô~ denotes the forward-composition of iterated instantiations,
 namely\linebreak ((~(PF ùìã‚ÇÅ) ùìã‚ÇÇ) ‚ãØ) ùìã‚Çô~, since we take prefix instantiation application
to have lower precedence that variational composition.
 In particular, an empty composition is the identity
 scheme, which performs no alteration, and has the explicit name ~id~.
 \linebreak
 Since ~PF id ‚âà PF~ and ~id~ is the identity of composition, we may
 write any /instantiation/ as a sequence of ‚ü¥-separated clauses:
~PF ‚ü¥ ùìã‚ÇÅ ‚ü¥ ùìã‚ÇÇ ‚ü¥ ‚ãØ ‚ü¥ ùìã‚Çô~ ---which is equivalent to \linebreak
~PF ((((id ‚ü¥ ùìã‚ÇÅ) ‚ü¥ ùìã‚ÇÇ) ‚ãØ)) ùìã‚Çô)~.

  The previous presentations can be obtained as follows.

  0. [@0] To make ~Monoid‚ÇÄ‚Ä≤~ the type of /arbitrary monoids/
   (that is, with arbitrary carrier), we declare:
        \vspace{0.3em}
   #+begin_src agda
 Monoid‚ÇÄ‚Ä≤  = MonoidP record
#+end_src

  1. [@1] We may obtain the previous formulation of
     ~Monoid‚ÇÅ~ as follows:
        \vspace{0.3em}
   # # -- WK: typeclass was not shown
   # # Monoid‚ÇÅ‚Ä≤  = MonoidP typeclass
   # # Monoid‚ÇÅ‚Ä≥ = MonoidP record exposing (Carrier)
   #+begin_src agda
 Monoid‚ÇÅ‚Ä≤  = MonoidP record ‚ü¥ exposing (Carrier)
 Monoid‚ÇÅ‚Ä≥ = MonoidP record ‚ü¥ unbundled 1
#+end_src
# ##  This also
# ##  Haskell2010-style (single-parameter) type classes then correspond to
# ##  ~_unbundled 1, and so we define
# ##    #+begin_src agda
# ##  MonmoidClass = MonoidP typeclass unbundled 1
# ## #+end_src
# ## WK: ?

# #    \vspace{0.3em}

  2. [@2] As for ~Monoid‚ÇÅ~, there are also different ways
     to regain the previous formulation of ~Monoid‚ÇÇ~.
        \vspace{0.3em}
    #+begin_src agda
 Monoid‚ÇÇ‚Ä≤  = MonoidP record ‚ü¥ unbundled 2
 Monoid‚ÇÇ‚Ä≥ = MonoidP
              record ‚ü¥ exposing (Carrier; _‚®æ_)
#+end_src

      \vspace{0.3em}

# # Our precedence rules indicate that ~MonoidP ‚ãØ~ parenthesises
# # as if it were ~MonoidP (‚ãØ)~.
# # Moreover, notice that the infix combinators for unbundling and exposing,
# # behave similar to the curry functional $(A √ó B ‚Üí C) \;‚Üí\; (A ‚Üí B ‚Üí C)$.
# #
# #   2. [@2] To speak of /a monoid over an arbitrary carrier/, we declare:
# #         \vspace{0.3em}
# #    #+begin_src agda
# #  Monoid‚ÇÉ = MonoidP record
# # #+end_src
# #    \vspace{0.3em}
# #    \noindent
# #    It behaves as if it were declared thusly:
# #    \vspace{0.3em}
# #    \noindent
# #    #+begin_src agda
# #     record Monoid‚ÇÉ : Set‚ÇÅ where
# #       field
# #         Carrier : Set
# #         _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
# #         Id      : Carrier
# #         ‚ãØ
# # #+end_src
# #
# #   The name ~Carrier~ is a default and could be renamed; likewise for ~Vars~ below.

  3. [@3] Finally, we mentioned metaprogramming's need to work with terms:
        \vspace{0.3em}
    #+begin_src agda
 Monoid‚ÇÉ‚Ä≤ = MonoidP termtype :carrier "Carrier"
#+end_src
    \vspace{0.3em}
   \noindent
   Our main example is the theory of monoids, which are single-sorted.
   However, a general PackageFormer may have multiple sorts ---as is the case with
   graphs--- and so one of the possibly many sorts needs to be designated as the
   universe of discourse, or carrier, of the resulting inductively defined term type.
   This is accomplished with the ~:carrier~ argument.

   \vspace{0.3em}
   \noindent
   Of course we may want to have terms /over/ a particular variable set, and so declare:
   \vspace{0.3em}
     #+begin_src agda
 Monoid‚ÇÑ = MonoidP termtype-with-variables
              :carrier "Carrier"
#+end_src
    \vspace{0.3em}
    \noindent
    Since a parameter's name does not matter, due to Œ±-equivalence, an arbitrary,
    albeit unique, name for the variable set is introduced along with an embedding
    function from it to the resulting term type. For brevity, the embedding function's
    name is ~inj~ and the user must ensure there is no name-clash.
    The resulting elaboration essentially is as follows.
       \vspace{0.3em}
       \noindent
    #+begin_src agda
    data Monoid‚ÇÑ (Vars : Set) : Set where
      inj : Vars ‚Üí Monoid‚ÇÑ Vars
      _‚®æ_  : Monoid‚ÇÑ Vars
           ‚Üí Monoid‚ÇÑ Vars ‚Üí Monoid‚ÇÑ Vars
      Id  : Monoid‚ÇÑ Vars
  #+end_src

     \vspace{0.3em}
     \noindent
     Note that only ‚Äòfunctional‚Äô symbols have been exposed in these
     instantiations;
     no ‚Äòproof-matter‚Äô such as the associativity consistent declared
     in ~MonoidP~.

# ##  WK: Try it:
# ##       #+begin_src agda
# ##   MonoidTermPropEqu = MonoidP equality where termtype = Monoid‚ÇÖ
# ##  #+end_src
# ##
# ##      #+begin_src agda
# ##      data MonoidTermPropEqu (Vars : Set) : Set where
# ##        eqVars : {v w : Vars}  ‚Üí v ‚â° w ‚Üí inj v ‚â° inj w
# ##        ...
# ##    #+end_src
# ##
# ##       #+begin_src agda
# ##   MonoidTermSetoid = MonoidP termSetoid where termtype = Monoid‚ÇÖ
# ##  #+end_src
# ##
# ##      #+begin_src agda
# ##      module _ {v e : Level} (Vars : Setoid v e) where
# ##        open SetoidV Vars
# ##        data _‚âàT_ : Monoid‚ÇÖ CarrierV ‚Üí Monoid‚ÇÖ CarrierV  ‚Üí Set (v \sqcup e) where
# ##          eqVars : {v w : Vars}  ‚Üí v ‚âàV w ‚Üí inj v ‚âàT inj w
# ##          ...
# ##        MonoidTermSetoid : Setoid v e
# ##        MonoidTermSetoid = record { ... }
# ##    #+end_src
# ##

# #  There are of-course a number of variations on how a package is to be presented;
# #  we have only mentioned two for brevity. The interested reader may consult
# #  the ‚Äònext 700 module systems‚Äô proposal \cite{alhassy_thesis_proposal};
# #  which discusses more variations and examples in detail.
  #+begin_export latex
  \edcomm{JC}{I would
instead, especially as you have the room, insert a paragraph naming the
additional things that can be done.}
#+end_export

  For brevity, we have only discussed product representations of packages, however
  the language feature also supports elaborations into nested dependent-sums
  as in the case where we may have a coherent substructure.
  Alongside ~_unbundled_~, we also have infix combinators for extending an
  instantiation with additional fields or constructors, and the renaming of constituents
  according to a user provided String-to-String function.
  Moreover, just as syntactic datatype declarations may be derived, we also
  allow support for the derivation of induction principles and structure-preserving homomorphism types.
  Our envisioned system would be able to derive simple, tedious, uninteresting concepts; leaving difficult,
  interesting, ones for humans to solve.

  :Remarks:
  0. Besides syntax, induction principles are also derived:

  2. The ability to extend an instantiation with additional new fields or constructors.

     - Since typeclass declarations provide type-level functions, these can be
       pre-composed with functions that alter their inputs.
       E.g., ~MonoidP typeclass~ is a parmeterised type which is a function of types,
       so, for example, ~MonoidP typeclass ‚àò List~ is the same but the carrier is now
       lists over the provide parameter.

       - Likewise we provide support for a constraint upon the parameter:
         MonoidP typeclass using constraint
         reduces
         MonoidP typeclass field constraint : ...

         nice.

  1. Records, Haskell-style typeclasses,
     nested dependent sums with the carrier declared or existentially quantified,
     sums: Disjoint collection of declarations where each declaration is itself
     a dependet sum consistong of the context necessayr toensure that the consitnutets
     are well-typed.

     There are obvious isomorphisms and these should be guarentted.

  4. The ability to apply a string-to-string function to alter the names of constiuents
     ‚Äòdecorated‚Äô.

  5. Derive homomorphisms, strucutre preserving operations.

  6. Support multiple defaults.

  3. Constitients of package formers give rise to functions ---e.g., by replacing the
     PackageFormer name with a new fresh variable. See ùíØ, page 42, of thesis-proposal.

     In turn, this can be used to produce simple, tedious, induction principles. See (0) above.

  4. This is particularly useful when one wants to extract such constieunte types for re-use elsewhere.
  :End:

  #+begin_quote
  *Quadratic to Linear:*
  Notice that the previous 4 monoid presentations, ~Monoid·µ¢~, had at least 2 constituents each
  totalling more than 4 √ó 2 = 16 lines of user input. However, using ~MonoidP~, above
  we have obtained the same presentations, ~Monoid·µ¢‚Ä≤~, using one definition having
  at least 2 lines and 4 single-line declarations, for a total of at least 4 + 2 = 8
  lines of user input.
  #+end_quote

  The PackageFormer declarations are not legal Agda syntax and as such appear in dedicated comments.
  The comments are read by Emacs Lisp and legitimate Agda is produced in a generated file, which is
  then automatically imported into the current file.
  Currently, the user enters commands into special comments from which legitimate Agda
  is produced in an auxiliary file ---examples are provided in an appendix.
  The generated file never needs to be consulted,
  as the declared names are furnished with tooltips rendering the elaborated, legitimate,
  Agda form. Moreover, we also provide a feature to extract a ‚Äòbare bones‚Äô version
  of a file that strips out all PackageFormer annotations, leaving only legitimate Agda
  as well as the import to the generated file. Finally, since the elaborations are
  legitimate Agda, one only needs to utilise the system once and future users are
  not forced to know about it.

  The \textsf{\upshape PackageFormer} language feature unifies disparate representations of the
  same concept under a single banner. How does one actually /do/ anything with
  these entities? Are we forced to code along particular instantiations?
  No; unless we desire to do so.

* \textsf{\upshape Variational} Polymorphism
# # A New Kind of Polymorphism

  Suppose we want to produce the function ~concat~, which composes the elements of a list
  according to a compositionality scheme --- examples of this include summing over
  a list, multiplication over a list, checking all items in a list are true, or
  at least one item in the list is true.
  Depending on the selected instantiation,
  the resulting function may have types such as the following:

  \vspace{1em}
#+BEGIN_SRC agda
  concat‚ÇÄ : {M : Monoid‚ÇÄ}
          ‚Üí let C = Monoid‚ÇÄ.Carrier M
             in  List C ‚Üí C

  concat‚ÇÅ : {C : Set} {M : Monoid‚ÇÅ C} ‚Üí List C ‚Üí C

  concat‚ÇÇ : {C : Set} {_‚®æ_ : C ‚Üí C‚Üí C}
            {M : Monoid‚ÇÇ C _‚®æ_} ‚Üí List C ‚Üí C

  concat‚ÇÉ : List Monoid‚ÇÉ ‚Üí Monoid‚ÇÉ
#+END_SRC
  \vspace{1em}

  \noindent
  An attempt to unify these declarations is trivial
  ---provided the variationals are already defined---
  as one merely appends the aforementioned PackageFormer definition with a new
  declaration that, unlike the rest, comes equipped with an /equation/.
    \vspace{0.3em}
#+BEGIN_SRC agda
    concat : List Carrier ‚Üí Carrier
    concat = foldr _‚®æ_ Id
#+END_SRC

  The real magic is the variationals. We have alluded that the type of variationals
  is extensible and this is achieved by having
  ~Variational ‚âÖ (PackageFormer ‚Üí PackageFormer)~.
  Indeed, our implementation relies on 5 meta-primitives to form arbitrary
  and complex schemes to transforming abstract PackageFormers into
  other grouping mechanisms. The meta-primitives were arrived at by codifying
  a number of structuring mechanisms directly then carefully extracting the minimal
  ingredients that enable them to be well-defined.
  This approach is reminiscent to that of Haskell's typeclasses.

  The details of the implementation and numerous common structuring mechanisms
  derived from the meta-primitives can be found on the prototype's homepage:
  #+begin_center org
  https://alhassy.github.io/next-700-module-systems-proposal/prototype/PackageFormer.html
  #+end_center

  \vspace{0.3em}
  \noindent
  It is important at this juncture to observe that the type of ~concatP~
  depends crucially on the variational that is invoked.

  # No longer true.
  #
  # This is a prime reason for using a dependently-typed language as the
  # setting for the \textsf{\upshape PackageFormer} feature.

* Next Steps
  :Remarks:
  Ignoring the implementation, there are no sound semantics for these constructs.
     Discuss theory presentation combinators and possible extensions.
  :End:

  We have outlined a new unifying language feature that is intended to massively reduce
  duplicated efforts involving different perspectives of datatypes. Moreover, to make
  this tractable we have also provided a novel form of polymorphism and demonstrated
  it with minimal examples.

  # We have implemented a meta-program that realises these
  # elaborations in an unobtrusive
  # fashion: An Agda programmer simply declares them in special comments.
  # The resulting ‚Äòeditor tactic‚Äô demonstrates
  # that this language feature is promising.
  We have implemented this as an ‚Äúeditor tactic'' meta-program.
  In actual use, an Agda programmer declares what they want
  using the combinators above (inside special Agda code comments),
  and these are then elaborated into Agda code.

  # Thus far we have relied on the reader's understanding of functional programming and
  # algebraic data types to provide an informal and indirect semantics by means of
  # elaborations into existing notions. An immediate next step would be to provide
  # explicit semantics for \textsf{\upshape PackageFormer}'s within a minimal type theory.
  We have presented our work indirectly by using examples, which we
  hope are sufficiently clear to indicate our intent. We next intend to
  provide explicit (elaboration) semantics for ~PackageFormer~ within a
  minimal type theory; cite:types_for_modules.

  Moreover there are a number of auxiliary goals, including:

  1. Explain how generative modules cite:modular_modules
     are supported by this scheme.

  3. How do multiple default, or optional, clauses for a constituent fit into this
     language feature.
     # This may necessitate a form of limited subtyping.

  4. Explore inheritance, coercion, and transport along canonical isomorphisms.

  However, the features of the existing prototype more than make up for the
  system's shortcoming. The features list currently include:

  + Extensible ::
     Users may extend the collection of variationals by providing the intended
     elaboration scheme.

     We have provided a number of auxiliary, derived, combinators
     that can be used to construct complex and common schemes.
     In doubt, the user has full and direct access to the entirety of Emacs Lisp
     as a programming language for restructuring PackageFormers into any desired shape
     ---the well-formedness of which is a matter the user must then worry about.

  + Practical :: The user manual demonstrates how boilerplate code for
                 renamings, hidings, decorations, and generations
     of hierarchical structures can be formed;
     cite:tpc.

  + Pragmatic :: The prototype comes equipped with a number of menus
                  to display the abstract PackageFormer's defined,
                  as well as the variationals defined, and one may
                  enable highlighting for these syntactical items, have
                  folded away, or simply extract an Agda file that does not mention
                  them at all.

                  Moreover, it can be tedious to consult generated code for high-level
                  PackageFormer instantiations and so every variational and PackageFormer
                  is tagged with tooltips providing relevant information.

  \noindent
  Finally, the careful reader will have noticed
  that our abstract mentions graphs, yet
  there was no further discussion on that example.
  We have avoided it for simplicity only.
  The prototype accommodates multi-sorted structures where
  sorts may /depend/ on one another, as edge-sets
  depend on the vertex-set chosen. Examples can be found on the prototype's
  webpage.

  # There are many routes to progress on this fruitful endeavour.
  # However, a prototype capable of supporting the examples mentioned
  # can be found at
  # \newline
  # https://alhassy.github.io/next-700-module-systems-proposal/.
  :Double_blind:
  We have a complete
  prototype available on github, which we will link to once the paper is
  no longer double-blind.
  :End:

  # We look forward to this feature reducing the length of our code
  # and alleviating us of tedious boilerplate constructions.

  This short paper has proposed a unifying language feature that enables users to selectively
  choose how information is to be organised, such as which parts are exposed as parameters,
  thereby reducing duplicated efforts involving different perspectives of datatypes.
  To demonstrate that the proposed feature is promising,
  we have implemented a meta-program to generate Agda using special code comments
  that specify how package elements are to be organised, such as their selective exposure
  as parameters which is a common issue with libraries in dependently-typed languages.

  As a prototype witnessing that a generic packaging formalism is possible, our variationals
  cannot yet be directly defined in Agda. Instead, we are making use of Emacs Lisp, a language
  close to the Agda ecosystem. Going forward, one of the aims of our work is to have variationals
  definable directly within Agda ---rather than having our users learn yet another language.
  Our exploratory efforts suggest that we may be able to realise PackageFormer's as Agda records
  of ‚Äòelements‚Äô ---a tuple of qualifier, name, type, and definitional clauses---
  and, so, the result is a conservative extension to Agda's underlying type theory.
  However, from a practical standpoint, it is highly likely that we will extend Agda to support
  the new syntax.

  #+begin_quote org
  /Structuring schemes tend to be easy to explain, yet the benefit of our/
  /system is that it transports them from design patterns to full-fledged/
  /library methods./
  #+end_quote
  # Consequently, one needn't worry about manually implementing
  # a scheme, possibly with errors, only to later decide a different one is needed
  # and has to start all over again.
  # Instead, the scheme is automatically produced
  # and explicitly documented to further users
  # ---a notable example from the prototype's webpage: One may simply say a homomorphism
  # type is required for a PackageFormer, rather than spelling-out the mundane and
  # uninsightful definition.

* Bib                                                                :ignore:

 #+latex: \bibliography{References}
 #+latex: \bibliographystyle{plainnat}

* space 2 √ó \newpage                                                 :ignore:
   \newpage
   #+latex: {\color{white}.}
   \newpage
* Appendix: Source code

  Below is a nearly self-contained source sample for the presented fragments.
  We have omitted some variational definitions, using ~‚ãØ~, since they
  offer little insight but their definitions may be involved.

  \vspace{0.3em}
  _Module Header_
  #+begin_tiny org
  #+BEGIN_SRC agda
open import Relation.Binary.PropositionalEquality using (_‚â°_)
open import Data.List hiding (concat)
module Paper0 where
{- Automatically generated & inserted by the prototype -}
open import Paper0_Generated
#+END_SRC
#+end_tiny

_Plain ~MonoidP~ PackageFormer_
#+BEGIN_SRC agda
{-700
PackageFormer MonoidP : Set‚ÇÅ where
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí x ‚®æ Id ‚â° x
-}
#+END_SRC

_The ~record~ variational and three instantiations_
#+BEGIN_SRC agda
{-700
ùí±-record = :kind record :waist-strings ("field")

Monoid‚ÇÄ‚Ä≤  = MonoidP record
Monoid‚ÇÅ‚Ä≥ = MonoidP record ‚ü¥ :waist 1
Monoid‚ÇÇ‚Ä≥ = MonoidP record ‚ü¥ :waist 2
-}
#+END_SRC
In the paper proper we mentioned ‚Äúunbundled‚Äù, which in the prototype
takes the form of the meta-primitive ~:waist~.

\vspace{0.3em}
_Complex variationals in ~lisp~ blocks_
#+begin_small org
#+BEGIN_SRC agda
{-lisp
(ùí± termtype carrier
  = "Reify as parameterless Agda ‚Äúdata‚Äù type.

     CARRIER refers to the sort that is designated as the
     domain of discourse of the resulting single-sorted
     inductive term data type.
    "
    :kind data
    :level dec
    :alter-elements (lambda (fs)
      (thread-last fs
        (--filter (s-contains? carrier (target (get-type it))))
        (--map (map-type (s-replace carrier $ùëõùëéùëöùëí type) it)))))

(ùí± termtype-with-variables carrier = ‚ãØ) -}

{-700
Monoid‚ÇÉ‚Ä≤ = MonoidP termtype :carrier "Carrier"
Monoid‚ÇÑ  = MonoidP termtype-with-variables :carrier "Carrier"
-}
#+END_SRC
#+end_small

_PackageFormers with Equations_
#+BEGIN_SRC agda
{-700
PackageFormer MonoidPE : Set‚ÇÅ where
    -- A few declarations
    Carrier : Set
    _‚®æ_     : Carrier ‚Üí Carrier ‚Üí Carrier
    Id      : Carrier
    assoc   : ‚àÄ {x y z} ‚Üí (x ‚®æ y) ‚®æ z ‚â° x ‚®æ (y ‚®æ z)

    -- A few declarations with equations
    Rid : Carrier ‚Üí Carrier
    Rid x = x ‚®æ Id
    concat : List Carrier ‚Üí Carrier
    concat = foldr _‚®æ_ Id

    -- More declarations
    leftId  : ‚àÄ {x : Carrier} ‚Üí Id ‚®æ x ‚â° x
    rightId : ‚àÄ {x : Carrier} ‚Üí Rid x ‚â° x
-}
#+END_SRC

_concat‚ÇÄ_
#+BEGIN_SRC agda
{-lisp
(ùí± record‚Çë
  = "Record variation with support for equations."
    ‚ãØ)

(ùí± decorated  by  = ‚ãØ) -}

{-700
Monoid‚Å∞ = MonoidPE decorated :by "‚Å∞" ‚ü¥ record‚Çë
-}

{- ‚ÄúConcatenation over an arbitrary monoid‚Äù -}
concat‚ÇÄ : {M : Monoid‚Å∞}
         ‚Üí let C = Monoid‚Å∞.Carrier‚Å∞ M
           in List C ‚Üí C
concat‚ÇÄ {M} = Monoid‚Å∞.concat‚Å∞ M
#+END_SRC

\vspace{0.3em}
_concat‚ÇÉ_
#+BEGIN_SRC agda
{-lisp
(ùí± termtype‚Çë carrier = ‚ãØ) -}

{-700
Monoid¬≥ = MonoidPE ‚ü¥ decorated :by "¬≥"
                   ‚ü¥ termtype‚Çë :carrier "Carrier¬≥"
-}

{- Concatenation over an arbitrary *closed* monoid term -}
concat‚ÇÉ : let C = Monoid¬≥
          in List C ‚Üí C
concat‚ÇÉ = concat¬≥
#+END_SRC

* OLD COMMENT other ideas

What about some context at the beginning of the first paragraph?

What does the term bundling refer to, bundling of what? and what kind of data exposure is a problem?
Suggestion (just an example of sth you can do), mention a record type (or something else) as a way of bundling, and explain that data exposure means what fields are exposed. I believe that is what you mean with type and value levels?

  ----other ideas----

  # We design and implement a language feature that allows both the library designer and user to make this choice as necessary.

  # True, but relevant?
  The more information known statically, the less arbitrary choices that need to be performed
  by inspecting data at runtime ---e.g., what to do when list elements, say in Java, differ
  or when list lengths, say in Haskell, differ when computing a dot product.
  However, it is not clear how much information exposure is ideal.

  For example, more exposure at the parameter or type-index level enforces too many constraints
  ---as in considering graphs /over/ a particular vertex set versus the type of graphs over an arbitrary
  vertex set. It thus appears that the context dictates which level of exposure is most appropriate.
  #
  # This definitely belongs in your abstract, but needs to be attached to something more concrete.
  #
  The traditional approach is to reduplicate utility functions or provide conversions between the few supported
  perspectives.
  Our proposed language feature will allow the library designer, and user, to make this choice only when necessary
  and otherwise leave the ‚Äòbelt line‚Äô between parameters and fields unspecified.

  To demonstrate the practicality of this feature, we have produced a prototype for the Agda language.
  After loading it, Agda users may employ special comments from which legitimate Agda code is automatically generated
  as users step-wise program.

** COMMENT OLD Abstract                                              :ignore:
   :PROPERTIES:
   :CUSTOM_ID: abstract
   :END:

 # Use:  x vs.{{{null}}} ys
 # This informs LaTeX not to put the normal space necessary after a period.
 #
 #+MACRO: null  @@latex:\null{}@@

 #+begin_center
 *Abstract*
 #+end_center
 #+begin_small
   Programming languages with sufficiently expressive type theories provide users with essentially two
   levels of data ‚Äòbundling‚Äô. One may expose important constituents at the type level or have them
   hidden at the value level. Alternatively put, which information is exposed dynamically at runtime and which is known
   statically. Rather than force a user to commit to a choice, we propose a language feature that allows such
   choices to be determined whenever is convenient for the task at hand.

   The more information known statically, the less arbitrary choices that need to be performed
   by inspecting data at runtime ---e.g., what to do when list elements, say in Java, differ
   or when list lengths, say in Haskell, differ when computing a dot product.
   However, it is not clear how much information exposure is ideal.
   For example, more exposure at the parameter or type-index level enforces too many constraints
   ---as in considering graphs /over/ a particular vertex set versus the type of graphs over an arbitrary
   vertex set. It thus appears that the context dictates which level of exposure is most appropriate.
   The traditional approach is to duplicate utility functions or provide conversions between the few supported
   perspectives.
   Our proposed language feature will allow the library designer, and user, to make this choice only when necessary
   and otherwise leave the ‚Äòbelt line‚Äô between parameters and fields unspecified.

   To demonstrate the practicality of this feature, we have produced a prototype for the Agda language.
   After loading it, Agda users may employ special comments from which legitimate Agda code is automatically generated
   as users step-wise program.
 #+end_small
 # \newpage
 # \thispagestyle{empty}
 # \tableofcontents
 # \newpage

** COMMENT OLD Introduction

   Programming languages with sufficiently expressive type theories provide users with essentially two
   levels of data ‚Äòbundling‚Äô. One may expose important constituents at the type level or have them
   hidden at the value level. Alternatively put, which information is exposed dynamically at runtime and which is known
   statically. Rather than force a user to commit to a choice, we propose a language feature that allows such
   choices to be determined whenever is convenient for the task at hand.

   For example, consider the dot-product $\Sigma_{i = 0}^n x_i \cdot y_i$ operation.
   It is unreasonable to have this as an operation of $2 \cdot n$ many numbers, instead of such a primitive type
   we may utilise the richer structure of vectors. Now what is the type of a vector ---is it ~Vec ‚Ñù n, Vec ‚Ñù,~ or just ~Vec~?
   That is, how much information is exposed at the type level and how much is hidden at the component value level.
   In the programming setting, nullary ~Vec~ may correspond to lists whose type is only known at runtime,
   whereas ~Vec ‚Ñù~ corresponds to lists of real numbers yet  the list length is known as run time, whereas
   ~Vec ‚Ñù n~ corresponds to lists of real numbers where the list length is statically known to be ~n~.

   Languages without sufficient support for polymorphism, such as old versions of Java, can only provide the nullary
   ~Vec~ form. The check that all the constituents are of the same type transpires at runtime, which necessities a decision
   of what is done when elements differ ---throwing an exception is common.
   In contrast, languages with elegant polymorphism support, such as Haskell, would have the element type pre-determined
   leaving the choice of what to do when vector lengths differ ---ignoring extra elements is common.
   Yet in dependently-typed languages, such as Agda, one can select either format or, better yet, have the length information
   at the type level. /The more information known statically, the less arbitrary choices that need to be performed./

   However, it is not clear how much information exposure is ideal.
   For example, when the type of elements is exposed we can easily form the dot-product
   and it would be awkward to phrase it otherwise. Perhaps a demonstration will clarify this further.
   {{{code(Typing the dot-product using different vector perspectives)}}}
   #+BEGIN_SRC agda
  data Vec (carrier : Set) (length : ‚Ñï) : Set where
    []  : Vec carrier 0
    _‚à∑_ : ‚àÄ {length : ‚Ñï}
      ‚Üí carrier ‚Üí Vec carrier length ‚Üí Vec carrier (length + 1)

  record Vec‚Ä≤ (carrier : Set)  : Set (‚Ñìsuc ‚Ñìzero) where
    field
      length   : ‚Ñï
      elements : Vec carrier length

  record Vec‚Ä≥ : Set (‚Ñìsuc ‚Ñìzero) where
    field
      carrier  : Set
      length   : ‚Ñï
      elements : Vec carrier length

   dot : ‚àÄ {n} (xs ys : Vec ‚Ñù n) ‚Üí ‚Ñù
   dot = ‚ãØ

   dot‚Ä≤ : (xs ys : Vec‚Ä≤ ‚Ñù) ‚Üí length xs ‚â° length ys ‚Üí ‚Ñù
   dot‚Ä≤ = ‚ãØ

   dot‚Ä≥ : (xs ys : Vec‚Ä≥)	‚Üí carrier xs ‚â° ‚Ñù  ‚Üí carrier ys ‚â° ‚Ñù
    ‚Üí length xs ‚â° length ys ‚Üí ‚Ñù
   dot‚Ä≥ = ‚ãØ
   #+END_SRC
   The more exposed data, the easier it is to type the dot-product.
   However, more exposure is not always ideal. For example, suppose we are interested
   is discussing the ubiquitous category ~ListSet~ whose objects are lists over some carrier set
   and whose morphisms are functions between the carrier sets. The type of objects cannot be
   ~Vec~ nor ~Vec‚Ä≤~ since they /enforce too many constraints/, instead it must be ~Vec‚Ä≥~.
   Hence, there is not best choice but it is contextual use that determines which presentation
   is most fitting. Are we then forced to re-duplicate the ~dot~ code for each level of exposure?
   Our proposed language feature suggests otherwise: /Write once, obtain many!/

   Interestingly, we can go so far as to form ~Vec ‚Ñù n xs~ to be the type consisting of a single formal value
   when ~xs~ is a list /and/ its constituents are of type ‚Ñù /and/ the list length is ~n~; and to have no value otherwise.
   This is, for nearly all uses, overkill; yet it begs the question /where is the line between parameters and component fields?/
   Traditionally, a library designer would make this choice and may provide views for the other perspectives.
   Our proposed language feature will allow the library designer, and user, to make this choice only when necessary
   and otherwise leave the ‚Äòbelt line‚Äô between parameters and fields unspecified.

   To demonstrate the practicality of this feature, we have produced a prototype for the Agda language.
   After loading it, Agda users may employ special comments from which legitimate Agda code is automatically generated
   as users step-wise program.

* COMMENT footer                                                     :ignore:

(shell-command "cp Paper0.pdf GPCE_19_Alhassy_Carette_Kahl.pdf")

# Local Variables:
# eval: (progn (org-babel-goto-named-src-block "make-acmart-class") (org-babel-execute-src-block))
# compile-command: (progn (org-babel-tangle) (org-latex-export-to-pdf) (async-shell-command "open Paper0.pdf"))
# End:
