:High_Priority:
+ Rename this paper to: gpce19_a_language_feature_to_unbundle_data_at_will.org
+ Move it into a papers/ directory.
+ Also make a proposal/ directory and move stuff there.
+ Ensure the same colouring for all variationals, else possibly confusion for
  readers!

+ The proposed idea is better motivated if the paper provides an example that library users come across in practice.
  Different variants of working with a vertex set in graph applications is a good example.
:End:
:WK_concerns:
# -- WK: typeclass was not shown
-   # # Monoid₁′  = MonoidP typeclass
-   # # Monoid₁″ = MonoidP record exposing (Carrier)

   ##  This also
-# ##  Haskell2010-style (single-parameter) type classes then correspond to
-# ##  ~_unbundled 1, and so we define
-# ##    #+begin_src agda
-# ##  MonmoidClass = MonoidP typeclass unbundled 1
-# ## #+end_src
-# ## WK: ?
:End:

#+TITLE: A Language Feature to Unbundle Data at Will (Short Paper)
#+DESCRIPTION: Thesis proposal for Musa Al-hassy; McMaster University 2019.
# AUTHOR: Musa Al-hassy, Jacques Carette, Wolfram Kahl
#+EMAIL: alhassy@gmail.com
#+OPTIONS: toc:nil d:nil title:nil author:nil
#+PROPERTY: header-args :tangle no :comments link
#+TODO: TODO | OLD LaTeX README Remarks space

:summary:
In a language with dependent types, the same notion may be formalised several different ways. For instance, a monoid could be:

(1) a record with as fields (i) its carrier, (ii) a binary operation on the carrier, (iii) an identity element of the carrier, and (iv) associative, (v) left, and (vi) right identity laws;

(2) a record indexed on a carrier, with (ii)-(vi) as fields;

(3) a record indexed on a carrier, binary operation, and identity, with (iv)-(vi) as fields;

(4) a datatype of free monoids, with a binary operation and identity as constructors;

(5) a datatype of free monoids indexed on a type of variables, with an injection from the variables as an additional constructor.

In general, a record with N fields might have M interesting variations, requiring order of N*M lines of code. The paper presents a technique (implemented as Emacs macros) where one can write N+M lines, from which the N*M lines are generated.
:End:

* Remarks COMMENT on writing
# At the end of a section, explain why the section is there,
# and what the reader should take away from it.

# MA: LaTeX pads colons, :, with spacing.
# For inline typing annotations, use ghost colon “\:” to avoid this issue.

# Drop the 'proposed'. Use positive, active language like

# YS.
# Maybe start with asking what is the message you want to deliver in this paper? What kind of
# bundling is bad and why is it so?

# (add-to-list 'org-latex-text-markup-alist '(code . verb))
# (add-to-list 'org-latex-text-markup-alist '(verbatim . verb))

:WK_Tips:

◈ Re: abstract:
Paragraph 1: Background and identified problem
Paragraph 2: Contribution

◈ After code blocks, and especially before one-line paragraphs between
code blocks, always put \noindent unless there is a strong reason not to.
Also consider doubling the code block indentation.

◈  PacakageFormer --> \textsf{\upshape PackageFormer}
    [Code is ALWAYS typeset as code,
     just like math is always typeset as math.]

:End:
:JC_Remarks:
◆ Consider Finite State Machines, rather than graphs, so as to have a multi-sorted
  structure where the sorts do not ‘depend’ on each other.

- The introduction needs to cover the *problem* that is being solved - and not the solution; that is not 100% clear below
- You need to save space for related work (can be a short paragraph, but without it, it'll get rejected)
- Where are the citations? There should be citations throughout!
:End:

** Headline-Style Capitalisation
   Headline-Style Capitalisation (according to the Chicago Manual of Style, Sections 8.157, 8.158, and 8.159)

   + Capitalise:
     - first and last word, first word after a colon (subtitle)
     - all major words (nouns, pronouns, verbs, adjectives, adverbs)

   + Lowercase:
     - articles (the, a, an)
     - prepositions (regardless of length)
     - conjunctions (and, but, for, or, nor)
     - to, as

   + Hyphenated Compounds:
     - always capitalize first element
     - lowercase second element for articles, prepositions, conjunctions
       and if the first element is a prefix or combining form that could not stand
       by itself (unless the second element is a proper noun / proper adjective)

* README COMMENT Dependencies of this org file

In the source blocks below, go into each one and press C-c C-c
to have it executed. Some ‘results’ will be echoed into the buffer
if everything went well.

Rather than executing the following blocks each time you edit this file,
consider adding them to your Emacs [[https://alhassy.github.io/init/][configuration file]].

 + org-mode :: This particular markup is called org-mode.

     Let's obtain Org-mode along with the extras that allow us to ignore
     heading names, but still utilise their contents --e.g., such as a heading
     named ‘preamble’ that contains org-mode setup for a file.
     #+begin_src emacs-lisp
;; first we get a handy-dandy package manager

(require 'package)
(setq package-archives '(("org"       . "https://orgmode.org/elpa/")
                         ("gnu"       . "https://elpa.gnu.org/packages/")
                         ("melpa"     . "https://melpa.org/packages/")
                         ("melpa-stable" . "https://stable.melpa.org/packages/")
                         ))
(package-initialize)

(package-refresh-contents)

(package-install 'use-package)
(require 'use-package)
(setq use-package-always-ensure t)

;; then we get the org-mode goodness

(use-package org
  :ensure org-plus-contrib
  :config
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines)))
#+end_src

     This lets us use the ~:ignore:~ tag on headlines you'd like to have ignored,
     while not ignoring their content --see [[https://emacs.stackexchange.com/a/17677/10352][here]].

     - Use the ~:noexport:~ tag to omit a headline /and/ its contents.

 + minted & bib :: Source blocks obtain colour.

     Execute the following for bib ref as well as minted
     Org-mode uses the Minted package for source code highlighting in PDF/LaTeX
     --which in turn requires the pygmentize system tool.
     #+BEGIN_SRC emacs-lisp
     (setq org-latex-listings 'minted
           org-latex-packages-alist '(("" "minted"))
           org-latex-pdf-process
           '("pdflatex -shell-escape -output-directory %o %f"
             ;; "biber %b"
             "bibtex %b"
             "pdflatex -shell-escape -output-directory %o %f"
             "pdflatex -shell-escape -output-directory %o %f")
     )
     #+END_SRC

     #+RESULTS:
     | pdflatex -shell-escape -output-directory %o %f | bibtex %b | pdflatex -shell-escape -output-directory %o %f | pdflatex -shell-escape -output-directory %o %f |

  # Enable the following to have small-font code blocks.
  # LATEX_HEADER: \RequirePackage{fancyvrb}
  # LATEX_HEADER: \DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\scriptsize}

 + acmart :: Enable acmart latex class.

   #+NAME: make-acmart-class
   #+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
             '("acmart" "\\documentclass{acmart}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

 (message "acmart has been loaded")
 #+END_SRC

 #+RESULTS: make-acmart-class
 : acmart has been loaded

   The ‘footer’ at the end of this file currently executes only this code block for you
   ---if you enable the local vars. You can easily tweak it to execute the other blocks,
   if you like.

 + org-ref :: [[https://github.com/jkitchin/org-ref][An exquisite system]] for handling references.

    If everything works, the following entity will display useful data
    when the mouse hovers over it (•̀ᴗ•́)و If you click on it, then you're
    in for a lot of super neat stuff, such as searching for the pdf online!

    cite:agda_overview

    #+BEGIN_SRC emacs-lisp
(use-package org-ref :demand t)

;; Files to look at when no “╲bibliography{⋯}” is not present in a file.
;; Most useful for non-LaTeX files.
(setq reftex-default-bibliography '("References.bib"))

(use-package helm-bibtex :demand t)
;; If you use helm-bibtex as the citation key completion method you should set these variables too.

(setq bibtex-completion-bibliography "References.bib")
#+END_SRC

#+RESULTS:
: References.bib

#+RESULTS:
: References.bib

#+RESULTS:
: References.bib

  Execute ~M-x helm-bibtex~ and, say, enter ~agda~ and you will be presented with
  all the entries in the bib database that mention ‘agda’. Super cool stuff.

* LaTeX setup                                                        :ignore:

  # Visible editorial comments.
  #+LATEX_HEADER: \usepackage{edcomms}
  #+LATEX_HEADER: \edcommsfalse

** Document class options                                            :ignore:
  #+LATEX_CLASS: acmart
  #+latex_class_options: [sigplan,screen]
  # latex_class_options: [sigplan,review,anonymous]
  # latex_class_options: [acmsmall,review,anonymous]

** Letter size and no page numbers or footers :ignore:
  # Letter-Size Paper Format, defaults
  #+latex_header: \pdfpagewidth=8.5in
  #+latex_header:\pdfpageheight=11in

  # switch off page numbering, “folios”
  # latex_header: \pagenumbering{gobble}

  # ACM uses the natbib package
  #
  #+LATEX: \settopmatter{printacmref=false, printccs=true, printfolios=false}

** Unicode & hyperlinks :ignore:
  # Dark green colour for links.
  #+LATEX_HEADER: \usepackage{color}
  #+LATEX_HEADER: \definecolor{darkgreen}{rgb}{0.0, 0.3, 0.1}
  #+LATEX_HEADER: \hypersetup{colorlinks,linkcolor=darkgreen,citecolor=darkgreen,urlcolor=darkgreen}

  #+LATEX_HEADER: \usepackage{CheatSheet/UnicodeSymbols}

  #+LATEX_HEADER: \DeclareMathOperator{\VCCompose}{\longrightarrow\hspace{-3ex}\oplus\;}
  #+LATEX_HEADER: \newunicodechar{⟴}{\ensuremath{\!\!\VCCompose}}
  #+LATEX_HEADER: \newunicodechar{𝓋}{\ensuremath{\!\! v}}
  #+LATEX_HEADER: \newunicodechar{𝒱}{\ensuremath{\mathcal{V}}}
  #+LATEX_HEADER: \newunicodechar{α}{\ensuremath{\alpha}}

  # 𝑛𝑎𝑚𝑒
  #+LATEX_HEADER: \newunicodechar{𝑛}{\ensuremath{n}}
  #+LATEX_HEADER: \newunicodechar{𝑎}{\ensuremath{a}}
  #+LATEX_HEADER: \newunicodechar{𝑚}{\ensuremath{m}}
  #+LATEX_HEADER: \newunicodechar{𝑒}{\ensuremath{e}}

  #+LATEX_HEADER: \newunicodechar{⁰}{\ensuremath{^0}}
  #+LATEX_HEADER: \newunicodechar{³}{\ensuremath{^3}}

** CCSXML and Keywords                                               :ignore:
   # This must be /before/ maketitle!
   #+begin_export latex
 %%
 %% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.

 \begin{CCSXML}
 <ccs2012>
 <concept>
 <concept_id>10011007.10011006.10011008.10011009.10011019</concept_id>
 <concept_desc>Software and its engineering~Extensible languages</concept_desc>
 <concept_significance>500</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011024.10011031</concept_id>
 <concept_desc>Software and its engineering~Modules / packages</concept_desc>
 <concept_significance>500</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
 <concept_desc>Software and its engineering~Functional languages</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011024.10011025</concept_id>
 <concept_desc>Software and its engineering~Polymorphism</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011024.10011028</concept_id>
 <concept_desc>Software and its engineering~Data types and structures</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011041.10011047</concept_id>
 <concept_desc>Software and its engineering~Source code generation</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011060.10011018</concept_id>
 <concept_desc>Software and its engineering~Design languages</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011066.10011069</concept_id>
 <concept_desc>Software and its engineering~Integrated and visual development environments</concept_desc>
 <concept_significance>300</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011009.10011010</concept_id>
 <concept_desc>Software and its engineering~Imperative languages</concept_desc>
 <concept_significance>100</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011024.10003202</concept_id>
 <concept_desc>Software and its engineering~Abstract data types</concept_desc>
 <concept_significance>100</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011008.10011024.10011036</concept_id>
 <concept_desc>Software and its engineering~Patterns</concept_desc>
 <concept_significance>100</concept_significance>
 </concept>
 <concept>
 <concept_id>10011007.10011006.10011039.10011040</concept_id>
 <concept_desc>Software and its engineering~Syntax</concept_desc>
 <concept_significance>100</concept_significance>
 </concept>
 </ccs2012>
 \end{CCSXML}

 \ccsdesc[500]{Software and its engineering~Extensible languages}
 \ccsdesc[500]{Software and its engineering~Modules / packages}
 \ccsdesc[300]{Software and its engineering~Functional languages}
 \ccsdesc[300]{Software and its engineering~Polymorphism}
 \ccsdesc[300]{Software and its engineering~Source code generation}
 \ccsdesc[300]{Software and its engineering~Integrated and visual development environments}

 %removed
 \ccsdesc[300]{Software and its engineering~Data types and structures}
 \ccsdesc[300]{Software and its engineering~Design languages}
 \ccsdesc[100]{Software and its engineering~Imperative languages}
 \ccsdesc[100]{Software and its engineering~Patterns}
 \ccsdesc[100]{Software and its engineering~Syntax}
 \ccsdesc[100]{Software and its engineering~Abstract data types}


 %%
 %% Keywords. The author(s) should pick words that accurately describe
 %% the work being presented. Separate the keywords with commas.
 \keywords{Agda, meta-program, extensible, Emacs, pacakges, modules, dependent-types}
   #+end_export

** Authors & title                                                   :ignore:

 #+begin_export latex
 \title{A Language Feature to Unbundle Data at Will}
\subtitle{ (Short Paper)}

 \author{Musa Al-hassy}
 \affiliation{McMaster University, Canada}
 \email{alhassy@gmail.com}

 \author{Jacques Carette}
 \orcid{0000-0001-8993-9804}
 \affiliation{McMaster University, Canada}
 \email{carette@mcmaster.ca}

 \author{Wolfram Kahl}
 \orcid{0000-0002-6355-214X}
 \affiliation{McMaster University, Canada}
 \email{kahl@cas.mcmaster.ca}

 % \author{Musa Al-hassy \\ {\small \url{alhassy@gmail.com} \\ McMaster University \\ Computing and Software \\ Hamilton, Ontario, Canada}}
 % \author{Jacques Carette \\ {\small \url{carette@mcmaster.ca} \\ McMaster University \\ Computing and Software \\ Hamilton, Ontario, Canada}}
 % \author{Wolfram Kahl \\ {\small \url{kahl@cas.mcmaster.ca} \\ McMaster University \\ Computing and Software \\ Hamilton, Ontario, Canada}}

 #+end_export

** Widows and Orphans                                                :ignore:
 # An "orphan" is an isolated line of text at the bottom of a page;
 # an "orphan heading" is a heading without following body text at the bottom of the page;
 # a "widow" is an isolated line of text at the top of a page.
 #
 # LaTeX: In order to eliminate widows and orphans, you can copy the following commands into the LaTeX source before \begin{document} :
 #
   #+latex_header:        \clubpenalty = 10000
   #+latex_header:        \widowpenalty = 10000
   #+latex_header:        \displaywidowpenalty = 10000

 # Sometimes, orphans and widows will survive these commands, in which case a \vspace command might help.

** Balanced Columns on Last Page                                     :ignore:
   #+latex_header: \usepackage{flushend}

 # The two columns of the last page need to have the same length.
 #
 # + LaTeX (Option 1) :: Insert the command \usepackage{flushend} into the LaTeX source before \begin{document}.
 #
 # + LaTeX (Option 2) :: Insert \usepackage{balance} into the LaTeX source before \begin{document}
 #      and the following in the text that would appear as left column on the last page without balancing: \balance.
 #
 # + LaTeX (Option 3) :: If the above options do not work, it seems that one of the used packages prevents
 #      the balancing from working properly. In case you do not want to spend time on finding out which
 #       package it is, you can manually balance the last page by inserting a \newpage between your
 #       references in the .bbl file at an appropriate position. (Attention: Running bibtex again
 #       will overwrite this; alternatively, the contents of the .bbl file can be copy-and-paste'ed
 #       into the main LaTeX file in place of the \bibliography command.)
 #
** GPCE’19 Copyright                                                 :ignore:

 # The following is specific to GPCE '19 and the paper
 # 'A Language Feature to Unbundle Data at Will (Short Paper)'
 # by Musa Al-hassy, Wolfram Kahl, and Jacques Carette.
 #
 #+latex_header: \setcopyright{acmcopyright}
 #+latex_header: \acmPrice{15.00}
 #+latex_header: \acmDOI{10.1145/3357765.3359523}
 #+latex_header: \acmYear{2019}
 #+latex_header: \copyrightyear{2019}
 #+latex_header: \acmISBN{978-1-4503-6980-0/19/10}
 #+latex_header: \acmConference[GPCE '19]{Proceedings of the 18th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences}{October 21--22, 2019}{Athens, Greece}
 #+latex_header: \acmBooktitle{Proceedings of the 18th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences (GPCE '19), October 21--22, 2019, Athens, Greece}
 #+latex_header:

* Abstract :ignore:
# Do not use footnotes and references in the abstract!

#+begin_abstract

  # The eager commit to what data should be a type parameter or a record component
  # is a premature design decision. We demonstrate a language feature that circumvents
  # such over-specification.
  #
  # WK:  That's quite a mouthful and hard to parse. Perhaps establish some context first?

  # This is analogous to
  # which information is exposed dynamically at runtime and which is known statically,
  # respectively.

  Programming languages with sufficiently expressive type systems provide users with
  different means of data ‘bundling’. Specifically, in dependently-typed languages such as
  Agda, Coq, Lean and Idris, one can choose to encode information
  in a record either as a parameter or a field.
  For example, we can speak of graphs /over/ a particular vertex set, or speak
  of arbitrary graphs where the vertex set is a component.
  These create isomorphic types, but differ with respect to intended use.
  Traditionally, a library designer would make this choice (between parameters and fields);
  if a user wants a different variant, they are forced to build conversion utilities, as well as
  duplicate functionality. For a graph data type,
  if a library only provides a Haskell-like typeclass view of graphs /over/ a vertex set,
  yet a user wishes to work with the category of graphs, they must now package a vertex
  set as a component in a record along with a graph over that set.

  We design and implement a language feature that allows both the library designer and
  the user to make the choice of information exposure only when necessary, and otherwise leave
  the distinguishing line between parameters and fields unspecified.
  Our language feature is currently implemented as a prototype meta-program
  incorporated into Agda's Emacs ecosystem, in a way that is unobtrusive to Agda users.
#+end_abstract

 \maketitle

* Introduction --- Selecting the ‘Right’ Perspective

  :Ideas:
  Which perspective of semigroups does one select? Semigroup𝒾 from the thesis proposal;
     the perspective considered should have legitimate uses rather than artificial ones.
     How do we write, e.g., ‘concat’ in the various forms. What is the minimal reduplication required using
     existing techniques.
   :End:

  Library designers want to produce software components that are useful for
  the perceived needs of a variety of users and usage scenarios.  It is therefore
  natural for designers to aim for substantial generality, in the hopes of increased
  reusability. One such particular ``choice'' will occupy us here: When creating a
  record to bundle up certain information that “naturally” belongs together, what
  parts of that record should be /parameters/ and what parts should be
  /fields/? This is analogous to whether functions are curried and so arguments
  may be provided partially, or otherwise must be provided all-together in one tuple.

  The subtlety of what is a ‘parameter’ --- exposed at the type level --- and what is a
  ‘field’ --- a component value --- has led to awkward formulations and
  the duplication of existing types for the sole purpose of different uses.
  Tom Hales cite:Hales-blog-post is quite eloquent in his critique of Lean:
  \begin{quote}
    Structures are meaninglessly parameterized from a mathematical perspective.
    [...] I think of the parametric versus bundled variants as analogous to currying
    or not; are the arguments to a function presented in succession or as a single
    ordered tuple? However, there is a big difference between currying functions
    and currying structures. Switching between curried and uncurried functions is
    cheap, but it is nearly impossible in Lean to curry a structure. That is, what
    is bundled cannot be later opened up as a parameter. (Going the other direction
    towards increased bundling of structures is easily achieved with sigma types.)
   This means that library designers are forced to take a conservative approach and
   expose as a parameter anything that any user might reasonably want exposed, because
   once it is bundled, it is not coming back.
  \end{quote}
  This is the problem we are solving.

  # For example, the ubiquitous monoid, used to model compositionality,
  # in Haskell, is only allowed one instance per datatype. However, the Booleans,
  # for example, support multiple monoid instances such as sequential and parallel monoids
  # ---the former being conjunction with
  # identity /true/ and the latter being disjunction with identity /false/.
  For example, each Haskell typeclass can have only one instance per datatype;
  since there are several monoids with the datatype ~Bool~ as carrier,
  in particular those induced by conjunction and disjunction,
  the de-facto-standard libraries for Haskell
  define two isomorphic copies ~All~ and ~Any~ of ~Bool~,
  only for the purpose of being able to attach the respective monoid instances to them.

  But perhaps Haskell's type system does not give the programmer sufficient
  tools to adequately express such ideas. As such, for the rest of this paper
  we will illustrate our ideas in Agda cite:Norell-2007,agda_overview.
  For the monoid example,
  it seems that there are three contenders for the monoid interface:

#    \vspace{-1.5em}\noindent

  \noindent
  #+begin_src agda
record Monoid₀ : Set₁ where
 field
  Carrier : Set
  _⨾_     : Carrier → Carrier → Carrier
  Id      : Carrier
  assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
  leftId  : ∀ {x} → Id ⨾ x ≡ x
  rightId : ∀ {x} → x ⨾ Id ≡ x
#+end_src

#+begin_src agda
record Monoid₁ (Carrier : Set) : Set where
  field
    _⨾_     : Carrier → Carrier → Carrier
    Id      : Carrier
    assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
    leftId  : ∀ {x} → Id ⨾ x ≡ x
    rightId : ∀ {x} → x ⨾ Id ≡ x
#+end_src
# \pagebreak
#+begin_src agda
record Monoid₂
         (Carrier : Set)
         (_⨾_ : Carrier → Carrier → Carrier)
       : Set  where
  field
    Id      : Carrier
    assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
    leftId  : ∀ {x} → Id ⨾ x ≡ x
    rightId : ∀ {x} → x ⨾ Id ≡ x
  #+end_src

  \vspace{0.3em}\noindent
  In ~Monoid₀~, we will call ~Carrier~ “bundled up”,
  while we call it “exposed” in ~Monoid₁~ and ~Monoid₂~.
  The bundled-up version allows us to speak of /a/
  monoid, rather than /a monoid on a given type/ which is captured by ~Monoid₁~.
  While ~Monoid₂~ exposes both the carrier and the composition operation,
  we might in some situation be interested
  in exposing the identity element instead
  --- e.g., the discrepancy ‘≢’ and indistinguishability ‘≡’ operations
  on the Booleans
  have the same identities as conjunction and disjunction, respectively.
  Moreover, there are other combinations of what is to be exposed and hidden,
  for applications that we might never think of.

  Rather than code with /interface formulations we think people will likely use/, we can
  instead try to /commit to no particular formulation/ and allow the user to select
  the form most convenient for their use-cases. This desire for reusability motivates
  a new language feature: The \textsf{\upshape PackageFormer}.

  Moreover, it is often the case that one begins working with a record of useful
  semantic data, but then, say, for proof automation, may want to use the associated
  datatype for syntax. For example, the syntax of closed monoid terms can be expressed,
  using trees, as follows.
  #+begin_src agda
    data Monoid₃ : Set where
      _⨾_ : Monoid₃ → Monoid₃ → Monoid₃
      Id  : Monoid₃
  #+end_src
  \noindent
  We can see that this can be
  obtained from ~Monoid₀~ by discarding the
  fields denoting equations, then turning the remaining fields into constructors.

  We show how these different
  presentations can be derived from a /single/
  \textsf{\upshape PackageFormer} declaration
  via a generative meta-program integrated into the
  most widely-used Agda “IDE”, the Emacs mode for Agda.
  In particular,
  if one were to explicitly write $M$ different bundlings of a package
  with $N$ constants then one would write nearly $N × M$ lines of code,
  yet this quadratic count becomes linear $N + M$ by having a single
  package declaration of $N$ constituents with $M$ subsequent instantiations.
  We hope that reducing such duplication of effort, and of potential maintenance
  burden, will be beneficial to the software engineering of large libraries
  of formal code --- and consider it the main contribution of our work.
  #
  #   a package of $N$ constituents with $M$ presentations of bundling
  # results in nearly $N × M$ lines of code,

  :Remarks:
  To demonstrate the generality of the notion of package formers we shall demonstrate how other common forms could be ‘derived’ from the single declaration above. It is to be noted that for such a small example, such derived code may be taken for granted, however for much larger theories —for example, a “field” comes with more than 20 fields— the ability to derive different perspectives in a consistent fashion is indispens- able; especially when the package is refactored. More realistically, a symmetric rig groupoid uses about 212 coherence laws [rig_computation], for which case-splitting, to perform proofs, yields over 200 goals thereby making metaprogramming a tempting approach.
  :End:

* \textsf{\upshape PackageFormer}s --- Being Non-committal as Much as Possible
  :Remarks:
  Unifying the different perspectives under the same banner. We speak in terms of elaborations,
  but may propose elementary typing rules or semantics. Discuss \textsf{\upshape PackageFormer}
  polymorphism, from §4 of thesis proposal.
     :End:

    # It is notoriously difficult to reconstruct the possible inputs to a function
    # that yielded a certain output.
    # That is, unless you are using Prolog of-course,
    # where the distinctions between input and output are an illusion
    # that is otherwise
    # made real only by how Prolog users treat arguments to a relation.
    # Dependently-typed programming at its core is the adamant hygienic blurring of
    # concepts
    # --- namely, types are terms \cite{types_overview} ---
    # and so the previous presentations of monoids are unified in the following
    # single declaration which does not distinguish between parameters and fields.
    #
    We claim that the above monoid-related pieces of Agda code
    can be unified as a single declaration
    which does not distinguish between parameters and fields,
    where ~PackageFormer~ is a keyword with similar syntax as ~record~:

      #+begin_src agda
  PackageFormer MonoidP : Set₁ where
    Carrier : Set
     _⨾_    : Carrier → Carrier → Carrier
    Id      : Carrier
    assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
    leftId  : ∀ {x} → Id ⨾ x ≡ x
    rightId : ∀ {x} → x ⨾ Id ≡ x
  #+end_src

  \noindent

  # #+BEGIN_EXPORT latex
  # \emph{One uses a \textsf{\upshape PackageFormer} by instantiating the particular presentation that is desired.}
  # #+END_EXPORT

    # Superficially, the parameters and fields have been flattened into a single location
  Then, with various directives that let one declare
  what should be parameters and what should be fields,
  we can reproduce the above presentations.
 The directives can be built from the following grammar:
    #+begin_src agda
id          :  Variational
record      :  Variational
typeclass   :  Variational
termtype    :  Variational
unbundled   :  ℕ → Variational
exposing    :  List Name → Variational
_⟴_        :  Variational → Variational → Variational
#+end_src
#                           -- Syntax as for using
# # JC proposes ~termlanguage~ for ~termtype~
\noindent
  A package former is used via /instantiations/, written as low-precedence
 juxtapositions of a package former name and expression of type
 ~Variational~.
 The variationals ~unbundled~ and ~exposing~ have arguments.
 While ~exposing~ explicitly lists the names that should be turned
 into parameters, in that sequence, ~“unbundled~ $n$” exposes the
 first $n$ names declared in the package former.

 An /instantiation/ juxtaposition is written ~PF 𝓋~ to indicate that the PackageFormer
 named ~PF~ is to be restructred according to scheme ~𝓋~. A /composition/ of variationals
 is denoted using the symbol ‘⟴’; for example,
 ~PF 𝓋₁ ⟴ 𝓋₂ ⟴ ⋯ ⟴ 𝓋ₙ~ denotes the forward-composition of iterated instantiations,
 namely ((~(PF 𝓋₁) 𝓋₂) ⋯) 𝓋ₙ~, since we take prefix instantiation application
to have lower precedence that variational composition.
 In particular, an empty composition is the identity
 scheme, which performs no alteration, and has the explicit name ~id~.
 Since $\mathsf{PF} \; \mathsf{id} ≈ \mathsf{PF}$ and ~id~ is the identity of composition, we may
 write any /instantiation/ as a sequence of \hspace{0.2em} ⟴-separated clauses:
~PF ⟴ 𝓋₁ ⟴ 𝓋₂ ⟴ ⋯ ⟴ 𝓋ₙ~.
 # ---which is equivalent to \linebreak ~PF ((((id ⟴ 𝓋₁) ⟴ 𝓋₂) ⋯)) 𝓋ₙ)~.

  The previous presentations can be obtained as follows.

  0. [@0] To make ~Monoid₀′~ the type of /arbitrary monoids/
   (that is, with arbitrary carrier), we declare:
        \vspace{0.3em}
   #+begin_src agda
 Monoid₀′  = MonoidP record
#+end_src

  1. [@1] We may obtain the previous formulation of
     ~Monoid₁~ in two different equivalent ways:
        \vspace{0.3em}
   #+begin_src agda
 Monoid₁′  = MonoidP record ⟴ exposing (Carrier)
 Monoid₁″ = MonoidP record ⟴ unbundled 1
#+end_src

# #    \vspace{0.3em}

  2. [@2] As with ~Monoid₁~, there are also different ways
     to obtain ~Monoid₂~.
        \vspace{0.3em}
    #+begin_src agda
 Monoid₂′  = MonoidP record ⟴ unbundled 2
 Monoid₂″ = MonoidP
              record ⟴ exposing (Carrier; _⨾_)
#+end_src

      \vspace{0.3em}

# # Our precedence rules indicate that ~MonoidP ⋯~ parenthesises
# # as if it were ~MonoidP (⋯)~.
# # Moreover, notice that the infix combinators for unbundling and exposing,
# # behave similar to the curry functional $(A × B → C) \;→\; (A → B → C)$.
# #
# #   2. [@2] To speak of /a monoid over an arbitrary carrier/, we declare:
# #         \vspace{0.3em}
# #    #+begin_src agda
# #  Monoid₃ = MonoidP record
# # #+end_src
# #    \vspace{0.3em}
# #    \noindent
# #    It behaves as if it were declared thusly:
# #    \vspace{0.3em}
# #    \noindent
# #    #+begin_src agda
# #     record Monoid₃ : Set₁ where
# #       field
# #         Carrier : Set
# #         _⨾_     : Carrier → Carrier → Carrier
# #         Id      : Carrier
# #         ⋯
# # #+end_src
# #
# #   The name ~Carrier~ is a default and could be renamed; likewise for ~Vars~ below.

  3. [@3] Metaprogramming is more clearly needed to produce the term language:
        \vspace{0.3em}
    #+begin_src agda
 Monoid₃′ = MonoidP termtype :carrier "Carrier"
#+end_src
    \vspace{0.3em}
   \noindent
   Our running example uses the theory of monoids, which is a single-sorted theory.
   In general, a PackageFormer may have multiple sorts ---as is the case with
   graphs--- and so one of the possibly many sorts needs to be designated as the
   universe of discourse, or carrier, of the resulting inductively defined term type.
   This is accomplished with the ~:carrier~ argument.

   \vspace{0.3em}
   \noindent
   We may also want to have terms /over/ a particular variable set, and so declare:
   \vspace{0.3em}
     #+begin_src agda
 Monoid₄ = MonoidP termtype-with-variables
              :carrier "Carrier"
#+end_src
    \vspace{0.3em}
    \noindent
    Since a parameter's name does not matter, due to α-equivalence, an arbitrary,
    albeit unique, name for the variable set is introduced along with an embedding
    function from it to the resulting term type. For brevity, the embedding function's
    name is ~inj~ and the user must ensure there is no name-clash.
    The resulting elaboration is as follows.
       \vspace{0.3em}
       \noindent
    #+begin_src agda
    data Monoid₄ (Vars : Set) : Set where
      inj : Vars → Monoid₄ Vars
      _⨾_  : Monoid₄ Vars
           → Monoid₄ Vars → Monoid₄ Vars
      Id  : Monoid₄ Vars
  #+end_src

     \vspace{0.3em}
     \noindent
     Note that these instantiations implicitly drop equations, such
     as associativity from ~MonoidP~.  This is what is commonly done
     in Universal Algebra. If we were instead doing $n$-category
     theory, these would be kept, but will be the subject of future
     work.

# ##  WK: Try it:
# ##       #+begin_src agda
# ##   MonoidTermPropEqu = MonoidP equality where termtype = Monoid₅
# ##  #+end_src
# ##
# ##      #+begin_src agda
# ##      data MonoidTermPropEqu (Vars : Set) : Set where
# ##        eqVars : {v w : Vars}  → v ≡ w → inj v ≡ inj w
# ##        ...
# ##    #+end_src
# ##
# ##       #+begin_src agda
# ##   MonoidTermSetoid = MonoidP termSetoid where termtype = Monoid₅
# ##  #+end_src
# ##
# ##      #+begin_src agda
# ##      module _ {v e : Level} (Vars : Setoid v e) where
# ##        open SetoidV Vars
# ##        data _≈T_ : Monoid₅ CarrierV → Monoid₅ CarrierV  → Set (v \sqcup e) where
# ##          eqVars : {v w : Vars}  → v ≈V w → inj v ≈T inj w
# ##          ...
# ##        MonoidTermSetoid : Setoid v e
# ##        MonoidTermSetoid = record { ... }
# ##    #+end_src
# ##

# #  There are of-course a number of variations on how a package is to be presented;
# #  we have only mentioned two for brevity. The interested reader may consult
# #  the ‘next 700 module systems’ proposal \cite{alhassy_thesis_proposal};
# #  which discusses more variations and examples in detail.

  We also have elaborations into nested dependent-sums, which is useful
  when looking at coherent substructures.
  Alongside ~_unbundled_~, we also have infix combinators for extending an
  instantiation with additional fields or constructors, and the renaming of constituents
  according to a user provided String-to-String function.
  Moreover, just as syntactic datatype declarations may be derived, we also
  allow support for the derivation of induction principles and structure-preserving homomorphism types.
  Our envisioned system would be able to derive simple, tedious, uninteresting concepts; leaving difficult,
  interesting ones for humans to solve.

  :Remarks:
  0. Besides syntax, induction principles are also derived:

  2. The ability to extend an instantiation with additional new fields or constructors.

     - Since typeclass declarations provide type-level functions, these can be
       pre-composed with functions that alter their inputs.
       E.g., ~MonoidP typeclass~ is a parmeterised type which is a function of types,
       so, for example, ~MonoidP typeclass ∘ List~ is the same but the carrier is now
       lists over the provide parameter.

       - Likewise we provide support for a constraint upon the parameter:
         MonoidP typeclass using constraint
         reduces
         MonoidP typeclass field constraint : ...

         nice.

  1. Records, Haskell-style typeclasses,
     nested dependent sums with the carrier declared or existentially quantified,
     sums: Disjoint collection of declarations where each declaration is itself
     a dependet sum consistong of the context necessayr toensure that the consitnutets
     are well-typed.

     There are obvious isomorphisms and these should be guarentted.

  4. The ability to apply a string-to-string function to alter the names of constiuents
     ‘decorated’.

  5. Derive homomorphisms, strucutre preserving operations.

  6. Support multiple defaults.

  3. Constitients of package formers give rise to functions ---e.g., by replacing the
     PackageFormer name with a new fresh variable. See 𝒯, page 42, of thesis-proposal.

     In turn, this can be used to produce simple, tedious, induction principles. See (0) above.

  4. This is particularly useful when one wants to extract such constieunte types for re-use elsewhere.
  :End:

  #+begin_quote
  *Quadratic to Linear:*
  Notice that the previous 5 monoid presentations, ~Monoid₀~ to ~Monoid₄~, spanned 32
  lines (8 for the original, 24 for the variants). Using ~MonoidP~ and our operators,
  this can be done in 7 + 6 = 13 lines.  This corresponds to using a 2-part code,
  with the initial lines being a model, and then 1-2 lines to specify variants.
  #+end_quote

  The PackageFormer declarations are not legal Agda syntax and thus appear as special comments.
  The comments are read by Emacs Lisp and legitimate Agda is produced in a generated file, which is
  then automatically imported into the current file --- examples are provided in an appendix.
  The generated file never needs to be consulted,
  as the declared names are furnished with tooltips rendering the elaborated
  Agda form. Moreover, we also provide a feature to extract a ‘bare bones’ version
  of a file that strips out all PackageFormer annotations, leaving only Agda
  as well as the import to the generated file. Finally, since the elaborations are
  just Agda, one only needs to use the system once and future users are
  not forced to know about it.

  :poor_transition:
    The \textsf{\upshape PackageFormer} language feature unifies disparate representations of the
same concept under a single banner. How does one actually /do/ anything with
these entities? Are we forced to code along particular instantiations?
No; unless we desire to do so.
:end:

* \textsf{\upshape Variational} Polymorphism
# # A New Kind of Polymorphism

  Suppose we want to produce the function ~concat~, which folds over the elements of a list
  according to a compositionality scheme --- examples of this include summing over
  a list, multiplication over a list, checking all items in a list are true, or
  at least one item in the list is true.
  Depending on the selected instantiation,
  the resulting function may have types such as the following:

  \vspace{1em}
#+BEGIN_SRC agda
  concat₀ : {M : Monoid₀}
          → let C = Monoid₀.Carrier M
             in  List C → C

  concat₁ : {C : Set} {M : Monoid₁ C} → List C → C

  concat₂ : {C : Set} {_⨾_ : C → C→ C}
            {M : Monoid₂ C _⨾_} → List C → C

  concat₃ : List Monoid₃ → Monoid₃
#+END_SRC
  \vspace{1em}

  \noindent
  Given our previous work, and providing that the variationals are already
  defined, we add a new declaration which, unlike the rest, comes
  equipped with a /definition/.
    \vspace{0.3em}
#+BEGIN_SRC agda
    concat : List Carrier → Carrier
    concat = foldr _⨾_ Id
#+END_SRC
  \noindent This is known as a /definitional extension/ (of a theory), which
  is known to be conservative (i.e. has the same models).

  The variationals is where this power comes from.  Furthermore, we have alluded to
  the fact that the type of variationals
  is extensible; this is achieved by having
  ~Variational ≅ (PackageFormer → PackageFormer)~.
  Indeed, our implementation relies on 5 meta-primitives to form arbitrary
  complex schemes that transform abstract PackageFormers into
  other grouping mechanisms. The meta-primitives were arrived at by codifying
  a number of structuring mechanisms directly then carefully extracting the minimal
  ingredients that enable them to be well-defined.

  The details of the implementation and numerous common structuring mechanisms
  derived from the meta-primitives can be found on the prototype's homepage:
  #+begin_center org
  https://alhassy.github.io/next-700-module-systems-proposal/prototype/PackageFormer.html
  #+end_center

* Next Steps
  :Remarks:
  Ignoring the implementation, there are no sound semantics for these constructs.
     Discuss theory presentation combinators and possible extensions.
  :End:

  We have outlined a new language feature that is intended to reduce
  duplicated effort involved in taking different perspectives on structures---and to solve
  Hales' problem of premature commitment to a particular encoding. Moreover, on the road
  to making this tractable, we have unearthed a novel form of polymorphism and demonstrated
  its usefulness with some examples.

  # We have implemented a meta-program that realises these
  # elaborations in an unobtrusive
  # fashion: An Agda programmer simply declares them in special comments.
  # The resulting ‘editor tactic’ demonstrates
  # that this language feature is promising.
  We have implemented this as an “editor tactic'' meta-program.
  In actual use, an Agda programmer declares what they want
  using the combinators above (inside special Agda code comments),
  and these are then elaborated into Agda code.

  # Thus far we have relied on the reader's understanding of functional programming and
  # algebraic data types to provide an informal and indirect semantics by means of
  # elaborations into existing notions. An immediate next step would be to provide
  # explicit semantics for \textsf{\upshape PackageFormer}'s within a minimal type theory.
  We have presented our work indirectly by using examples, which we
  hope are sufficiently clear to indicate our intent. We next intend to
  provide explicit (elaboration) semantics for ~PackageFormer~ within a
  minimal type theory; \newline cite:types_for_modules.

  Furthermore, there are additional pieces of future work, including:

  1. Explain how generative modules cite:modular_modules
     are supported by this scheme.

  3. How do multiple default, or optional, clauses for a constituent fit into this
     language feature.
     # This may necessitate a form of limited subtyping.

  4. Explore inheritance, coercion, and transport along canonical isomorphisms.

  The existing prototype already has the following nice properties:

  + Extensible ::
     Users may extend the collection of variationals by providing the intended
     elaboration scheme.

     We have provided a number of auxiliary, derived, combinators
     that can be used to construct complex and common schemes.
     Furthermore, the user has full and direct access to the entirety of Emacs Lisp
     as a programming language for restructuring PackageFormers into any desired shape
     ---the well-formedness of which is a matter the user must then worry about.

  + Practical :: The user manual demonstrates how boilerplate code for
                 renamings, hidings, decorations, and generations
     of hierarchical structures can be formed; \newline
     cite:tpc.

  + Pragmatic :: The prototype comes equipped with a number of menus
                  to display the abstract PackageFormer's defined,
                  as well as the variationals defined, and one may
                  enable highlighting for these syntactical items, have
                  folded away, or simply extract an Agda file that does not mention
                  them at all.

                  As it can be tedious to consult generated code for high-level
                  PackageFormer instantiations and so every variational and PackageFormer
                  is tagged with tooltips providing relevant information.

  \noindent
  Finally, the careful reader will have noticed
  that our abstract mentions graphs, yet
  there was no further discussion of that example.
  We have avoided it for simplicity;
  the prototype accommodates multi-sorted structures where
  sorts may /depend/ on one another, as edge-sets
  depend on the vertex-set chosen. Examples can be found on the prototype's
  webpage.

  This short paper proposes a language feature that enables users to selectively
  choose how information is to be organised, such as which parts are exposed as parameters,
  thereby reducing effort when taking different perspectives on structures.
  To demonstrate that this feature seems useful in practice,
  we have implemented a meta-program to generate Agda using special code comments
  that specify how package elements are to be organised, such as their selective exposure
  as parameters which is a common issue with libraries in dependently-typed languages.

  Our variationals
  cannot yet be directly defined in Agda. Instead, we are making use of Emacs Lisp, a language
  close to the Agda ecosystem. Going forward, one of the aims of our work is to have variationals
  definable directly within Agda ---rather than having our users learn yet another language.
  Our exploratory efforts suggest that we may be able to realise PackageFormer's as Agda records
  of ‘elements’ ---a tuple of qualifier, name, type, and definitional clauses---
  and, so, the result is a conservative extension to Agda's underlying type theory.
  However, from a practical standpoint, it is highly likely that we will extend Agda to support
  the new syntax.

  #+begin_quote org
  /Structuring schemes tend to be easy to explain, yet the benefit of our/
  /system is that it transports them from design patterns to full-fledged/
  /library methods./
  #+end_quote
  # Consequently, one needn't worry about manually implementing
  # a scheme, possibly with errors, only to later decide a different one is needed
  # and has to start all over again.
  # Instead, the scheme is automatically produced
  # and explicitly documented to further users
  # ---a notable example from the prototype's webpage: One may simply say a homomorphism
  # type is required for a PackageFormer, rather than spelling-out the mundane and
  # uninsightful definition.

* Bib                                                                :ignore:

 #+latex: \bibliography{References}
 #+latex: \bibliographystyle{plainnat}
 # latex: \bibliographystyle{ACM-Reference-Format}

* space COMMENT 1 × \newpage                                                 :ignore:
   # \newpage
   # latex: {\color{white}.}
   \newpage
* Appendix: Source code

  Below is a nearly self-contained source sample for the presented fragments.
  # We have omitted some variational definitions, using ~⋯~, since they
  # offer little insight but their definitions may be involved.

  \vspace{0.3em}
  _Module Header_
  #+begin_footnotesize org
  #+BEGIN_SRC agda
open import Relation.Binary.PropositionalEquality using (_≡_)
open import Data.List hiding (concat)
module Paper0 where
{- Automatically generated & inserted by the prototype -}
open import Paper0_Generated
#+END_SRC

_Plain ~MonoidP~ PackageFormer_
#+BEGIN_SRC agda
{-700
PackageFormer MonoidP : Set₁ where
    Carrier : Set
    _⨾_     : Carrier → Carrier → Carrier
    Id      : Carrier
    assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)
    leftId  : ∀ {x : Carrier} → Id ⨾ x ≡ x
    rightId : ∀ {x : Carrier} → x ⨾ Id ≡ x
-}
#+END_SRC

_The ~record~ variational and three instantiations_
#+BEGIN_SRC agda
{-700
𝒱-record = :kind record :waist-strings ("field")

Monoid₀′  = MonoidP record
Monoid₁″ = MonoidP record ⟴ :waist 1
Monoid₂″ = MonoidP record ⟴ :waist 2
-}
#+END_SRC
In the paper proper we mentioned “unbundled”, which in the prototype
takes the form of the meta-primitive ~:waist~.

\vspace{0.3em}
_Complex variationals in ~lisp~ blocks_
#+begin_small org
#+BEGIN_SRC agda
{-lisp
(𝒱 termtype carrier
  = "Reify as parameterless Agda “data” type.

     CARRIER refers to the sort that is designated as the
     domain of discourse of the resulting single-sorted
     inductive term data type.
    "
    :kind data
    :level dec
    :alter-elements (lambda (fs)
      (thread-last fs
        (--filter (s-contains? carrier (target (get-type it))))
        (--map (map-type (s-replace carrier $𝑛𝑎𝑚𝑒 type) it)))))

(𝒱 termtype-with-variables carrier = ⋯) -}

{-700
Monoid₃′ = MonoidP termtype :carrier "Carrier"
Monoid₄  = MonoidP termtype-with-variables :carrier "Carrier"
-}
#+END_SRC
#+end_small

_PackageFormers with Equations_
#+BEGIN_SRC agda
{-700
PackageFormer MonoidPE : Set₁ where
    -- A few declarations
    Carrier : Set
    _⨾_     : Carrier → Carrier → Carrier
    Id      : Carrier
    assoc   : ∀ {x y z} → (x ⨾ y) ⨾ z ≡ x ⨾ (y ⨾ z)

    -- A few declarations with equations
    Rid : Carrier → Carrier
    Rid x = x ⨾ Id
    concat : List Carrier → Carrier
    concat = foldr _⨾_ Id

    -- More declarations
    leftId  : ∀ {x : Carrier} → Id ⨾ x ≡ x
    rightId : ∀ {x : Carrier} → Rid x ≡ x
-}
#+END_SRC

_concat₀ and concat₃_
#+BEGIN_SRC agda
{-700
𝒱-decorated by = ⋯
Monoid⁰ = MonoidPE decorated :by "⁰" ⟴ recordₑ
Monoid³ = MonoidPE ⟴ decorated :by "³"
                   ⟴ termtypeₑ :carrier "Carrier³"
-}

{- “Concatenation over an arbitrary monoid” -}
concat₀ : {M : Monoid⁰}
         → let C = Monoid⁰.Carrier⁰ M
           in List C → C
concat₀ {M} = Monoid⁰.concat⁰ M

{- Concatenation over an arbitrary *closed* monoid term -}
concat₃ : let C = Monoid³
          in List C → C
concat₃ = concat³
#+END_SRC
#+end_footnotesize

* OLD COMMENT other ideas

What about some context at the beginning of the first paragraph?

What does the term bundling refer to, bundling of what? and what kind of data exposure is a problem?
Suggestion (just an example of sth you can do), mention a record type (or something else) as a way of bundling, and explain that data exposure means what fields are exposed. I believe that is what you mean with type and value levels?

  ----other ideas----

  # We design and implement a language feature that allows both the library designer and user to make this choice as necessary.

  # True, but relevant?
  The more information known statically, the less arbitrary choices that need to be performed
  by inspecting data at runtime ---e.g., what to do when list elements, say in Java, differ
  or when list lengths, say in Haskell, differ when computing a dot product.
  However, it is not clear how much information exposure is ideal.

  For example, more exposure at the parameter or type-index level enforces too many constraints
  ---as in considering graphs /over/ a particular vertex set versus the type of graphs over an arbitrary
  vertex set. It thus appears that the context dictates which level of exposure is most appropriate.
  #
  # This definitely belongs in your abstract, but needs to be attached to something more concrete.
  #
  The traditional approach is to reduplicate utility functions or provide conversions between the few supported
  perspectives.
  Our proposed language feature will allow the library designer, and user, to make this choice only when necessary
  and otherwise leave the ‘belt line’ between parameters and fields unspecified.

  To demonstrate the practicality of this feature, we have produced a prototype for the Agda language.
  After loading it, Agda users may employ special comments from which legitimate Agda code is automatically generated
  as users step-wise program.

** COMMENT OLD Abstract                                              :ignore:
   :PROPERTIES:
   :CUSTOM_ID: abstract
   :END:

 # Use:  x vs.{{{null}}} ys
 # This informs LaTeX not to put the normal space necessary after a period.
 #
 #+MACRO: null  @@latex:\null{}@@

 #+begin_center
 *Abstract*
 #+end_center
 #+begin_small
   Programming languages with sufficiently expressive type theories provide users with essentially two
   levels of data ‘bundling’. One may expose important constituents at the type level or have them
   hidden at the value level. Alternatively put, which information is exposed dynamically at runtime and which is known
   statically. Rather than force a user to commit to a choice, we propose a language feature that allows such
   choices to be determined whenever is convenient for the task at hand.

   The more information known statically, the less arbitrary choices that need to be performed
   by inspecting data at runtime ---e.g., what to do when list elements, say in Java, differ
   or when list lengths, say in Haskell, differ when computing a dot product.
   However, it is not clear how much information exposure is ideal.
   For example, more exposure at the parameter or type-index level enforces too many constraints
   ---as in considering graphs /over/ a particular vertex set versus the type of graphs over an arbitrary
   vertex set. It thus appears that the context dictates which level of exposure is most appropriate.
   The traditional approach is to duplicate utility functions or provide conversions between the few supported
   perspectives.
   Our proposed language feature will allow the library designer, and user, to make this choice only when necessary
   and otherwise leave the ‘belt line’ between parameters and fields unspecified.

   To demonstrate the practicality of this feature, we have produced a prototype for the Agda language.
   After loading it, Agda users may employ special comments from which legitimate Agda code is automatically generated
   as users step-wise program.
 #+end_small
 # \newpage
 # \thispagestyle{empty}
 # \tableofcontents
 # \newpage

** COMMENT OLD Introduction

   Programming languages with sufficiently expressive type theories provide users with essentially two
   levels of data ‘bundling’. One may expose important constituents at the type level or have them
   hidden at the value level. Alternatively put, which information is exposed dynamically at runtime and which is known
   statically. Rather than force a user to commit to a choice, we propose a language feature that allows such
   choices to be determined whenever is convenient for the task at hand.

   For example, consider the dot-product $\Sigma_{i = 0}^n x_i \cdot y_i$ operation.
   It is unreasonable to have this as an operation of $2 \cdot n$ many numbers, instead of such a primitive type
   we may utilise the richer structure of vectors. Now what is the type of a vector ---is it ~Vec ℝ n, Vec ℝ,~ or just ~Vec~?
   That is, how much information is exposed at the type level and how much is hidden at the component value level.
   In the programming setting, nullary ~Vec~ may correspond to lists whose type is only known at runtime,
   whereas ~Vec ℝ~ corresponds to lists of real numbers yet  the list length is known as run time, whereas
   ~Vec ℝ n~ corresponds to lists of real numbers where the list length is statically known to be ~n~.

   Languages without sufficient support for polymorphism, such as old versions of Java, can only provide the nullary
   ~Vec~ form. The check that all the constituents are of the same type transpires at runtime, which necessities a decision
   of what is done when elements differ ---throwing an exception is common.
   In contrast, languages with elegant polymorphism support, such as Haskell, would have the element type pre-determined
   leaving the choice of what to do when vector lengths differ ---ignoring extra elements is common.
   Yet in dependently-typed languages, such as Agda, one can select either format or, better yet, have the length information
   at the type level. /The more information known statically, the less arbitrary choices that need to be performed./

   However, it is not clear how much information exposure is ideal.
   For example, when the type of elements is exposed we can easily form the dot-product
   and it would be awkward to phrase it otherwise. Perhaps a demonstration will clarify this further.
   {{{code(Typing the dot-product using different vector perspectives)}}}
   #+BEGIN_SRC agda
  data Vec (carrier : Set) (length : ℕ) : Set where
    []  : Vec carrier 0
    _∷_ : ∀ {length : ℕ}
      → carrier → Vec carrier length → Vec carrier (length + 1)

  record Vec′ (carrier : Set)  : Set (ℓsuc ℓzero) where
    field
      length   : ℕ
      elements : Vec carrier length

  record Vec″ : Set (ℓsuc ℓzero) where
    field
      carrier  : Set
      length   : ℕ
      elements : Vec carrier length

   dot : ∀ {n} (xs ys : Vec ℝ n) → ℝ
   dot = ⋯

   dot′ : (xs ys : Vec′ ℝ) → length xs ≡ length ys → ℝ
   dot′ = ⋯

   dot″ : (xs ys : Vec″)	→ carrier xs ≡ ℝ  → carrier ys ≡ ℝ
    → length xs ≡ length ys → ℝ
   dot″ = ⋯
   #+END_SRC
   The more exposed data, the easier it is to type the dot-product.
   However, more exposure is not always ideal. For example, suppose we are interested
   is discussing the ubiquitous category ~ListSet~ whose objects are lists over some carrier set
   and whose morphisms are functions between the carrier sets. The type of objects cannot be
   ~Vec~ nor ~Vec′~ since they /enforce too many constraints/, instead it must be ~Vec″~.
   Hence, there is not best choice but it is contextual use that determines which presentation
   is most fitting. Are we then forced to re-duplicate the ~dot~ code for each level of exposure?
   Our proposed language feature suggests otherwise: /Write once, obtain many!/

   Interestingly, we can go so far as to form ~Vec ℝ n xs~ to be the type consisting of a single formal value
   when ~xs~ is a list /and/ its constituents are of type ℝ /and/ the list length is ~n~; and to have no value otherwise.
   This is, for nearly all uses, overkill; yet it begs the question /where is the line between parameters and component fields?/
   Traditionally, a library designer would make this choice and may provide views for the other perspectives.
   Our proposed language feature will allow the library designer, and user, to make this choice only when necessary
   and otherwise leave the ‘belt line’ between parameters and fields unspecified.

   To demonstrate the practicality of this feature, we have produced a prototype for the Agda language.
   After loading it, Agda users may employ special comments from which legitimate Agda code is automatically generated
   as users step-wise program.

* COMMENT footer                                                     :ignore:

(shell-command "cp Paper0.pdf GPCE_19_Alhassy_Carette_Kahl.pdf")

# Local Variables:
# eval: (progn (org-babel-goto-named-src-block "make-acmart-class") (org-babel-execute-src-block))
# compile-command: (progn (org-babel-tangle) (org-latex-export-to-pdf) (async-shell-command "open Paper0.pdf"))
# End:
